# Source Code Compilation

Generated on: Fri Sep 26 09:40:48 EDT 2025

## agents/agentManager/agentManager.ts

```typescript
import { BaseAgent } from '../baseAgent';
import { AgentManagerConfig } from '../../config/agents';
import {
  ListAgentsMode,
  GetAgentMode,
  CreateAgentMode,
  UpdateAgentMode,
  DeleteAgentMode,
  ToggleAgentMode,
  ListModelsMode,
  ExecutePromptMode,
  BatchExecutePromptMode,
  GenerateImageMode
} from './modes';
import { CustomPromptStorageService } from './services/CustomPromptStorageService';
import { Settings } from '../../settings';
import { sanitizeVaultName } from '../../utils/vaultUtils';
import { LLMProviderManager } from '../../services/llm/providers/ProviderManager';
import { AgentManager } from '../../services/AgentManager';
import { UsageTracker } from '../../services/UsageTracker';
import { Vault } from 'obsidian';

/**
 * AgentManager Agent for custom prompt operations
 */
export class AgentManagerAgent extends BaseAgent {
  /**
   * Custom prompt storage service
   */
  private storageService: CustomPromptStorageService;

  /**
   * Vault name for multi-vault support
   */
  private vaultName: string;

  /**
   * Flag to prevent infinite recursion in description getter
   */
  private isGettingDescription = false;

  /**
   * LLM Provider Manager for model operations
   */
  private providerManager: LLMProviderManager | null = null;

  /**
   * Agent Manager for inter-agent communication
   */
  private parentAgentManager: AgentManager | null = null;
  
  /**
   * Usage Tracker for LLM cost tracking
   */
  private usageTracker: UsageTracker | null = null;
  
  /**
   * Create a new AgentManagerAgent
   * @param settings Settings instance for prompt storage
   */
  constructor(settings: Settings) {
    super(
      AgentManagerConfig.name,
      AgentManagerConfig.description,
      AgentManagerConfig.version
    );
    
    this.storageService = new CustomPromptStorageService(settings);
    
    // Get vault name from settings (which has access to plugin.app)
    const plugin = (settings as any).plugin;
    if (plugin && plugin.app) {
      this.vaultName = sanitizeVaultName(plugin.app.vault.getName());
    } else {
      this.vaultName = 'unknown-vault';
    }
    
    // Register prompt management modes
    this.registerMode(new ListAgentsMode(this.storageService));
    this.registerMode(new GetAgentMode(this.storageService));
    this.registerMode(new CreateAgentMode(this.storageService));
    this.registerMode(new UpdateAgentMode(this.storageService));
    this.registerMode(new DeleteAgentMode(this.storageService));
    this.registerMode(new ToggleAgentMode(this.storageService));

    // Register LLM modes (will be initialized when provider manager is set)
    this.registerMode(new ListModelsMode());
    this.registerMode(new ExecutePromptMode());
    this.registerMode(new BatchExecutePromptMode());
    
    // Register image generation mode
    this.registerMode(new GenerateImageMode());
  }

  /**
   * Dynamic description that includes information about custom prompt agents
   */
  get description(): string {
    const baseDescription = AgentManagerConfig.description;
    
    // Prevent infinite recursion
    if (this.isGettingDescription) {
      return `[${this.vaultName}] ${baseDescription}`;
    }
    
    this.isGettingDescription = true;
    try {
      const customAgentsContext = this.getAgentsSummary();
      return `[${this.vaultName}] ${baseDescription}\n\n${customAgentsContext}`;
    } finally {
      this.isGettingDescription = false;
    }
  }
  
  /**
   * Get the storage service for direct access if needed
   * @returns CustomPromptStorageService instance
   */
  getStorageService(): CustomPromptStorageService {
    return this.storageService;
  }

  /**
   * Set the LLM Provider Manager for model operations
   */
  setProviderManager(providerManager: LLMProviderManager): void {
    this.providerManager = providerManager;
    
    // Update the LLM modes with the provider manager
    const listModelsMode = this.getMode('listModels') as ListModelsMode;
    if (listModelsMode) {
      listModelsMode.setProviderManager(providerManager);
    }

    const executePromptMode = this.getMode('executePrompt') as ExecutePromptMode;
    if (executePromptMode) {
      executePromptMode.setProviderManager(providerManager);
      executePromptMode.setPromptStorage(this.storageService);
      if (this.parentAgentManager) {
        executePromptMode.setAgentManager(this.parentAgentManager);
      }
      if (this.usageTracker) {
        executePromptMode.setUsageTracker(this.usageTracker);
      }
    }

    const batchExecutePromptMode = this.getMode('batchExecutePrompt') as BatchExecutePromptMode;
    if (batchExecutePromptMode) {
      batchExecutePromptMode.setProviderManager(providerManager);
      batchExecutePromptMode.setPromptStorage(this.storageService);
      if (this.parentAgentManager) {
        batchExecutePromptMode.setAgentManager(this.parentAgentManager);
      }
      if (this.usageTracker) {
        batchExecutePromptMode.setUsageTracker(this.usageTracker);
      }
    }
  }

  /**
   * Set the Usage Tracker for LLM cost tracking
   */
  setUsageTracker(usageTracker: UsageTracker): void {
    this.usageTracker = usageTracker;
    
    // Update the execute modes with the usage tracker
    const executePromptMode = this.getMode('executePrompt') as ExecutePromptMode;
    if (executePromptMode) {
      executePromptMode.setUsageTracker(usageTracker);
    }

    const batchExecutePromptMode = this.getMode('batchExecutePrompt') as BatchExecutePromptMode;
    if (batchExecutePromptMode) {
      batchExecutePromptMode.setUsageTracker(usageTracker);
    }
  }

  /**
   * Set the Agent Manager for inter-agent communication
   */
  setParentAgentManager(agentManager: AgentManager): void {
    this.parentAgentManager = agentManager;
    
    // Update execute prompt mode if it exists
    const executePromptMode = this.getMode('executePrompt') as ExecutePromptMode;
    if (executePromptMode) {
      executePromptMode.setAgentManager(agentManager);
    }

    // Update batch execute prompt mode if it exists
    const batchExecutePromptMode = this.getMode('batchExecutePrompt') as BatchExecutePromptMode;
    if (batchExecutePromptMode) {
      batchExecutePromptMode.setAgentManager(agentManager);
    }
  }

  /**
   * Set the Vault instance for image generation
   */
  setVault(vault: Vault): void {
    // Update image generation mode if it exists
    const generateImageMode = this.getMode('generateImage') as GenerateImageMode;
    if (generateImageMode) {
      generateImageMode.setVault(vault);
    }
  }

  /**
   * Set LLM provider settings for image generation
   */
  setLLMSettings(settings: any): void {
    const generateImageMode = this.getMode('generateImage') as GenerateImageMode;
    if (generateImageMode) {
      generateImageMode.setLLMSettings(settings?.llmProviders);
    }
  }

  /**
   * Get a summary of all available custom prompt agents
   * @returns Formatted string with custom prompt agent information
   * @private
   */
  private getAgentsSummary(): string {
    try {
      // Check if storage service is available
      if (!this.storageService) {
        return `ü§ñ Custom Agents: Storage service not available`;
      }

      // Check if custom prompts feature is enabled
      if (!this.storageService.isEnabled()) {
        return `ü§ñ Custom Agents: Custom prompts feature is disabled`;
      }

      // Get all custom prompt agents
      const customPrompts = this.storageService.getAllPrompts();
      
      if (!customPrompts || customPrompts.length === 0) {
        return `ü§ñ Custom Agents: No custom prompt agents created yet`;
      }

      const enabledCount = customPrompts.filter(prompt => prompt.isEnabled).length;
      const agentSummary = [`ü§ñ Custom Agents (${customPrompts.length} total, ${enabledCount} enabled):`];
      
      for (const prompt of customPrompts) {
        const status = prompt.isEnabled ? '‚úÖ' : '‚ùå';
        const description = prompt.description || 'No description provided';
        agentSummary.push(`   ${status} ${prompt.name}: ${description}`);
      }

      return agentSummary.join('\n');
    } catch (error) {
      return `ü§ñ Custom Agents: Error loading custom prompt agents (${error})`;
    }
  }
}
```

## agents/agentManager/modes/batchExecutePrompt/BatchExecutePromptMode.ts

```typescript
import { Plugin } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { getErrorMessage } from '../../../../utils/errorUtils';
import { createResult } from '../../../../utils/schemaUtils';
import { LLMProviderManager } from '../../../../services/llm/providers/ProviderManager';
import { LLMService } from '../../../../services/llm/core/LLMService';
import { AgentManager } from '../../../../services/AgentManager';
import { CustomPromptStorageService } from '../../services/CustomPromptStorageService';
import { UsageTracker } from '../../../../services/UsageTracker';

// Import refactored services and types
import {
  BatchExecutePromptParams,
  BatchExecutePromptResult,
  PromptConfig,
  ExecutionContext
} from './types';
import {
  BudgetValidator,
  ContextBuilder,
  PromptExecutor,
  RequestExecutor,
  SequenceManager,
  ResultProcessor,
  ActionExecutor
} from './services';
import { PromptParser } from './utils';
import { addRecommendations } from '../../../../utils/recommendationUtils';
import { AGENT_MANAGER_RECOMMENDATIONS } from '../../recommendations';

/**
 * Refactored batch mode for executing multiple LLM prompts concurrently
 * Now follows SOLID principles with service composition
 * 
 * Responsibilities:
 * - Orchestrate prompt execution workflow
 * - Coordinate specialized services
 * - Handle high-level error management
 */
export class BatchExecutePromptMode extends BaseMode<BatchExecutePromptParams, BatchExecutePromptResult> {
  // Core services (injected)
  private llmService: LLMService | null = null;
  private providerManager: LLMProviderManager | null = null;
  private agentManager: AgentManager | null = null;
  private promptStorage: CustomPromptStorageService | null = null;
  private usageTracker: UsageTracker | null = null;

  // Specialized services (composition)
  private budgetValidator!: BudgetValidator;
  private contextBuilder!: ContextBuilder;
  private promptExecutor!: PromptExecutor;
  private requestExecutor!: RequestExecutor;
  private sequenceManager!: SequenceManager;
  private resultProcessor!: ResultProcessor;
  private actionExecutor!: ActionExecutor;
  
  // Utilities
  private promptParser!: PromptParser;

  constructor(
    plugin?: Plugin,
    llmService?: LLMService,
    providerManager?: LLMProviderManager,
    agentManager?: AgentManager,
    promptStorage?: CustomPromptStorageService
  ) {
    super(
      'batchExecutePrompt',
      'Batch Execute LLM Prompts',
      'Execute multiple LLM and image prompts concurrently across different providers. Supports context gathering, workspace integration, and result merging.',
      '1.0.0'
    );
    
    // Store injected dependencies
    this.llmService = llmService || null;
    this.providerManager = providerManager || null;
    this.agentManager = agentManager || null;
    this.promptStorage = promptStorage || null;

    // Initialize specialized services
    this.initializeServices();
  }

  /**
   * Wait for dependencies to be initialized
   * @param timeoutMs Maximum time to wait in milliseconds
   * @private
   */
  private async waitForDependencies(timeoutMs: number): Promise<void> {
    const startTime = Date.now();
    const checkInterval = 100; // Check every 100ms
    
    while (Date.now() - startTime < timeoutMs) {
      if (this.llmService && this.providerManager && this.promptStorage) {
        return;
      }
      
      // Wait for the next check
      await new Promise(resolve => setTimeout(resolve, checkInterval));
    }
  }

  /**
   * Initialize all specialized services following dependency injection patterns
   */
  private initializeServices(): void {
    // Initialize utilities
    this.promptParser = new PromptParser();

    // Initialize core services
    this.budgetValidator = new BudgetValidator(this.usageTracker || undefined);
    this.contextBuilder = new ContextBuilder();
    this.actionExecutor = new ActionExecutor(this.agentManager || undefined);

    // PromptExecutor requires LLM service, so we'll initialize it in execute() if needed
    // Same for SequenceManager and ResultProcessor
    this.resultProcessor = new ResultProcessor();
  }

  /**
   * Ensure request executor is initialized with all dependencies
   */
  private ensureRequestExecutor(): void {
    if (!this.promptExecutor && this.llmService) {
      this.promptExecutor = new PromptExecutor(
        this.llmService,
        this.budgetValidator,
        this.contextBuilder,
        this.promptStorage || undefined
      );
    }

    if (!this.requestExecutor && this.promptExecutor && this.actionExecutor) {
      this.requestExecutor = new RequestExecutor(
        this.promptExecutor,
        this.actionExecutor
      );

      this.sequenceManager = new SequenceManager(
        this.requestExecutor,
        this.contextBuilder
      );
    }
  }

  /**
   * Execute multiple LLM prompts with orchestrated workflow
   */
  async execute(params: BatchExecutePromptParams): Promise<BatchExecutePromptResult> {
    try {
      // Try to wait for dependencies if not available
      if (!this.llmService || !this.providerManager || !this.promptStorage) {
        await this.waitForDependencies(3000);
      }
      
      // Validate dependencies
      if (!this.llmService) {
        return createResult<BatchExecutePromptResult>(
          false, undefined, 'LLM Service not initialized',
          undefined, undefined, params.context.sessionId, params.context
        );
      }
      
      if (!this.providerManager) {
        return createResult<BatchExecutePromptResult>(
          false, undefined, 'LLM Provider Manager not initialized. Please ensure you have configured at least one LLM provider with valid API keys.',
          undefined, undefined, params.context.sessionId, params.context
        );
      }
      
      if (!this.promptStorage) {
        return createResult<BatchExecutePromptResult>(
          false, undefined, 'Prompt storage service not initialized',
          undefined, undefined, params.context.sessionId, params.context
        );
      }

      // Ensure specialized services are ready
      this.ensureRequestExecutor();
      if (!this.requestExecutor || !this.sequenceManager) {
        return createResult<BatchExecutePromptResult>(
          false, undefined, 'Failed to initialize execution services',
          undefined, undefined, params.context.sessionId, params.context
        );
      }

      // Validate parameters using utility
      const validation = this.promptParser.validateParameters(params);
      if (!validation.valid) {
        return createResult<BatchExecutePromptResult>(
          false, undefined, `Parameter validation failed: ${validation.errors.join(', ')}`,
          undefined, undefined, params.context.sessionId, params.context
        );
      }

      const startTime = performance.now();
      
      // Normalize prompt configurations
      const normalizedPrompts = this.promptParser.normalizePromptConfigs(params.prompts);
      
      // Initialize execution context
      const executionContext = this.contextBuilder.initializeExecutionContext(
        params.context.sessionId,
        params.context
      );
      
      // Execute prompts with sequence and parallel group support
      const results = await this.sequenceManager.executePromptsWithSequencing(
        normalizedPrompts,
        executionContext
      );
      
      // Process actions for results that have them
      await this.processResultActions(results, normalizedPrompts, params);
      
      const totalExecutionTime = performance.now() - startTime;
      
      // Process and format final results
      const processedResults = this.resultProcessor.processResults(
        results,
        params.mergeResponses || false,
        totalExecutionTime,
        params.prompts.length
      );
      
      const result = createResult<BatchExecutePromptResult>(
        processedResults.success,
        processedResults,
        processedResults.error,
        undefined, // workspaceContext
        params.context.sessionId,
        params.context
      );
      
      return addRecommendations(result, AGENT_MANAGER_RECOMMENDATIONS.batchExecutePrompt);
      
    } catch (error) {
      console.error('Batch LLM prompt execution failed:', error);
      return createResult<BatchExecutePromptResult>(
        false,
        undefined,
        `Batch execution failed: ${getErrorMessage(error)}`,
        undefined, // workspaceContext
        params.context.sessionId,
        params.context
      );
    }
  }

  /**
   * Process content actions for results that specify them
   */
  private async processResultActions(
    results: any[],
    promptConfigs: PromptConfig[],
    params: BatchExecutePromptParams
  ): Promise<void> {
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const promptConfig = promptConfigs.find(p => p.id === result.id) || promptConfigs[i];
      
      // Only process actions for text results
      if (promptConfig?.type === 'text' && 'action' in promptConfig && promptConfig.action && 
          result.success && result.type === 'text' && result.response) {
        try {
          const actionResult = await this.actionExecutor.executeContentAction(
            promptConfig.action,
            result.response,
            params.context.sessionId,
            typeof params.context === 'string' ? params.context : JSON.stringify(params.context)
          );

          result.actionPerformed = {
            type: promptConfig.action.type,
            targetPath: promptConfig.action.targetPath,
            success: actionResult.success,
            error: actionResult.error
          };
        } catch (actionError) {
          result.actionPerformed = {
            type: promptConfig.action.type,
            targetPath: promptConfig.action.targetPath,
            success: false,
            error: actionError instanceof Error ? actionError.message : 'Unknown action error'
          };
        }
      }
    }
  }

  /**
   * Set the LLM service instance
   */
  setLLMService(llmService: LLMService): void {
    this.llmService = llmService;
  }

  /**
   * Set the usage tracker for LLM cost tracking
   */
  setUsageTracker(usageTracker: UsageTracker): void {
    this.usageTracker = usageTracker;
    this.budgetValidator = new BudgetValidator(usageTracker);
  }

  /**
   * Set the provider manager instance
   */
  setProviderManager(providerManager: LLMProviderManager): void {
    this.providerManager = providerManager;
    
    // Get LLM service from provider manager if we don't have one
    if (!this.llmService && providerManager) {
      this.llmService = providerManager.getLLMService();
    }
  }

  /**
   * Set the agent manager for action execution
   */
  setAgentManager(agentManager: AgentManager): void {
    this.agentManager = agentManager;
    this.actionExecutor = new ActionExecutor(agentManager);
  }

  /**
   * Set the prompt storage for custom agent support
   */
  setPromptStorage(promptStorage: CustomPromptStorageService): void {
    this.promptStorage = promptStorage;
  }

  /**
   * Get parameter schema for MCP tool definition
   */
  getParameterSchema(): any {
    // Get default from data.json settings
    const defaultModel = this.providerManager?.getSettings()?.defaultModel;
    
    const customSchema = {
      properties: {
        prompts: {
          type: 'array',
          description: 'Array of text and/or image generation requests to execute in batch',
          minItems: 1,
          maxItems: 100,
          items: {
            type: 'object',
            properties: {
              type: {
                type: 'string',
                enum: ['text', 'image'],
                description: 'Type of request: "text" for LLM prompts, "image" for AI image generation'
              },
              id: {
                type: 'string',
                description: 'Optional unique identifier for this request'
              },
              prompt: {
                type: 'string',
                description: 'Text prompt (for LLM) or image description (for image generation)',
                minLength: 1,
                maxLength: 32000
              },
              sequence: {
                type: 'integer',
                minimum: 0,
                description: 'Execution sequence (0, 1, 2, etc.). Requests in same sequence run in parallel'
              },
              parallelGroup: {
                type: 'string',
                description: 'Parallel group identifier within sequence. Different groups run sequentially'
              },
              includePreviousResults: {
                type: 'boolean',
                description: 'Include results from previous sequences as context'
              },
              contextFromSteps: {
                type: 'array',
                items: { type: 'string' },
                description: 'Specific request IDs to include as context'
              },
              // Text-specific properties
              provider: {
                type: 'string',
                description: `LLM provider (defaults to: ${defaultModel?.provider || 'not configured'}). For images, use "google". Use listModels to see available providers.`,
                default: defaultModel?.provider
              },
              model: {
                type: 'string',
                description: `Model name (defaults to: ${defaultModel?.model || 'not configured'}). Use listModels to see available models.`,
                default: defaultModel?.model
              },
              contextFiles: {
                type: 'array',
                items: { type: 'string' },
                description: 'File paths to include as context (text requests only)'
              },
              workspace: {
                type: 'string',
                description: 'Workspace name for context gathering (text requests only)'
              },
              action: {
                type: 'object',
                description: 'Content action to perform with LLM response (text requests only)',
                properties: {
                  type: {
                    type: 'string',
                    enum: ['create', 'append', 'prepend', 'replace', 'findReplace']
                  },
                  targetPath: { type: 'string' },
                  findText: { type: 'string' },
                  replaceAll: { type: 'boolean' },
                  caseSensitive: { type: 'boolean' },
                  wholeWord: { type: 'boolean' }
                },
                required: ['type', 'targetPath']
              },
              agent: {
                type: 'string',
                description: 'Custom agent/prompt name to use (text requests only)'
              },
              // Image-specific properties
              savePath: {
                type: 'string',
                description: 'Vault-relative path to save generated image (image requests only)',
                pattern: '^[^/].*\\.(png|jpg|jpeg|webp)$'
              },
              aspectRatio: {
                type: 'string',
                description: 'Image aspect ratio (image requests only)',
                enum: ['1:1', '3:4', '4:3', '9:16', '16:9'],
                default: '1:1'
              }
            },
            required: ['type', 'prompt', 'provider', 'model'],
            allOf: [
              {
                if: { properties: { type: { const: 'image' } } },
                then: {
                  required: ['savePath'],
                  properties: {
                    provider: { const: 'google' }
                  }
                }
              }
            ]
          }
        },
        mergeResponses: {
          type: 'boolean',
          description: 'Whether to merge all responses into a single result',
          default: false
        }
      },
      required: ['prompts']
    };
    
    return this.getMergedSchema(customSchema);
  }

  /**
   * Get result schema for MCP tool definition
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the batch execution succeeded overall'
        },
        message: {
          type: 'string',
          description: 'Status message about the batch execution'
        },
        data: {
          type: 'object',
          properties: {
            results: {
              type: 'array',
              description: 'Individual results from each request',
              items: {
                oneOf: [
                  {
                    type: 'object',
                    description: 'Text prompt result',
                    properties: {
                      type: { const: 'text' },
                      id: { type: 'string' },
                      prompt: { type: 'string' },
                      success: { type: 'boolean' },
                      response: { type: 'string' },
                      provider: { type: 'string' },
                      model: { type: 'string' },
                      agent: { type: 'string' },
                      error: { type: 'string' },
                      executionTime: { type: 'number' },
                      sequence: { type: 'number' },
                      parallelGroup: { type: 'string' },
                      usage: {
                        type: 'object',
                        properties: {
                          promptTokens: { type: 'number' },
                          completionTokens: { type: 'number' },
                          totalTokens: { type: 'number' }
                        }
                      },
                      cost: {
                        type: 'object',
                        properties: {
                          inputCost: { type: 'number' },
                          outputCost: { type: 'number' },
                          totalCost: { type: 'number' },
                          currency: { type: 'string' }
                        }
                      },
                      filesIncluded: {
                        type: 'array',
                        items: { type: 'string' }
                      },
                      actionPerformed: {
                        type: 'object',
                        properties: {
                          type: { type: 'string' },
                          targetPath: { type: 'string' },
                          success: { type: 'boolean' },
                          error: { type: 'string' }
                        }
                      }
                    },
                    required: ['type', 'success']
                  },
                  {
                    type: 'object',
                    description: 'Image generation result',
                    properties: {
                      type: { const: 'image' },
                      id: { type: 'string' },
                      prompt: { type: 'string' },
                      success: { type: 'boolean' },
                      imagePath: { type: 'string' },
                      revisedPrompt: { type: 'string' },
                      provider: { type: 'string' },
                      model: { type: 'string' },
                      error: { type: 'string' },
                      executionTime: { type: 'number' },
                      sequence: { type: 'number' },
                      parallelGroup: { type: 'string' },
                      dimensions: {
                        type: 'object',
                        properties: {
                          width: { type: 'number' },
                          height: { type: 'number' }
                        }
                      },
                      fileSize: { type: 'number' },
                      format: { type: 'string' },
                      usage: {
                        type: 'object',
                        properties: {
                          imagesGenerated: { type: 'number' },
                          resolution: { type: 'string' },
                          model: { type: 'string' },
                          provider: { type: 'string' }
                        }
                      },
                      cost: {
                        type: 'object',
                        properties: {
                          inputCost: { type: 'number' },
                          outputCost: { type: 'number' },
                          totalCost: { type: 'number' },
                          currency: { type: 'string' },
                          ratePerImage: { type: 'number' }
                        }
                      },
                      metadata: {
                        type: 'object',
                        description: 'Additional image metadata'
                      }
                    },
                    required: ['type', 'success']
                  }
                ]
              }
            },
            mergedResponse: {
              type: 'object',
              description: 'Merged response when mergeResponses is true',
              properties: {
                totalPrompts: { type: 'number' },
                successfulPrompts: { type: 'number' },
                mergedContent: { type: 'string' },
                providersUsed: {
                  type: 'array',
                  items: { type: 'string' }
                }
              }
            },
            executionStats: {
              type: 'object',
              properties: {
                totalExecutionTimeMS: { type: 'number' },
                promptsExecuted: { type: 'number' },
                promptsFailed: { type: 'number' },
                avgExecutionTimeMS: { type: 'number' },
                totalTokens: { type: 'number' },
                totalCost: { type: 'number' }
              }
            }
          },
          required: ['results']
        }
      },
      required: ['success']
    };
  }
}
```

## agents/agentManager/modes/batchExecutePrompt/index.ts

```typescript
// Re-export all components for easy importing
export * from './types';
export * from './services';
export * from './utils';
export { BatchExecutePromptMode } from './BatchExecutePromptMode';
```

## agents/agentManager/modes/batchExecutePrompt/services/ActionExecutor.ts

```typescript
import { AgentManager } from '../../../../../services/AgentManager';
import { ContentAction, ImagePromptConfig } from '../types';

/**
 * Service responsible for executing content actions with LLM responses
 * Follows SRP by focusing only on action execution logic
 */
export class ActionExecutor {
  constructor(private agentManager?: AgentManager) {}

  /**
   * Execute a ContentManager action with the LLM response
   */
  async executeContentAction(
    action: ContentAction,
    content: string,
    sessionId?: string,
    context?: string
  ): Promise<{ success: boolean; error?: string }> {
    if (!this.agentManager) {
      return { success: false, error: 'Agent manager not available' };
    }

    try {
      const actionParams: any = {
        sessionId: sessionId || '',
        context: context || '',
        content
      };

      switch (action.type) {
        case 'create':
          return await this.executeCreateAction(actionParams, action);
        case 'append':
          return await this.executeAppendAction(actionParams, action);
        case 'prepend':
          return await this.executePrependAction(actionParams, action);
        case 'replace':
          return await this.executeReplaceAction(actionParams, action);
        case 'findReplace':
          return await this.executeFindReplaceAction(actionParams, action);
        default:
          return { success: false, error: `Unknown action type: ${action.type}` };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error executing action'
      };
    }
  }

  /**
   * Execute create content action
   */
  private async executeCreateAction(
    actionParams: any,
    action: ContentAction
  ): Promise<{ success: boolean; error?: string }> {
    actionParams.filePath = action.targetPath;
    const createResult = await this.agentManager!.executeAgentMode('contentManager', 'createContent', actionParams);
    return { success: createResult.success, error: createResult.error };
  }

  /**
   * Execute append content action
   */
  private async executeAppendAction(
    actionParams: any,
    action: ContentAction
  ): Promise<{ success: boolean; error?: string }> {
    actionParams.filePath = action.targetPath;
    const appendResult = await this.agentManager!.executeAgentMode('contentManager', 'appendContent', actionParams);
    return { success: appendResult.success, error: appendResult.error };
  }

  /**
   * Execute prepend content action
   */
  private async executePrependAction(
    actionParams: any,
    action: ContentAction
  ): Promise<{ success: boolean; error?: string }> {
    actionParams.filePath = action.targetPath;
    const prependResult = await this.agentManager!.executeAgentMode('contentManager', 'prependContent', actionParams);
    return { success: prependResult.success, error: prependResult.error };
  }

  /**
   * Execute replace content action
   */
  private async executeReplaceAction(
    actionParams: any,
    action: ContentAction
  ): Promise<{ success: boolean; error?: string }> {
    actionParams.filePath = action.targetPath;
    let replaceResult;
    
    if (action.position !== undefined) {
      actionParams.line = action.position;
      replaceResult = await this.agentManager!.executeAgentMode('contentManager', 'replaceByLine', actionParams);
    } else {
      replaceResult = await this.agentManager!.executeAgentMode('contentManager', 'replaceContent', actionParams);
    }
    
    return { success: replaceResult.success, error: replaceResult.error };
  }

  /**
   * Execute find and replace content action
   */
  private async executeFindReplaceAction(
    actionParams: any,
    action: ContentAction
  ): Promise<{ success: boolean; error?: string }> {
    if (!action.findText) {
      return { success: false, error: 'findText is required for findReplace action' };
    }
    
    actionParams.filePath = action.targetPath;
    actionParams.findText = action.findText;
    actionParams.replaceText = actionParams.content; // LLM response becomes the replacement text
    actionParams.replaceAll = action.replaceAll ?? false;
    actionParams.caseSensitive = action.caseSensitive ?? true;
    actionParams.wholeWord = action.wholeWord ?? false;
    
    const findReplaceResult = await this.agentManager!.executeAgentMode('contentManager', 'findReplaceContent', actionParams);
    return { success: findReplaceResult.success, error: findReplaceResult.error };
  }

  /**
   * Validate action configuration
   */
  validateAction(action: ContentAction): { valid: boolean; error?: string } {
    if (!action.type) {
      return { valid: false, error: 'Action type is required' };
    }

    if (!action.targetPath) {
      return { valid: false, error: 'Target path is required' };
    }

    if (action.type === 'findReplace' && !action.findText) {
      return { valid: false, error: 'findText is required for findReplace action' };
    }

    if (action.type === 'replace' && action.position !== undefined && action.position < 0) {
      return { valid: false, error: 'Position must be non-negative for replace action' };
    }

    return { valid: true };
  }

  /**
   * Execute image generation action
   */
  async executeImageGenerationAction(
    imageConfig: ImagePromptConfig,
    sessionId?: string,
    context?: string
  ): Promise<{ success: boolean; error?: string; imagePath?: string }> {
    if (!this.agentManager) {
      return { success: false, error: 'Agent manager not available' };
    }

    try {
      console.log(`[ActionExecutor] Image config aspectRatio:`, imageConfig.aspectRatio);
      const imageParams = {
        prompt: imageConfig.prompt,
        provider: imageConfig.provider,
        model: imageConfig.model,
        aspectRatio: imageConfig.aspectRatio,
        savePath: imageConfig.savePath,
        sessionId: sessionId || '',
        context: context || ''
      };
      console.log(`[ActionExecutor] Image params aspectRatio:`, imageParams.aspectRatio);

      const imageResult = await this.agentManager.executeAgentMode('agentManager', 'generateImage', imageParams);
      
      if (imageResult.success && imageResult.data?.imagePath) {
        return { 
          success: true, 
          imagePath: imageResult.data.imagePath 
        };
      } else {
        return { 
          success: false, 
          error: imageResult.error || 'Image generation failed without specific error' 
        };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error executing image generation'
      };
    }
  }

  /**
   * Get supported action types
   */
  getSupportedActionTypes(): string[] {
    return ['create', 'append', 'prepend', 'replace', 'findReplace'];
  }

  /**
   * Get supported request types
   */
  getSupportedRequestTypes(): string[] {
    return ['text', 'image'];
  }
}
```

## agents/agentManager/modes/batchExecutePrompt/services/BudgetValidator.ts

```typescript
import { UsageTracker } from '../../../../../services/UsageTracker';

/**
 * Service responsible for validating budget constraints before prompt execution
 * Follows SRP by focusing only on budget-related validation
 */
export class BudgetValidator {
  constructor(private usageTracker?: UsageTracker) {}

  /**
   * Check if the monthly budget has been exceeded
   * @throws Error if budget is exceeded
   */
  async validateBudget(): Promise<void> {
    if (!this.usageTracker) {
      return; // No budget tracking configured
    }

    const budgetStatus = await this.usageTracker.getBudgetStatusAsync();
    if (budgetStatus.budgetExceeded) {
      throw new Error(
        `Monthly LLM budget of $${budgetStatus.monthlyBudget.toFixed(2)} has been exceeded. ` +
        `Current spending: $${budgetStatus.currentSpending.toFixed(2)}. ` +
        `Please reset or increase your budget in settings.`
      );
    }
  }

  /**
   * Track usage after successful execution
   * @param provider LLM provider used
   * @param cost Total cost of the execution
   */
  async trackUsage(provider: string, cost: number): Promise<void> {
    if (!this.usageTracker) {
      return; // No usage tracking configured
    }

    try {
      await this.usageTracker.trackUsage(provider.toLowerCase(), cost);
    } catch (error) {
      console.error('Failed to track LLM usage:', error);
      // Don't fail the request if usage tracking fails
    }
  }

  /**
   * Get current budget status for reporting
   */
  async getBudgetStatus() {
    if (!this.usageTracker) {
      return null;
    }

    return await this.usageTracker.getBudgetStatusAsync();
  }
}
```

## agents/agentManager/modes/batchExecutePrompt/services/ContextBuilder.ts

```typescript
import { ExecutionContext, PromptExecutionResult, PromptConfig } from '../types';

/**
 * Service responsible for building context from previous execution results
 * Follows SRP by focusing only on context building logic
 */
export class ContextBuilder {

  /**
   * Build context string from previous sequence and group results with precise ID-based selection
   */
  buildPreviousResultsContext(
    previousResults: Map<number, PromptExecutionResult[]> | { [sequence: number]: PromptExecutionResult[] },
    currentSequence: number,
    currentSequenceGroupResults?: { [groupKey: string]: PromptExecutionResult[] },
    currentParallelGroup?: string,
    contextFromSteps?: string[],
    allResults?: PromptExecutionResult[]
  ): string {
    const contextParts: string[] = [];
    
    // If specific step IDs are requested, use those exclusively
    if (contextFromSteps && contextFromSteps.length > 0 && allResults) {
      contextParts.push('--- Selected Step Results ---');
      
      for (const stepId of contextFromSteps) {
        const result = allResults.find(r => r.id === stepId);
        if (result && result.success) {
          const groupLabel = result.parallelGroup ? ` (${result.parallelGroup})` : '';
          const sequenceLabel = result.sequence !== undefined ? ` [seq:${result.sequence}]` : '';
          
          if (result.type === 'text' && result.response) {
            contextParts.push(`${stepId}${groupLabel}${sequenceLabel}: ${result.response}`);
          } else if (result.type === 'image' && result.imagePath) {
            contextParts.push(`${stepId}${groupLabel}${sequenceLabel}: [Image generated: ${result.imagePath}]`);
          }
        } else if (!result) {
          contextParts.push(`${stepId}: [Step not found or not yet executed]`);
        } else if (!result.success) {
          contextParts.push(`${stepId}: [Step failed: ${result.error || 'Unknown error'}]`);
        }
      }
      
      return contextParts.join('\n');
    }
    
    // Otherwise, use the default behavior: include all previous sequences and groups
    
    // Include results from all previous sequences
    for (let seq = 0; seq < currentSequence; seq++) {
      const sequenceResults = previousResults instanceof Map ? previousResults.get(seq) : previousResults[seq];
      if (sequenceResults && sequenceResults.length > 0) {
        contextParts.push(`--- Sequence ${seq} Results ---`);
        sequenceResults.forEach((result, index) => {
          if (result.success) {
            const label = result.id ? `${result.id}` : `Step ${index + 1}`;
            const groupLabel = result.parallelGroup ? ` (${result.parallelGroup})` : '';
            
            if (result.type === 'text' && result.response) {
              contextParts.push(`${label}${groupLabel}: ${result.response}`);
            } else if (result.type === 'image' && result.imagePath) {
              contextParts.push(`${label}${groupLabel}: [Image generated: ${result.imagePath}]`);
            }
          }
        });
        contextParts.push('');
      }
    }
    
    // Include results from previous parallel groups in the current sequence
    if (currentSequenceGroupResults && currentParallelGroup) {
      for (const [groupKey, groupResults] of Object.entries(currentSequenceGroupResults)) {
        // Only include groups that come before the current group alphabetically
        if (groupKey !== 'default' && currentParallelGroup !== 'default' && groupKey >= currentParallelGroup) {
          continue;
        }
        if (groupKey === currentParallelGroup) {
          continue; // Don't include current group
        }
        
        if (groupResults && groupResults.length > 0) {
          contextParts.push(`--- Sequence ${currentSequence}, Group ${groupKey} Results ---`);
          groupResults.forEach((result, index) => {
            if (result.success) {
              const label = result.id ? `${result.id}` : `Step ${index + 1}`;
              
              if (result.type === 'text' && result.response) {
                contextParts.push(`${label}: ${result.response}`);
              } else if (result.type === 'image' && result.imagePath) {
                contextParts.push(`${label}: [Image generated: ${result.imagePath}]`);
              }
            }
          });
          contextParts.push('');
        }
      }
    }
    
    return contextParts.join('\n');
  }

  /**
   * Build enhanced user prompt with context from previous results
   */
  buildUserPromptWithContext(
    originalPrompt: string,
    promptConfig: PromptConfig,
    executionContext: ExecutionContext
  ): string {
    let userPrompt = originalPrompt;
    
    // Add previous results as context if requested
    if (promptConfig.includePreviousResults) {
      const previousContext = this.buildPreviousResultsContext(
        executionContext.previousResults,
        promptConfig.sequence || 0,
        undefined, // currentSequenceGroupResults - would need to be passed in
        promptConfig.parallelGroup,
        promptConfig.contextFromSteps,
        executionContext.allResults
      );
      
      if (previousContext) {
        userPrompt = `Previous step results:\n${previousContext}\n\nCurrent prompt: ${originalPrompt}`;
      }
    }
    
    return userPrompt;
  }

  /**
   * Initialize execution context for batch processing
   */
  initializeExecutionContext(sessionId?: string, context?: any): ExecutionContext {
    return {
      sessionId,
      context,
      previousResults: new Map(),
      allResults: []
    };
  }

  /**
   * Update execution context with new results
   */
  updateExecutionContext(
    executionContext: ExecutionContext,
    sequence: number,
    results: PromptExecutionResult[]
  ): void {
    // Store results by sequence
    const currentSequenceResults = executionContext.previousResults.get(sequence) || [];
    currentSequenceResults.push(...results);
    executionContext.previousResults.set(sequence, currentSequenceResults);
    
    // Add to all results
    executionContext.allResults.push(...results);
  }
}
```

## agents/agentManager/modes/batchExecutePrompt/services/PromptExecutor.ts

```typescript
import { LLMService } from '../../../../../services/llm/core/LLMService';
import { CustomPromptStorageService } from '../../../services/CustomPromptStorageService';
import { BudgetValidator } from './BudgetValidator';
import { ContextBuilder } from './ContextBuilder';
import { 
  PromptConfig, 
  TextPromptConfig,
  PromptExecutionResult, 
  PromptExecutionParams,
  ExecutionContext 
} from '../types';
import { getErrorMessage } from '../../../../../utils/errorUtils';

/**
 * Service responsible for executing individual LLM prompts
 * Follows SRP by focusing only on prompt execution logic
 */
export class PromptExecutor {
  constructor(
    private llmService: LLMService,
    private budgetValidator: BudgetValidator,
    private contextBuilder: ContextBuilder,
    private promptStorage?: CustomPromptStorageService
  ) {}

  /**
   * Execute a single prompt with all necessary context and validation
   */
  async executePrompt(
    promptConfig: PromptConfig,
    executionContext: ExecutionContext,
    currentSequence: number,
    index: number = 0
  ): Promise<PromptExecutionResult> {
    try {
      // Add delay between concurrent requests to avoid overwhelming APIs
      if (index > 0) {
        await new Promise(resolve => setTimeout(resolve, index * 100));
      }
      
      const startTime = performance.now();
      
      // Only handle text prompts - images are handled by RequestExecutor
      if (promptConfig.type !== 'text') {
        const executionTime = performance.now() - startTime;
        return {
          type: 'text',
          id: promptConfig.id,
          prompt: promptConfig.prompt,
          success: false,
          error: 'PromptExecutor only handles text prompts',
          executionTime,
          sequence: currentSequence,
          parallelGroup: promptConfig.parallelGroup
        };
      }

      const textConfig = promptConfig as TextPromptConfig;

      // Validate and determine provider and model
      const { provider, model, validationError } = await this.validateAndSelectProviderModel(textConfig);
      if (validationError) {
        const executionTime = performance.now() - startTime;
        return {
          type: 'text',
          id: textConfig.id,
          prompt: textConfig.prompt,
          success: false,
          error: validationError,
          provider: textConfig.provider,
          model: textConfig.model,
          agent: textConfig.agent || 'default',
          executionTime,
          sequence: currentSequence,
          parallelGroup: textConfig.parallelGroup
        };
      }

      // Resolve custom agent/prompt if specified
      const { systemPrompt, agentUsed } = await this.resolveCustomPrompt(textConfig.agent);
      
      // Build user prompt with context from previous results
      const userPrompt = this.contextBuilder.buildUserPromptWithContext(
        textConfig.prompt,
        textConfig,
        executionContext
      );
      
      // Build execution parameters with validated provider and model
      const executeParams: PromptExecutionParams = {
        systemPrompt,
        userPrompt,
        filepaths: textConfig.contextFiles,
        provider,
        model,
        workspace: textConfig.workspace,
        sessionId: executionContext.sessionId
      };
      
      // Check budget before executing
      await this.budgetValidator.validateBudget();
      
      // Execute the prompt
      const response = await this.llmService.executePrompt(executeParams);
      
      // Track usage
      if (response.cost && response.provider) {
        await this.budgetValidator.trackUsage(
          response.provider.toLowerCase(),
          response.cost.totalCost || 0
        );
      }
      
      const executionTime = performance.now() - startTime;
      
      return {
        type: 'text',
        id: textConfig.id,
        prompt: textConfig.prompt,
        success: true,
        response: response.response,
        provider: response.provider,
        model: response.model,
        agent: agentUsed,
        usage: response.usage,
        cost: response.cost,
        executionTime,
        filesIncluded: response.filesIncluded,
        sequence: currentSequence,
        parallelGroup: textConfig.parallelGroup
      };
      
    } catch (error) {
      console.warn(`LLM prompt execution failed for prompt "${promptConfig.prompt.substring(0, 50)}...":`, error);
      
      return {
        type: 'text',
        id: promptConfig.id,
        prompt: promptConfig.prompt,
        success: false,
        error: getErrorMessage(error),
        provider: promptConfig.provider,
        model: promptConfig.model,
        agent: promptConfig.type === 'text' ? (promptConfig as TextPromptConfig).agent || 'default' : 'default',
        executionTime: 0,
        sequence: currentSequence,
        parallelGroup: promptConfig.parallelGroup
      };
    }
  }

  /**
   * Execute multiple prompts concurrently
   */
  async executeConcurrentPrompts(
    prompts: PromptConfig[],
    executionContext: ExecutionContext,
    currentSequence: number
  ): Promise<PromptExecutionResult[]> {
    const batchPromises = prompts.map((promptConfig, index) => 
      this.executePrompt(promptConfig, executionContext, currentSequence, index)
    );
    
    return await Promise.all(batchPromises);
  }

  /**
   * Validate and select provider and model for execution
   */
  private async validateAndSelectProviderModel(textConfig: TextPromptConfig): Promise<{
    provider?: string;
    model?: string;
    validationError?: string;
  }> {
    try {
      // Get available providers
      const availableProviders = this.llmService.getAvailableProviders();
      
      if (availableProviders.length === 0) {
        return {
          validationError: 'No LLM providers available. Please configure at least one provider with valid API keys in settings.'
        };
      }

      // Determine provider
      let selectedProvider = textConfig.provider;
      
      // If no provider specified, use the first available one
      if (!selectedProvider) {
        const defaultModel = this.llmService.getDefaultModel();
        selectedProvider = defaultModel.provider;
        
        // If default provider isn't available, use first available provider
        if (!availableProviders.includes(selectedProvider)) {
          selectedProvider = availableProviders[0];
        }
      }
      
      // Validate that selected provider is available
      if (!availableProviders.includes(selectedProvider)) {
        return {
          validationError: `Provider '${selectedProvider}' is not available. Available providers: ${availableProviders.join(', ')}. Please check your API key configuration.`
        };
      }

      // Get available models for the provider
      const availableModels = await this.llmService.getAvailableModels();
      const providerModels = availableModels.filter(m => m.provider === selectedProvider);
      
      if (providerModels.length === 0) {
        return {
          validationError: `No models available for provider '${selectedProvider}'.`
        };
      }

      // Determine model
      let selectedModel = textConfig.model;
      
      // If no model specified, use default or first available for provider
      if (!selectedModel) {
        const defaultModel = this.llmService.getDefaultModel();
        
        // If default provider matches, use default model
        if (defaultModel.provider === selectedProvider) {
          selectedModel = defaultModel.model;
        } else {
          // Use first available model for the provider
          selectedModel = providerModels[0].id;
        }
      }
      
      // Validate that selected model exists for the provider
      const modelExists = providerModels.some(m => m.id === selectedModel);
      if (!modelExists) {
        const availableModelNames = providerModels.map(m => m.id);
        return {
          validationError: `Model '${selectedModel}' is not available for provider '${selectedProvider}'. Available models: ${availableModelNames.join(', ')}`
        };
      }

      return {
        provider: selectedProvider,
        model: selectedModel
      };
      
    } catch (error) {
      return {
        validationError: `Failed to validate provider/model: ${getErrorMessage(error)}`
      };
    }
  }

  /**
   * Resolve custom agent/prompt configuration
   */
  private async resolveCustomPrompt(agentName?: string): Promise<{ systemPrompt: string; agentUsed: string }> {
    let systemPrompt = '';
    let agentUsed = 'default';
    
    if (agentName && this.promptStorage) {
      try {
        const customPrompt = await this.promptStorage.getPromptByName(agentName);
        if (customPrompt && customPrompt.isEnabled) {
          systemPrompt = customPrompt.prompt;
          agentUsed = customPrompt.name;
        }
      } catch (error) {
        console.warn(`Failed to resolve custom prompt "${agentName}":`, error);
      }
    }
    
    return { systemPrompt, agentUsed };
  }
}
```

## agents/agentManager/modes/batchExecutePrompt/services/RequestExecutor.ts

```typescript
import { 
  PromptConfig, 
  TextPromptConfig, 
  ImagePromptConfig, 
  PromptExecutionResult,
  TextExecutionResult,
  ImageExecutionResult
} from '../types';
import { PromptExecutor } from './PromptExecutor';
import { ActionExecutor } from './ActionExecutor';

/**
 * Service responsible for executing different types of requests (text and image)
 * Coordinates between PromptExecutor and ActionExecutor for unified handling
 */
export class RequestExecutor {
  constructor(
    private promptExecutor: PromptExecutor,
    private actionExecutor: ActionExecutor
  ) {}

  /**
   * Execute a single request (text or image)
   */
  async executeRequest(
    config: PromptConfig,
    context: any,
    sessionId?: string
  ): Promise<PromptExecutionResult> {
    const startTime = performance.now();

    try {
      if (config.type === 'text') {
        return await this.executeTextRequest(config as TextPromptConfig, context, sessionId, startTime);
      } else if (config.type === 'image') {
        return await this.executeImageRequest(config as ImagePromptConfig, context, sessionId, startTime);
      } else {
        const executionTime = performance.now() - startTime;
        // Cast to any temporarily to access properties
        const anyConfig = config as any;
        return {
          type: 'text', // Default fallback
          id: anyConfig.id,
          prompt: anyConfig.prompt,
          success: false,
          error: `Unknown request type: ${anyConfig.type}`,
          executionTime,
          sequence: anyConfig.sequence,
          parallelGroup: anyConfig.parallelGroup
        } as TextExecutionResult;
      }
    } catch (error) {
      const executionTime = performance.now() - startTime;
      return {
        type: 'text', // Default fallback for errors
        id: config.id,
        prompt: config.prompt,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown execution error',
        executionTime,
        sequence: config.sequence,
        parallelGroup: config.parallelGroup
      } as TextExecutionResult;
    }
  }

  /**
   * Execute a text prompt request
   */
  private async executeTextRequest(
    config: TextPromptConfig,
    context: any,
    sessionId?: string,
    startTime?: number
  ): Promise<TextExecutionResult> {
    const actualStartTime = startTime || performance.now();

    try {
      // Execute the text prompt using the existing PromptExecutor
      const result = await this.promptExecutor.executePrompt(
        config, 
        context, 
        config.sequence || 0
      );
      
      const executionTime = performance.now() - actualStartTime;

      // Type guard to ensure we have a text result
      if (result.type === 'text') {
        return {
          type: 'text',
          id: config.id,
          prompt: config.prompt,
          success: result.success,
          response: result.response,
          provider: result.provider,
          model: result.model,
          agent: result.agent,
          error: result.error,
          executionTime,
          sequence: config.sequence,
          parallelGroup: config.parallelGroup,
          usage: result.usage,
          cost: result.cost,
          filesIncluded: result.filesIncluded,
          actionPerformed: result.actionPerformed
        };
      } else {
        // Handle unexpected result type
        return {
          type: 'text',
          id: config.id,
          prompt: config.prompt,
          success: false,
          error: 'Unexpected result type from text execution',
          executionTime,
          sequence: config.sequence,
          parallelGroup: config.parallelGroup
        };
      }
    } catch (error) {
      const executionTime = performance.now() - actualStartTime;
      return {
        type: 'text',
        id: config.id,
        prompt: config.prompt,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown text execution error',
        executionTime,
        sequence: config.sequence,
        parallelGroup: config.parallelGroup
      };
    }
  }

  /**
   * Execute an image generation request
   */
  private async executeImageRequest(
    config: ImagePromptConfig,
    context: any,
    sessionId?: string,
    startTime?: number
  ): Promise<ImageExecutionResult> {
    const actualStartTime = startTime || performance.now();

    try {
      // Execute image generation using ActionExecutor
      const result = await this.actionExecutor.executeImageGenerationAction(
        config,
        sessionId,
        typeof context === 'string' ? context : JSON.stringify(context)
      );

      const executionTime = performance.now() - actualStartTime;

      if (result.success) {
        return {
          type: 'image',
          id: config.id,
          prompt: config.prompt,
          success: true,
          imagePath: result.imagePath,
          provider: config.provider,
          model: config.model || 'imagen-4',
          executionTime,
          sequence: config.sequence,
          parallelGroup: config.parallelGroup,
          // Note: Additional metadata like dimensions, fileSize, etc. would need to be
          // extracted from the image generation result if available
        };
      } else {
        return {
          type: 'image',
          id: config.id,
          prompt: config.prompt,
          success: false,
          error: result.error,
          provider: config.provider,
          model: config.model || 'imagen-4',
          executionTime,
          sequence: config.sequence,
          parallelGroup: config.parallelGroup
        };
      }
    } catch (error) {
      const executionTime = performance.now() - actualStartTime;
      return {
        type: 'image',
        id: config.id,
        prompt: config.prompt,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown image execution error',
        provider: config.provider,
        model: config.model || 'imagen-4',
        executionTime,
        sequence: config.sequence,
        parallelGroup: config.parallelGroup
      };
    }
  }

  /**
   * Execute multiple requests in parallel
   */
  async executeRequestsInParallel(
    configs: PromptConfig[],
    context: any,
    sessionId?: string
  ): Promise<PromptExecutionResult[]> {
    const promises = configs.map(config => 
      this.executeRequest(config, context, sessionId)
    );
    
    return await Promise.all(promises);
  }

  /**
   * Validate a request configuration
   */
  validateRequest(config: PromptConfig): { valid: boolean; error?: string } {
    if (!config.type) {
      return { valid: false, error: 'Request type is required' };
    }

    if (!config.prompt || config.prompt.trim().length === 0) {
      return { valid: false, error: 'Prompt is required' };
    }

    if (config.type === 'image') {
      const imageConfig = config as ImagePromptConfig;
      
      if (!imageConfig.savePath || imageConfig.savePath.trim().length === 0) {
        return { valid: false, error: 'Save path is required for image generation' };
      }

      if (imageConfig.savePath.includes('..') || imageConfig.savePath.startsWith('/')) {
        return { valid: false, error: 'Save path must be relative to vault root' };
      }

      if (imageConfig.provider !== 'google') {
        return { valid: false, error: 'Only Google provider is currently supported for image generation' };
      }
    }

    return { valid: true };
  }
}
```

## agents/agentManager/modes/batchExecutePrompt/services/ResultProcessor.ts

```typescript
import { 
  PromptExecutionResult, 
  BatchExecutePromptResult, 
  ExecutionStats, 
  MergedResponse 
} from '../types';

/**
 * Service responsible for processing and formatting execution results
 * Follows SRP by focusing only on result processing logic
 */
export class ResultProcessor {

  /**
   * Process results into final batch execution result
   */
  processResults(
    results: PromptExecutionResult[],
    mergeResponses: boolean,
    totalExecutionTime: number,
    totalPrompts: number
  ): BatchExecutePromptResult {
    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);

    const stats: ExecutionStats = {
      totalExecutionTimeMS: totalExecutionTime,
      promptsExecuted: totalPrompts,
      promptsFailed: failed.length,
      avgExecutionTimeMS: totalPrompts > 0 ? totalExecutionTime / totalPrompts : 0,
      tokensUsed: this.calculateTotalTokens(results)
    };

    if (mergeResponses) {
      const merged = this.mergePromptResults(successful);
      
      return {
        success: true,
        merged: {
          totalPrompts,
          successfulPrompts: successful.length,
          combinedResponse: merged.combinedResponse,
          providersUsed: merged.providersUsed
        },
        stats
      };
    } else {
      return {
        success: true,
        results: results,
        stats
      };
    }
  }

  /**
   * Create error result for batch execution failures
   */
  createErrorResult(error: string): BatchExecutePromptResult {
    return {
      success: false,
      error
    };
  }

  /**
   * Merge multiple prompt results into a single unified response
   */
  private mergePromptResults(results: PromptExecutionResult[]): MergedResponse {
    const responses: string[] = [];
    const providersUsed = new Set<string>();
    
    results.forEach((result, index) => {
      if (result.success) {
        let responseContent = '';
        
        if (result.type === 'text' && result.response) {
          responseContent = result.response;
        } else if (result.type === 'image' && result.imagePath) {
          responseContent = `[Image generated: ${result.imagePath}]`;
        }
        
        if (responseContent) {
          responses.push(
            `## Response ${index + 1}${result.id ? ` (${result.id})` : ''}${result.provider ? ` - ${result.provider}` : ''}\n\n${responseContent}`
          );
          
          if (result.provider) {
            providersUsed.add(result.provider);
          }
        }
      }
    });
    
    const combinedResponse = responses.join('\n\n---\n\n');
    
    return {
      totalPrompts: results.length,
      successfulPrompts: results.filter(r => r.success).length,
      combinedResponse,
      providersUsed: Array.from(providersUsed)
    };
  }

  /**
   * Calculate total tokens used across all results
   */
  private calculateTotalTokens(results: PromptExecutionResult[]): number | undefined {
    let totalTokens = 0;
    let hasTokenData = false;

    for (const result of results) {
      if (result.usage) {
        if (result.type === 'text' && 'totalTokens' in result.usage && result.usage.totalTokens) {
          totalTokens += result.usage.totalTokens;
          hasTokenData = true;
        }
        // Note: Image usage has different metrics (imagesGenerated, resolution, etc.)
        // and doesn't have totalTokens, so we skip those for token calculation
      }
    }

    return hasTokenData ? totalTokens : undefined;
  }

  /**
   * Calculate total cost across all results
   */
  calculateTotalCost(results: PromptExecutionResult[]): { totalCost: number; currency: string } | undefined {
    let totalCost = 0;
    let currency = 'USD';
    let hasCostData = false;

    for (const result of results) {
      if (result.cost?.totalCost) {
        totalCost += result.cost.totalCost;
        currency = result.cost.currency || 'USD';
        hasCostData = true;
      }
    }

    return hasCostData ? { totalCost, currency } : undefined;
  }

  /**
   * Get summary statistics for reporting
   */
  getResultsSummary(results: PromptExecutionResult[]) {
    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);
    const providersUsed = new Set(results.map(r => r.provider).filter(Boolean));
    const modelsUsed = new Set(results.map(r => r.model).filter(Boolean));

    return {
      total: results.length,
      successful: successful.length,
      failed: failed.length,
      successRate: results.length > 0 ? (successful.length / results.length) * 100 : 0,
      providersUsed: Array.from(providersUsed),
      modelsUsed: Array.from(modelsUsed),
      totalCost: this.calculateTotalCost(results),
      totalTokens: this.calculateTotalTokens(results)
    };
  }

  /**
   * Filter results by criteria
   */
  filterResults(
    results: PromptExecutionResult[],
    criteria: {
      onlySuccessful?: boolean;
      onlyFailed?: boolean;
      provider?: string;
      sequence?: number;
      parallelGroup?: string;
    }
  ): PromptExecutionResult[] {
    return results.filter(result => {
      if (criteria.onlySuccessful && !result.success) return false;
      if (criteria.onlyFailed && result.success) return false;
      if (criteria.provider && result.provider !== criteria.provider) return false;
      if (criteria.sequence !== undefined && result.sequence !== criteria.sequence) return false;
      if (criteria.parallelGroup && result.parallelGroup !== criteria.parallelGroup) return false;
      return true;
    });
  }
}
```

## agents/agentManager/modes/batchExecutePrompt/services/SequenceManager.ts

```typescript
import { RequestExecutor } from './RequestExecutor';
import { ContextBuilder } from './ContextBuilder';
import { 
  PromptConfig, 
  PromptExecutionResult, 
  ExecutionContext 
} from '../types';

/**
 * Service responsible for managing request execution sequences and parallel groups
 * Handles both text and image requests through RequestExecutor
 * Follows SRP by focusing only on execution orchestration logic
 */
export class SequenceManager {
  constructor(
    private requestExecutor: RequestExecutor,
    private contextBuilder: ContextBuilder
  ) {}

  /**
   * Execute prompts with sequence and parallel group support
   * - Sequences execute in numerical order (0, 1, 2, etc.)
   * - Within each sequence, parallel groups execute sequentially
   * - Prompts within the same parallel group execute concurrently
   */
  async executePromptsWithSequencing(
    prompts: PromptConfig[],
    executionContext: ExecutionContext
  ): Promise<PromptExecutionResult[]> {
    const results: PromptExecutionResult[] = [];
    
    // Group prompts by sequence number (default to 0 if not specified)
    const sequenceGroups = this.groupPromptsBySequence(prompts);
    
    // Sort sequences to execute in order
    const sortedSequences = Array.from(sequenceGroups.keys()).sort((a, b) => a - b);
    
    // Execute each sequence in order
    for (const sequence of sortedSequences) {
      const sequencePrompts = sequenceGroups.get(sequence)!;
      
      // Execute prompts within this sequence with parallel group support
      const sequenceResults = await this.executeSequenceWithParallelGroups(
        sequencePrompts,
        executionContext,
        sequence
      );
      
      results.push(...sequenceResults);
      
      // Update execution context with results from this sequence
      this.contextBuilder.updateExecutionContext(executionContext, sequence, sequenceResults);
    }
    
    return results;
  }

  /**
   * Execute a sequence with parallel group support
   * Groups prompts by parallelGroup and executes groups sequentially, prompts within groups concurrently
   */
  private async executeSequenceWithParallelGroups(
    prompts: PromptConfig[],
    executionContext: ExecutionContext,
    currentSequence: number
  ): Promise<PromptExecutionResult[]> {
    const results: PromptExecutionResult[] = [];
    
    // Group prompts by parallelGroup within this sequence
    const parallelGroups = this.groupPromptsByParallelGroup(prompts);
    
    // Sort groups to ensure consistent execution order (default group first, then alphabetically)
    const sortedGroups = this.sortParallelGroups(Array.from(parallelGroups.keys()));
    
    // Execute each parallel group sequentially
    for (const groupKey of sortedGroups) {
      const groupPrompts = parallelGroups.get(groupKey)!;
      
      // Execute all requests in this group concurrently (text and image)
      const groupExecutionResults = await this.requestExecutor.executeRequestsInParallel(
        groupPrompts,
        executionContext,
        executionContext.sessionId
      );
      
      results.push(...groupExecutionResults);
      
      // Update context with results from this group
      executionContext.allResults.push(...groupExecutionResults);
    }
    
    return results;
  }

  /**
   * Group prompts by sequence number
   */
  private groupPromptsBySequence(prompts: PromptConfig[]): Map<number, PromptConfig[]> {
    const sequenceGroups = new Map<number, PromptConfig[]>();
    
    for (const prompt of prompts) {
      const sequence = prompt.sequence || 0;
      if (!sequenceGroups.has(sequence)) {
        sequenceGroups.set(sequence, []);
      }
      sequenceGroups.get(sequence)!.push(prompt);
    }
    
    return sequenceGroups;
  }

  /**
   * Group prompts by parallel group within a sequence
   */
  private groupPromptsByParallelGroup(prompts: PromptConfig[]): Map<string, PromptConfig[]> {
    const parallelGroups = new Map<string, PromptConfig[]>();
    
    for (const prompt of prompts) {
      const groupKey = prompt.parallelGroup || 'default';
      if (!parallelGroups.has(groupKey)) {
        parallelGroups.set(groupKey, []);
      }
      parallelGroups.get(groupKey)!.push(prompt);
    }
    
    return parallelGroups;
  }

  /**
   * Sort parallel groups to ensure consistent execution order
   * Default group executes first, then alphabetically
   */
  private sortParallelGroups(groupKeys: string[]): string[] {
    return groupKeys.sort((a, b) => {
      if (a === 'default' && b !== 'default') return -1;
      if (a !== 'default' && b === 'default') return 1;
      return a.localeCompare(b);
    });
  }

  /**
   * Get execution statistics from results
   */
  getExecutionStatistics(results: PromptExecutionResult[]) {
    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);
    const totalExecutionTime = results.reduce((sum, r) => sum + (r.executionTime || 0), 0);
    
    return {
      totalPrompts: results.length,
      successfulPrompts: successful.length,
      failedPrompts: failed.length,
      totalExecutionTimeMS: totalExecutionTime,
      avgExecutionTimeMS: results.length > 0 ? totalExecutionTime / results.length : 0
    };
  }
}
```

## agents/agentManager/modes/batchExecutePrompt/services/index.ts

```typescript
// Re-export all services for easy importing
export * from './ActionExecutor';
export * from './BudgetValidator';
export * from './ContextBuilder';
export * from './PromptExecutor';
export * from './RequestExecutor';
export * from './ResultProcessor';
export * from './SequenceManager';
```

## agents/agentManager/modes/batchExecutePrompt/types/BatchExecuteTypes.ts

```typescript
import { CommonParameters } from '../../../../../types';
import { AspectRatio } from '../../../../../services/llm/types/ImageTypes';

/**
 * Parameters for batch LLM prompt execution
 * Now supports mixed text and image generation requests
 */
export interface BatchExecutePromptParams extends CommonParameters {
  /** Array of requests to execute - can be text prompts or image generation requests */
  prompts: Array<BatchRequest>;
  /** Whether to merge all responses into a single result */
  mergeResponses?: boolean;
}

/**
 * Base interface for batch requests
 */
export interface BaseBatchRequest {
  /** Custom identifier for this request */
  id?: string;
  /** Sequence number for ordered execution (sequences execute in numerical order: 0, 1, 2, etc.) */
  sequence?: number;
  /** Parallel group within sequence - requests with same parallelGroup run together */
  parallelGroup?: string;
  /** Whether to include previous step results as context */
  includePreviousResults?: boolean;
  /** Specific IDs of previous steps to include as context */
  contextFromSteps?: string[];
}

/**
 * Text prompt request for LLM generation
 */
export interface TextPromptRequest extends BaseBatchRequest {
  /** Request type identifier */
  type: 'text';
  /** The prompt text to send to the LLM */
  prompt: string;
  /** Optional provider to use (defaults to settings default) */
  provider?: string;
  /** Optional model to use (defaults to settings default) */
  model?: string;
  /** Optional context files to include */
  contextFiles?: string[];
  /** Optional workspace for context */
  workspace?: string;
  /** Optional action to perform with the LLM response */
  action?: ContentAction;
  /** Optional custom agent/prompt to use */
  agent?: string;
}

/**
 * Image generation request
 */
export interface ImageGenerationRequest extends BaseBatchRequest {
  /** Request type identifier */
  type: 'image';
  /** The prompt text describing the image to generate */
  prompt: string;
  /** Image generation provider (google for Imagen, openai disabled for now) */
  provider: 'google'; // Only Google supported currently due to OpenAI speed issues
  /** Optional model to use (imagen-4, imagen-4-ultra) */
  model?: 'imagen-4' | 'imagen-4-ultra';
  /** Image aspect ratio */
  aspectRatio?: AspectRatio;
  /** Vault-relative path where the image should be saved */
  savePath: string;
}

/**
 * Union type for all batch request types
 */
export type BatchRequest = TextPromptRequest | ImageGenerationRequest;

/**
 * Individual request configuration for execution (unified for text and image)
 */
export type PromptConfig = TextPromptConfig | ImagePromptConfig;

/**
 * Text prompt configuration for execution
 */
export interface TextPromptConfig {
  type: 'text';
  prompt: string;
  provider?: string;
  model?: string;
  contextFiles?: string[];
  workspace?: string;
  id?: string;
  sequence?: number;
  parallelGroup?: string;
  includePreviousResults?: boolean;
  contextFromSteps?: string[];
  action?: ContentAction;
  agent?: string;
}

/**
 * Image generation configuration for execution
 */
export interface ImagePromptConfig {
  type: 'image';
  prompt: string;
  provider: 'google';
  model?: 'imagen-4' | 'imagen-4-ultra';
  aspectRatio?: AspectRatio;
  savePath: string;
  id?: string;
  sequence?: number;
  parallelGroup?: string;
  includePreviousResults?: boolean;
  contextFromSteps?: string[];
}

/**
 * Content action configuration
 */
export interface ContentAction {
  type: 'create' | 'append' | 'prepend' | 'replace' | 'findReplace';
  targetPath: string;
  position?: number;
  findText?: string;
  replaceAll?: boolean;
  caseSensitive?: boolean;
  wholeWord?: boolean;
}

/**
 * Execution context for prompt processing
 */
export interface ExecutionContext {
  sessionId?: string;
  context?: any;
  previousResults: Map<number, PromptExecutionResult[]>;
  allResults: PromptExecutionResult[];
}

/**
 * Parameters for individual prompt execution
 */
export interface PromptExecutionParams {
  systemPrompt: string;
  userPrompt: string;
  filepaths?: string[];
  provider?: string;
  model?: string;
  workspace?: string;
  sessionId?: string;
}

/**
 * Result from individual request execution (unified for text and image)
 */
export type PromptExecutionResult = TextExecutionResult | ImageExecutionResult;

/**
 * Result from text prompt execution
 */
export interface TextExecutionResult {
  type: 'text';
  id?: string;
  prompt: string;
  success: boolean;
  response?: string;
  provider?: string;
  model?: string;
  agent?: string;
  error?: string;
  executionTime?: number;
  sequence?: number;
  parallelGroup?: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  cost?: {
    inputCost: number;
    outputCost: number;
    totalCost: number;
    currency: string;
  };
  filesIncluded?: string[];
  actionPerformed?: {
    type: string;
    targetPath: string;
    success: boolean;
    error?: string;
  };
}

/**
 * Result from image generation execution
 */
export interface ImageExecutionResult {
  type: 'image';
  id?: string;
  prompt: string;
  success: boolean;
  imagePath?: string;
  revisedPrompt?: string;
  provider?: string;
  model?: string;
  error?: string;
  executionTime?: number;
  sequence?: number;
  parallelGroup?: string;
  dimensions?: { width: number; height: number };
  fileSize?: number;
  format?: string;
  usage?: {
    imagesGenerated: number;
    resolution: string;
    model: string;
    provider: string;
  };
  cost?: {
    inputCost: number;
    outputCost: number;
    totalCost: number;
    currency: string;
    ratePerImage?: number;
  };
  metadata?: Record<string, any>;
}
```

## agents/agentManager/modes/batchExecutePrompt/types/ExecutionResult.ts

```typescript
import { PromptExecutionResult } from './BatchExecuteTypes';

/**
 * Result from batch LLM prompt execution
 */
export interface BatchExecutePromptResult {
  success: boolean;
  /** Individual prompt results (if mergeResponses is false) */
  results?: PromptExecutionResult[];
  /** Merged response (if mergeResponses is true) */
  merged?: {
    totalPrompts: number;
    successfulPrompts: number;
    combinedResponse: string;
    providersUsed: string[];
  };
  /** Execution statistics */
  stats?: {
    totalExecutionTimeMS: number;
    promptsExecuted: number;
    promptsFailed: number;
    avgExecutionTimeMS: number;
    tokensUsed?: number;
  };
  error?: string;
}

/**
 * Execution statistics for monitoring
 */
export interface ExecutionStats {
  totalExecutionTimeMS: number;
  promptsExecuted: number;
  promptsFailed: number;
  avgExecutionTimeMS: number;
  tokensUsed?: number;
}

/**
 * Merged response data
 */
export interface MergedResponse {
  totalPrompts: number;
  successfulPrompts: number;
  combinedResponse: string;
  providersUsed: string[];
}
```

## agents/agentManager/modes/batchExecutePrompt/types/index.ts

```typescript
// Re-export all types for easy importing
export * from './BatchExecuteTypes';
export * from './ExecutionResult';
```

## agents/agentManager/modes/batchExecutePrompt/utils/PromptParser.ts

```typescript
import { PromptConfig, BatchExecutePromptParams, BatchRequest, TextPromptRequest, ImageGenerationRequest } from '../types';

/**
 * Utility for parsing and validating prompt configurations
 * Follows SRP by focusing only on prompt parsing logic
 */
export class PromptParser {

  /**
   * Validate batch execution parameters
   */
  validateParameters(params: BatchExecutePromptParams): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!params.prompts || params.prompts.length === 0) {
      errors.push('At least one prompt is required');
    }

    if (params.prompts && params.prompts.length > 100) {
      errors.push('Maximum of 100 prompts allowed per batch');
    }

    // Validate individual prompts
    if (params.prompts) {
      params.prompts.forEach((prompt, index) => {
        const promptErrors = this.validatePromptConfig(prompt, index);
        errors.push(...promptErrors);
      });
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * Validate individual request configuration (text or image)
   */
  validatePromptConfig(requestConfig: any, index: number): string[] {
    const errors: string[] = [];
    const prefix = `Request ${index + 1}`;
    const requestType = requestConfig.type || 'text'; // Default to text for backward compatibility

    if (!requestConfig.prompt || typeof requestConfig.prompt !== 'string') {
      errors.push(`${prefix}: prompt text is required and must be a string`);
    }

    if (requestConfig.prompt && requestConfig.prompt.length > 32000) {
      errors.push(`${prefix}: prompt text cannot exceed 32,000 characters`);
    }

    // Type-specific validation
    if (requestType === 'image') {
      const imageConfig = requestConfig as ImageGenerationRequest;
      
      if (!imageConfig.savePath || typeof imageConfig.savePath !== 'string') {
        errors.push(`${prefix}: savePath is required for image generation`);
      }

      if (imageConfig.savePath && (imageConfig.savePath.includes('..') || imageConfig.savePath.startsWith('/'))) {
        errors.push(`${prefix}: savePath must be relative to vault root`);
      }

      if (!imageConfig.provider || imageConfig.provider !== 'google') {
        errors.push(`${prefix}: only 'google' provider is currently supported for image generation`);
      }

      if (imageConfig.model && !['imagen-4', 'imagen-4-ultra'].includes(imageConfig.model)) {
        errors.push(`${prefix}: invalid model for image generation. Supported: imagen-4, imagen-4-ultra`);
      }

    }

    if (requestConfig.sequence !== undefined && (typeof requestConfig.sequence !== 'number' || requestConfig.sequence < 0)) {
      errors.push(`${prefix}: sequence must be a non-negative number`);
    }

    if (requestConfig.contextFiles && !Array.isArray(requestConfig.contextFiles)) {
      errors.push(`${prefix}: contextFiles must be an array`);
    }

    if (requestConfig.contextFromSteps && !Array.isArray(requestConfig.contextFromSteps)) {
      errors.push(`${prefix}: contextFromSteps must be an array`);
    }

    // Only validate actions for text requests (images don't have actions)
    if (requestType === 'text' && requestConfig.action) {
      const actionErrors = this.validateActionConfig(requestConfig.action, prefix);
      errors.push(...actionErrors);
    }

    return errors;
  }

  /**
   * Validate action configuration
   */
  validateActionConfig(action: any, prefix: string): string[] {
    const errors: string[] = [];

    if (!action.type) {
      errors.push(`${prefix}: action.type is required`);
    }

    if (!action.targetPath) {
      errors.push(`${prefix}: action.targetPath is required`);
    }

    const validActionTypes = ['create', 'append', 'prepend', 'replace', 'findReplace'];
    if (action.type && !validActionTypes.includes(action.type)) {
      errors.push(`${prefix}: action.type must be one of: ${validActionTypes.join(', ')}`);
    }

    if (action.type === 'findReplace' && !action.findText) {
      errors.push(`${prefix}: action.findText is required for findReplace action`);
    }

    if (action.position !== undefined && (typeof action.position !== 'number' || action.position < 0)) {
      errors.push(`${prefix}: action.position must be a non-negative number`);
    }

    return errors;
  }

  /**
   * Normalize request configurations (text and image)
   */
  normalizePromptConfigs(requests: any[]): PromptConfig[] {
    return requests.map((request, index) => {
      const requestType = request.type || 'text'; // Default to text for backward compatibility
      const baseConfig = {
        id: request.id || `request_${index + 1}`,
        sequence: request.sequence || 0,
        parallelGroup: request.parallelGroup || 'default',
        includePreviousResults: request.includePreviousResults || false,
        contextFromSteps: request.contextFromSteps || [],
        prompt: request.prompt
      };

      if (requestType === 'image') {
        return {
          type: 'image',
          ...baseConfig,
          provider: request.provider || 'google',
          model: request.model || 'imagen-4',
          aspectRatio: request.aspectRatio,
          size: request.size,
          quality: request.quality,
          safety: request.safety,
          savePath: request.savePath,
          format: request.format,
          background: request.background
        } as PromptConfig;
      } else {
        return {
          type: 'text',
          ...baseConfig,
          provider: request.provider,
          model: request.model,
          contextFiles: request.contextFiles || [],
          workspace: request.workspace,
          action: request.action,
          agent: request.agent
        } as PromptConfig;
      }
    });
  }

  /**
   * Extract unique sequences from prompts
   */
  extractSequences(prompts: PromptConfig[]): number[] {
    const sequences = new Set(prompts.map(p => p.sequence || 0));
    return Array.from(sequences).sort((a, b) => a - b);
  }

  /**
   * Extract unique parallel groups from prompts
   */
  extractParallelGroups(prompts: PromptConfig[]): string[] {
    const groups = new Set(prompts.map(p => p.parallelGroup || 'default'));
    return Array.from(groups).sort();
  }

  /**
   * Get execution plan summary
   */
  getExecutionPlan(prompts: PromptConfig[]): {
    totalPrompts: number;
    sequences: number[];
    parallelGroups: string[];
    estimatedDuration: string;
  } {
    const sequences = this.extractSequences(prompts);
    const parallelGroups = this.extractParallelGroups(prompts);
    
    // Rough estimation based on typical LLM response times
    const avgPromptTime = 5; // seconds
    const maxConcurrency = Math.max(...parallelGroups.map(group => 
      prompts.filter(p => (p.parallelGroup || 'default') === group).length
    ));
    
    const estimatedSeconds = sequences.length * avgPromptTime * Math.ceil(prompts.length / maxConcurrency);
    const estimatedDuration = this.formatDuration(estimatedSeconds);

    return {
      totalPrompts: prompts.length,
      sequences,
      parallelGroups,
      estimatedDuration
    };
  }

  /**
   * Format duration in human-readable format
   */
  private formatDuration(seconds: number): string {
    if (seconds < 60) {
      return `${seconds}s`;
    } else if (seconds < 3600) {
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`;
    } else {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
    }
  }
}
```

## agents/agentManager/modes/batchExecutePrompt/utils/index.ts

```typescript
// Re-export all utilities for easy importing
export * from './PromptParser';
```

## agents/agentManager/modes/createAgentMode.ts

```typescript
import { BaseMode } from '../../baseMode';
import { CreateAgentParams, CreateAgentResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';
import { getCommonResultSchema, createResult } from '../../../utils/schemaUtils';
import { addRecommendations } from '../../../utils/recommendationUtils';
import { AGENT_MANAGER_RECOMMENDATIONS } from '../recommendations';

/**
 * Mode for creating a new custom agent
 */
export class CreateAgentMode extends BaseMode<CreateAgentParams, CreateAgentResult> {
  private storageService: CustomPromptStorageService;
  
  /**
   * Create a new CreateAgentMode
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'createAgent',
      'Create Agent',
      'Create a new custom agent',
      '1.0.0'
    );
    
    this.storageService = storageService;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the created prompt
   */
  async execute(params: CreateAgentParams): Promise<CreateAgentResult> {
    try {
      const { name, description, prompt, isEnabled = true } = params;
      
      // Validate required fields
      if (!name?.trim()) {
        return createResult<CreateAgentResult>(false, null, 'Name is required', undefined, undefined, params.context.sessionId, params.context);
      }
      
      if (!description?.trim()) {
        return createResult<CreateAgentResult>(false, null, 'Description is required', undefined, undefined, params.context.sessionId, params.context);
      }
      
      if (!prompt?.trim()) {
        return createResult<CreateAgentResult>(false, null, 'Agent prompt text is required', undefined, undefined, params.context.sessionId, params.context);
      }
      
      // Create the prompt
      const newPrompt = await this.storageService.createPrompt({
        name: name.trim(),
        description: description.trim(),
        prompt: prompt.trim(),
        isEnabled
      });
      
      const result = createResult<CreateAgentResult>(true, newPrompt, undefined, undefined, undefined, params.context.sessionId, params.context);
      return addRecommendations(result, AGENT_MANAGER_RECOMMENDATIONS.createAgent);
    } catch (error) {
      return createResult<CreateAgentResult>(false, null, `Failed to create agent: ${error}`, undefined, undefined, params.context.sessionId, params.context);
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Name of the agent (must be unique)',
          minLength: 1,
          maxLength: 100
        },
        description: {
          type: 'string',
          description: 'Description of what this agent does',
          minLength: 1,
          maxLength: 500
        },
        prompt: {
          type: 'string',
          description: 'The actual agent prompt text/persona',
          minLength: 1
        },
        isEnabled: {
          type: 'boolean',
          description: 'Whether the agent is enabled',
          default: true
        }
      },
      required: ['name', 'description', 'prompt']
    };

    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    const commonSchema = getCommonResultSchema();
    
    // Override the data property to define the specific structure for this mode
    return {
      ...commonSchema,
      properties: {
        ...commonSchema.properties,
        data: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            name: { type: 'string' },
            description: { type: 'string' },
            prompt: { type: 'string' },
            isEnabled: { type: 'boolean' }
          },
          required: ['id', 'name', 'description', 'prompt', 'isEnabled']
        },
        recommendations: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              type: { type: 'string' },
              message: { type: 'string' }
            },
            required: ['type', 'message']
          },
          description: 'Workspace-agent optimization recommendations'
        }
      }
    };
  }
}
```

## agents/agentManager/modes/deleteAgentMode.ts

```typescript
import { BaseMode } from '../../baseMode';
import { DeleteAgentParams, DeleteAgentResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';
import { getCommonResultSchema, createResult } from '../../../utils/schemaUtils';

/**
 * Mode for deleting a custom prompt
 */
export class DeleteAgentMode extends BaseMode<DeleteAgentParams, DeleteAgentResult> {
  private storageService: CustomPromptStorageService;
  
  /**
   * Create a new DeletePromptMode
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'deleteAgent',
      'Delete Agent',
      'Delete a custom agent',
      '1.0.0'
    );
    
    this.storageService = storageService;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with deletion result
   */
  async execute(params: DeleteAgentParams): Promise<DeleteAgentResult> {
    try {
      const { id } = params;
      
      // Validate required ID
      if (!id?.trim()) {
        return createResult<DeleteAgentResult>(false, null, 'ID is required', undefined, undefined, params.context.sessionId, params.context);
      }
      
      // Check if prompt exists before deletion
      const existingPrompt = this.storageService.getPrompt(id.trim());
      if (!existingPrompt) {
        return createResult<DeleteAgentResult>(false, null, `Prompt with ID "${id}" not found`, undefined, undefined, params.context.sessionId, params.context);
      }
      
      // Delete the prompt
      const deleted = await this.storageService.deletePrompt(id.trim());
      
      return createResult<DeleteAgentResult>(true, {
        deleted,
        id: id.trim()
      }, undefined, undefined, undefined, params.context.sessionId, params.context);
    } catch (error) {
      return createResult<DeleteAgentResult>(false, null, `Failed to delete prompt: ${error}`, undefined, undefined, params.context.sessionId, params.context);
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'Unique ID of the prompt to delete',
          minLength: 1
        }
      },
      required: ['id']
    };

    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    const commonSchema = getCommonResultSchema();
    
    // Override the data property to define the specific structure for this mode
    return {
      ...commonSchema,
      properties: {
        ...commonSchema.properties,
        data: {
          type: 'object',
          properties: {
            deleted: { type: 'boolean' },
            id: { type: 'string' }
          },
          required: ['deleted', 'id']
        }
      }
    };
  }
}
```

## agents/agentManager/modes/execute/ExecutePromptMode.ts

```typescript
/**
 * Execute Prompt Mode - Orchestrates LLM prompt execution workflow
 * Follows Single Responsibility Principle by delegating specialized tasks to services
 */

import { BaseMode } from '../../../baseMode';
import { CommonResult, CommonParameters } from '../../../../types';
import { createResult, getCommonResultSchema } from '../../../../utils/schemaUtils';
import { LLMProviderManager } from '../../../../services/llm/providers/ProviderManager';
import { CustomPromptStorageService } from '../../services/CustomPromptStorageService';
import { AgentManager } from '../../../../services/AgentManager';
import { UsageTracker, BudgetStatus } from '../../../../services/UsageTracker';
import { 
    DependencyValidator, 
    PromptExecutor, 
    ActionExecutor, 
    BudgetManager,
    ServiceDependencies
} from './services';
import { addRecommendations } from '../../../../utils/recommendationUtils';
import { AGENT_MANAGER_RECOMMENDATIONS } from '../../recommendations';

export interface ExecutePromptParams extends CommonParameters {
    agent?: string;
    filepaths?: string[];
    prompt: string;
    provider?: string;
    model?: string;
    temperature?: number;
    maxTokens?: number;
    returnContent?: boolean;
    webSearch?: boolean;
    action?: {
        type: 'create' | 'append' | 'prepend' | 'replace' | 'findReplace';
        targetPath: string;
        position?: number;
        findText?: string;
        replaceAll?: boolean;
        caseSensitive?: boolean;
        wholeWord?: boolean;
    };
    // sessionId, context, workspaceContext now inherited from CommonParameters
}

export interface ExecutePromptResult extends CommonResult {
    data: {
        response: string;
        model: string;
        provider: string;
        agentUsed: string;
        usage?: {
            promptTokens: number;
            completionTokens: number;
            totalTokens: number;
        };
        cost?: {
            inputCost: number;
            outputCost: number;
            totalCost: number;
            currency: string;
        };
        budgetStatus?: BudgetStatus;
        filesIncluded?: string[];
        actionPerformed?: {
            type: string;
            targetPath: string;
            success: boolean;
            error?: string;
        };
    };
}

/**
 * Main orchestrator for prompt execution workflow
 * Delegates specialized tasks to focused services following SOLID principles
 */
export class ExecutePromptMode extends BaseMode<ExecutePromptParams, ExecutePromptResult> {
    private dependencyValidator: DependencyValidator;
    private promptExecutor: PromptExecutor;
    private actionExecutor: ActionExecutor;
    private budgetManager: BudgetManager;

    constructor() {
        super(
            'executePrompt',
            'Execute Prompt',
            'Execute an LLM prompt using a custom agent with optional file content and ContentManager actions',
            '1.0.0'
        );

        // Initialize services with null dependencies - will be updated via setters
        const dependencies: ServiceDependencies = {
            providerManager: null,
            promptStorage: null,
            agentManager: null,
            usageTracker: null
        };

        this.dependencyValidator = new DependencyValidator(dependencies);
        this.promptExecutor = new PromptExecutor(null!, null!);
        this.actionExecutor = new ActionExecutor(null);
        this.budgetManager = new BudgetManager(null);
    }

    /**
     * Set the provider manager instance
     */
    setProviderManager(providerManager: LLMProviderManager): void {
        this.dependencyValidator.updateDependencies({ providerManager });
        this.promptExecutor = new PromptExecutor(providerManager, this.promptExecutor['promptStorage']);
    }

    /**
     * Set the prompt storage service
     */
    setPromptStorage(promptStorage: CustomPromptStorageService): void {
        this.dependencyValidator.updateDependencies({ promptStorage });
        this.promptExecutor = new PromptExecutor(this.promptExecutor['providerManager'], promptStorage);
    }

    /**
     * Set the usage tracker for LLM cost tracking
     */
    setUsageTracker(usageTracker: UsageTracker): void {
        this.dependencyValidator.updateDependencies({ usageTracker });
        this.budgetManager.updateUsageTracker(usageTracker);
    }

    /**
     * Set the agent manager for action operations
     */
    setAgentManager(agentManager: AgentManager): void {
        this.dependencyValidator.updateDependencies({ agentManager });
        this.actionExecutor.updateAgentManager(agentManager);
    }

    /**
     * Execute the prompt mode using service orchestration
     */
    async execute(params: ExecutePromptParams): Promise<ExecutePromptResult> {
        try {
            // Phase 1: Validate dependencies
            const dependencyValidation = await this.dependencyValidator.validateDependencies();
            if (!dependencyValidation.isValid) {
                return createResult<ExecutePromptResult>(
                    false,
                    undefined,
                    dependencyValidation.error!,
                    undefined,
                    undefined,
                    params.context.sessionId,
                    params.context
                );
            }

            // Phase 2: Validate custom agent if specified
            if (params.agent) {
                const agentValidation = await this.dependencyValidator.validateCustomPromptAgent(params.agent);
                if (!agentValidation.isValid) {
                    return createResult<ExecutePromptResult>(
                        false,
                        undefined,
                        agentValidation.error!,
                        undefined,
                        undefined,
                        params.context.sessionId,
                        params.context
                    );
                }
            }

            // Phase 3: Validate budget
            const budgetValidation = await this.budgetManager.validateBudget();
            if (!budgetValidation.isValid) {
                return createResult<ExecutePromptResult>(
                    false,
                    undefined,
                    budgetValidation.error!,
                    undefined,
                    undefined,
                    params.context.sessionId,
                    params.context
                );
            }

            // Phase 4: Execute prompt
            const promptResult = await this.promptExecutor.executePrompt(params);
            if (!promptResult.success) {
                return createResult<ExecutePromptResult>(
                    false,
                    undefined,
                    promptResult.error!,
                    undefined,
                    undefined,
                    params.context.sessionId,
                    params.context
                );
            }

            // Phase 5: Track usage
            let finalBudgetStatus: BudgetStatus | undefined = budgetValidation.budgetStatus;
            if (promptResult.cost && promptResult.provider) {
                const usageResult = await this.budgetManager.trackUsage(
                    promptResult.provider,
                    promptResult.cost.totalCost
                );
                if (usageResult.success && usageResult.budgetStatus) {
                    finalBudgetStatus = usageResult.budgetStatus;
                }
            }

            // Phase 6: Execute action if specified
            const actionResult = await this.actionExecutor.executeAction(
                params,
                promptResult.response || '',
                promptResult.webSearchResults
            );

            // Phase 7: Build result
            const resultData: ExecutePromptResult['data'] = {
                response: (params.returnContent ?? true) ? (promptResult.response || '') : '[Content not returned]',
                model: promptResult.model || 'unknown',
                provider: promptResult.provider || 'unknown',
                agentUsed: promptResult.agentUsed,
                usage: promptResult.usage,
                cost: promptResult.cost,
                budgetStatus: finalBudgetStatus,
                filesIncluded: promptResult.filesIncluded,
                actionPerformed: actionResult.actionPerformed
            };

            const result = createResult<ExecutePromptResult>(
                true,
                resultData,
                undefined,
                undefined,
                undefined,
                params.context.sessionId,
                params.context
            );
            
            return addRecommendations(result, AGENT_MANAGER_RECOMMENDATIONS.executePrompt);

        } catch (error) {
            return createResult<ExecutePromptResult>(
                false,
                undefined,
                `Failed to execute prompt: ${error instanceof Error ? error.message : 'Unknown error'}`,
                undefined,
                undefined,
                params.context.sessionId,
                params.context
            );
        }
    }

    /**
     * Get parameter schema for the mode
     */
    getParameterSchema(): any {
        // Get default from data.json settings
        const providerManager = this.dependencyValidator.getDependencies().providerManager;
        const defaultModel = providerManager?.getSettings()?.defaultModel;
        
        const customSchema = {
            properties: {
                agent: {
                    type: 'string',
                    description: 'Custom prompt agent name/id to use as system prompt (optional - if not provided, uses raw prompt only)'
                },
                filepaths: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Optional array of file paths to include content as context'
                },
                prompt: {
                    type: 'string',
                    description: 'User prompt/question to send to the LLM'
                },
                provider: {
                    type: 'string',
                    description: `LLM provider (defaults to: ${defaultModel?.provider || 'not configured'}). Use listModels to see available providers.`,
                    default: defaultModel?.provider
                },
                model: {
                    type: 'string',
                    description: `Model name (defaults to: ${defaultModel?.model || 'not configured'}). Use listModels to see available models.`,
                    default: defaultModel?.model
                },
                temperature: {
                    type: 'number',
                    minimum: 0,
                    maximum: 1,
                    description: 'Temperature setting for response randomness (0.0-1.0)'
                },
                maxTokens: {
                    type: 'number',
                    description: 'Maximum tokens to generate'
                },
                returnContent: {
                    type: 'boolean',
                    description: 'Whether to return the LLM response content in the result (defaults to true)',
                    default: true
                },
                webSearch: {
                    type: 'boolean',
                    description: 'Enable web search for current information (supported by: perplexity, openrouter, openai, google, anthropic, groq, mistral)',
                    default: false
                },
                action: {
                    type: 'object',
                    description: 'Content action to perform with LLM response',
                    properties: {
                        type: {
                            type: 'string',
                            enum: ['create', 'append', 'prepend', 'replace', 'findReplace']
                        },
                        targetPath: { type: 'string' },
                        position: { type: 'number' },
                        findText: { type: 'string' },
                        replaceAll: { type: 'boolean' },
                        caseSensitive: { type: 'boolean' },
                        wholeWord: { type: 'boolean' }
                    },
                    required: ['type', 'targetPath']
                }
            },
            required: ['prompt', 'provider', 'model']
        };
        
        return this.getMergedSchema(customSchema);
    }

    /**
     * Get result schema for the mode
     */
    getResultSchema(): any {
        const commonSchema = getCommonResultSchema();
        
        return {
            ...commonSchema,
            properties: {
                ...commonSchema.properties,
                data: {
                    type: 'object',
                    properties: {
                        response: { type: 'string', description: 'The LLM response' },
                        model: { type: 'string', description: 'Model that was used' },
                        provider: { type: 'string', description: 'Provider that was used' },
                        agentUsed: { type: 'string', description: 'Agent that was used' },
                        usage: {
                            type: 'object',
                            properties: {
                                promptTokens: { type: 'number' },
                                completionTokens: { type: 'number' },
                                totalTokens: { type: 'number' }
                            }
                        },
                        cost: {
                            type: 'object',
                            properties: {
                                inputCost: { type: 'number' },
                                outputCost: { type: 'number' },
                                totalCost: { type: 'number' },
                                currency: { type: 'string' }
                            }
                        },
                        filesIncluded: {
                            type: 'array',
                            items: { type: 'string' }
                        },
                        actionPerformed: {
                            type: 'object',
                            properties: {
                                type: { type: 'string' },
                                targetPath: { type: 'string' },
                                success: { type: 'boolean' },
                                error: { type: 'string' }
                            }
                        }
                    },
                    required: ['response', 'model', 'provider', 'agentUsed']
                },
                recommendations: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            type: { type: 'string' },
                            message: { type: 'string' }
                        },
                        required: ['type', 'message']
                    },
                    description: 'Workspace-agent optimization recommendations'
                }
            }
        };
    }
}
```

## agents/agentManager/modes/execute/services/ActionExecutor.ts

```typescript
/**
 * ActionExecutor - Handles content action execution
 * Follows Single Responsibility Principle by focusing only on content action operations
 */

import { AgentManager } from '../../../../../services/AgentManager';
import { ExecutePromptParams } from '../ExecutePromptMode';
import { WebSearchUtils } from '../../../../../services/llm/utils/WebSearchUtils';

export interface ActionExecutionResult {
    success: boolean;
    actionPerformed?: {
        type: string;
        targetPath: string;
        success: boolean;
        error?: string;
    };
    error?: string;
}

/**
 * Service responsible for executing content actions
 * Follows SRP by focusing only on content action execution operations
 */
export class ActionExecutor {
    constructor(private agentManager: AgentManager | null) {}

    /**
     * Execute content action with LLM response
     */
    async executeAction(
        params: ExecutePromptParams,
        llmResponse: string,
        webSearchResults?: any[]
    ): Promise<ActionExecutionResult> {
        // Check if action is specified and agent manager is available
        if (!params.action) {
            return {
                success: true // No action to execute is not an error
            };
        }

        if (!this.agentManager) {
            return {
                success: false,
                error: 'Agent manager not available for action execution'
            };
        }

        try {
            const actionResult = await this.executeContentAction(
                params.action,
                llmResponse,
                params.context.sessionId || '',
                typeof params.context === 'string' ? params.context : JSON.stringify(params.context),
                webSearchResults
            );

            return {
                success: true,
                actionPerformed: {
                    type: params.action.type,
                    targetPath: params.action.targetPath,
                    success: actionResult.success,
                    error: actionResult.error
                }
            };
        } catch (error) {
            console.error('ActionExecutor: Action execution failed with exception:', error);
            return {
                success: false,
                actionPerformed: {
                    type: params.action.type,
                    targetPath: params.action.targetPath,
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown action error'
                },
                error: error instanceof Error ? error.message : 'Unknown action error'
            };
        }
    }

    /**
     * Execute a ContentManager action with the LLM response
     */
    private async executeContentAction(
        action: {
            type: string;
            targetPath: string;
            position?: number;
            findText?: string;
            replaceAll?: boolean;
            caseSensitive?: boolean;
            wholeWord?: boolean;
        },
        content: string,
        sessionId: string,
        context: string,
        webSearchResults?: any[]
    ): Promise<{ success: boolean; error?: string }> {
        console.log('executeContentAction called with:', {
            actionType: action.type,
            targetPath: action.targetPath,
            contentLength: content.length,
            hasAgentManager: !!this.agentManager
        });

        if (!this.agentManager) {
            console.error('executeContentAction: Agent manager not available');
            return { success: false, error: 'Agent manager not available' };
        }

        try {
            // Build proper context object for CommonParameters
            const contextObject = typeof context === 'string' ?
                JSON.parse(context) : context;

            // Prepare content with sources if available
            let finalContent = content;
            if (action.type === 'create' && webSearchResults && webSearchResults.length > 0) {
                const sourcesSection = WebSearchUtils.generateSourcesSection(webSearchResults);
                finalContent = content + sourcesSection;
            }

            const actionParams: any = {
                context: {
                    sessionId,
                    workspaceId: contextObject?.workspaceId,
                    sessionDescription: contextObject?.sessionDescription || '',
                    sessionMemory: contextObject?.sessionMemory || '',
                    toolContext: contextObject?.toolContext || '',
                    primaryGoal: contextObject?.primaryGoal || ''
                },
                content: finalContent,
                filePath: action.targetPath
            };

            console.log('executeContentAction: Preparing to call agent with params:', {
                actionType: action.type,
                paramsKeys: Object.keys(actionParams),
                targetPath: action.targetPath,
                hasContent: !!content,
                contentLength: content?.length || 0
            });

            switch (action.type) {
                case 'create':
                    console.log('executeContentAction: Calling createContent mode');
                    await this.agentManager.executeAgentMode('contentManager', 'createContent', actionParams);
                    break;

                case 'append':
                    console.log('executeContentAction: Calling appendContent mode');
                    await this.agentManager.executeAgentMode('contentManager', 'appendContent', actionParams);
                    break;

                case 'prepend':
                    console.log('executeContentAction: Calling prependContent mode');
                    await this.agentManager.executeAgentMode('contentManager', 'prependContent', actionParams);
                    break;

                case 'replace':
                    if (action.position !== undefined) {
                        actionParams.line = action.position;
                        console.log('executeContentAction: Calling replaceByLine mode');
                        await this.agentManager.executeAgentMode('contentManager', 'replaceByLine', actionParams);
                    } else {
                        console.log('executeContentAction: Calling replaceContent mode');
                        await this.agentManager.executeAgentMode('contentManager', 'replaceContent', actionParams);
                    }
                    break;

                case 'findReplace':
                    if (!action.findText) {
                        console.error('executeContentAction: findText is required for findReplace action');
                        return { success: false, error: 'findText is required for findReplace action' };
                    }
                    actionParams.findText = action.findText;
                    actionParams.replaceText = content; // LLM response becomes the replacement text
                    actionParams.replaceAll = action.replaceAll ?? false;
                    actionParams.caseSensitive = action.caseSensitive ?? true;
                    actionParams.wholeWord = action.wholeWord ?? false;
                    console.log('executeContentAction: Calling findReplaceContent mode');
                    await this.agentManager.executeAgentMode('contentManager', 'findReplaceContent', actionParams);
                    break;

                default:
                    console.error('executeContentAction: Unknown action type:', action.type);
                    return { success: false, error: `Unknown action type: ${action.type}` };
            }

            console.log('executeContentAction: Agent mode execution completed successfully');
            return { success: true };
        } catch (error) {
            console.error('executeContentAction: Agent mode execution failed:', error);
            return { 
                success: false, 
                error: error instanceof Error ? error.message : 'Unknown error' 
            };
        }
    }

    /**
     * Validate action parameters
     */
    validateActionParameters(action: ExecutePromptParams['action']): {
        isValid: boolean;
        errors: string[];
        warnings: string[];
    } {
        const errors: string[] = [];
        const warnings: string[] = [];

        if (!action) {
            return { isValid: true, errors, warnings }; // No action is valid
        }

        // Validate required fields
        if (!action.type || typeof action.type !== 'string') {
            errors.push('Action type is required and must be a string');
        } else if (!['create', 'append', 'prepend', 'replace', 'findReplace'].includes(action.type)) {
            errors.push('Action type must be one of: create, append, prepend, replace, findReplace');
        }

        if (!action.targetPath || typeof action.targetPath !== 'string') {
            errors.push('Action targetPath is required and must be a string');
        }

        // Validate action-specific requirements
        if (action.type === 'findReplace' && !action.findText) {
            errors.push('findText is required for findReplace action');
        }

        if (action.type === 'replace' && action.position !== undefined && 
            (typeof action.position !== 'number' || action.position < 0)) {
            errors.push('Position must be a non-negative number');
        }

        // Validate optional boolean fields
        if (action.replaceAll !== undefined && typeof action.replaceAll !== 'boolean') {
            errors.push('replaceAll must be a boolean');
        }

        if (action.caseSensitive !== undefined && typeof action.caseSensitive !== 'boolean') {
            errors.push('caseSensitive must be a boolean');
        }

        if (action.wholeWord !== undefined && typeof action.wholeWord !== 'boolean') {
            errors.push('wholeWord must be a boolean');
        }

        // Warnings
        if (!this.agentManager) {
            warnings.push('Agent manager not available - actions will not be executed');
        }

        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }

    /**
     * Get action execution capability
     */
    getActionCapability(): {
        canExecuteActions: boolean;
        supportedActionTypes: string[];
        hasAgentManager: boolean;
    } {
        return {
            canExecuteActions: !!this.agentManager,
            supportedActionTypes: ['create', 'append', 'prepend', 'replace', 'findReplace'],
            hasAgentManager: !!this.agentManager
        };
    }

    /**
     * Get action type description
     */
    getActionTypeDescription(actionType: string): string {
        const descriptions: Record<string, string> = {
            create: 'Create a new file with the LLM response content',
            append: 'Append the LLM response to the end of an existing file',
            prepend: 'Prepend the LLM response to the beginning of an existing file',
            replace: 'Replace the entire file content or a specific line with the LLM response',
            findReplace: 'Find specific text and replace it with the LLM response'
        };

        return descriptions[actionType] || 'Unknown action type';
    }

    /**
     * Update agent manager
     */
    updateAgentManager(agentManager: AgentManager | null): void {
        this.agentManager = agentManager;
    }

    /**
     * Test action execution capability
     */
    testActionCapability(): {
        canExecute: boolean;
        error?: string;
    } {
        if (!this.agentManager) {
            return {
                canExecute: false,
                error: 'Agent manager not available'
            };
        }

        try {
            // Test if agent manager has the required methods
            if (typeof this.agentManager.executeAgentMode !== 'function') {
                return {
                    canExecute: false,
                    error: 'Agent manager does not have executeAgentMode method'
                };
            }

            return {
                canExecute: true
            };
        } catch (error) {
            return {
                canExecute: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }
}
```

## agents/agentManager/modes/execute/services/BudgetManager.ts

```typescript
/**
 * BudgetManager - Handles budget validation and usage tracking
 * Follows Single Responsibility Principle by focusing only on budget operations
 */

import { UsageTracker, BudgetStatus } from '../../../../../services/UsageTracker';

export interface BudgetValidationResult {
    isValid: boolean;
    budgetStatus?: BudgetStatus;
    error?: string;
}

export interface UsageTrackingResult {
    success: boolean;
    budgetStatus?: BudgetStatus;
    error?: string;
}

/**
 * Service responsible for budget validation and usage tracking
 * Follows SRP by focusing only on budget management operations
 */
export class BudgetManager {
    constructor(private usageTracker: UsageTracker | null) {}

    /**
     * Validate budget before LLM execution
     */
    async validateBudget(): Promise<BudgetValidationResult> {
        if (!this.usageTracker) {
            return {
                isValid: true // No budget tracking available, allow execution
            };
        }

        try {
            const budgetStatus = await this.usageTracker.getBudgetStatusAsync();
            
            if (budgetStatus.budgetExceeded) {
                return {
                    isValid: false,
                    budgetStatus,
                    error: `Monthly LLM budget of $${budgetStatus.monthlyBudget.toFixed(2)} has been exceeded. Current spending: $${budgetStatus.currentSpending.toFixed(2)}. Please reset or increase your budget in settings.`
                };
            }

            return {
                isValid: true,
                budgetStatus
            };
        } catch (error) {
            console.error('BudgetManager: Failed to validate budget:', error);
            return {
                isValid: true, // Allow execution if budget check fails
                error: error instanceof Error ? error.message : 'Unknown budget validation error'
            };
        }
    }

    /**
     * Track usage after LLM execution
     */
    async trackUsage(provider: string, cost: number): Promise<UsageTrackingResult> {
        if (!this.usageTracker) {
            return {
                success: true // No usage tracking available
            };
        }

        if (!provider || typeof cost !== 'number' || cost <= 0) {
            return {
                success: false,
                error: 'Invalid provider or cost for usage tracking'
            };
        }

        try {
            const usageResponse = await this.usageTracker.trackUsage(
                provider.toLowerCase(),
                cost
            );

            return {
                success: true,
                budgetStatus: usageResponse.budgetStatus
            };
        } catch (error) {
            console.error('BudgetManager: Failed to track usage:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown usage tracking error'
            };
        }
    }

    /**
     * Get current budget status
     */
    async getCurrentBudgetStatus(): Promise<BudgetStatus | null> {
        if (!this.usageTracker) {
            return null;
        }

        try {
            return await this.usageTracker.getBudgetStatusAsync();
        } catch (error) {
            console.error('BudgetManager: Failed to get budget status:', error);
            return null;
        }
    }

    /**
     * Check if budget tracking is available
     */
    isBudgetTrackingAvailable(): boolean {
        return !!this.usageTracker;
    }

    /**
     * Get budget tracking capability
     */
    getBudgetTrackingCapability(): {
        hasBudgetTracking: boolean;
        canValidateBudget: boolean;
        canTrackUsage: boolean;
    } {
        const hasTracker = !!this.usageTracker;
        
        return {
            hasBudgetTracking: hasTracker,
            canValidateBudget: hasTracker && typeof this.usageTracker!.getBudgetStatusAsync === 'function',
            canTrackUsage: hasTracker && typeof this.usageTracker!.trackUsage === 'function'
        };
    }

    /**
     * Get budget summary
     */
    async getBudgetSummary(): Promise<{
        hasBudgetTracking: boolean;
        budgetStatus?: BudgetStatus;
        budgetUtilization?: number;
        remainingBudget?: number;
        error?: string;
    }> {
        if (!this.usageTracker) {
            return {
                hasBudgetTracking: false
            };
        }

        try {
            const budgetStatus = await this.usageTracker.getBudgetStatusAsync();
            const budgetUtilization = budgetStatus.monthlyBudget > 0 
                ? (budgetStatus.currentSpending / budgetStatus.monthlyBudget) * 100
                : 0;
            const remainingBudget = Math.max(0, budgetStatus.monthlyBudget - budgetStatus.currentSpending);

            return {
                hasBudgetTracking: true,
                budgetStatus,
                budgetUtilization,
                remainingBudget
            };
        } catch (error) {
            return {
                hasBudgetTracking: true,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }

    /**
     * Validate cost parameter
     */
    validateCost(cost: any): {
        isValid: boolean;
        error?: string;
    } {
        if (cost === undefined || cost === null) {
            return {
                isValid: false,
                error: 'Cost is required for budget tracking'
            };
        }

        if (typeof cost !== 'number') {
            return {
                isValid: false,
                error: 'Cost must be a number'
            };
        }

        if (cost < 0) {
            return {
                isValid: false,
                error: 'Cost cannot be negative'
            };
        }

        if (!isFinite(cost)) {
            return {
                isValid: false,
                error: 'Cost must be a finite number'
            };
        }

        return {
            isValid: true
        };
    }

    /**
     * Validate provider parameter
     */
    validateProvider(provider: any): {
        isValid: boolean;
        error?: string;
    } {
        if (!provider) {
            return {
                isValid: false,
                error: 'Provider is required for budget tracking'
            };
        }

        if (typeof provider !== 'string') {
            return {
                isValid: false,
                error: 'Provider must be a string'
            };
        }

        if (provider.trim() === '') {
            return {
                isValid: false,
                error: 'Provider cannot be empty'
            };
        }

        return {
            isValid: true
        };
    }

    /**
     * Update usage tracker
     */
    updateUsageTracker(usageTracker: UsageTracker | null): void {
        this.usageTracker = usageTracker;
    }

    /**
     * Test budget tracking capability
     */
    async testBudgetTracking(): Promise<{
        canTrack: boolean;
        error?: string;
    }> {
        if (!this.usageTracker) {
            return {
                canTrack: false,
                error: 'Usage tracker not available'
            };
        }

        try {
            // Test getting budget status
            const budgetStatus = await this.usageTracker.getBudgetStatusAsync();
            
            if (!budgetStatus) {
                return {
                    canTrack: false,
                    error: 'Budget status not available'
                };
            }

            return {
                canTrack: true
            };
        } catch (error) {
            return {
                canTrack: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }

    /**
     * Get usage statistics
     */
    async getUsageStatistics(): Promise<{
        hasUsageTracker: boolean;
        totalSpending?: number;
        monthlyBudget?: number;
        budgetExceeded?: boolean;
        daysInMonth?: number;
        error?: string;
    }> {
        if (!this.usageTracker) {
            return {
                hasUsageTracker: false
            };
        }

        try {
            const budgetStatus = await this.usageTracker.getBudgetStatusAsync();
            
            return {
                hasUsageTracker: true,
                totalSpending: budgetStatus.currentSpending,
                monthlyBudget: budgetStatus.monthlyBudget,
                budgetExceeded: budgetStatus.budgetExceeded,
                daysInMonth: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0).getDate()
            };
        } catch (error) {
            return {
                hasUsageTracker: true,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }
}
```

## agents/agentManager/modes/execute/services/DependencyValidator.ts

```typescript
/**
 * DependencyValidator - Handles service dependency validation
 * Follows Single Responsibility Principle by focusing only on dependency validation
 */

import { LLMProviderManager } from '../../../../../services/llm/providers/ProviderManager';
import { CustomPromptStorageService } from '../../../services/CustomPromptStorageService';
import { AgentManager } from '../../../../../services/AgentManager';
import { UsageTracker } from '../../../../../services/UsageTracker';

export interface DependencyValidationResult {
    isValid: boolean;
    error?: string;
    warnings?: string[];
}

export interface ServiceDependencies {
    providerManager: LLMProviderManager | null;
    promptStorage: CustomPromptStorageService | null;
    agentManager: AgentManager | null;
    usageTracker: UsageTracker | null;
}

/**
 * Service responsible for validating service dependencies
 * Follows SRP by focusing only on dependency validation operations
 */
export class DependencyValidator {
    constructor(private dependencies: ServiceDependencies) {}

    /**
     * Wait for a specific dependency to be initialized
     * @param dependencyName Name of the dependency to wait for
     * @param timeoutMs Maximum time to wait in milliseconds
     * @private
     */
    private async waitForDependency(dependencyName: keyof ServiceDependencies, timeoutMs: number): Promise<void> {
        const startTime = Date.now();
        const checkInterval = 100; // Check every 100ms
        
        while (Date.now() - startTime < timeoutMs) {
            if (this.dependencies[dependencyName]) {
                return;
            }
            
            // Wait for the next check
            await new Promise(resolve => setTimeout(resolve, checkInterval));
        }
    }

    /**
     * Validate all required dependencies
     */
    async validateDependencies(): Promise<DependencyValidationResult> {
        const errors: string[] = [];
        const warnings: string[] = [];

        // Try to wait for critical dependencies if they're not available
        if (!this.dependencies.providerManager) {
            await this.waitForDependency('providerManager', 3000);
        }

        if (!this.dependencies.promptStorage) {
            await this.waitForDependency('promptStorage', 3000);
        }

        // Validate critical dependencies
        if (!this.dependencies.providerManager) {
            errors.push('LLM Provider Manager not initialized. Please ensure you have configured at least one LLM provider with valid API keys.');
        }

        if (!this.dependencies.promptStorage) {
            errors.push('Prompt storage service not initialized');
        }

        // Validate optional dependencies
        if (!this.dependencies.agentManager) {
            warnings.push('Agent manager not available - actions will not be supported');
        }

        if (!this.dependencies.usageTracker) {
            warnings.push('Usage tracker not available - budget tracking disabled');
        }

        return {
            isValid: errors.length === 0,
            error: errors.length > 0 ? errors.join(', ') : undefined,
            warnings
        };
    }

    /**
     * Validate specific service availability
     */
    validateService(serviceName: keyof ServiceDependencies): DependencyValidationResult {
        const service = this.dependencies[serviceName];
        
        if (!service) {
            return {
                isValid: false,
                error: `${serviceName} not available`
            };
        }

        return {
            isValid: true
        };
    }

    /**
     * Validate custom prompt agent availability
     */
    async validateCustomPromptAgent(agentName: string): Promise<DependencyValidationResult> {
        if (!this.dependencies.promptStorage) {
            return {
                isValid: false,
                error: 'Custom agent specified but prompt storage not available'
            };
        }

        try {
            const customPrompt = await this.dependencies.promptStorage.getPromptByName(agentName);
            
            if (!customPrompt) {
                return {
                    isValid: false,
                    error: `Custom prompt agent '${agentName}' not found`
                };
            }

            if (!customPrompt.isEnabled) {
                return {
                    isValid: false,
                    error: `Custom prompt agent '${agentName}' is disabled`
                };
            }

            return {
                isValid: true
            };
        } catch (error) {
            return {
                isValid: false,
                error: `Failed to validate custom prompt agent: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }

    /**
     * Get service availability status
     */
    getServiceStatus(): {
        providerManager: boolean;
        promptStorage: boolean;
        agentManager: boolean;
        usageTracker: boolean;
    } {
        return {
            providerManager: !!this.dependencies.providerManager,
            promptStorage: !!this.dependencies.promptStorage,
            agentManager: !!this.dependencies.agentManager,
            usageTracker: !!this.dependencies.usageTracker
        };
    }

    /**
     * Get dependency statistics
     */
    getDependencyStatistics(): {
        totalServices: number;
        availableServices: number;
        criticalServices: number;
        availableCriticalServices: number;
        optionalServices: number;
        availableOptionalServices: number;
    } {
        const status = this.getServiceStatus();
        const criticalServices = ['providerManager', 'promptStorage'];
        const optionalServices = ['agentManager', 'usageTracker'];

        const availableServices = Object.values(status).filter(Boolean).length;
        const availableCriticalServices = criticalServices.filter(service => 
            status[service as keyof typeof status]
        ).length;
        const availableOptionalServices = optionalServices.filter(service =>
            status[service as keyof typeof status]
        ).length;

        return {
            totalServices: 4,
            availableServices,
            criticalServices: criticalServices.length,
            availableCriticalServices,
            optionalServices: optionalServices.length,
            availableOptionalServices
        };
    }

    /**
     * Update dependencies
     */
    updateDependencies(newDependencies: Partial<ServiceDependencies>): void {
        Object.assign(this.dependencies, newDependencies);
    }

    /**
     * Get current dependencies
     */
    getDependencies(): ServiceDependencies {
        return { ...this.dependencies };
    }

    /**
     * Get dependency descriptions
     */
    getDependencyDescriptions(): Record<keyof ServiceDependencies, string> {
        return {
            providerManager: 'LLM Provider Manager for executing prompts',
            promptStorage: 'Custom Prompt Storage Service for agent management',
            agentManager: 'Agent Manager for executing content actions',
            usageTracker: 'Usage Tracker for budget and cost tracking'
        };
    }

    /**
     * Get missing dependencies
     */
    getMissingDependencies(): string[] {
        const status = this.getServiceStatus();
        return Object.entries(status)
            .filter(([_, available]) => !available)
            .map(([serviceName]) => serviceName);
    }

    /**
     * Check if actions are supported
     */
    areActionsSupported(): boolean {
        return !!this.dependencies.agentManager;
    }

    /**
     * Check if budget tracking is supported
     */
    isBudgetTrackingSupported(): boolean {
        return !!this.dependencies.usageTracker;
    }

    /**
     * Check if custom prompts are supported
     */
    areCustomPromptsSupported(): boolean {
        return !!this.dependencies.promptStorage;
    }
}
```

## agents/agentManager/modes/execute/services/PromptExecutor.ts

```typescript
/**
 * PromptExecutor - Handles LLM prompt execution
 * Follows Single Responsibility Principle by focusing only on prompt execution
 */

import { LLMProviderManager } from '../../../../../services/llm/providers/ProviderManager';
import { CustomPromptStorageService } from '../../../services/CustomPromptStorageService';
import { ExecutePromptParams } from '../ExecutePromptMode';

export interface PromptExecutionResult {
    success: boolean;
    response?: string;
    model?: string;
    provider?: string;
    agentUsed: string;
    usage?: {
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
    };
    cost?: {
        inputCost: number;
        outputCost: number;
        totalCost: number;
        currency: string;
    };
    filesIncluded?: string[];
    webSearchResults?: any[];
    error?: string;
}

/**
 * Service responsible for executing LLM prompts
 * Follows SRP by focusing only on prompt execution operations
 */
export class PromptExecutor {
    constructor(
        private providerManager: LLMProviderManager,
        private promptStorage: CustomPromptStorageService
    ) {}

    /**
     * Execute prompt with optional custom agent
     */
    async executePrompt(params: ExecutePromptParams): Promise<PromptExecutionResult> {
        try {
            // Get custom prompt/agent if specified
            const customPrompt = await this.getCustomPrompt(params.agent);
            const agentUsed = customPrompt?.name || 'default';

            // Execute the LLM prompt
            const llmService = this.providerManager.getLLMService();
            const result = await llmService.executePrompt({
                systemPrompt: customPrompt?.prompt || '', // Use custom prompt if available, otherwise empty
                userPrompt: params.prompt,
                filepaths: params.filepaths,
                provider: params.provider,
                model: params.model,
                temperature: params.temperature,
                maxTokens: params.maxTokens,
                webSearch: params.webSearch
            });

            if (!result.success) {
                return {
                    success: false,
                    agentUsed,
                    error: result.error || 'LLM execution failed'
                };
            }

            return {
                success: true,
                response: result.response || '',
                model: result.model || 'unknown',
                provider: result.provider || 'unknown',
                agentUsed,
                usage: result.usage,
                cost: result.cost,
                filesIncluded: result.filesIncluded,
                webSearchResults: result.webSearchResults
            };
        } catch (error) {
            return {
                success: false,
                agentUsed: 'default',
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }

    /**
     * Get custom prompt by name
     */
    private async getCustomPrompt(agentName?: string): Promise<any> {
        if (!agentName) {
            return null;
        }

        try {
            const customPrompt = await this.promptStorage.getPromptByName(agentName);
            return customPrompt && customPrompt.isEnabled ? customPrompt : null;
        } catch (error) {
            console.warn(`Failed to get custom prompt '${agentName}':`, error);
            return null;
        }
    }

    /**
     * Validate prompt parameters
     */
    validatePromptParameters(params: ExecutePromptParams): {
        isValid: boolean;
        errors: string[];
        warnings: string[];
    } {
        const errors: string[] = [];
        const warnings: string[] = [];

        // Validate required parameters
        if (!params.prompt || typeof params.prompt !== 'string' || params.prompt.trim() === '') {
            errors.push('Prompt is required and must be a non-empty string');
        }

        // Validate optional parameters
        if (params.filepaths && !Array.isArray(params.filepaths)) {
            errors.push('Filepaths must be an array');
        }

        if (params.filepaths && params.filepaths.some(path => typeof path !== 'string')) {
            errors.push('All filepaths must be strings');
        }

        if (params.provider && typeof params.provider !== 'string') {
            errors.push('Provider must be a string');
        }

        if (params.model && typeof params.model !== 'string') {
            errors.push('Model must be a string');
        }

        if (params.temperature !== undefined) {
            if (typeof params.temperature !== 'number' || params.temperature < 0 || params.temperature > 1) {
                errors.push('Temperature must be a number between 0 and 1');
            }
        }

        if (params.maxTokens !== undefined) {
            if (typeof params.maxTokens !== 'number' || params.maxTokens < 1) {
                errors.push('MaxTokens must be a positive number');
            }
        }

        // Warnings
        if (params.agent && typeof params.agent !== 'string') {
            warnings.push('Agent name should be a string');
        }

        if (params.filepaths && params.filepaths.length === 0) {
            warnings.push('Empty filepaths array provided');
        }

        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }

    /**
     * Get execution statistics
     */
    getExecutionStatistics(): {
        hasProviderManager: boolean;
        hasPromptStorage: boolean;
        canExecutePrompts: boolean;
        supportsCustomPrompts: boolean;
    } {
        return {
            hasProviderManager: !!this.providerManager,
            hasPromptStorage: !!this.promptStorage,
            canExecutePrompts: !!(this.providerManager && this.providerManager.getLLMService()),
            supportsCustomPrompts: !!this.promptStorage
        };
    }

    /**
     * Get available models for validation
     */
    getAvailableModels(): string[] {
        if (!this.providerManager) {
            return [];
        }

        try {
            const llmService = this.providerManager.getLLMService();
            const models = llmService.getAvailableModels?.();
            if (Array.isArray(models)) {
                return models;
            }
            return [];
        } catch (error) {
            console.warn('Failed to get available models:', error);
            return [];
        }
    }

    /**
     * Get available providers for validation
     */
    getAvailableProviders(): string[] {
        if (!this.providerManager) {
            return [];
        }

        try {
            const llmService = this.providerManager.getLLMService();
            const providers = llmService.getAvailableProviders?.();
            if (Array.isArray(providers)) {
                return providers;
            }
            return [];
        } catch (error) {
            console.warn('Failed to get available providers:', error);
            return [];
        }
    }

    /**
     * Test prompt execution capability
     */
    async testExecutionCapability(): Promise<{
        canExecute: boolean;
        error?: string;
    }> {
        try {
            if (!this.providerManager) {
                return {
                    canExecute: false,
                    error: 'Provider manager not available'
                };
            }

            const llmService = this.providerManager.getLLMService();
            if (!llmService) {
                return {
                    canExecute: false,
                    error: 'LLM service not available'
                };
            }

            // Test with a simple prompt
            const testResult = await llmService.executePrompt({
                systemPrompt: '',
                userPrompt: 'Hello',
                filepaths: [],
                provider: undefined,
                model: undefined,
                temperature: 0.1,
                maxTokens: 10
            });

            return {
                canExecute: true
            };
        } catch (error) {
            return {
                canExecute: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }

    /**
     * Get prompt execution context
     */
    getExecutionContext(params: ExecutePromptParams): {
        hasCustomAgent: boolean;
        hasFilepaths: boolean;
        hasCustomProvider: boolean;
        hasCustomModel: boolean;
        hasTemperature: boolean;
        hasMaxTokens: boolean;
    } {
        return {
            hasCustomAgent: !!params.agent,
            hasFilepaths: !!(params.filepaths && params.filepaths.length > 0),
            hasCustomProvider: !!params.provider,
            hasCustomModel: !!params.model,
            hasTemperature: params.temperature !== undefined,
            hasMaxTokens: params.maxTokens !== undefined
        };
    }
}
```

## agents/agentManager/modes/execute/services/index.ts

```typescript
/**
 * Service exports for executePromptMode
 * Provides centralized access to all prompt execution services
 */

export { DependencyValidator } from './DependencyValidator';
export { PromptExecutor } from './PromptExecutor';
export { ActionExecutor } from './ActionExecutor';
export { BudgetManager } from './BudgetManager';

// Type exports
export type { DependencyValidationResult, ServiceDependencies } from './DependencyValidator';
export type { PromptExecutionResult } from './PromptExecutor';
export type { ActionExecutionResult } from './ActionExecutor';
export type { BudgetValidationResult, UsageTrackingResult } from './BudgetManager';
```

## agents/agentManager/modes/executePromptMode.ts

```typescript
/**
 * Execute Prompt Mode - Re-export of refactored components
 * Original file has been refactored following SOLID principles
 */

export { ExecutePromptMode } from './execute/ExecutePromptMode';
export type { ExecutePromptParams, ExecutePromptResult } from './execute/ExecutePromptMode';
```

## agents/agentManager/modes/generateImageMode.ts

```typescript
/**
 * Generate Image Mode - Image generation workflow for AgentManager
 * Integrates with ImageGenerationService and follows AgentManager patterns
 */

import { BaseMode } from '../../baseMode';
import { CommonResult, CommonParameters } from '../../../types';
import { createResult } from '../../../utils/schemaUtils';
import { ImageGenerationService } from '../../../services/llm/ImageGenerationService';
import { 
  ImageGenerationParams,
  ImageGenerationResult,
  AspectRatio
} from '../../../services/llm/types/ImageTypes';
import { SchemaBuilder, SchemaType } from '../../../utils/schemas/SchemaBuilder';
import { Vault } from 'obsidian';
import { LLMProviderSettings } from '../../../types/llm/ProviderTypes';

export interface GenerateImageParams extends CommonParameters {
  prompt: string;
  provider: 'google'; // Only Google Imagen supported
  model?: 'imagen-4' | 'imagen-4-ultra' | 'imagen-4-fast';
  aspectRatio?: AspectRatio;
  numberOfImages?: number;
  sampleImageSize?: '1K' | '2K';
  savePath: string;
}

export interface GenerateImageModeResult extends CommonResult {
  data?: {
    imagePath: string;
    prompt: string;
    revisedPrompt?: string;
    model: string;
    provider: string;
    dimensions: { width: number; height: number };
    fileSize: number;
    format: string;
    cost?: {
      totalCost: number;
      currency: string;
      ratePerImage: number;
    };
    usage?: {
      imagesGenerated: number;
      resolution: string;
      model: string;
      provider: string;
    };
    metadata?: Record<string, any>;
  };
}

/**
 * Image Generation Mode for AgentManager
 * Handles AI image generation requests through Google provider
 */
export class GenerateImageMode extends BaseMode<GenerateImageParams, GenerateImageModeResult> {
  private imageService: ImageGenerationService | null = null;
  private schemaBuilder: SchemaBuilder;
  private vault: Vault | null = null;
  private llmSettings: LLMProviderSettings | null = null;

  constructor() {
    super(
      'generateImage',
      'Generate Image',
      'Generate images using Google Imagen 4 and save to vault',
      '1.0.0'
    );

    this.schemaBuilder = new SchemaBuilder(null);
  }

  /**
   * Set the vault instance for image generation service
   */
  setVault(vault: Vault): void {
    this.vault = vault;
    this.initializeImageService();
  }

  /**
   * Set LLM provider settings
   */
  setLLMSettings(llmSettings: LLMProviderSettings): void {
    this.llmSettings = llmSettings;
    this.initializeImageService();
  }

  /**
   * Initialize image service when both vault and settings are available
   */
  private initializeImageService(): void {
    if (this.vault && this.llmSettings) {
      this.imageService = new ImageGenerationService(this.vault, this.llmSettings);
    }
  }

  /**
   * Execute image generation
   */
  async execute(params: GenerateImageParams): Promise<GenerateImageModeResult> {
    try {
      // Validate service availability
      if (!this.imageService) {
        return createResult<GenerateImageModeResult>(
          false,
          undefined,
          'Image generation service not initialized. Vault instance required.',
          undefined,
          undefined,
          params.context.sessionId,
          params.context
        );
      }

      // Check if any providers are available
      if (!this.imageService.hasAvailableProviders()) {
        return createResult<GenerateImageModeResult>(
          false,
          undefined,
          'No image generation providers available. Please configure Google API key in plugin settings.',
          undefined,
          undefined,
          params.context.sessionId,
          params.context
        );
      }

      // Validate parameters
      const validation = await this.imageService.validateParams({
        prompt: params.prompt,
        provider: params.provider,
        model: params.model,
        aspectRatio: params.aspectRatio,
        numberOfImages: params.numberOfImages,
        sampleImageSize: params.sampleImageSize,
        savePath: params.savePath,
        sessionId: params.context.sessionId,
        context: typeof params.context === 'string' ? params.context : JSON.stringify(params.context)
      });

      if (!validation.isValid) {
        return createResult<GenerateImageModeResult>(
          false,
          undefined,
          `Parameter validation failed: ${validation.errors.join(', ')}`,
          undefined,
          undefined,
          params.context.sessionId,
          params.context
        );
      }

      // Generate the image
      const result = await this.imageService.generateImage({
        prompt: params.prompt,
        provider: params.provider,
        model: params.model,
        aspectRatio: params.aspectRatio,
        numberOfImages: params.numberOfImages,
        sampleImageSize: params.sampleImageSize,
        savePath: params.savePath,
        sessionId: params.context.sessionId,
        context: typeof params.context === 'string' ? params.context : JSON.stringify(params.context)
      });

      if (!result.success) {
        return createResult<GenerateImageModeResult>(
          false,
          undefined,
          result.error || 'Image generation failed',
          undefined,
          undefined,
          params.context.sessionId,
          params.context
        );
      }

      // Return successful result
      return createResult<GenerateImageModeResult>(
        true,
        result.data ? {
          imagePath: result.data.imagePath,
          prompt: result.data.prompt,
          revisedPrompt: result.data.revisedPrompt,
          model: result.data.model,
          provider: result.data.provider,
          dimensions: result.data.dimensions,
          fileSize: result.data.fileSize,
          format: result.data.format,
          cost: result.data.cost,
          usage: result.data.usage,
          metadata: result.data.metadata
        } : undefined,
        'Image generated successfully',
        undefined,
        undefined,
        params.context.sessionId,
        params.context
      );

    } catch (error) {
      return createResult<GenerateImageModeResult>(
        false,
        undefined,
        `Image generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        undefined,
        undefined,
        params.context.sessionId,
        params.context
      );
    }
  }

  /**
   * Get parameter schema for MCP
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        prompt: {
          type: 'string',
          description: 'Text prompt describing the image to generate',
          minLength: 1,
          maxLength: 32000
        },
        provider: {
          type: 'string',
          enum: ['google'],
          description: 'AI provider for image generation (google for Imagen 4)'
        },
        model: {
          type: 'string',
          enum: ['imagen-4', 'imagen-4-ultra', 'imagen-4-fast'],
          description: 'Specific model to use (optional, will use provider default)'
        },
        aspectRatio: {
          type: 'string',
          enum: ['1:1', '3:4', '4:3', '9:16', '16:9'],
          description: 'Aspect ratio for the generated image'
        },
        numberOfImages: {
          type: 'number',
          minimum: 1,
          maximum: 4,
          description: 'Number of images to generate (1-4)'
        },
        sampleImageSize: {
          type: 'string',
          enum: ['1K', '2K'],
          description: 'Image resolution (1K or 2K). 2K only available for imagen-4 and imagen-4-ultra'
        },
        savePath: {
          type: 'string',
          description: 'Vault-relative path where the image should be saved (e.g., "images/my-image.png")',
          pattern: '^[^/].*\\.(png|jpg|jpeg|webp)$'
        },
        format: {
          type: 'string',
          enum: ['png', 'jpeg', 'webp'],
          description: 'Image format (optional, inferred from savePath extension or provider default)'
        }
      },
      required: ['prompt', 'provider', 'savePath']
    };
    
    return this.getMergedSchema(modeSchema);
  }

  /**
   * Get result schema for MCP
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the image generation succeeded'
        },
        message: {
          type: 'string',
          description: 'Status message'
        },
        data: {
          type: 'object',
          properties: {
            imagePath: {
              type: 'string',
              description: 'Path where the image was saved in the vault'
            },
            prompt: {
              type: 'string',
              description: 'Original prompt used for generation'
            },
            revisedPrompt: {
              type: 'string',
              description: 'Provider-revised prompt (if applicable)'
            },
            model: {
              type: 'string',
              description: 'AI model used for generation'
            },
            provider: {
              type: 'string',
              description: 'AI provider used (google)'
            },
            dimensions: {
              type: 'object',
              properties: {
                width: {
                  type: 'number',
                  description: 'Image width in pixels'
                },
                height: {
                  type: 'number',
                  description: 'Image height in pixels'
                }
              },
              required: ['width', 'height']
            },
            fileSize: {
              type: 'number',
              description: 'File size in bytes'
            },
            format: {
              type: 'string',
              description: 'Image format (png, jpeg, webp)'
            },
            cost: {
              type: 'object',
              properties: {
                totalCost: {
                  type: 'number',
                  description: 'Total cost in USD'
                },
                currency: {
                  type: 'string',
                  description: 'Currency (USD)'
                },
                ratePerImage: {
                  type: 'number',
                  description: 'Cost per image'
                }
              }
            },
            usage: {
              type: 'object',
              properties: {
                imagesGenerated: {
                  type: 'number',
                  description: 'Number of images generated'
                },
                resolution: {
                  type: 'string',
                  description: 'Image resolution'
                },
                model: {
                  type: 'string',
                  description: 'Model used'
                },
                provider: {
                  type: 'string',
                  description: 'Provider used'
                }
              }
            },
            metadata: {
              type: 'object',
              description: 'Additional metadata'
            }
          }
        }
      },
      required: ['success']
    };
  }

  /**
   * Get available providers and their status
   */
  async getAvailableProviders() {
    if (!this.imageService) {
      return [];
    }
    return await this.imageService.getAvailableProviders();
  }

  /**
   * Get supported models for Google provider
   */
  async getSupportedModels(provider: 'google' = 'google'): Promise<string[]> {
    if (!this.imageService) {
      return [];
    }
    return await this.imageService.getSupportedModels(provider);
  }

  /**
   * Get supported sizes for Google provider
   */
  getSupportedSizes(provider: 'google' = 'google'): string[] {
    if (!this.imageService) {
      return [];
    }
    return this.imageService.getSupportedSizes(provider);
  }

  /**
   * Estimate cost for image generation
   */
  async estimateCost(params: Pick<GenerateImageParams, 'provider' | 'model'>): Promise<{
    estimatedCost: number;
    currency: string;
    breakdown: string;
  } | null> {
    if (!this.imageService) {
      return null;
    }
    return await this.imageService.estimateCost({
      prompt: 'example',
      provider: params.provider,
      model: params.model,
      savePath: 'example.png',
      sessionId: 'example'
    });
  }
}
```

## agents/agentManager/modes/getAgentMode.ts

```typescript
import { BaseMode } from '../../baseMode';
import { GetAgentParams, GetAgentResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';
import { getCommonResultSchema, createResult } from '../../../utils/schemaUtils';
import { addRecommendations } from '../../../utils/recommendationUtils';
import { AGENT_MANAGER_RECOMMENDATIONS } from '../recommendations';

/**
 * Mode for getting a specific custom agent for persona adoption
 */
export class GetAgentMode extends BaseMode<GetAgentParams, GetAgentResult> {
  private storageService: CustomPromptStorageService;
  
  /**
   * Create a new GetAgentMode
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'getAgent',
      'Get Agent',
      'Get a custom agent for persona adoption - does NOT execute tasks automatically',
      '1.0.0'
    );
    
    this.storageService = storageService;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the prompt data
   */
  async execute(params: GetAgentParams): Promise<GetAgentResult> {
    try {
      const { id, name } = params;
      
      // Must provide either id or name
      if (!id && !name) {
        return createResult<GetAgentResult>(false, null, 'Either id or name must be provided', undefined, undefined, params.context.sessionId, params.context);
      }
      
      // Get prompt by id or name
      let prompt = null;
      if (id) {
        // First try as unique identifier
        prompt = this.storageService.getPrompt(id);
        // If not found, try as agent name
        if (!prompt) {
          prompt = this.storageService.getPromptByName(id);
        }
      } else if (name) {
        prompt = this.storageService.getPromptByName(name);
      }
      
      if (!prompt) {
        const identifier = id ? `ID "${id}"` : `name "${name}"`;
        return createResult<GetAgentResult>(false, null, `Agent with ${identifier} not found`, undefined, undefined, params.context.sessionId, params.context);
      }

      // Create message with persona instruction and warning (prompt content is already in the prompt field)
      const message = `üé≠ AGENT PERSONA RETRIEVED: "${prompt.name}"

‚ö†Ô∏è  IMPORTANT EXECUTION BOUNDARY:
‚ùå This is PERSONA ADOPTION only - no tasks will be executed
‚ùå Do NOT automatically use executePrompt unless explicitly requested
‚ùå Do NOT run actions, create files, or modify content
‚úÖ You may adopt this persona for conversation
‚úÖ Ask permission before switching to execution mode

To execute tasks: User must explicitly request agentManager_executePrompt`;
      
      const resultWithMessage = {
        ...prompt,
        message: message
      };
      
      const result = createResult<GetAgentResult>(true, resultWithMessage, undefined, undefined, undefined, params.context.sessionId, params.context);
      return addRecommendations(result, AGENT_MANAGER_RECOMMENDATIONS.getAgent);
    } catch (error) {
      return createResult<GetAgentResult>(false, null, `Failed to get agent: ${error}`, undefined, undefined, params.context.sessionId, params.context);
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'Unique ID or name of the agent to retrieve for persona adoption (will try ID first, then name)'
        },
        name: {
          type: 'string',
          description: 'Name of the agent to retrieve for persona adoption'
        }
      },
      required: [],
      anyOf: [
        { required: ['id'] },
        { required: ['name'] }
      ]
    };

    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    const commonSchema = getCommonResultSchema();
    
    // Override the data property to define the specific structure for this mode
    return {
      ...commonSchema,
      properties: {
        ...commonSchema.properties,
        data: {
          oneOf: [
            { type: 'null' },
            {
              type: 'object',
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                description: { type: 'string' },
                prompt: { type: 'string' },
                isEnabled: { type: 'boolean' },
                message: { type: 'string', description: 'Complete persona instructions and warning about execute mode usage' }
              },
              required: ['id', 'name', 'description', 'prompt', 'isEnabled', 'message']
            }
          ]
        }
      }
    };
  }
}
```

## agents/agentManager/modes/index.ts

```typescript
// Export all AgentManager modes
export { ListAgentsMode } from './listAgentsMode';
export { GetAgentMode } from './getAgentMode';
export { CreateAgentMode } from './createAgentMode';
export { UpdateAgentMode } from './updateAgentMode';
export { DeleteAgentMode } from './deleteAgentMode';
export { ToggleAgentMode } from './toggleAgentMode';
export { ListModelsMode } from './listModelsMode';
export { ExecutePromptMode } from './executePromptMode';
export { BatchExecutePromptMode } from './batchExecutePrompt';
export { GenerateImageMode } from './generateImageMode';
```

## agents/agentManager/modes/listAgentsMode.ts

```typescript
import { BaseMode } from '../../baseMode';
import { ListAgentsParams, ListAgentsResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';
import { getCommonResultSchema, createResult } from '../../../utils/schemaUtils';
import { addRecommendations } from '../../../utils/recommendationUtils';
import { AGENT_MANAGER_RECOMMENDATIONS } from '../recommendations';

/**
 * Mode for listing custom prompts
 */
export class ListAgentsMode extends BaseMode<ListAgentsParams, ListAgentsResult> {
  private storageService: CustomPromptStorageService;
  
  /**
   * Create a new ListPromptsMode
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'listAgents',
      'List Agents',
      'List all custom agents',
      '1.0.0'
    );
    
    this.storageService = storageService;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the list of prompts
   */
  async execute(params: ListAgentsParams): Promise<ListAgentsResult> {
    try {
      const { enabledOnly = false } = params;
      
      // Get prompts based on filter
      const allPrompts = this.storageService.getAllPrompts();
      const enabledPrompts = this.storageService.getEnabledPrompts();
      
      const prompts = enabledOnly ? enabledPrompts : allPrompts;
      
      // Map to return only name and description for listing
      const promptList = prompts.map(prompt => ({
        id: prompt.id,
        name: prompt.name,
        description: prompt.description,
        isEnabled: prompt.isEnabled
      }));

      // Add warning message about execute mode
      const warningMessage = "IMPORTANT: Do not use the executePrompt mode or run any tasks automatically when working with these agents. Only take on their persona and respond in character. If the user wants you to actually execute tasks or use the executePrompt functionality, they must explicitly ask you to do so.";
      
      const result = createResult<ListAgentsResult>(true, {
        prompts: promptList,
        totalCount: allPrompts.length,
        enabledCount: enabledPrompts.length,
        message: warningMessage
      }, undefined, undefined, undefined, params.context.sessionId, params.context);
      
      return addRecommendations(result, AGENT_MANAGER_RECOMMENDATIONS.listAgents);
    } catch (error) {
      return createResult<ListAgentsResult>(false, null, `Failed to list prompts: ${error}`, undefined, undefined, params.context.sessionId, params.context);
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        enabledOnly: {
          type: 'boolean',
          description: 'If true, only return enabled prompts',
          default: false
        }
      },
      required: []
    };

    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    const commonSchema = getCommonResultSchema();
    
    // Override the data property to define the specific structure for this mode
    return {
      ...commonSchema,
      properties: {
        ...commonSchema.properties,
        data: {
          type: 'object',
          properties: {
            prompts: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  name: { type: 'string' },
                  description: { type: 'string' },
                  isEnabled: { type: 'boolean' }
                },
                required: ['id', 'name', 'description', 'isEnabled']
              }
            },
            totalCount: { type: 'number' },
            enabledCount: { type: 'number' },
            message: { type: 'string', description: 'Warning message about execute mode usage' }
          },
          required: ['prompts', 'totalCount', 'enabledCount', 'message']
        }
      }
    };
  }
}
```

## agents/agentManager/modes/listModelsMode.ts

```typescript
/**
 * List Models Mode
 * Lists available LLM models from enabled providers with capabilities and pricing
 */

import { BaseMode } from '../../baseMode';
import { CommonResult, CommonParameters } from '../../../types';
import { createResult, getCommonResultSchema } from '../../../utils/schemaUtils';
// Import removed - using this.getMergedSchema() instead of mergeWithCommonSchema
import { LLMProviderManager } from '../../../services/llm/providers/ProviderManager';

export interface ListModelsParams extends CommonParameters {
  // No additional parameters beyond common ones
}

export interface ListModelsResult extends CommonResult {
  data: {
    models: Array<{
      provider: string;
      model: string;
      displayName: string;
      userDescription?: string;
      isDefault: boolean;
      capabilities: {
        contextWindow: number;
        maxOutputTokens?: number;
        supportsJSON: boolean;
        supportsImages: boolean;
        supportsFunctions: boolean;
        supportsStreaming: boolean;
        supportsThinking?: boolean;
      };
      pricing: {
        inputPerMillion: number;
        outputPerMillion: number;
        currency: string;
        lastUpdated: string;
      };
    }>;
    defaultModel: {
      provider: string;
      model: string;
    };
    statistics: {
      totalModels: number;
      providerCount: number;
      averageContextWindow: number;
      maxContextWindow: number;
      minCostPerMillion: number;
      maxCostPerMillion: number;
    };
    availableProviders: Array<{
      id: string;
      name: string;
      description: string;
      isEnabled: boolean;
      userDescription?: string;
      modelCount: number;
      specialFeatures?: string[];
    }>;
  };
}

export class ListModelsMode extends BaseMode<ListModelsParams, ListModelsResult> {
  private providerManager: LLMProviderManager | null = null;

  constructor() {
    super(
      'listModels',
      'List Available Models',
      'List all available LLM models from enabled providers with capabilities, pricing, and statistics',
      '1.0.0'
    );
  }

  /**
   * Set the provider manager instance
   */
  setProviderManager(providerManager: LLMProviderManager): void {
    this.providerManager = providerManager;
  }

  /**
   * Wait for the provider manager to be initialized
   * @param timeoutMs Maximum time to wait in milliseconds
   * @private
   */
  private async waitForProviderManager(timeoutMs: number): Promise<void> {
    const startTime = Date.now();
    const checkInterval = 100; // Check every 100ms
    
    while (Date.now() - startTime < timeoutMs) {
      if (this.providerManager) {
        return;
      }
      
      // Wait for the next check
      await new Promise(resolve => setTimeout(resolve, checkInterval));
    }
  }

  /**
   * Execute the list models mode
   */
  async execute(params: ListModelsParams): Promise<ListModelsResult> {
    try {
      // If provider manager is not set, try to wait for it or get it lazily
      if (!this.providerManager) {
        // Try to wait briefly for initialization to complete
        await this.waitForProviderManager(3000); // Wait up to 3 seconds
        
        if (!this.providerManager) {
          return createResult<ListModelsResult>(
            false,
            undefined,
            'LLM Provider Manager not initialized. Please ensure you have configured at least one LLM provider with valid API keys.',
            undefined,
            undefined,
            params.context.sessionId,
            params.context
          );
        }
      }

      // Get all available models
      const models = await this.providerManager.getAvailableModels();
      
      // Get provider information
      const enabledProviders = this.providerManager.getEnabledProviders();
      
      // Get default model from settings
      const settings = this.providerManager.getSettings();
      const defaultModel = {
        provider: settings.defaultModel.provider,
        model: settings.defaultModel.model
      };

      // Group models by provider for counting
      const modelsByProvider = models.reduce((acc, model) => {
        acc[model.provider] = (acc[model.provider] || 0) + 1;
        return acc;
      }, {} as { [key: string]: number });

      // Calculate statistics with safe pricing access
      const modelsWithPricing = models.filter(m => m.pricing && typeof m.pricing.inputPerMillion === 'number');
      const statistics = {
        totalModels: models.length,
        providerCount: enabledProviders.length,
        averageContextWindow: models.length > 0 ? Math.round(models.reduce((sum, m) => sum + m.contextWindow, 0) / models.length) : 0,
        maxContextWindow: models.length > 0 ? Math.max(...models.map(m => m.contextWindow)) : 0,
        minCostPerMillion: modelsWithPricing.length > 0 ? Math.min(...modelsWithPricing.map(m => m.pricing.inputPerMillion)) : 0,
        maxCostPerMillion: modelsWithPricing.length > 0 ? Math.max(...modelsWithPricing.map(m => m.pricing.inputPerMillion)) : 0
      };

      // Format the response
      const formattedModels = models.map(model => ({
        provider: model.provider,
        model: model.id,
        displayName: model.name,
        userDescription: model.userDescription,
        isDefault: model.isDefault || false,
        capabilities: {
          contextWindow: model.contextWindow,
          maxOutputTokens: model.maxOutputTokens,
          supportsJSON: model.supportsJSON,
          supportsImages: model.supportsImages,
          supportsFunctions: model.supportsFunctions,
          supportsStreaming: model.supportsStreaming,
          supportsThinking: model.supportsThinking
        },
        pricing: {
          inputPerMillion: model.pricing?.inputPerMillion ?? 0,
          outputPerMillion: model.pricing?.outputPerMillion ?? 0,
          currency: model.pricing?.currency ?? 'USD',
          lastUpdated: model.pricing?.lastUpdated ?? new Date().toISOString()
        }
      }));

      // Format provider information
      const availableProviders = enabledProviders.map(provider => {
        const baseInfo = {
          id: provider.id,
          name: provider.name,
          description: provider.description,
          isEnabled: provider.isEnabled,
          userDescription: provider.userDescription,
          modelCount: modelsByProvider[provider.id] || 0
        };
        
        // Add special features for OpenRouter
        if (provider.id === 'openrouter') {
          return {
            ...baseInfo,
            specialFeatures: [
              'Add ":online" to any model name for web-enabled responses (e.g., "gpt-4:online")'
            ]
          };
        }
        
        return baseInfo;
      });

      const resultData = {
        models: formattedModels,
        defaultModel,
        statistics,
        availableProviders
      };

      return createResult<ListModelsResult>(
        true,
        resultData,
        undefined,
        undefined,
        undefined,
        params.context.sessionId,
        params.context
      );

    } catch (error) {
      return createResult<ListModelsResult>(
        false,
        undefined,
        `Failed to list models: ${error instanceof Error ? error.message : 'Unknown error'}`,
        undefined,
        undefined,
        params.context.sessionId,
        params.context
      );
    }
  }

  /**
   * Get parameter schema for the mode
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        // No additional parameters beyond common ones
      },
      required: []
    };
    
    return this.getMergedSchema(modeSchema);
  }

  /**
   * Get result schema for the mode
   */
  getResultSchema(): any {
    const commonSchema = getCommonResultSchema();
    
    // Override the data property to define the specific structure for this mode
    return {
      ...commonSchema,
      properties: {
        ...commonSchema.properties,
        data: {
          type: 'object',
          properties: {
            models: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  provider: { type: 'string' },
                  model: { type: 'string' },
                  displayName: { type: 'string' },
                  userDescription: { type: 'string' },
                  isDefault: { type: 'boolean' },
                  capabilities: {
                    type: 'object',
                    properties: {
                      contextWindow: { type: 'number' },
                      maxOutputTokens: { type: 'number' },
                      supportsJSON: { type: 'boolean' },
                      supportsImages: { type: 'boolean' },
                      supportsFunctions: { type: 'boolean' },
                      supportsStreaming: { type: 'boolean' },
                      supportsThinking: { type: 'boolean' }
                    },
                    required: ['contextWindow', 'supportsJSON', 'supportsImages', 'supportsFunctions', 'supportsStreaming']
                  },
                  pricing: {
                    type: 'object',
                    properties: {
                      inputPerMillion: { type: 'number' },
                      outputPerMillion: { type: 'number' },
                      currency: { type: 'string' },
                      lastUpdated: { type: 'string' }
                    },
                    required: ['inputPerMillion', 'outputPerMillion', 'currency', 'lastUpdated']
                  }
                },
                required: ['provider', 'model', 'displayName', 'isDefault', 'capabilities', 'pricing']
              }
            },
            defaultModel: {
              type: 'object',
              properties: {
                provider: { type: 'string' },
                model: { type: 'string' }
              },
              required: ['provider', 'model']
            },
            statistics: {
              type: 'object',
              properties: {
                totalModels: { type: 'number' },
                providerCount: { type: 'number' },
                averageContextWindow: { type: 'number' },
                maxContextWindow: { type: 'number' },
                minCostPerMillion: { type: 'number' },
                maxCostPerMillion: { type: 'number' }
              },
              required: ['totalModels', 'providerCount', 'averageContextWindow', 'maxContextWindow', 'minCostPerMillion', 'maxCostPerMillion']
            },
            availableProviders: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  name: { type: 'string' },
                  description: { type: 'string' },
                  isEnabled: { type: 'boolean' },
                  userDescription: { type: 'string' },
                  modelCount: { type: 'number' },
                  specialFeatures: {
                    type: 'array',
                    items: { type: 'string' }
                  }
                },
                required: ['id', 'name', 'description', 'isEnabled', 'modelCount']
              }
            }
          },
          required: ['models', 'defaultModel', 'statistics', 'availableProviders']
        }
      }
    };
  }
}
```

## agents/agentManager/modes/toggleAgentMode.ts

```typescript
import { BaseMode } from '../../baseMode';
import { ToggleAgentParams, ToggleAgentResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';
import { getCommonResultSchema, createResult } from '../../../utils/schemaUtils';

/**
 * Mode for toggling a custom prompt's enabled state
 */
export class ToggleAgentMode extends BaseMode<ToggleAgentParams, ToggleAgentResult> {
  private storageService: CustomPromptStorageService;
  
  /**
   * Create a new TogglePromptMode
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'toggleAgent',
      'Toggle Agent',
      'Toggle a custom agent enabled/disabled state',
      '1.0.0'
    );
    
    this.storageService = storageService;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the toggled prompt
   */
  async execute(params: ToggleAgentParams): Promise<ToggleAgentResult> {
    try {
      const { id } = params;
      
      // Validate required ID
      if (!id?.trim()) {
        return createResult<ToggleAgentResult>(false, null, 'ID is required', undefined, undefined, params.context.sessionId, params.context);
      }
      
      // Toggle the prompt
      const toggledPrompt = await this.storageService.togglePrompt(id.trim());
      
      return createResult<ToggleAgentResult>(true, toggledPrompt, undefined, undefined, undefined, params.context.sessionId, params.context);
    } catch (error) {
      return createResult<ToggleAgentResult>(false, null, `Failed to toggle prompt: ${error}`, undefined, undefined, params.context.sessionId, params.context);
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'Unique ID of the prompt to toggle',
          minLength: 1
        }
      },
      required: ['id']
    };

    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    const commonSchema = getCommonResultSchema();
    
    // Override the data property to define the specific structure for this mode
    return {
      ...commonSchema,
      properties: {
        ...commonSchema.properties,
        data: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            name: { type: 'string' },
            description: { type: 'string' },
            prompt: { type: 'string' },
            isEnabled: { type: 'boolean' }
          },
          required: ['id', 'name', 'description', 'prompt', 'isEnabled']
        }
      }
    };
  }
}
```

## agents/agentManager/modes/updateAgentMode.ts

```typescript
import { BaseMode } from '../../baseMode';
import { UpdateAgentParams, UpdateAgentResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';
import { getCommonResultSchema, createResult } from '../../../utils/schemaUtils';
import { addRecommendations } from '../../../utils/recommendationUtils';
import { AGENT_MANAGER_RECOMMENDATIONS } from '../recommendations';

/**
 * Mode for updating an existing custom agent
 */
export class UpdateAgentMode extends BaseMode<UpdateAgentParams, UpdateAgentResult> {
  private storageService: CustomPromptStorageService;
  
  /**
   * Create a new UpdateAgentMode
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'updateAgent',
      'Update Agent',
      'Update an existing custom agent',
      '1.0.0'
    );
    
    this.storageService = storageService;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the updated prompt
   */
  async execute(params: UpdateAgentParams): Promise<UpdateAgentResult> {
    try {
      const { id, name, description, prompt, isEnabled } = params;
      
      // Validate required ID
      if (!id?.trim()) {
        return createResult<UpdateAgentResult>(false, null, 'ID is required', undefined, undefined, params.context.sessionId, params.context);
      }
      
      // Check that at least one field is being updated
      if (name === undefined && description === undefined && prompt === undefined && isEnabled === undefined) {
        return createResult<UpdateAgentResult>(false, null, 'At least one field must be provided for update', undefined, undefined, params.context.sessionId, params.context);
      }
      
      // Prepare updates object
      const updates: any = {};
      
      if (name !== undefined) {
        if (!name.trim()) {
          return createResult<UpdateAgentResult>(false, null, 'Name cannot be empty', undefined, undefined, params.context.sessionId, params.context);
        }
        updates.name = name.trim();
      }
      
      if (description !== undefined) {
        if (!description.trim()) {
          return createResult<UpdateAgentResult>(false, null, 'Description cannot be empty', undefined, undefined, params.context.sessionId, params.context);
        }
        updates.description = description.trim();
      }
      
      if (prompt !== undefined) {
        if (!prompt.trim()) {
          return createResult<UpdateAgentResult>(false, null, 'Prompt text cannot be empty', undefined, undefined, params.context.sessionId, params.context);
        }
        updates.prompt = prompt.trim();
      }
      
      if (isEnabled !== undefined) {
        updates.isEnabled = isEnabled;
      }
      
      // Update the prompt
      const updatedPrompt = await this.storageService.updatePrompt(id.trim(), updates);
      
      const result = createResult<UpdateAgentResult>(true, updatedPrompt, undefined, undefined, undefined, params.context.sessionId, params.context);
      return addRecommendations(result, AGENT_MANAGER_RECOMMENDATIONS.updateAgent);
    } catch (error) {
      return createResult<UpdateAgentResult>(false, null, `Failed to update prompt: ${error}`, undefined, undefined, params.context.sessionId, params.context);
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'Unique ID of the prompt to update',
          minLength: 1
        },
        name: {
          type: 'string',
          description: 'New name for the prompt (must be unique)',
          minLength: 1,
          maxLength: 100
        },
        description: {
          type: 'string',
          description: 'New description for the prompt',
          minLength: 1,
          maxLength: 500
        },
        prompt: {
          type: 'string',
          description: 'New prompt text/persona',
          minLength: 1
        },
        isEnabled: {
          type: 'boolean',
          description: 'Whether the prompt is enabled'
        }
      },
      required: ['id']
    };

    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    const commonSchema = getCommonResultSchema();
    
    // Override the data property to define the specific structure for this mode
    return {
      ...commonSchema,
      properties: {
        ...commonSchema.properties,
        data: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            name: { type: 'string' },
            description: { type: 'string' },
            prompt: { type: 'string' },
            isEnabled: { type: 'boolean' }
          },
          required: ['id', 'name', 'description', 'prompt', 'isEnabled']
        },
        recommendations: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              type: { type: 'string' },
              message: { type: 'string' }
            },
            required: ['type', 'message']
          },
          description: 'Workspace-agent optimization recommendations'
        }
      }
    };
  }
}
```

## agents/agentManager/recommendations.ts

```typescript
/**
 * Static recommendation definitions for AgentManager tools
 * Provides workspace-agent optimization suggestions through MCP responses
 */

import { Recommendation } from '../../utils/recommendationUtils';

export const AGENT_MANAGER_RECOMMENDATIONS: Record<string, Recommendation[]> = {
	// Execute and batch execute prompt recommendations
	executePrompt: [
		{
			type: "workspace_agent",
			message: "Consider updating your workspace agent based on this task, or create a specialized agent if none exists."
		},
		{
			type: "workflow_optimization",
			message: "If you frequently run similar prompts, consider creating a custom agent for this workspace."
		}
	],

	batchExecutePrompt: [
		{
			type: "workspace_agent",
			message: "Batch operations suggest routine workflows. Consider creating a workspace-specific agent to automate these patterns."
		},
		{
			type: "agent_efficiency",
			message: "If these batch operations are workspace-specific, bind an agent to this workspace for automatic context loading."
		}
	],

	// Prompt management recommendations
	createAgent: [
		{
			type: "workspace_binding",
			message: "Consider associating this new agent with your current workspace for automatic loading."
		},
		{
			type: "agent_organization",
			message: "Group related prompts by workspace to improve agent discoverability and context relevance."
		}
	],

	updateAgent: [
		{
			type: "workspace_sync",
			message: "If this agent is bound to a workspace, the changes will be automatically available when the workspace loads."
		},
		{
			type: "version_control",
			message: "Consider documenting significant agent changes in your workspace context for better collaboration."
		}
	],

	deleteAgent: [
		{
			type: "workspace_cleanup",
			message: "If this agent was bound to a workspace, you may want to update the workspace configuration."
		},
		{
			type: "agent_migration",
			message: "Consider whether workspace-bound functionality should be transferred to another agent."
		}
	],

	toggleAgent: [
		{
			type: "workspace_management",
			message: "Toggling agents on/off can help manage workspace-specific vs. global agent availability."
		}
	],

	// Discovery and browsing recommendations
	listAgents: [
		{
			type: "workspace_discovery",
			message: "Consider which of these agents would be most useful for your current workspace context."
		},
		{
			type: "agent_binding",
			message: "You can bind frequently used agents to specific workspaces for automatic loading."
		}
	],

	getAgent: [
		{
			type: "workspace_integration",
			message: "If this agent fits your current workspace workflow, consider binding it for automatic availability."
		},
		{
			type: "agent_context",
			message: "Review if this agent's capabilities align with your workspace's typical tasks and content."
		}
	],

	// Tool discovery recommendations
	listModels: [
		{
			type: "workspace_optimization",
			message: "Different models may be optimal for different workspace types. Consider workspace-specific model preferences."
		},
		{
			type: "agent_configuration",
			message: "Workspace-bound agents can specify preferred models for consistent behavior in specific contexts."
		}
	],

	// Image generation recommendations
	generateImage: [
		{
			type: "workspace_assets",
			message: "Consider organizing generated images within your workspace structure for better project coherence."
		},
		{
			type: "visual_workflow",
			message: "If image generation is common in this workspace, consider creating a specialized visual content agent."
		}
	]
};
```

## agents/agentManager/services/CustomPromptStorageService.ts

```typescript
import { CustomPrompt, CustomPromptsSettings, DEFAULT_CUSTOM_PROMPTS_SETTINGS } from '../../../types';
import { Settings } from '../../../settings';

/**
 * Service for managing custom prompt storage and persistence
 * Handles CRUD operations for custom prompts within plugin settings
 */
export class CustomPromptStorageService {
    private settings: Settings;

    constructor(settings: Settings) {
        this.settings = settings;
    }

    /**
     * Get all custom prompts
     * @returns Array of all custom prompts
     */
    getAllPrompts(): CustomPrompt[] {
        this.ensureCustomPromptsSettings();
        return this.settings.settings.customPrompts?.prompts || [];
    }

    /**
     * Get enabled custom prompts only
     * @returns Array of enabled custom prompts
     */
    getEnabledPrompts(): CustomPrompt[] {
        return this.getAllPrompts().filter(prompt => prompt.isEnabled);
    }

    /**
     * Get a specific prompt by ID
     * @param id Prompt ID
     * @returns Custom prompt or undefined if not found
     */
    getPrompt(id: string): CustomPrompt | undefined {
        return this.getAllPrompts().find(prompt => prompt.id === id);
    }

    /**
     * Get a specific prompt by name
     * @param name Prompt name
     * @returns Custom prompt or undefined if not found
     */
    getPromptByName(name: string): CustomPrompt | undefined {
        return this.getAllPrompts().find(prompt => prompt.name === name);
    }

    /**
     * Create a new custom prompt
     * @param prompt Prompt data (without id - will be generated)
     * @returns Created prompt with generated ID
     * @throws Error if prompt name already exists
     */
    async createPrompt(promptData: Omit<CustomPrompt, 'id'>): Promise<CustomPrompt> {
        this.ensureCustomPromptsSettings();
        
        // Check for duplicate names
        if (this.getPromptByName(promptData.name)) {
            throw new Error(`A prompt with the name "${promptData.name}" already exists`);
        }

        // Generate unique ID
        const id = this.generateId();
        
        // Create the new prompt
        const newPrompt: CustomPrompt = {
            id,
            ...promptData
        };

        // Add to prompts array
        this.settings.settings.customPrompts!.prompts.push(newPrompt);
        
        // Save settings
        await this.settings.saveSettings();
        
        return newPrompt;
    }

    /**
     * Update an existing custom prompt
     * @param id Prompt ID
     * @param updates Partial prompt data to update
     * @returns Updated prompt
     * @throws Error if prompt not found or name conflict
     */
    async updatePrompt(id: string, updates: Partial<Omit<CustomPrompt, 'id'>>): Promise<CustomPrompt> {
        this.ensureCustomPromptsSettings();
        
        const prompts = this.settings.settings.customPrompts!.prompts;
        const index = prompts.findIndex(prompt => prompt.id === id);
        
        if (index === -1) {
            throw new Error(`Prompt with ID "${id}" not found`);
        }

        // Check for name conflicts if name is being updated
        if (updates.name && updates.name !== prompts[index].name) {
            const existingPrompt = this.getPromptByName(updates.name);
            if (existingPrompt && existingPrompt.id !== id) {
                throw new Error(`A prompt with the name "${updates.name}" already exists`);
            }
        }

        // Update the prompt
        prompts[index] = {
            ...prompts[index],
            ...updates
        };

        // Save settings
        await this.settings.saveSettings();
        
        return prompts[index];
    }

    /**
     * Delete a custom prompt
     * @param id Prompt ID
     * @returns True if deleted, false if not found
     */
    async deletePrompt(id: string): Promise<boolean> {
        this.ensureCustomPromptsSettings();
        
        const prompts = this.settings.settings.customPrompts!.prompts;
        const index = prompts.findIndex(prompt => prompt.id === id);
        
        if (index === -1) {
            return false;
        }

        // Remove the prompt
        prompts.splice(index, 1);
        
        // Save settings
        await this.settings.saveSettings();
        
        return true;
    }

    /**
     * Toggle enabled state of a prompt
     * @param id Prompt ID
     * @returns Updated prompt
     * @throws Error if prompt not found
     */
    async togglePrompt(id: string): Promise<CustomPrompt> {
        const prompt = this.getPrompt(id);
        if (!prompt) {
            throw new Error(`Prompt with ID "${id}" not found`);
        }

        return await this.updatePrompt(id, { isEnabled: !prompt.isEnabled });
    }

    /**
     * Check if custom prompts are enabled globally
     * @returns True if enabled
     */
    isEnabled(): boolean {
        this.ensureCustomPromptsSettings();
        return this.settings.settings.customPrompts?.enabled || false;
    }

    /**
     * Enable or disable custom prompts globally
     * @param enabled Whether to enable custom prompts
     */
    async setEnabled(enabled: boolean): Promise<void> {
        this.ensureCustomPromptsSettings();
        this.settings.settings.customPrompts!.enabled = enabled;
        await this.settings.saveSettings();
    }

    /**
     * Ensure custom prompts settings exist with defaults
     */
    private ensureCustomPromptsSettings(): void {
        if (!this.settings.settings.customPrompts) {
            this.settings.settings.customPrompts = { ...DEFAULT_CUSTOM_PROMPTS_SETTINGS };
        }
    }

    /**
     * Generate a unique ID for a prompt
     * @returns Unique string ID
     */
    private generateId(): string {
        return `prompt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}
```

## agents/agentManager/services/index.ts

```typescript
/**
 * Agent Manager Services Exports
 */

export { CustomPromptStorageService } from './CustomPromptStorageService';
```

## agents/agentManager/types.ts

```typescript
import { CommonParameters, CommonResult, CustomPrompt } from '../../types';

// List Agents Mode
export interface ListAgentsParams extends CommonParameters {
  enabledOnly?: boolean;
}

export interface ListAgentsResult extends CommonResult {
  data: {
    prompts: Array<Pick<CustomPrompt, 'id' | 'name' | 'description' | 'isEnabled'>>;
    totalCount: number;
    enabledCount: number;
    message: string;
  };
}

// Get Agent Mode
export interface GetAgentParams extends CommonParameters {
  id?: string;
  name?: string;
}

export interface GetAgentResult extends CommonResult {
  data: (CustomPrompt & { message: string }) | null;
}

// Create Agent Mode
export interface CreateAgentParams extends CommonParameters {
  name: string;
  description: string;
  prompt: string;
  isEnabled?: boolean;
}

export interface CreateAgentResult extends CommonResult {
  data: CustomPrompt;
}

// Update Agent Mode
export interface UpdateAgentParams extends CommonParameters {
  id: string;
  name?: string;
  description?: string;
  prompt?: string;
  isEnabled?: boolean;
}

export interface UpdateAgentResult extends CommonResult {
  data: CustomPrompt;
}

// Delete Agent Mode
export interface DeleteAgentParams extends CommonParameters {
  id: string;
}

export interface DeleteAgentResult extends CommonResult {
  data: {
    deleted: boolean;
    id: string;
  };
}

// Toggle Agent Mode
export interface ToggleAgentParams extends CommonParameters {
  id: string;
}

export interface ToggleAgentResult extends CommonResult {
  data: CustomPrompt;
}
```

## agents/baseAgent.ts

```typescript
import { IAgent } from './interfaces/IAgent';
import { IMode } from './interfaces/IMode';
import { CommonParameters, CommonResult } from '../types';
import { parseWorkspaceContext } from '../utils/contextUtils';
import { createErrorMessage } from '../utils/errorUtils';

/**
 * Base class for all agents in the MCP plugin
 * Provides common functionality for agent implementation
 */
export abstract class BaseAgent implements IAgent {
  name: string;
  protected _description: string;
  version: string;
  protected modes: Map<string, IMode> = new Map();
  
  // Reference to agent manager
  protected agentManager?: {
    getAgent(agentName: string): IAgent | undefined;
  };
  
  /**
   * Create a new agent
   * @param name Name of the agent
   * @param description Description of the agent
   * @param version Version of the agent
   */
  constructor(name: string, description: string, version: string) {
    this.name = name;
    this._description = description;
    this.version = version;
  }

  /**
   * Get the agent description
   * Can be overridden by subclasses for dynamic descriptions
   */
  get description(): string {
    return this._description;
  }
  
  /**
   * Set the agent manager reference
   * @param manager Agent manager instance
   */
  setAgentManager(manager: { getAgent(agentName: string): IAgent | undefined }): void {
    this.agentManager = manager;
  }
  
  /**
   * Get all modes provided by this agent
   * @returns Array of modes
   */
  getModes(): IMode[] {
    return Array.from(this.modes.values());
  }
  
  /**
   * Get a specific mode by slug
   * @param modeSlug Slug of the mode to get
   * @returns Mode with the specified slug or undefined if not found
   */
  getMode(modeSlug: string): IMode | undefined {
    return this.modes.get(modeSlug);
  }
  
  /**
   * Register a mode with this agent
   * @param mode Mode to register
   */
  registerMode(mode: IMode): void {
    this.modes.set(mode.slug, mode);
  }
  
  /**
   * Initialize the agent
   * Default implementation does nothing
   * @returns Promise that resolves when initialization is complete
   */
  async initialize(): Promise<void> {
    // Default implementation does nothing
  }
  
  /**
   * Execute a mode by slug
   * @param modeSlug Slug of the mode to execute
   * @param params Parameters to pass to the mode
   * @returns Promise that resolves with the mode's result
   * @throws Error if mode not found
   */
  async executeMode(modeSlug: string, params: any): Promise<any> {
    const mode = this.modes.get(modeSlug);
    if (!mode) {
      throw new Error(`Mode ${modeSlug} not found in agent ${this.name}`);
    }
    
    // Session ID and description are now required for all tool calls (in context)
    if (!params.context?.sessionId) {
      // Return error if sessionId is missing - provide helpful message about providing session name
      return {
        success: false,
        error: createErrorMessage('Session ID required: ', 
          `Mode ${modeSlug} requires context.sessionId. Provide a 2-4 word session name or existing session ID in the context block.`),
        data: null
      };
    }
    
    // sessionDescription is optional but recommended for better session management
    if (!params.context?.sessionDescription) {
      console.warn(`[${this.name}] context.sessionDescription not provided for ${modeSlug}. Consider providing a brief description for better session tracking.`);
    }
    
    // Store the sessionId on the mode instance for use in prepareResult
    (mode as any).sessionId = params.context.sessionId;
    
    // If the mode has setParentContext method, use it to propagate workspace context
    // Pass the workspace context even if undefined, as the mode's setParentContext
    // method can handle the default context inheritance logic
    if (typeof (mode as any).setParentContext === 'function') {
      (mode as any).setParentContext(params.workspaceContext);
    }
    
    // If the mode supports getInheritedWorkspaceContext and there's no explicit workspace context,
    // try to retrieve the inherited context and apply it to the params
    if (typeof (mode as any).getInheritedWorkspaceContext === 'function' && 
        (!params.workspaceContext || !parseWorkspaceContext(params.workspaceContext)?.workspaceId)) {
      const inheritedContext = (mode as any).getInheritedWorkspaceContext(params);
      if (inheritedContext) {
        params = {
          ...params,
          workspaceContext: inheritedContext
        };
      }
    }
    
    // Execute the requested mode
    const result = await mode.execute(params);
    
    return result;
  }
  
  
  /**
   * Clean up resources when the agent is unloaded
   * This is a base implementation that child classes can extend
   */
  onunload(): void {
    // Default implementation does nothing
  }
}
```

## agents/baseMode.ts

```typescript
import { IMode } from './interfaces/IMode';
import { CommonParameters, CommonResult } from '../types';
import { 
  getCommonParameterSchema, 
  getCommonResultSchema, 
  createResult,
  mergeWithCommonSchema
} from '../utils/schemaUtils';
import { parseWorkspaceContext } from '../utils/contextUtils';
import { getErrorMessage } from '../utils/errorUtils';
import { enhanceSchemaDocumentation } from '../utils/validationUtils';

// Import new validation utilities
import { 
  ValidationResultHelper, 
  ValidationError,
  ValidationResult
} from '../utils/validation/ValidationResultHelper';
import { 
  CommonValidators,
  ValidationRuleSet
} from '../utils/validation/CommonValidators';

/**
 * Base class for all modes in the MCP plugin
 * Provides common functionality for mode implementation
 */
export abstract class BaseMode<T extends CommonParameters = CommonParameters, R extends CommonResult = CommonResult> implements IMode<T, R> {
  slug: string;
  name: string;
  description: string;
  version: string;
  
  /**
   * Create a new mode
   * @param slug Slug of the mode (used for identification)
   * @param name Name of the mode
   * @param description Description of the mode
   * @param version Version of the mode
   */
  constructor(slug: string, name: string, description: string, version: string) {
    this.slug = slug;
    this.name = name;
    this.description = description;
    this.version = version;
  }
  
  /**
   * Execute the mode with parameters
   * @param params Parameters for the mode
   * @returns Promise that resolves with the mode's result
   */
  abstract execute(params: T): Promise<R>;
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  abstract getParameterSchema(): any;
  
  /**
   * Get common parameter schema elements for workspace context
   * This is now a proxy to the central utility for DRY implementation
   * @returns JSON schema for common parameters
   */
  protected getCommonParameterSchema(): any {
    return getCommonParameterSchema();
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    // Default implementation returns the common result schema
    return getCommonResultSchema();
  }
  
  /**
   * Helper method to merge mode-specific schema with common schema and enhance documentation
   * This ensures that every mode has workspace context parameters,
   * and provides clear documentation on which parameters are required vs. optional
   * 
   * @param customSchema The mode-specific schema
   * @returns Merged and enhanced schema with common parameters and improved documentation
   */
  protected getMergedSchema(customSchema: any): any {
    // Get the merged schema with common parameters
    const mergedSchema = mergeWithCommonSchema(customSchema);
    
    // Ensure the schema has a type and properties
    mergedSchema.type = mergedSchema.type || 'object';
    mergedSchema.properties = mergedSchema.properties || {};
    
    // Make sure workspaceContext is defined as optional property
    // This is a safety check in case it's not included in the common schema for some reason
    if (!mergedSchema.properties.workspaceContext) {
      mergedSchema.properties.workspaceContext = {
        type: 'object',
        properties: {
          workspaceId: { 
            type: 'string',
            description: 'Workspace identifier' 
          },
          workspacePath: { 
            type: 'array', 
            items: { type: 'string' },
            description: 'Path from root workspace to specific phase/task'
          },
          sessionId: {
            type: 'string',
            description: 'Session identifier to track related tool calls (required)'
          }
        },
        description: 'Optional workspace context'
      };
    }
    
    // Enhance schema with detailed documentation on required vs. optional parameters
    // and type information, to improve user experience
    return enhanceSchemaDocumentation(mergedSchema);
  }
  
  /**
   * Prepare a standardized result object
   * @param success Whether the operation was successful
   * @param data Operation-specific data
   * @param error Error message if operation failed
   * @param context Either a string with contextual information or a record of additional properties to include
   * @param workspaceContext Workspace context used
   * @returns Standardized result object
   */
  protected prepareResult(
    success: boolean,
    data?: any,
    error?: string,
    context?: CommonResult['context'],
    workspaceContext?: CommonResult['workspaceContext']
  ): R {
    // Extract sessionId from context parameter (DRY fix for all modes)
    let sessionId: string | undefined;
    
    if (context && typeof context === 'object' && 'sessionId' in context) {
      // New pattern: extract sessionId from context object
      sessionId = context.sessionId;
    } else {
      // Fallback: try to get from instance (backward compatibility)
      sessionId = (this as any).sessionId;
    }
    
    if (!sessionId) {
      // Session ID is required, so we should report an error
      return createResult<R>(
        false, 
        null, 
        'Session ID is required but not provided',
        workspaceContext, 
        undefined,
        undefined
      );
    }
    
    // If no workspace context was explicitly provided, but there's a parent context,
    // inherit the workspace context from the parent
    if (!workspaceContext && (this as any).parentContext) {
      workspaceContext = (this as any).parentContext;
    }
    
    return createResult<R>(
      success, 
      data, 
      error, 
      workspaceContext, 
      sessionId,
      context
    );
  }
  
  /**
   * Set parent workspace context for session tracking
   * This allows session IDs to be propagated between modes
   * @param context Parent workspace context
   */
  setParentContext(context: CommonResult['workspaceContext']): void {
    (this as any).parentContext = context;
  }
  
  /**
   * Get the inherited workspace context
   * This method handles workspace context inheritance, where a child operation
   * can inherit context from its parent if not explicitly specified.
   * 
   * Order of precedence:
   * 1. Current params.workspaceContext if explicitly provided
   * 2. Parent context from setParentContext if available
   * 3. Context from default session context
   * 
   * @param params Parameters that may include workspaceContext
   * @returns The effective workspace context to use, or null if none available
   */
  protected getInheritedWorkspaceContext(params: CommonParameters): CommonResult['workspaceContext'] | null {
    // 1. Use explicitly provided context if available
    if (params.workspaceContext) {
      // Use the utility function to safely parse context
      const fallbackId = ((this as any).parentContext?.workspaceId) || 'default-workspace';
      return parseWorkspaceContext(params.workspaceContext, fallbackId);
    }
    
    // 2. Fall back to parent context
    if ((this as any).parentContext?.workspaceId) {
      return (this as any).parentContext;
    }
    
    // 3. No context available
    return null;
  }
  

  // ========================================
  // NEW VALIDATION UTILITIES (Phase 1)
  // ========================================

  /**
   * Helper for standardized error responses
   * 
   * Creates consistent error results using ValidationResultHelper while maintaining
   * backward compatibility with existing result creation patterns.
   * 
   * @param error Error string, Error object, or array of ValidationErrors
   * @param params Original parameters (for context extraction)
   * @param context Additional context to include in result
   * @returns Standardized error result
   */
  protected createErrorResult(
    error: string | Error | ValidationError[],
    params?: T,
    context?: any
  ): R {
    return ValidationResultHelper.createErrorResult(this as any, error, params, context);
  }

  /**
   * Helper for standardized success responses
   * 
   * Creates consistent success results using ValidationResultHelper with proper
   * context propagation and session tracking.
   * 
   * @param data Result data to include
   * @param params Original parameters (for context extraction)
   * @param additionalData Additional properties to include in result
   * @returns Standardized success result
   */
  protected createSuccessResult(
    data: any,
    params?: T,
    additionalData?: any
  ): R {
    return ValidationResultHelper.createSuccessResult(this as any, data, params, additionalData);
  }

  /**
   * Enhanced validation execution pipeline
   * 
   * Validates multiple fields using CommonValidators and returns a comprehensive
   * validation result with all errors collected.
   * 
   * @param params Parameters object to validate
   * @param validators Mapping of field names to validation functions
   * @returns Validation result with success status and error details
   */
  protected validateCustom<TParams>(
    params: TParams,
    validators: ValidationRuleSet<TParams>
  ): ValidationResult<TParams> {
    const errors = CommonValidators.validateFields(params, validators);
    return ValidationResultHelper.createValidationResult(params, errors);
  }

  /**
   * Validate session context using standardized patterns
   * 
   * Validates CommonParameters context structure using CommonValidators
   * with appropriate options for the current mode.
   * 
   * @param params CommonParameters to validate
   * @param options Validation options (optional)
   * @returns Array of validation errors
   */
  protected validateSessionContext(
    params: CommonParameters,
    options?: {
      requireSessionId?: boolean;
      requireWorkspace?: boolean;
      minContextLength?: number;
    }
  ): ValidationError[] {
    return CommonValidators.validateSessionContext(params, this as any, options);
  }

  /**
   * Helper for quick validation with automatic error result creation
   * 
   * Combines validation and error result creation into a single method
   * for simpler error handling in mode implementations.
   * 
   * @param params Parameters to validate
   * @param validators Validation rule set
   * @returns Error result if validation fails, null if valid
   */
  protected quickValidate<TParams>(
    params: TParams,
    validators: ValidationRuleSet<TParams>
  ): R | null {
    const validation = this.validateCustom(params, validators);
    if (!validation.success) {
      return this.createErrorResult(validation.errors, params as any);
    }
    return null;
  }
}
```

## agents/commandManager/commandManager.ts

```typescript
import { App } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import { CommandManagerConfig } from '../../config/agents';
import {
  ListCommandsMode,
  ExecuteCommandMode
} from './modes';
import { MemoryService } from "../../agents/memoryManager/services/MemoryService";

/**
 * CommandManager Agent for command palette operations
 */
export class CommandManagerAgent extends BaseAgent {
  /**
   * Obsidian app instance
   */
  private app: App;
  
  /**
   * Memory service for activity recording
   */
  private memoryService: MemoryService | null = null;
  
  /**
   * Create a new CommandManagerAgent
   * @param app Obsidian app instance
   * @param memoryService Optional memory service for activity recording
   */
  constructor(app: App, memoryService?: MemoryService) {
    super(
      CommandManagerConfig.name,
      CommandManagerConfig.description,
      CommandManagerConfig.version
    );
    
    this.app = app;
    this.memoryService = memoryService || null;
    
    // Register modes
    this.registerMode(new ListCommandsMode(app));
    this.registerMode(new ExecuteCommandMode(app, this));
    
    // Try to get memory service from plugin if not provided in constructor
    if (!this.memoryService) {
      try {
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
        }
      } catch (error) {
        console.error('Error accessing memory service for command manager:', error);
      }
    }
  }
  
  /**
   * Get a list of available commands
   * @param filter Optional filter to apply to command list
   * @returns Promise that resolves with the command list
   */
  async listCommands(filter?: string): Promise<{
    commands: Array<{
      id: string;
      name: string;
      icon?: string;
      hotkeys?: string[];
    }>;
    total: number;
  }> {
    // Get all commands from the app
    const commands = this.app.commands.listCommands();
    
    // Filter commands if filter is provided
    const filteredCommands = filter
      ? commands.filter(cmd => 
          cmd.name.toLowerCase().includes(filter.toLowerCase()) ||
          cmd.id.toLowerCase().includes(filter.toLowerCase())
        )
      : commands;
    
    // Map to the desired format
    const mappedCommands = filteredCommands.map(cmd => ({
      id: cmd.id,
      name: cmd.name,
      icon: cmd.icon,
      hotkeys: this.getCommandHotkeys(cmd.id)
    }));
    
    return {
      commands: mappedCommands,
      total: mappedCommands.length
    };
  }
  
  /**
   * Execute a command by ID
   * @param commandId ID of the command to execute
   * @returns Promise that resolves when the command is executed
   */
  async executeCommand(commandId: string): Promise<boolean> {
    try {
      // Check if the command exists
      const commands = this.app.commands.listCommands();
      const command = commands.find(cmd => cmd.id === commandId);
      
      if (!command) {
        throw new Error(`Command with ID ${commandId} not found`);
      }
      
      // Execute the command
      await this.app.commands.executeCommandById(commandId);
      
      return true;
    } catch (error) {
      console.error(`Error executing command ${commandId}:`, error);
      throw error;
    }
  }
  
  /**
   * Record command execution activity in workspace memory
   * @param commandId ID of the executed command
   * @param commandName Name of the executed command
   * @param workspaceId ID of the workspace
   * @param workspacePath Path of the workspace
   */
  async recordCommandActivity(
    commandId: string,
    commandName: string,
    workspaceId: string,
    workspacePath?: string[]
  ): Promise<void> {
    // Skip if no memory service
    if (!this.memoryService) {
      return;
    }
    
    try {
      // Create a descriptive content about this command execution
      const content = `Executed command: ${commandName}\n` +
                      `Command ID: ${commandId}\n`;
      
      // Record the activity using memory service
      await this.memoryService.recordActivityTrace({
        workspaceId,
        type: 'command',
        content,
        timestamp: Date.now(),
        metadata: {
          tool: 'ExecuteCommandMode',
          params: { commandId },
          result: { success: true }
        }
      }
      );
    } catch (error) {
      // Log but don't fail the main operation
      console.error('Failed to record command activity:', error);
      
      // Try to get memory service from plugin if not available
      if (!this.memoryService) {
        try {
          const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
          if (plugin?.services?.memoryService) {
            this.memoryService = plugin.services.memoryService;
            // Try again with the newly found service
            await this.recordCommandActivity(commandId, commandName, workspaceId, workspacePath);
          }
        } catch (retryError) {
          console.error('Error accessing memory service for retry:', retryError);
        }
      }
    }
  }
  
  /**
   * Get hotkeys for a command
   * @param commandId ID of the command
   * @returns Array of hotkey strings or undefined if none
   */
  private getCommandHotkeys(commandId: string): string[] | undefined {
    try {
      // Access the Obsidian internal API to retrieve hotkeys
      const hotkeyManager = (this.app as any).hotkeyManager;
      if (!hotkeyManager) return undefined;
      
      // Get all hotkeys from the manager
      const hotkeys = hotkeyManager.getHotkeys(commandId) || [];
      
      // Format hotkey strings
      return hotkeys.map((hotkey: any) => {
        // Accessing internal Obsidian API properties
        const { modifiers, key } = hotkey;
        const modifierKeys = [];
        
        // Add modifiers in a standard order
        if (modifiers.contains('Mod')) modifierKeys.push('Ctrl/Cmd');
        if (modifiers.contains('Shift')) modifierKeys.push('Shift');
        if (modifiers.contains('Alt')) modifierKeys.push('Alt');
        if (modifiers.contains('Meta')) modifierKeys.push('Meta');
        
        // Join modifiers + key with + sign
        return [...modifierKeys, key].join('+');
      });
    } catch (error) {
      console.warn(`Error retrieving hotkeys for command ${commandId}:`, error);
      return undefined;
    }
  }
}
```

## agents/commandManager/modes/executeCommandMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { ExecuteCommandParams, ExecuteCommandResult } from '../types';
import { CommandManagerAgent } from '../commandManager';
import { parseWorkspaceContext } from '../../../utils/contextUtils';
import { addRecommendations, Recommendation } from '../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../utils/nudgeHelpers';

/**
 * Mode for executing a command
 */
export class ExecuteCommandMode extends BaseMode<ExecuteCommandParams, ExecuteCommandResult> {
  private app: App;
  private agent: CommandManagerAgent;
  
  /**
   * Create a new ExecuteCommandMode
   * @param app Obsidian app instance
   * @param agent CommandManager agent instance
   */
  constructor(app: App, agent: CommandManagerAgent) {
    super(
      'executeCommand',
      'Execute Command',
      'Run an Obsidian command',
      '1.0.0'
    );
    
    this.app = app;
    this.agent = agent;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves when the command is executed
   */
  async execute(params: ExecuteCommandParams): Promise<ExecuteCommandResult> {
    try {
      const { commandId, workspaceContext } = params;
      
      if (!commandId) {
        return this.prepareResult(false, undefined, 'Command ID is required');
      }
      
      // Check if the command exists
      const commands = this.app.commands.listCommands();
      const command = commands.find(cmd => cmd.id === commandId);
      
      if (!command) {
        return this.prepareResult(false, undefined, `Command with ID ${commandId} not found`);
      }
      
      // Execute the command
      await this.app.commands.executeCommandById(commandId);
      
      // Record activity if in a workspace context
      const parsedContext = parseWorkspaceContext(workspaceContext) || undefined;
      if (parsedContext) {
        await this.agent.recordCommandActivity(
          commandId,
          command.name,
          parsedContext.workspaceId,
          parsedContext.workspacePath
        );
      }
      
      // Prepare result with workspace context
      const response = this.prepareResult(
        true,
        {
          commandId
        },
        undefined,
        params.context,
        parseWorkspaceContext(workspaceContext) || undefined
      );
      
      // Generate nudges for command execution
      const nudges = this.generateCommandNudges();
      const responseWithNudges = addRecommendations(response, nudges);
      
      return responseWithNudges;
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.prepareResult(false, undefined, `Error executing command: ${errorMessage}`);
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    // Create the mode-specific schema
    const modeSchema = {
      type: 'object',
      properties: {
        commandId: {
          type: 'string',
          description: 'ID of the command to execute'
        }
      },
      required: ['commandId']
    };
    
    // Merge with common schema (workspace context)
    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    // Use the base result schema from BaseMode, which includes common result properties
    const baseSchema = super.getResultSchema();
    
    // Add mode-specific data properties
    baseSchema.properties.data = {
      type: 'object',
      properties: {
        commandId: {
          type: 'string',
          description: 'ID of the executed command'
        }
      },
      required: ['commandId']
    };
    
    return baseSchema;
  }

  /**
   * Generate nudges for command execution
   */
  private generateCommandNudges(): Recommendation[] {
    const nudges: Recommendation[] = [];

    // Always suggest impact awareness after command execution
    nudges.push(NudgeHelpers.suggestImpactAwareness());

    return nudges;
  }
}
```

## agents/commandManager/modes/index.ts

```typescript
export { ListCommandsMode } from './listCommandsMode';
export { ExecuteCommandMode } from './executeCommandMode';
```

## agents/commandManager/modes/listCommandsMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { ListCommandsParams, ListCommandsResult } from '../types';
import { parseWorkspaceContext } from '../../../utils/contextUtils';

/**
 * Mode for listing available commands
 */
export class ListCommandsMode extends BaseMode<ListCommandsParams, ListCommandsResult> {
  private app: App;
  
  /**
   * Create a new ListCommandsMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'listCommands',
      'List Commands',
      'List available Obsidian commands',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the list of commands
   */
  async execute(params: ListCommandsParams): Promise<ListCommandsResult> {
    try {
      const { filter, workspaceContext } = params;
      
      // Get all commands from the app
      const commands = this.app.commands.listCommands();
      
      // Filter commands if filter is provided
      const filteredCommands = filter
        ? commands.filter(cmd => 
            cmd.name.toLowerCase().includes(filter.toLowerCase()) ||
            cmd.id.toLowerCase().includes(filter.toLowerCase())
          )
        : commands;
      
      // Map to the desired format
      const mappedCommands = filteredCommands.map(cmd => ({
        id: cmd.id,
        name: cmd.name,
        icon: cmd.icon,
        hotkeys: this.getCommandHotkeys(cmd.id)
      }));
      
      // Prepare result with workspace context
      const response = this.prepareResult(true, {
          commands: mappedCommands,
          total: mappedCommands.length
        }, undefined, params.context, parseWorkspaceContext(workspaceContext) || undefined);
      
      return response;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.prepareResult(false, undefined, `Error listing commands: ${errorMessage}`);
    }
  }
  
  /**
   * Get hotkeys for a command
   * @param commandId ID of the command
   * @returns Array of hotkey strings or undefined if none
   */
  private getCommandHotkeys(_commandId: string): string[] | undefined {
    // This is a placeholder as Obsidian's public API doesn't expose hotkeys directly
    // In a real implementation, we'd need to access the internal hotkey registry
    return undefined;
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const customSchema = {
      type: 'object',
      properties: {
        filter: {
          type: 'string',
          description: 'Optional filter to apply to command list'
        }
      }
    };
    
    return this.getMergedSchema(customSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            commands: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                    description: 'Command ID'
                  },
                  name: {
                    type: 'string',
                    description: 'Display name of the command'
                  },
                  icon: {
                    type: 'string',
                    description: 'Optional icon name'
                  },
                  hotkeys: {
                    type: 'array',
                    items: {
                      type: 'string'
                    },
                    description: 'List of hotkeys associated with the command'
                  }
                },
                required: ['id', 'name']
              },
              description: 'List of available commands'
            },
            total: {
              type: 'number',
              description: 'Total number of commands'
            }
          },
          required: ['commands', 'total']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'ID of the workspace'
            },
            workspacePath: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Path of the workspace'
            },
            activeWorkspace: {
              type: 'boolean',
              description: 'Whether this is the active workspace'
            }
          }
        },
      },
      required: ['success']
    };
  }
}
```

## agents/commandManager/types.ts

```typescript
import { CommonParameters, CommonResult } from '../../types';

/**
 * Parameters for listing available commands
 */
export interface ListCommandsParams extends CommonParameters {
  /**
   * Optional filter to apply to command list
   */
  filter?: string;
}

/**
 * Command information
 */
export interface CommandInfo {
  /**
   * Command ID
   */
  id: string;
  
  /**
   * Display name of the command
   */
  name: string;
  
  /**
   * Optional icon name
   */
  icon?: string;
  
  /**
   * List of hotkeys associated with the command
   */
  hotkeys?: string[];
}

/**
 * Result of listing available commands
 */
export interface ListCommandsResult extends CommonResult {
  data?: {
    /**
     * List of available commands
     */
    commands: CommandInfo[];
    
    /**
     * Total number of commands
     */
    total: number;
  };
}

/**
 * Parameters for executing a command
 */
export interface ExecuteCommandParams extends CommonParameters {
  /**
   * ID of the command to execute
   */
  commandId: string;
}

/**
 * Result of executing a command
 */
export interface ExecuteCommandResult extends CommonResult {
  data?: {
    /**
     * ID of the executed command
     */
    commandId: string;
  };
}
```

## agents/contentManager/contentManager.ts

```typescript
import { App } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import { ContentManagerConfig } from '../../config/agents';
import {
  ReadContentMode,
  CreateContentMode,
  AppendContentMode,
  PrependContentMode,
  ReplaceContentMode,
  ReplaceByLineMode,
  DeleteContentMode,
  FindReplaceContentMode,
  BatchContentMode
} from './modes';
// import { AgentManager } from '../../services/AgentManager';
import ClaudesidianPlugin from '../../main';
import { WorkspaceService } from "../memoryManager/services/WorkspaceService";
import { MemoryService } from '../memoryManager/services/MemoryService';

/**
 * Agent for content operations in the vault
 * Consolidates functionality from noteEditor and noteReader
 */
export class ContentManagerAgent extends BaseAgent {
  protected app: App;
  protected plugin: ClaudesidianPlugin | null = null;
  
  private workspaceService: WorkspaceService | null = null;
  private memoryService: MemoryService | null = null;

  /**
   * Create a new ContentManagerAgent
   * @param app Obsidian app instance
   * @param plugin Claudesidian plugin instance
   */
  constructor(app: App, plugin?: ClaudesidianPlugin) {
    super(
      ContentManagerConfig.name,
      ContentManagerConfig.description,
      ContentManagerConfig.version
    );
    
    this.app = app;
    
    // Store plugin reference if provided
    if (plugin) {
      this.plugin = plugin;
      
      // Get memory services if available
      if (plugin.services) {
        
        if (plugin.services.workspaceService) {
          this.workspaceService = plugin.services.workspaceService;
        }
        
        if (plugin.services.memoryService) {
          this.memoryService = plugin.services.memoryService;
        }
      }
    }
    
    // Register modes with access to memory services
    this.registerMode(new ReadContentMode(app, this.memoryService));
    this.registerMode(new CreateContentMode(app));
    this.registerMode(new AppendContentMode(app));
    this.registerMode(new PrependContentMode(app));
    this.registerMode(new ReplaceContentMode(app));
    this.registerMode(new ReplaceByLineMode(app));
    this.registerMode(new DeleteContentMode(app));
    this.registerMode(new FindReplaceContentMode(app));
    this.registerMode(new BatchContentMode(app, this.memoryService));
  }
  
  
  /**
   * Gets the workspace service
   * @returns WorkspaceService instance or null
   */
  public getWorkspaceService(): WorkspaceService | null {
    return this.workspaceService;
  }
  
  /**
   * Gets the memory service
   * @returns MemoryService instance or null
   */
  public getMemoryService(): MemoryService | null {
    return this.memoryService;
  }
  
}
```

## agents/contentManager/modes/appendContentMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { AppendContentParams, AppendContentResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import { createErrorMessage, getErrorMessage } from '../../../utils/errorUtils';
import { parseWorkspaceContext } from '../../../utils/contextUtils';
import { MemoryService } from '../../memoryManager/services/MemoryService';

/**
 * Mode for appending content to a file
 */
export class AppendContentMode extends BaseMode<AppendContentParams, AppendContentResult> {
  private app: App;
  private memoryService: MemoryService | null = null;
  
  /**
   * Create a new AppendContentMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'appendContent',
      'Append Content',
      'Append content to a file in the vault',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the append result
   */
  async execute(params: AppendContentParams): Promise<AppendContentResult> {
    try {
      const { filePath, content, workspaceContext } = params;
      
      const result = await ContentOperations.appendContent(this.app, filePath, content);
      
      // File change detection are handled automatically by FileEventManager
      
      const resultData = {
        filePath,
        appendedLength: result.appendedLength,
        totalLength: result.totalLength
      };
      
      // Record session activity for memory tracking
      await this.recordActivity(params, resultData);
      
      const response = this.prepareResult(true, resultData, undefined, params.context, parseWorkspaceContext(workspaceContext) || undefined);
      
      return response;
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error appending content: ', error), params.context, parseWorkspaceContext(params.workspaceContext) || undefined);
    }
  }
  
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const customSchema = {
      type: 'object',
      properties: {
        filePath: {
          type: 'string',
          description: 'Path to the file to append to'
        },
        content: {
          type: 'string',
          description: 'Content to append to the file'
        }
      },
      required: ['filePath', 'content']
    };
    
    return this.getMergedSchema(customSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            filePath: {
              type: 'string',
              description: 'Path to the file'
            },
            appendedLength: {
              type: 'number',
              description: 'Length of the content appended'
            },
            totalLength: {
              type: 'number',
              description: 'Total length of the file after appending'
            }
          },
          required: ['filePath', 'appendedLength', 'totalLength']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'ID of the workspace'
            },
            workspacePath: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Path of the workspace'
            },
            activeWorkspace: {
              type: 'boolean',
              description: 'Whether this is the active workspace'
            }
          }
        },
      },
      required: ['success']
    };
  }
  
  /**
   * Record content appending activity in workspace memory
   * @param params Parameters used for appending content
   * @param resultData Result data containing append information
   */
  private async recordActivity(
    params: AppendContentParams,
    resultData: {
      filePath: string;
      appendedLength: number;
      totalLength: number;
    }
  ): Promise<void> {
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(params.workspaceContext) || undefined;
    
    // Skip if no workspace context
    if (!parsedContext?.workspaceId) {
      return;
    }
    
    // Skip if no memory service
    if (!this.memoryService) {
      try {
        // Try to get the memory service from the plugin
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
        } else {
          // No memory service available, skip activity recording
          return;
        }
      } catch (error) {
        console.error('Failed to get memory service from plugin:', getErrorMessage(error));
        return;
      }
    }
    
    // Create a descriptive content about this operation
    let contentSnippet = params.content.substring(0, 100);
    if (params.content.length > 100) {
      contentSnippet += '...';
    }
    
    const content = `Appended to file ${params.filePath} (${resultData.appendedLength} chars added, ${resultData.totalLength} total)\nContent: ${contentSnippet}`;
    
    try {
      await this.memoryService!.recordActivityTrace({
        workspaceId: parsedContext.workspaceId,
        type: 'content',
        content: content,
        timestamp: Date.now(),
        metadata: {
          tool: 'contentManager.appendContent',
          params: { filePath: params.filePath },
          result: resultData,
          relatedFiles: [params.filePath]
        },
        sessionId: params.context.sessionId
      });
    } catch (error) {
      console.error('Failed to record append content activity:', getErrorMessage(error));
    }
  }
}
```

## agents/contentManager/modes/batch/BatchContentMode.ts

```typescript
/**
 * BatchContentMode - Refactored following SOLID principles
 * Main orchestrator for batch content operations
 */

import { App } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { BatchContentParams, BatchContentResult } from '../../types';
import { MemoryService } from '../../../memoryManager/services/MemoryService';
import { parseWorkspaceContext, extractContextFromParams } from '../../../../utils/contextUtils';

// Import specialized services
import { OperationValidator } from './validation/OperationValidator';
import { BatchExecutor } from './execution/BatchExecutor';
import { ResultCollector } from './results/ResultCollector';
import { ActivityRecorder } from './activity/ActivityRecorder';
import { SchemaBuilder } from './schemas/SchemaBuilder';
import { addRecommendations, Recommendation } from '../../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../../utils/nudgeHelpers';

/**
 * Refactored BatchContentMode following SOLID principles
 * Orchestrates specialized services for batch content operations
 */
export class BatchContentMode extends BaseMode<BatchContentParams, BatchContentResult> {
  private app: App;
  private memoryService: MemoryService | null = null;
  
  // Composed services following Dependency Injection principle
  private operationValidator: OperationValidator;
  private batchExecutor: BatchExecutor;
  private resultCollector: ResultCollector;
  private activityRecorder: ActivityRecorder;
  private schemaBuilder: SchemaBuilder;

  constructor(app: App, memoryService?: MemoryService | null | undefined) {
    super(
      'batchContent',
      'Batch Content Operations',
      'Execute multiple content operations in a batch',
      '1.0.0'
    );
    
    this.app = app;
    this.memoryService = memoryService || null;
    
    // Initialize specialized services
    this.operationValidator = new OperationValidator();
    this.batchExecutor = new BatchExecutor(app);
    this.resultCollector = new ResultCollector();
    this.activityRecorder = new ActivityRecorder(memoryService || null);
    this.schemaBuilder = new SchemaBuilder();
  }

  /**
   * Execute batch content operations
   */
  async execute(params: BatchContentParams): Promise<BatchContentResult> {
    try {
      const { operations, workspaceContext } = params;
      
      // 1. Validate operations
      const validationResult = this.operationValidator.validateOperations(operations);
      if (!validationResult.success) {
        throw new Error(validationResult.error);
      }

      // 2. Execute operations
      const executionResults = await this.batchExecutor.executeOperations(operations);

      // 3. Process results
      const processedResults = this.resultCollector.collectResults(executionResults);

      // 4. Record activity
      await this.activityRecorder.recordBatchActivity(params, processedResults);

      // 5. Prepare response
      const response = this.prepareResult(
        true, 
        { results: processedResults }, 
        undefined, 
        extractContextFromParams(params), 
        parseWorkspaceContext(workspaceContext) || undefined
      );

      // 6. Generate nudges based on batch operations
      const nudges = this.generateBatchContentNudges(operations, processedResults);
      const responseWithNudges = addRecommendations(response, nudges);

      return responseWithNudges;
    } catch (error: unknown) {
      return this.prepareResult(
        false, 
        undefined, 
        error instanceof Error ? error.message : String(error), 
        extractContextFromParams(params), 
        parseWorkspaceContext(params.workspaceContext) || undefined
      );
    }
  }

  /**
   * Get parameter schema
   */
  getParameterSchema(): any {
    return this.schemaBuilder.getParameterSchema();
  }

  /**
   * Get result schema
   */
  getResultSchema(): any {
    return this.schemaBuilder.getResultSchema();
  }

  /**
   * Generate nudges based on batch operations
   */
  private generateBatchContentNudges(operations: any[], results: any[]): Recommendation[] {
    const nudges: Recommendation[] = [];

    // Count operations by type
    const operationCounts = NudgeHelpers.countOperationsByType(operations);

    // Check for multiple read operations (>3 files read)
    const batchReadNudge = NudgeHelpers.checkBatchReadOperations(operationCounts.read);
    if (batchReadNudge) {
      nudges.push(batchReadNudge);
    }

    // Check for multiple create operations (>2 files created)
    const batchCreateNudge = NudgeHelpers.checkBatchCreateOperations(operationCounts.create);
    if (batchCreateNudge) {
      nudges.push(batchCreateNudge);
    }

    return nudges;
  }
}
```

## agents/contentManager/modes/batch/activity/ActivityRecorder.ts

```typescript
/**
 * ActivityRecorder - Handles activity recording for batch operations
 * Follows Single Responsibility Principle by focusing only on activity recording
 */

import { MemoryService } from '../../../../memoryManager/services/MemoryService';
import { BatchContentParams } from '../../../types';
import { ProcessedResult } from '../results/ResultCollector';
import { parseWorkspaceContext } from '../../../../../utils/contextUtils';

/**
 * Service responsible for recording batch operation activities
 * Follows SRP by focusing only on activity recording operations
 */
export class ActivityRecorder {
  constructor(private memoryService: MemoryService | null) {}

  /**
   * Record batch operation activity in workspace memory
   */
  async recordBatchActivity(params: BatchContentParams, results: ProcessedResult[]): Promise<void> {
    try {
      // Skip if no memory service is available
      if (!this.memoryService) {
        return;
      }

      // Parse workspace context
      const parsedContext = parseWorkspaceContext(params.workspaceContext);
      
      // Skip if no workspace context is available
      if (!parsedContext?.workspaceId) {
        return;
      }

      // Get successful operations and their file paths
      const successfulOps = results.filter(result => result.success);
      const relatedFiles = successfulOps.map(result => result.filePath);

      // Create activity content
      const activityContent = this.createActivityContent(successfulOps, relatedFiles);

      // Record activity using MemoryService
      await this.memoryService.storeMemoryTrace({
        workspaceId: parsedContext.workspaceId,
        type: 'batch_operation',
        content: activityContent,
        timestamp: Date.now(),
        metadata: this.createActivityMetadata(successfulOps, relatedFiles),
        sessionId: params.context.sessionId || ''
      });
    } catch (error) {
      console.error('Error recording batch activity with ChromaDB:', error);
      // Don't throw - activity recording is a secondary operation
    }
  }

  /**
   * Create activity content description
   */
  private createActivityContent(successfulOps: ProcessedResult[], relatedFiles: string[]): string {
    const opTypes = successfulOps.map(result => result.type);
    const uniqueOpTypes = [...new Set(opTypes)];

    return `Performed batch operation with ${successfulOps.length} operations ` +
      `(${uniqueOpTypes.join(', ')}) on ${relatedFiles.length} files.`;
  }

  /**
   * Create activity metadata
   */
  private createActivityMetadata(successfulOps: ProcessedResult[], relatedFiles: string[]): any {
    const opTypes = successfulOps.map(result => result.type);
    
    return {
      tool: 'BatchContentMode',
      params: {
        operations: opTypes
      },
      result: {
        files: relatedFiles,
        count: successfulOps.length
      },
      relatedFiles: relatedFiles
    };
  }

  /**
   * Create detailed activity summary
   */
  createActivitySummary(results: ProcessedResult[]): {
    operationCount: number;
    operationTypes: string[];
    fileCount: number;
    successRate: number;
    summary: string;
  } {
    const successfulOps = results.filter(result => result.success);
    const opTypes = successfulOps.map(result => result.type);
    const uniqueOpTypes = [...new Set(opTypes)];
    const relatedFiles = successfulOps.map(result => result.filePath);
    const uniqueFiles = [...new Set(relatedFiles)];

    const successRate = results.length > 0 ? successfulOps.length / results.length : 0;

    return {
      operationCount: successfulOps.length,
      operationTypes: uniqueOpTypes,
      fileCount: uniqueFiles.length,
      successRate,
      summary: `Executed ${successfulOps.length} operations (${uniqueOpTypes.join(', ')}) ` +
        `on ${uniqueFiles.length} files with ${Math.round(successRate * 100)}% success rate.`
    };
  }

  /**
   * Check if activity recording is available
   */
  isActivityRecordingAvailable(): boolean {
    return !!this.memoryService;
  }

  /**
   * Get activity recording statistics
   */
  getRecordingStats(): {
    memoryServiceAvailable: boolean;
    canRecordActivity: boolean;
  } {
    return {
      memoryServiceAvailable: !!this.memoryService,
      canRecordActivity: this.isActivityRecordingAvailable()
    };
  }
}
```

## agents/contentManager/modes/batch/execution/BatchExecutor.ts

```typescript
/**
 * BatchExecutor - Handles batch execution of content operations
 * Follows Single Responsibility Principle by focusing only on execution
 */

import { App } from 'obsidian';
import { ContentOperation } from '../../../types';
import { ContentOperations } from '../../../utils/ContentOperations';

export interface ExecutionResult {
  success: boolean;
  error?: string;
  data?: any;
  type: string;
  filePath: string;
}

/**
 * Service responsible for executing batch content operations
 * Follows SRP by focusing only on execution operations
 */
export class BatchExecutor {
  constructor(private app: App) {}

  /**
   * Execute an array of operations sequentially
   */
  async executeOperations(operations: ContentOperation[]): Promise<ExecutionResult[]> {
    const results: ExecutionResult[] = [];

    // Execute operations sequentially to avoid conflicts
    for (const operation of operations) {
      const result = await this.executeOperation(operation);
      results.push(result);
    }

    return results;
  }

  /**
   * Execute a single operation
   */
  private async executeOperation(operation: ContentOperation): Promise<ExecutionResult> {
    try {
      let result: any;

      switch (operation.type) {
        case 'read':
          result = await this.executeReadOperation(operation);
          break;
        case 'create':
          result = await this.executeCreateOperation(operation);
          break;
        case 'append':
          result = await this.executeAppendOperation(operation);
          break;
        case 'prepend':
          result = await this.executePrependOperation(operation);
          break;
        case 'replace':
          result = await this.executeReplaceOperation(operation);
          break;
        case 'replaceByLine':
          result = await this.executeReplaceByLineOperation(operation);
          break;
        case 'delete':
          result = await this.executeDeleteOperation(operation);
          break;
        case 'findReplace':
          result = await this.executeFindReplaceOperation(operation);
          break;
        default:
          throw new Error(`Unknown operation type: ${(operation as any).type}`);
      }

      return {
        success: true,
        data: result,
        type: operation.type,
        filePath: operation.params.filePath
      };
    } catch (error: unknown) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        type: operation.type,
        filePath: operation.params.filePath || 'unknown'
      };
    }
  }

  /**
   * Execute read operation
   */
  private async executeReadOperation(operation: Extract<ContentOperation, { type: 'read' }>): Promise<any> {
    const { filePath, limit, offset, includeLineNumbers } = operation.params;
    
    if (typeof limit === 'number' && typeof offset === 'number') {
      const lines = await ContentOperations.readLines(
        this.app,
        filePath,
        offset,
        offset + limit - 1,
        includeLineNumbers
      );
      
      return {
        content: lines.join('\n'),
        filePath,
        lineNumbersIncluded: includeLineNumbers,
        startLine: offset,
        endLine: offset + limit - 1
      };
    } else if (includeLineNumbers) {
      const content = await ContentOperations.readContentWithLineNumbers(this.app, filePath);
      
      return {
        content,
        filePath,
        lineNumbersIncluded: true
      };
    } else {
      const content = await ContentOperations.readContent(this.app, filePath);
      
      return {
        content,
        filePath,
        lineNumbersIncluded: false
      };
    }
  }

  /**
   * Execute create operation
   */
  private async executeCreateOperation(operation: Extract<ContentOperation, { type: 'create' }>): Promise<any> {
    const { filePath, content } = operation.params;
    
    const file = await ContentOperations.createContent(this.app, filePath, content);
    
    return {
      filePath,
      created: file.stat.ctime
    };
  }

  /**
   * Execute append operation
   */
  private async executeAppendOperation(operation: Extract<ContentOperation, { type: 'append' }>): Promise<any> {
    const { filePath, content } = operation.params;
    
    return await ContentOperations.appendContent(this.app, filePath, content);
  }

  /**
   * Execute prepend operation
   */
  private async executePrependOperation(operation: Extract<ContentOperation, { type: 'prepend' }>): Promise<any> {
    const { filePath, content } = operation.params;
    
    return await ContentOperations.prependContent(this.app, filePath, content);
  }

  /**
   * Execute replace operation
   */
  private async executeReplaceOperation(operation: Extract<ContentOperation, { type: 'replace' }>): Promise<any> {
    const { filePath, oldContent, newContent, similarityThreshold = 0.95 } = operation.params;
    
    const replacements = await ContentOperations.replaceContent(
      this.app,
      filePath,
      oldContent,
      newContent,
      similarityThreshold
    );
    
    return {
      filePath,
      replacements
    };
  }

  /**
   * Execute replace by line operation
   */
  private async executeReplaceByLineOperation(operation: Extract<ContentOperation, { type: 'replaceByLine' }>): Promise<any> {
    const { filePath, startLine, endLine, newContent } = operation.params;
    
    const linesReplaced = await ContentOperations.replaceByLine(
      this.app,
      filePath,
      startLine,
      endLine,
      newContent
    );
    
    return {
      filePath,
      linesReplaced
    };
  }

  /**
   * Execute delete operation
   */
  private async executeDeleteOperation(operation: Extract<ContentOperation, { type: 'delete' }>): Promise<any> {
    const { filePath, content, similarityThreshold = 0.95 } = operation.params;
    
    const deletions = await ContentOperations.deleteContent(
      this.app,
      filePath,
      content,
      similarityThreshold
    );
    
    return {
      filePath,
      deletions
    };
  }

  /**
   * Execute find and replace operation
   */
  private async executeFindReplaceOperation(operation: Extract<ContentOperation, { type: 'findReplace' }>): Promise<any> {
    const { 
      filePath, 
      findText, 
      replaceText, 
      replaceAll = false, 
      caseSensitive = true, 
      wholeWord = false 
    } = operation.params;
    
    const replacements = await ContentOperations.findReplaceContent(
      this.app,
      filePath,
      findText,
      replaceText,
      replaceAll,
      caseSensitive,
      wholeWord
    );
    
    return {
      filePath,
      replacements,
      findText,
      replaceText
    };
  }

  /**
   * Get execution statistics
   */
  getExecutionStats(results: ExecutionResult[]): {
    totalOperations: number;
    successfulOperations: number;
    failedOperations: number;
    operationTypes: Record<string, number>;
    successRate: number;
  } {
    const stats = {
      totalOperations: results.length,
      successfulOperations: results.filter(r => r.success).length,
      failedOperations: results.filter(r => !r.success).length,
      operationTypes: {} as Record<string, number>,
      successRate: 0
    };

    for (const result of results) {
      stats.operationTypes[result.type] = (stats.operationTypes[result.type] || 0) + 1;
    }

    stats.successRate = stats.totalOperations > 0 ? stats.successfulOperations / stats.totalOperations : 0;

    return stats;
  }
}
```

## agents/contentManager/modes/batch/results/ResultCollector.ts

```typescript
/**
 * ResultCollector - Handles result collection and processing
 * Follows Single Responsibility Principle by focusing only on result processing
 */

import { ExecutionResult } from '../execution/BatchExecutor';

export interface ProcessedResult {
  success: boolean;
  error?: string;
  data?: any;
  type: "read" | "create" | "append" | "prepend" | "replace" | "replaceByLine" | "delete" | "findReplace";
  filePath: string;
}

/**
 * Service responsible for collecting and processing batch operation results
 * Follows SRP by focusing only on result processing operations
 */
export class ResultCollector {
  /**
   * Collect and process execution results
   */
  collectResults(executionResults: ExecutionResult[]): ProcessedResult[] {
    return executionResults.map(result => this.processResult(result));
  }

  /**
   * Process a single execution result
   */
  private processResult(result: ExecutionResult): ProcessedResult {
    return {
      success: result.success,
      error: result.error,
      data: result.data,
      type: result.type as ProcessedResult['type'],
      filePath: result.filePath
    };
  }

  /**
   * Filter successful results
   */
  getSuccessfulResults(results: ProcessedResult[]): ProcessedResult[] {
    return results.filter(result => result.success);
  }

  /**
   * Filter failed results
   */
  getFailedResults(results: ProcessedResult[]): ProcessedResult[] {
    return results.filter(result => !result.success);
  }

  /**
   * Get results by operation type
   */
  getResultsByType(results: ProcessedResult[], type: ProcessedResult['type']): ProcessedResult[] {
    return results.filter(result => result.type === type);
  }

  /**
   * Get results by file path
   */
  getResultsByFilePath(results: ProcessedResult[], filePath: string): ProcessedResult[] {
    return results.filter(result => result.filePath === filePath);
  }

  /**
   * Get unique file paths from results
   */
  getUniqueFilePaths(results: ProcessedResult[]): string[] {
    const filePaths = results.map(result => result.filePath);
    return [...new Set(filePaths)];
  }

  /**
   * Get operation type counts
   */
  getOperationTypeCounts(results: ProcessedResult[]): Record<string, number> {
    const counts: Record<string, number> = {};
    
    for (const result of results) {
      counts[result.type] = (counts[result.type] || 0) + 1;
    }
    
    return counts;
  }

  /**
   * Get success/failure statistics
   */
  getResultStatistics(results: ProcessedResult[]): {
    total: number;
    successful: number;
    failed: number;
    successRate: number;
    operationTypes: Record<string, number>;
    uniqueFiles: number;
  } {
    const successful = this.getSuccessfulResults(results);
    const failed = this.getFailedResults(results);
    
    const self = this;
    return {
      total: results.length,
      successful: successful.length,
      failed: failed.length,
      successRate: results.length > 0 ? successful.length / results.length : 0,
      operationTypes: self.getOperationTypeCounts(results),
      uniqueFiles: self.getUniqueFilePaths(results).length
    };
  }

  /**
   * Format results for display
   */
  formatResults(results: ProcessedResult[]): {
    summary: string;
    details: ProcessedResult[];
    statistics: any;
  } {
    const stats = this.getResultStatistics(results);
    const operationTypes = Object.keys(stats.operationTypes).join(', ');
    
    const summary = `Executed ${stats.total} operations (${operationTypes}) ` +
      `on ${stats.uniqueFiles} files. Success rate: ${Math.round(stats.successRate * 100)}%`;

    return {
      summary,
      details: results,
      statistics: stats
    };
  }

  /**
   * Create error summary for failed operations
   */
  createErrorSummary(results: ProcessedResult[]): {
    hasErrors: boolean;
    errorCount: number;
    errors: Array<{
      type: string;
      filePath: string;
      error: string;
    }>;
  } {
    const failedResults = this.getFailedResults(results);
    
    return {
      hasErrors: failedResults.length > 0,
      errorCount: failedResults.length,
      errors: failedResults.map(result => ({
        type: result.type,
        filePath: result.filePath,
        error: result.error || 'Unknown error'
      }))
    };
  }
}
```

## agents/contentManager/modes/batch/schemas/SchemaBuilder.ts

```typescript
/**
 * SchemaBuilder - Handles JSON schema generation for batch operations
 * Follows Single Responsibility Principle by focusing only on schema building
 */

/**
 * Service responsible for building JSON schemas for batch content operations
 * Follows SRP by focusing only on schema generation operations
 */
export class SchemaBuilder {
  /**
   * Get parameter schema for batch content mode
   */
  getParameterSchema(): any {
    return {
      type: 'object',
      properties: {
        operations: {
          type: 'array',
          description: 'Array of operations to perform',
          items: {
            type: 'object',
            properties: {
              type: {
                type: 'string',
                enum: ['read', 'create', 'append', 'prepend', 'replace', 'replaceByLine', 'delete', 'findReplace'],
                description: 'Type of operation'
              },
              params: {
                type: 'object',
                description: 'Operation-specific parameters. IMPORTANT: All operations require a "filePath" parameter.',
                allOf: [
                  this.getReadOperationSchema(),
                  this.getCreateOperationSchema(),
                  this.getAppendPrependOperationSchema(),
                  this.getReplaceOperationSchema(),
                  this.getReplaceByLineOperationSchema(),
                  this.getDeleteOperationSchema(),
                  this.getFindReplaceOperationSchema()
                ]
              }
            },
            required: ['type', 'params']
          }
        },
        workspaceContext: {
          type: 'object',
          description: 'Workspace context for the operation'
        },
        sessionId: {
          type: 'string',
          description: 'Session identifier for tracking'
        },
      },
      required: ['operations']
    };
  }

  /**
   * Get result schema for batch content mode
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            results: {
              type: 'array',
              description: 'Array of operation results',
              items: this.getResultItemSchema()
            }
          },
          required: ['results']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'ID of the workspace'
            },
            workspacePath: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Path of the workspace'
            },
            activeWorkspace: {
              type: 'boolean',
              description: 'Whether this is the active workspace'
            }
          }
        },
      },
      required: ['success']
    };
  }

  /**
   * Get schema for read operations
   */
  private getReadOperationSchema(): any {
    return {
      if: {
        properties: { 
          "type": { "enum": ["read"] } 
        }
      },
      then: {
        properties: {
          filePath: { type: 'string', description: 'Path to the file to read' },
          limit: { type: 'number', description: 'Optional number of lines to read' },
          offset: { type: 'number', description: 'Optional line number to start reading from (1-based)' },
          includeLineNumbers: { type: 'boolean', description: 'Whether to include line numbers in the output' }
        },
        required: ['filePath']
      }
    };
  }

  /**
   * Get schema for create operations
   */
  private getCreateOperationSchema(): any {
    return {
      if: {
        properties: { 
          "type": { "enum": ["create"] }
        }
      },
      then: {
        properties: {
          filePath: { type: 'string', description: 'Path to the file to create' },
          content: { type: 'string', description: 'Content to write to the file' }
        },
        required: ['filePath', 'content']
      }
    };
  }

  /**
   * Get schema for append/prepend operations
   */
  private getAppendPrependOperationSchema(): any {
    return {
      if: {
        properties: { 
          "type": { "enum": ["append", "prepend"] }
        }
      },
      then: {
        properties: {
          filePath: { type: 'string', description: 'Path to the file to modify' },
          content: { type: 'string', description: 'Content to append/prepend to the file' }
        },
        required: ['filePath', 'content']
      }
    };
  }

  /**
   * Get schema for replace operations
   */
  private getReplaceOperationSchema(): any {
    return {
      if: {
        properties: { 
          "type": { "enum": ["replace"] }
        }
      },
      then: {
        properties: {
          filePath: { type: 'string', description: 'Path to the file to modify' },
          oldContent: { type: 'string', description: 'Content to replace' },
          newContent: { type: 'string', description: 'Content to replace with' },
          similarityThreshold: { 
            type: 'number', 
            description: 'Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)',
            default: 0.95,
            minimum: 0.0,
            maximum: 1.0
          }
        },
        required: ['filePath', 'oldContent', 'newContent']
      }
    };
  }

  /**
   * Get schema for replace by line operations
   */
  private getReplaceByLineOperationSchema(): any {
    return {
      if: {
        properties: { 
          "type": { "enum": ["replaceByLine"] }
        }
      },
      then: {
        properties: {
          filePath: { type: 'string', description: 'Path to the file to modify' },
          startLine: { type: 'number', description: 'Start line number (1-based)' },
          endLine: { type: 'number', description: 'End line number (1-based, inclusive)' },
          newContent: { type: 'string', description: 'Content to replace with' }
        },
        required: ['filePath', 'startLine', 'endLine', 'newContent']
      }
    };
  }

  /**
   * Get schema for delete operations
   */
  private getDeleteOperationSchema(): any {
    return {
      if: {
        properties: { 
          "type": { "enum": ["delete"] }
        }
      },
      then: {
        properties: {
          filePath: { type: 'string', description: 'Path to the file to modify' },
          content: { type: 'string', description: 'Content to delete' },
          similarityThreshold: { 
            type: 'number', 
            description: 'Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)',
            default: 0.95,
            minimum: 0.0,
            maximum: 1.0
          }
        },
        required: ['filePath', 'content']
      }
    };
  }

  /**
   * Get schema for find/replace operations
   */
  private getFindReplaceOperationSchema(): any {
    return {
      if: {
        properties: { 
          "type": { "enum": ["findReplace"] }
        }
      },
      then: {
        properties: {
          filePath: { type: 'string', description: 'Path to the file to modify' },
          findText: { type: 'string', description: 'Text to find' },
          replaceText: { type: 'string', description: 'Text to replace with' },
          replaceAll: { 
            type: 'boolean', 
            description: 'Whether to replace all occurrences or just the first one',
            default: false
          },
          caseSensitive: { 
            type: 'boolean', 
            description: 'Whether the search should be case sensitive',
            default: true
          },
          wholeWord: { 
            type: 'boolean', 
            description: 'Whether to use whole word matching',
            default: false
          }
        },
        required: ['filePath', 'findText', 'replaceText']
      }
    };
  }

  /**
   * Get schema for result items
   */
  private getResultItemSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          description: 'Operation-specific result data'
        },
        type: {
          type: 'string',
          description: 'Type of operation'
        },
        filePath: {
          type: 'string',
          description: 'File path for the operation'
        }
      },
      required: ['success', 'type', 'filePath']
    };
  }

  /**
   * Get schema validation statistics
   */
  getSchemaStats(): {
    parameterSchemaProperties: number;
    resultSchemaProperties: number;
    supportedOperations: string[];
  } {
    return {
      parameterSchemaProperties: Object.keys(this.getParameterSchema().properties).length,
      resultSchemaProperties: Object.keys(this.getResultSchema().properties).length,
      supportedOperations: ['read', 'create', 'append', 'prepend', 'replace', 'replaceByLine', 'delete', 'findReplace']
    };
  }
}
```

## agents/contentManager/modes/batch/validation/OperationValidator.ts

```typescript
/**
 * OperationValidator - Handles validation of batch content operations
 * Follows Single Responsibility Principle by focusing only on validation
 */

import { ContentOperation } from '../../../types';

export interface ValidationResult {
  success: boolean;
  error?: string;
}

/**
 * Service responsible for validating batch content operations
 * Follows SRP by focusing only on validation operations
 */
export class OperationValidator {
  /**
   * Validate an array of operations
   */
  validateOperations(operations: ContentOperation[]): ValidationResult {
    try {
      // Validate operations array
      if (!operations || !Array.isArray(operations) || operations.length === 0) {
        return {
          success: false,
          error: 'Operations array is empty or not provided'
        };
      }

      // Validate each operation
      for (let index = 0; index < operations.length; index++) {
        const operation = operations[index];
        const operationResult = this.validateSingleOperation(operation, index);
        
        if (!operationResult.success) {
          return operationResult;
        }
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: `Validation failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Validate a single operation
   */
  private validateSingleOperation(operation: ContentOperation, index: number): ValidationResult {
    // Validate basic structure
    if (!operation.type) {
      return {
        success: false,
        error: `Missing 'type' property in operation at index ${index}`
      };
    }

    if (!operation.params) {
      return {
        success: false,
        error: `Missing 'params' property in operation at index ${index}`
      };
    }

    if (!operation.params.filePath) {
      return {
        success: false,
        error: `Missing 'filePath' property in operation at index ${index}. Each operation must include a 'filePath' parameter.`
      };
    }

    // Validate operation-specific parameters
    return this.validateOperationParams(operation, index);
  }

  /**
   * Validate operation-specific parameters
   */
  private validateOperationParams(operation: ContentOperation, index: number): ValidationResult {
    switch (operation.type) {
      case 'create':
      case 'append':
      case 'prepend':
        return this.validateContentOperation(operation, index);
      
      case 'replace':
        return this.validateReplaceOperation(operation, index);
      
      case 'replaceByLine':
        return this.validateReplaceByLineOperation(operation, index);
      
      case 'delete':
        return this.validateDeleteOperation(operation, index);
      
      case 'findReplace':
        return this.validateFindReplaceOperation(operation, index);
      
      case 'read':
        return this.validateReadOperation(operation, index);
      
      default:
        return {
          success: false,
          error: `Unknown operation type: ${(operation as any).type} at index ${index}`
        };
    }
  }

  /**
   * Validate content operations (create, append, prepend)
   */
  private validateContentOperation(operation: ContentOperation, index: number): ValidationResult {
    const params = operation.params as any;
    if (!params.content) {
      return {
        success: false,
        error: `Missing 'content' property in ${operation.type} operation at index ${index}`
      };
    }
    return { success: true };
  }

  /**
   * Validate replace operation
   */
  private validateReplaceOperation(operation: ContentOperation, index: number): ValidationResult {
    const params = operation.params as any;
    if (!params.oldContent) {
      return {
        success: false,
        error: `Missing 'oldContent' property in replace operation at index ${index}`
      };
    }

    if (!params.newContent) {
      return {
        success: false,
        error: `Missing 'newContent' property in replace operation at index ${index}`
      };
    }

    return { success: true };
  }

  /**
   * Validate replace by line operation
   */
  private validateReplaceByLineOperation(operation: ContentOperation, index: number): ValidationResult {
    const params = operation.params as any;
    if (typeof params.startLine !== 'number') {
      return {
        success: false,
        error: `Missing or invalid 'startLine' property in replaceByLine operation at index ${index}`
      };
    }

    if (typeof params.endLine !== 'number') {
      return {
        success: false,
        error: `Missing or invalid 'endLine' property in replaceByLine operation at index ${index}`
      };
    }

    if (!params.newContent) {
      return {
        success: false,
        error: `Missing 'newContent' property in replaceByLine operation at index ${index}`
      };
    }

    return { success: true };
  }

  /**
   * Validate delete operation
   */
  private validateDeleteOperation(operation: ContentOperation, index: number): ValidationResult {
    const params = operation.params as any;
    if (!params.content) {
      return {
        success: false,
        error: `Missing 'content' property in delete operation at index ${index}`
      };
    }
    return { success: true };
  }

  /**
   * Validate find and replace operation
   */
  private validateFindReplaceOperation(operation: ContentOperation, index: number): ValidationResult {
    const params = operation.params as any;
    if (!params.findText) {
      return {
        success: false,
        error: `Missing 'findText' property in findReplace operation at index ${index}`
      };
    }

    if (!params.replaceText) {
      return {
        success: false,
        error: `Missing 'replaceText' property in findReplace operation at index ${index}`
      };
    }

    return { success: true };
  }

  /**
   * Validate read operation
   */
  private validateReadOperation(operation: ContentOperation, index: number): ValidationResult {
    // Read operation only requires filePath, which is already validated
    return { success: true };
  }

  /**
   * Get validation statistics
   */
  getValidationStats(operations: ContentOperation[]): {
    totalOperations: number;
    operationTypes: Record<string, number>;
    hasValidationErrors: boolean;
  } {
    const stats = {
      totalOperations: operations.length,
      operationTypes: {} as Record<string, number>,
      hasValidationErrors: false
    };

    for (const operation of operations) {
      const type = operation.type || 'unknown';
      stats.operationTypes[type] = (stats.operationTypes[type] || 0) + 1;
    }

    const validationResult = this.validateOperations(operations);
    stats.hasValidationErrors = !validationResult.success;

    return stats;
  }
}
```

## agents/contentManager/modes/batchContentMode.ts

```typescript
/**
 * BatchContentMode - Refactored for backward compatibility
 * Re-exports the refactored BatchContentMode to maintain API compatibility
 */

import { App } from 'obsidian';
import { MemoryService } from '../../memoryManager/services/MemoryService';

// Export the refactored BatchContentMode as the main BatchContentMode
export { BatchContentMode } from './batch/BatchContentMode';

// Keep original file as reference
// Original implementation moved to ./batch/ directory following SOLID principles
// The refactored version maintains full backward compatibility
// Original implementation moved to ./batch/ directory
// The refactored version provides the same functionality with better architecture
// All implementation moved to specialized services in ./batch/ directory
// This maintains backward compatibility while providing better architecture
```

## agents/contentManager/modes/createContentMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { CreateContentParams, CreateContentResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import { createErrorMessage, getErrorMessage } from '../../../utils/errorUtils';
import { parseWorkspaceContext } from '../../../utils/contextUtils';
import { MemoryService } from '../../memoryManager/services/MemoryService';
import { addRecommendations, Recommendation } from '../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../utils/nudgeHelpers';

/**
 * Mode for creating a new file with content
 * Follows Single Responsibility Principle - only handles content creation
 * File change detection is handled automatically by FileEventManager
 */
export class CreateContentMode extends BaseMode<CreateContentParams, CreateContentResult> {
  private app: App;
  private memoryService?: MemoryService | null;
  
  /**
   * Create a new CreateContentMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'createContent',
      'Create Content',
      'Create a new file with content in the vault',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the creation result
   */
  async execute(params: CreateContentParams): Promise<CreateContentResult> {
    try {
      const { filePath, content, workspaceContext } = params;
      
      // Validate parameters
      if (!filePath) {
        return this.prepareResult(false, undefined, 'File path is required', params.context, parseWorkspaceContext(workspaceContext) || undefined);
      }
      
      if (content === undefined || content === null) {
        return this.prepareResult(false, undefined, 'Content is required', params.context, parseWorkspaceContext(workspaceContext) || undefined);
      }
      
      // Create file
      const file = await ContentOperations.createContent(this.app, filePath, content);
      
      
      const resultData = {
        filePath,
        created: file.stat.ctime
      };
      
      // Record session activity for memory tracking
      await this.recordActivity(params, resultData);
      
      const result = this.prepareResult(true, resultData, undefined, params.context, parseWorkspaceContext(workspaceContext) || undefined);
      
      // Generate nudges based on file creation
      const nudges = this.generateCreateContentNudges(params, resultData);
      const resultWithNudges = addRecommendations(result, nudges);
      
      return resultWithNudges;
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error creating file: ', error), params.context, parseWorkspaceContext(params.workspaceContext) || undefined);
    }
  }
  
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const customSchema = {
      type: 'object',
      properties: {
        filePath: {
          type: 'string',
          description: 'Path to the file to create (REQUIRED)'
        },
        content: {
          type: 'string',
          description: 'Content to write to the file (REQUIRED)'
        }
      },
      required: ['filePath', 'content']
    };
    
    return this.getMergedSchema(customSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            filePath: {
              type: 'string',
              description: 'Path to the created file'
            },
            created: {
              type: 'number',
              description: 'Creation timestamp'
            }
          },
          required: ['filePath', 'created']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'ID of the workspace'
            },
            workspacePath: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Path of the workspace'
            },
            activeWorkspace: {
              type: 'boolean',
              description: 'Whether this is the active workspace'
            }
          }
        },
      },
      required: ['success']
    };
  }
  
  /**
   * Record content creation activity in workspace memory
   * @param params Parameters used for creating content
   * @param resultData Result data containing creation information
   */
  private async recordActivity(
    params: CreateContentParams,
    resultData: {
      filePath: string;
      created: number;
    }
  ): Promise<void> {
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(params.workspaceContext) || undefined;
    
    // Skip if no workspace context
    if (!parsedContext?.workspaceId) {
      return;
    }
    
    // Skip if no memory service
    if (!this.memoryService) {
      try {
        // Try to get the memory service from the plugin
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
        } else {
          // No memory service available, skip activity recording
          return;
        }
      } catch (error) {
        console.error('Failed to get memory service from plugin:', getErrorMessage(error));
        return;
      }
    }
    
    // Create a descriptive content about this operation
    let contentSnippet = params.content.substring(0, 100);
    if (params.content.length > 100) {
      contentSnippet += '...';
    }
    
    const content = `Created file ${params.filePath}\nContent: ${contentSnippet}`;
    
    try {
      await this.memoryService!.recordActivityTrace({
        workspaceId: parsedContext.workspaceId,
        type: 'content',
        content: content,
        timestamp: Date.now(),
        metadata: {
          tool: 'contentManager.createContent',
          params: { filePath: params.filePath },
          result: { created: resultData.created },
          relatedFiles: [params.filePath]
        },
        sessionId: params.context.sessionId
      });
    } catch (error) {
      console.error('Failed to record create content activity:', getErrorMessage(error));
    }
  }

  /**
   * Generate nudges for file creation
   */
  private generateCreateContentNudges(params: CreateContentParams, resultData: { filePath: string }): Recommendation[] {
    const nudges: Recommendation[] = [];

    // Always suggest Obsidian features for new files
    nudges.push(NudgeHelpers.suggestObsidianFeatures());

    // Check session for multiple file creations (this would need enhanced session tracking)
    const multipleFilesNudge = NudgeHelpers.checkMultipleFilesInSession(params.context);
    if (multipleFilesNudge) {
      nudges.push(multipleFilesNudge);
    }

    return nudges;
  }
}
```

## agents/contentManager/modes/deleteContentMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { DeleteContentParams, DeleteContentResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import { createErrorMessage, getErrorMessage } from '../../../utils/errorUtils';
import { parseWorkspaceContext } from '../../../utils/contextUtils';
import { MemoryService } from '../../memoryManager/services/MemoryService';

/**
 * Mode for deleting content from a file
 * Follows Single Responsibility Principle - only handles content deletion
 * File change detection are handled automatically by FileEventManager
 */
export class DeleteContentMode extends BaseMode<DeleteContentParams, DeleteContentResult> {
  private app: App;
  private memoryService: MemoryService | null = null;
  
  /**
   * Create a new DeleteContentMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'deleteContent',
      'Delete Content',
      'Delete content from a file in the vault',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the delete result
   */
  async execute(params: DeleteContentParams): Promise<DeleteContentResult> {
    try {
      const { filePath, content, similarityThreshold = 0.95, workspaceContext } = params;
      
      const deletions = await ContentOperations.deleteContent(
        this.app,
        filePath,
        content,
        similarityThreshold
      );
      
      // File change detection are handled automatically by FileEventManager
      
      const resultData = {
        filePath,
        deletions
      };
      
      // Record session activity for memory tracking
      await this.recordActivity(params, resultData);
      
      const response = this.prepareResult(true, resultData, undefined, params.context, parseWorkspaceContext(workspaceContext) || undefined);
      
      return response;
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error deleting content: ', error), params.context, parseWorkspaceContext(params.workspaceContext) || undefined);
    }
  }
  
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const customSchema = {
      type: 'object',
      properties: {
        filePath: {
          type: 'string',
          description: 'Path to the file to modify'
        },
        content: {
          type: 'string',
          description: 'Content to delete'
        },
        similarityThreshold: {
          type: 'number',
          description: 'Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)',
          default: 0.95,
          minimum: 0.0,
          maximum: 1.0
        }
      },
      required: ['filePath', 'content']
    };
    
    return this.getMergedSchema(customSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            filePath: {
              type: 'string',
              description: 'Path to the file'
            },
            deletions: {
              type: 'number',
              description: 'Number of deletions made'
            }
          },
          required: ['filePath', 'deletions']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'ID of the workspace'
            },
            workspacePath: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Path of the workspace'
            },
            activeWorkspace: {
              type: 'boolean',
              description: 'Whether this is the active workspace'
            }
          }
        },
      },
      required: ['success']
    };
  }
  
  /**
   * Record content deletion activity in workspace memory
   * @param params Parameters used for deleting content
   * @param resultData Result data containing deletion information
   */
  private async recordActivity(
    params: DeleteContentParams,
    resultData: {
      filePath: string;
      deletions: number;
    }
  ): Promise<void> {
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(params.workspaceContext) || undefined;
    
    // Skip if no workspace context
    if (!parsedContext?.workspaceId) {
      return;
    }
    
    // Skip if no memory service
    if (!this.memoryService) {
      try {
        // Try to get the memory service from the plugin
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
        } else {
          // No memory service available, skip activity recording
          return;
        }
      } catch (error) {
        console.error('Failed to get memory service from plugin:', getErrorMessage(error));
        return;
      }
    }
    
    // Create a descriptive content about this operation
    let contentSnippet = params.content.substring(0, 100);
    if (params.content.length > 100) {
      contentSnippet += '...';
    }
    
    const content = `Deleted content from ${params.filePath} (${resultData.deletions} deletions)\nDeleted: ${contentSnippet}`;
    
    try {
      await this.memoryService!.recordActivityTrace({
        workspaceId: parsedContext.workspaceId,
        type: 'content',
        content: content,
        timestamp: Date.now(),
        metadata: {
          tool: 'contentManager.deleteContent',
          params: { filePath: params.filePath },
          result: resultData,
          relatedFiles: [params.filePath]
        },
        sessionId: params.context.sessionId
      });
    } catch (error) {
      console.error('Failed to record delete content activity:', getErrorMessage(error));
    }
  }
}
```

## agents/contentManager/modes/findReplaceContentMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { FindReplaceContentParams, FindReplaceContentResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import { createErrorMessage, getErrorMessage } from '../../../utils/errorUtils';
import { parseWorkspaceContext } from '../../../utils/contextUtils';
import { MemoryService } from '../../memoryManager/services/MemoryService';

/**
 * Mode for find and replace operations in a file
 */
export class FindReplaceContentMode extends BaseMode<FindReplaceContentParams, FindReplaceContentResult> {
  private app: App;
  private memoryService: MemoryService | null = null;
  
  /**
   * Create a new FindReplaceContentMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'findReplaceContent',
      'Find and Replace Content',
      'Find and replace text in a file in the vault',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the find and replace result
   */
  async execute(params: FindReplaceContentParams): Promise<FindReplaceContentResult> {
    try {
      const { 
        filePath, 
        findText, 
        replaceText, 
        replaceAll = false, 
        caseSensitive = true, 
        wholeWord = false,
        workspaceContext
      } = params;
      
      
      const replacements = await ContentOperations.findReplaceContent(
        this.app,
        filePath,
        findText,
        replaceText,
        replaceAll,
        caseSensitive,
        wholeWord
      );
      
      // File change detection are handled automatically by FileEventManager
      
      const resultData = {
        filePath,
        replacements,
        findText,
        replaceText
      };
      
      // Record session activity for memory tracking
      await this.recordActivity(params, resultData);
      
      const response = this.prepareResult(true, resultData, undefined, params.context, parseWorkspaceContext(workspaceContext) || undefined);
      
      return response;
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error in find and replace: ', error), params.context, parseWorkspaceContext(params.workspaceContext) || undefined);
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const customSchema = {
      type: 'object',
      properties: {
        filePath: {
          type: 'string',
          description: 'Path to the file to modify'
        },
        findText: {
          type: 'string',
          description: 'Text to find'
        },
        replaceText: {
          type: 'string',
          description: 'Text to replace with'
        },
        replaceAll: {
          type: 'boolean',
          description: 'Whether to replace all occurrences or just the first one',
          default: false
        },
        caseSensitive: {
          type: 'boolean',
          description: 'Whether the search should be case sensitive',
          default: true
        },
        wholeWord: {
          type: 'boolean',
          description: 'Whether to use whole word matching',
          default: false
        }
      },
      required: ['filePath', 'findText', 'replaceText']
    };
    
    return this.getMergedSchema(customSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            filePath: {
              type: 'string',
              description: 'Path to the file'
            },
            replacements: {
              type: 'number',
              description: 'Number of replacements made'
            },
            findText: {
              type: 'string',
              description: 'Text that was searched for'
            },
            replaceText: {
              type: 'string',
              description: 'Text that was used as replacement'
            }
          },
          required: ['filePath', 'replacements', 'findText', 'replaceText']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'ID of the workspace'
            },
            workspacePath: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Path of the workspace'
            },
            activeWorkspace: {
              type: 'boolean',
              description: 'Whether this is the active workspace'
            }
          }
        },
      },
      required: ['success']
    };
  }
  
  /**
   * Record find and replace activity in workspace memory
   * @param params Parameters used for find and replace operation
   * @param resultData Result data containing replacement information
   */
  private async recordActivity(
    params: FindReplaceContentParams,
    resultData: {
      filePath: string;
      replacements: number;
      findText: string;
      replaceText: string;
    }
  ): Promise<void> {
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(params.workspaceContext) || undefined;
    
    // Skip if no workspace context
    if (!parsedContext?.workspaceId) {
      return;
    }
    
    // Skip if no memory service
    if (!this.memoryService) {
      try {
        // Try to get the memory service from the plugin
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
        } else {
          // No memory service available, skip activity recording
          return;
        }
      } catch (error) {
        console.error('Failed to get memory service from plugin:', getErrorMessage(error));
        return;
      }
    }
    
    // Create a descriptive content about this operation
    const findSnippet = params.findText.substring(0, 50) + (params.findText.length > 50 ? '...' : '');
    const replaceSnippet = params.replaceText.substring(0, 50) + (params.replaceText.length > 50 ? '...' : '');
    
    const content = `Find and replace in ${params.filePath} (${resultData.replacements} replacements)\nFind: "${findSnippet}"\nReplace: "${replaceSnippet}"`;
    
    try {
      await this.memoryService!.recordActivityTrace({
        workspaceId: parsedContext.workspaceId,
        type: 'content',
        content: content,
        timestamp: Date.now(),
        metadata: {
          tool: 'contentManager.findReplaceContent',
          params: { filePath: params.filePath },
          result: resultData,
          relatedFiles: [params.filePath]
        },
        sessionId: params.context.sessionId
      });
    } catch (error) {
      console.error('Failed to record find replace content activity:', getErrorMessage(error));
    }
  }
}
```

## agents/contentManager/modes/index.ts

```typescript
export { ReadContentMode } from './readContentMode';
export { CreateContentMode } from './createContentMode';
export { AppendContentMode } from './appendContentMode';
export { PrependContentMode } from './prependContentMode';
export { ReplaceContentMode } from './replaceContentMode';
export { ReplaceByLineMode } from './replaceByLineMode';
export { DeleteContentMode } from './deleteContentMode';
export { FindReplaceContentMode } from './findReplaceContentMode';
export { BatchContentMode } from './batchContentMode';
```

## agents/contentManager/modes/prependContentMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { PrependContentParams, PrependContentResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import { createErrorMessage, getErrorMessage } from '../../../utils/errorUtils';
import { parseWorkspaceContext } from '../../../utils/contextUtils';
import { MemoryService } from '../../memoryManager/services/MemoryService';

/**
 * Mode for prepending content to a file
 */
export class PrependContentMode extends BaseMode<PrependContentParams, PrependContentResult> {
  private app: App;
  private memoryService: MemoryService | null = null;
  
  /**
   * Create a new PrependContentMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'prependContent',
      'Prepend Content',
      'Prepend content to a file in the vault',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the prepend result
   */
  async execute(params: PrependContentParams): Promise<PrependContentResult> {
    try {
      const { filePath, content, workspaceContext } = params;
      
      const result = await ContentOperations.prependContent(this.app, filePath, content);
      
      // File change detection are handled automatically by FileEventManager
      
      const resultData = {
        filePath,
        prependedLength: result.prependedLength,
        totalLength: result.totalLength
      };
      
      // Record session activity for memory tracking
      await this.recordActivity(params, resultData);
      
      const response = this.prepareResult(true, resultData, undefined, params.context, parseWorkspaceContext(workspaceContext) || undefined);
      
      return response;
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error prepending content: ', error), params.context, parseWorkspaceContext(params.workspaceContext) || undefined);
    }
  }
  
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const customSchema = {
      type: 'object',
      properties: {
        filePath: {
          type: 'string',
          description: 'Path to the file to prepend to'
        },
        content: {
          type: 'string',
          description: 'Content to prepend to the file'
        }
      },
      required: ['filePath', 'content']
    };
    
    return this.getMergedSchema(customSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            filePath: {
              type: 'string',
              description: 'Path to the file'
            },
            prependedLength: {
              type: 'number',
              description: 'Length of the content prepended'
            },
            totalLength: {
              type: 'number',
              description: 'Total length of the file after prepending'
            }
          },
          required: ['filePath', 'prependedLength', 'totalLength']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'ID of the workspace'
            },
            workspacePath: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Path of the workspace'
            },
            activeWorkspace: {
              type: 'boolean',
              description: 'Whether this is the active workspace'
            }
          }
        },
      },
      required: ['success']
    };
  }
  
  /**
   * Record content prepending activity in workspace memory
   * @param params Parameters used for prepending content
   * @param resultData Result data containing prepend information
   */
  private async recordActivity(
    params: PrependContentParams,
    resultData: {
      filePath: string;
      prependedLength: number;
      totalLength: number;
    }
  ): Promise<void> {
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(params.workspaceContext) || undefined;
    
    // Skip if no workspace context
    if (!parsedContext?.workspaceId) {
      return;
    }
    
    // Skip if no memory service
    if (!this.memoryService) {
      try {
        // Try to get the memory service from the plugin
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
        } else {
          // No memory service available, skip activity recording
          return;
        }
      } catch (error) {
        console.error('Failed to get memory service from plugin:', getErrorMessage(error));
        return;
      }
    }
    
    // Create a descriptive content about this operation
    let contentSnippet = params.content.substring(0, 100);
    if (params.content.length > 100) {
      contentSnippet += '...';
    }
    
    const content = `Prepended to file ${params.filePath} (${resultData.prependedLength} chars added, ${resultData.totalLength} total)\nContent: ${contentSnippet}`;
    
    try {
      await this.memoryService!.recordActivityTrace({
        workspaceId: parsedContext.workspaceId,
        type: 'content',
        content: content,
        timestamp: Date.now(),
        metadata: {
          tool: 'contentManager.prependContent',
          params: { filePath: params.filePath },
          result: resultData,
          relatedFiles: [params.filePath]
        },
        sessionId: params.context.sessionId
      });
    } catch (error) {
      console.error('Failed to record prepend content activity:', getErrorMessage(error));
    }
  }
}
```

## agents/contentManager/modes/readContentMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { ReadContentParams, ReadContentResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import {parseWorkspaceContext} from '../../../utils/contextUtils';
import { MemoryService } from '../../memoryManager/services/MemoryService';
import { getErrorMessage, createErrorMessage } from '../../../utils/errorUtils';
import { addRecommendations, Recommendation } from '../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../utils/nudgeHelpers';

/**
 * Mode for reading content from a file
 */
export class ReadContentMode extends BaseMode<ReadContentParams, ReadContentResult> {
  private app: App;
  private memoryService: MemoryService | null = null;
  
  /**
   * Create a new ReadContentMode
   * @param app Obsidian app instance
   * @param memoryService Optional MemoryService for activity recording
   */
  constructor(
    app: App, 
    memoryService?: MemoryService | null
  ) {
    super(
      'readContent',
      'Read Content',
      'Read content from a file in the vault',
      '1.0.0'
    );
    
    this.app = app;
    this.memoryService = memoryService || null;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the file content
   */
  async execute(params: ReadContentParams): Promise<ReadContentResult> {
    try {
      const { filePath, limit, offset, includeLineNumbers, workspaceContext } = params;
      
      let content: string;
      let startLine: number | undefined;
      let endLine: number | undefined;
      
      // If both limit and offset are specified, read specific lines
      if (typeof limit === 'number' && typeof offset === 'number') {
        startLine = offset;
        endLine = offset + limit - 1;
        const lines = await ContentOperations.readLines(
          this.app,
          filePath,
          startLine,
          endLine,
          includeLineNumbers
        );
        content = lines.join('\n');
      } else if (includeLineNumbers) {
        // Read entire file with line numbers
        content = await ContentOperations.readContentWithLineNumbers(this.app, filePath);
      } else {
        // Read entire file
        content = await ContentOperations.readContent(this.app, filePath);
      }
      
      const resultData = {
        content,
        filePath,
        lineNumbersIncluded: includeLineNumbers,
        startLine,
        endLine
      };
      
      // Record this activity in workspace memory if applicable
      await this.recordActivity(params, resultData);
      
      const result = this.prepareResult(true, resultData, undefined, params.context, parseWorkspaceContext(workspaceContext) || undefined);
      
      // Generate nudges based on content
      const nudges = this.generateReadContentNudges(resultData);
      const resultWithNudges = addRecommendations(result, nudges);
      
      return resultWithNudges;
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error reading content: ', error), params.context, parseWorkspaceContext(params.workspaceContext) || undefined);
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    // Create the mode-specific schema
    const modeSchema = {
      type: 'object',
      properties: {
        filePath: {
          type: 'string',
          description: 'Path to the file to read'
        },
        limit: {
          type: 'number',
          description: 'Optional number of lines to read'
        },
        offset: {
          type: 'number',
          description: 'Optional line number to start reading from (1-based)'
        },
        includeLineNumbers: {
          type: 'boolean',
          description: 'Whether to include line numbers in the output',
          default: false
        }
      },
      required: ['filePath']
    };
    
    // Merge with common schema (workspace context)
    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Record content reading activity in workspace memory
   * @param params Parameters used for reading content
   * @param resultData Result data containing content information
   */
  private async recordActivity(
    params: ReadContentParams,
    resultData: {
      content: string;
      filePath: string;
      lineNumbersIncluded?: boolean;
      startLine?: number;
      endLine?: number;
    }
  ): Promise<void> {
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(params.workspaceContext) || undefined;
    
    // Skip if no workspace context
    if (!parsedContext?.workspaceId) {
      return;
    }
    
    // Skip if no memory service
    if (!this.memoryService) {
      try {
        // Try to get the memory service from the plugin
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
        } else {
          // No memory service available, skip activity recording
          return;
        }
      } catch (error) {
        console.error('Failed to get memory service from plugin:', getErrorMessage(error));
        return;
      }
    }
    
    // Create a descriptive content about this operation
    let contentSnippet = resultData.content.substring(0, 100);
    if (resultData.content.length > 100) {
      contentSnippet += '...';
    }
    
    const readDescription = params.limit && params.offset 
      ? `Read lines ${params.offset}-${params.offset + params.limit - 1}` 
      : 'Read full content';
    
    const content = `${readDescription} from ${params.filePath}\nSnippet: ${contentSnippet}`;
    
    try {
      // Record activity using MemoryService - we've already checked it's not null
      await this.memoryService!.storeMemoryTrace({
        workspaceId: parsedContext.workspaceId,
        type: 'content_read',
        content: content,
        timestamp: Date.now(),
        metadata: {
          tool: 'ReadContentMode',
          params: {
            filePath: params.filePath,
            limit: params.limit,
            offset: params.offset,
            includeLineNumbers: params.includeLineNumbers
          },
          result: {
            contentLength: content.length,
            startLine: params.offset || 0,
            endLine: params.limit && params.offset !== undefined ? params.offset + params.limit : undefined
          },
          relatedFiles: [params.filePath]
        },
        sessionId: params.context.sessionId || ''
      });
      
      // Auto-track external files as associated notes
      try {
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        const workspaceService = plugin?.services?.workspaceService;
        
        if (workspaceService && parsedContext.workspaceId) {
          // Get the current workspace to check if this file is outside the workspace folder
          const workspace = await workspaceService.getWorkspace(parsedContext.workspaceId);
          
          if (workspace) {
            // Normalize paths for comparison
            const { sanitizePath } = await import('../../../utils/pathUtils');
            const normalizedFilePath = sanitizePath(params.filePath, false);
            const normalizedRootFolder = sanitizePath(workspace.rootFolder, false);
            const rootFolderWithSlash = normalizedRootFolder.endsWith('/') ? 
              normalizedRootFolder : normalizedRootFolder + '/';
            
            // Check if file is outside workspace folder
            const isOutsideWorkspace = normalizedFilePath !== normalizedRootFolder && 
                                     !normalizedFilePath.startsWith(rootFolderWithSlash);
            
            if (isOutsideWorkspace) {
              // Add to workspace's associatedNotes
              await workspaceService.addAssociatedNote(parsedContext.workspaceId, params.filePath);
            }
          }
        }
        
        // Also use the FileEventManager to record the activity across all relevant workspaces
        const fileEventManager = plugin?.services?.fileEventManager;
        
        if (fileEventManager && typeof fileEventManager.updateFileActivity === 'function') {
          // This will automatically update all workspaces that contain this file
          await fileEventManager.updateFileActivity(
            params.filePath,
            'view'
          );
        } else {
          // Fallback to direct workspace service if file event manager is not available          
          if (workspaceService && parsedContext.workspaceId) {
            await workspaceService.recordActivity(parsedContext.workspaceId, {
              action: 'view',
              timestamp: Date.now(),
              hierarchyPath: [params.filePath],
              toolName: 'readContent'
            });
          }
        }
      } catch (error) {
        console.warn('Error recording file activity:', getErrorMessage(error));
        // Don't fail the main operation
      }
    } catch (error) {
      // Log but don't fail the main operation
      console.error('Failed to record content reading activity with memory service:', getErrorMessage(error));
    }
  }

  getResultSchema(): any {
    // Use the base result schema from BaseMode, which includes common result properties
    const baseSchema = super.getResultSchema();
    
    // Add mode-specific data properties
    baseSchema.properties.data = {
      type: 'object',
      properties: {
        content: {
          type: 'string',
          description: 'Content of the file'
        },
        filePath: {
          type: 'string',
          description: 'Path to the file'
        },
        lineNumbersIncluded: {
          type: 'boolean',
          description: 'Whether line numbers are included in the content'
        },
        startLine: {
          type: 'number',
          description: 'Starting line if offset was specified'
        },
        endLine: {
          type: 'number',
          description: 'Ending line if limit was specified'
        }
      },
      required: ['content', 'filePath']
    };
    
    return baseSchema;
  }

  /**
   * Generate nudges based on content reading results
   */
  private generateReadContentNudges(resultData: { content: string; filePath: string }): Recommendation[] {
    const nudges: Recommendation[] = [];

    // Check for large content (>7,000 characters)
    const largeContentNudge = NudgeHelpers.checkLargeContent(resultData.content.length);
    if (largeContentNudge) {
      nudges.push(largeContentNudge);
    }

    return nudges;
  }
}
```

## agents/contentManager/modes/replaceByLineMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { ReplaceByLineParams, ReplaceByLineResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import { parseWorkspaceContext } from '../../../utils/contextUtils';

/**
 * Mode for replacing content by line number in a file
 */
export class ReplaceByLineMode extends BaseMode<ReplaceByLineParams, ReplaceByLineResult> {
  private app: App;
  
  /**
   * Create a new ReplaceByLineMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'replaceByLine',
      'Replace By Line',
      'Replace content by line number in a file in the vault',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the replace result
   */
  async execute(params: ReplaceByLineParams): Promise<ReplaceByLineResult> {
    try {
      const { filePath, startLine, endLine, newContent, workspaceContext } = params;
      
      const linesReplaced = await ContentOperations.replaceByLine(
        this.app,
        filePath,
        startLine,
        endLine,
        newContent
      );
      
      // File change detection are handled automatically by FileEventManager
      
      const response = this.prepareResult(true, {
          filePath,
          linesReplaced
        }, undefined, params.context, parseWorkspaceContext(workspaceContext) || undefined);
      
      return response;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.prepareResult(false, undefined, errorMessage, params.context, parseWorkspaceContext(params.workspaceContext) || undefined);
    }
  }
  
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const customSchema = {
      type: 'object',
      properties: {
        filePath: {
          type: 'string',
          description: 'Path to the file to modify'
        },
        startLine: {
          type: 'number',
          description: 'Start line number (1-based)'
        },
        endLine: {
          type: 'number',
          description: 'End line number (1-based, inclusive)'
        },
        newContent: {
          type: 'string',
          description: 'Content to replace with'
        }
      },
      required: ['filePath', 'startLine', 'endLine', 'newContent']
    };
    
    return this.getMergedSchema(customSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            filePath: {
              type: 'string',
              description: 'Path to the file'
            },
            linesReplaced: {
              type: 'number',
              description: 'Number of lines replaced'
            }
          },
          required: ['filePath', 'linesReplaced']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'ID of the workspace'
            },
            workspacePath: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Path of the workspace'
            },
            activeWorkspace: {
              type: 'boolean',
              description: 'Whether this is the active workspace'
            }
          }
        },
      },
      required: ['success']
    };
  }
}
```

## agents/contentManager/modes/replaceContentMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { ReplaceContentParams, ReplaceContentResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import { createErrorMessage, getErrorMessage } from '../../../utils/errorUtils';
import { parseWorkspaceContext } from '../../../utils/contextUtils';
import { MemoryService } from '../../memoryManager/services/MemoryService';

/**
 * Mode for replacing content in a file
 */
export class ReplaceContentMode extends BaseMode<ReplaceContentParams, ReplaceContentResult> {
  private app: App;
  private memoryService: MemoryService | null = null;
  
  /**
   * Create a new ReplaceContentMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'replaceContent',
      'Replace Content',
      'Replace content in a file in the vault',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the replace result
   */
  async execute(params: ReplaceContentParams): Promise<ReplaceContentResult> {
    try {
      const { filePath, oldContent, newContent, similarityThreshold = 0.95, workspaceContext } = params;
      
      const replacements = await ContentOperations.replaceContent(
        this.app,
        filePath,
        oldContent,
        newContent,
        similarityThreshold
      );
      
      // File change detection are handled automatically by FileEventManager
      
      const resultData = {
        filePath,
        replacements
      };
      
      // Record session activity for memory tracking
      await this.recordActivity(params, resultData);
      
      const response = this.prepareResult(true, resultData, undefined, params.context, parseWorkspaceContext(workspaceContext) || undefined);
      
      return response;
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error replacing content: ', error), params.context, parseWorkspaceContext(params.workspaceContext) || undefined);
    }
  }
  
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const customSchema = {
      type: 'object',
      properties: {
        filePath: {
          type: 'string',
          description: 'Path to the file to modify'
        },
        oldContent: {
          type: 'string',
          description: 'Content to replace'
        },
        newContent: {
          type: 'string',
          description: 'Content to replace with'
        },
        similarityThreshold: {
          type: 'number',
          description: 'Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)',
          default: 0.95,
          minimum: 0.0,
          maximum: 1.0
        }
      },
      required: ['filePath', 'oldContent', 'newContent']
    };
    
    return this.getMergedSchema(customSchema);
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            filePath: {
              type: 'string',
              description: 'Path to the file'
            },
            replacements: {
              type: 'number',
              description: 'Number of replacements made'
            }
          },
          required: ['filePath', 'replacements']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'ID of the workspace'
            },
            workspacePath: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Path of the workspace'
            },
            activeWorkspace: {
              type: 'boolean',
              description: 'Whether this is the active workspace'
            }
          }
        },
      },
      required: ['success']
    };
  }
  
  /**
   * Record content replacement activity in workspace memory
   * @param params Parameters used for replacing content
   * @param resultData Result data containing replacement information
   */
  private async recordActivity(
    params: ReplaceContentParams,
    resultData: {
      filePath: string;
      replacements: number;
    }
  ): Promise<void> {
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(params.workspaceContext) || undefined;
    
    // Skip if no workspace context
    if (!parsedContext?.workspaceId) {
      return;
    }
    
    // Skip if no memory service
    if (!this.memoryService) {
      try {
        // Try to get the memory service from the plugin
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
        } else {
          // No memory service available, skip activity recording
          return;
        }
      } catch (error) {
        console.error('Failed to get memory service from plugin:', getErrorMessage(error));
        return;
      }
    }
    
    // Create a descriptive content about this operation
    const oldSnippet = params.oldContent.substring(0, 50) + (params.oldContent.length > 50 ? '...' : '');
    const newSnippet = params.newContent.substring(0, 50) + (params.newContent.length > 50 ? '...' : '');
    
    const content = `Replaced content in ${params.filePath} (${resultData.replacements} replacements)\nOld: ${oldSnippet}\nNew: ${newSnippet}`;
    
    try {
      await this.memoryService!.recordActivityTrace({
        workspaceId: parsedContext.workspaceId,
        type: 'content',
        content: content,
        timestamp: Date.now(),
        metadata: {
          tool: 'contentManager.replaceContent',
          params: { filePath: params.filePath },
          result: resultData,
          relatedFiles: [params.filePath]
        },
        sessionId: params.context.sessionId
      });
    } catch (error) {
      console.error('Failed to record replace content activity:', getErrorMessage(error));
    }
  }
}
```

## agents/contentManager/types.ts

```typescript
import { CommonParameters, CommonResult } from '../../types';

/**
 * Parameters for reading content from a file
 */
export interface ReadContentParams extends CommonParameters {
  /**
   * Path to the file to read
   */
  filePath: string;
  
  /**
   * Optional number of lines to read
   */
  limit?: number;
  
  /**
   * Optional line number to start reading from (1-based)
   */
  offset?: number;
  
  /**
   * Whether to include line numbers in the output
   */
  includeLineNumbers?: boolean;
}

/**
 * Result of reading content from a file
 */
export interface ReadContentResult extends CommonResult {
  data?: {
    /**
     * Content of the file
     */
    content: string;
    
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Whether line numbers are included in the content
     */
    lineNumbersIncluded?: boolean;
    
    /**
     * Starting line if offset was specified
     */
    startLine?: number;
    
    /**
     * Ending line if limit was specified
     */
    endLine?: number;
  };
}

/**
 * Parameters for creating a new file with content
 */
export interface CreateContentParams extends CommonParameters {
  /**
   * Path to the file to create
   */
  filePath: string;
  
  /**
   * Content to write to the file
   */
  content: string;
}

/**
 * Result of creating a file
 */
export interface CreateContentResult extends CommonResult {
  data?: {
    /**
     * Path to the created file
     */
    filePath: string;
    
    /**
     * Creation timestamp
     */
    created: number;
  };
}

/**
 * Parameters for appending content to a file
 */
export interface AppendContentParams extends CommonParameters {
  /**
   * Path to the file to append to
   */
  filePath: string;
  
  /**
   * Content to append to the file
   */
  content: string;
}

/**
 * Result of appending content to a file
 */
export interface AppendContentResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Length of the content appended
     */
    appendedLength: number;
    
    /**
     * Total length of the file after appending
     */
    totalLength: number;
  };
}

/**
 * Parameters for prepending content to a file
 */
export interface PrependContentParams extends CommonParameters {
  /**
   * Path to the file to prepend to
   */
  filePath: string;
  
  /**
   * Content to prepend to the file
   */
  content: string;
}

/**
 * Result of prepending content to a file
 */
export interface PrependContentResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Length of the content prepended
     */
    prependedLength: number;
    
    /**
     * Total length of the file after prepending
     */
    totalLength: number;
  };
}

/**
 * Parameters for replacing content in a file
 */
export interface ReplaceContentParams extends CommonParameters {
  /**
   * Path to the file to modify
   */
  filePath: string;
  
  /**
   * Content to replace
   */
  oldContent: string;
  
  /**
   * Content to replace with
   */
  newContent: string;
  
  /**
   * Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)
   * @default 0.95
   */
  similarityThreshold?: number;
}

/**
 * Result of replacing content in a file
 */
export interface ReplaceContentResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Number of replacements made
     */
    replacements: number;
  };
}

/**
 * Parameters for replacing content by line number
 */
export interface ReplaceByLineParams extends CommonParameters {
  /**
   * Path to the file to modify
   */
  filePath: string;
  
  /**
   * Start line number (1-based)
   */
  startLine: number;
  
  /**
   * End line number (1-based, inclusive)
   */
  endLine: number;
  
  /**
   * Content to replace with
   */
  newContent: string;
}

/**
 * Result of replacing content by line number
 */
export interface ReplaceByLineResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Number of lines replaced
     */
    linesReplaced: number;
  };
}

/**
 * Parameters for deleting content from a file
 */
export interface DeleteContentParams extends CommonParameters {
  /**
   * Path to the file to modify
   */
  filePath: string;
  
  /**
   * Content to delete
   */
  content: string;
  
  /**
   * Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)
   * @default 0.95
   */
  similarityThreshold?: number;
}

/**
 * Result of deleting content from a file
 */
export interface DeleteContentResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Number of deletions made
     */
    deletions: number;
  };
}

/**
 * Parameters for find and replace operations in a file
 */
export interface FindReplaceContentParams extends CommonParameters {
  /**
   * Path to the file to modify
   */
  filePath: string;
  
  /**
   * Text to find
   */
  findText: string;
  
  /**
   * Text to replace with
   */
  replaceText: string;
  
  /**
   * Whether to replace all occurrences or just the first one
   * @default false
   */
  replaceAll?: boolean;
  
  /**
   * Whether the search should be case sensitive
   * @default true
   */
  caseSensitive?: boolean;
  
  /**
   * Whether to use whole word matching
   * @default false
   */
  wholeWord?: boolean;
}

/**
 * Result of find and replace operations in a file
 */
export interface FindReplaceContentResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Number of replacements made
     */
    replacements: number;
    
    /**
     * Text that was searched for
     */
    findText: string;
    
    /**
     * Text that was used as replacement
     */
    replaceText: string;
  };
}

/**
 * Content operation type for batch operations
 */
export type ContentOperation = 
  | { type: 'read', params: Omit<ReadContentParams, keyof CommonParameters> }
  | { type: 'create', params: Omit<CreateContentParams, keyof CommonParameters> }
  | { type: 'append', params: Omit<AppendContentParams, keyof CommonParameters> }
  | { type: 'prepend', params: Omit<PrependContentParams, keyof CommonParameters> }
  | { type: 'replace', params: Omit<ReplaceContentParams, keyof CommonParameters> }
  | { type: 'replaceByLine', params: Omit<ReplaceByLineParams, keyof CommonParameters> }
  | { type: 'delete', params: Omit<DeleteContentParams, keyof CommonParameters> }
  | { type: 'findReplace', params: Omit<FindReplaceContentParams, keyof CommonParameters> };

/**
 * Parameters for batch content operations
 */
export interface BatchContentParams extends CommonParameters {
  /**
   * Array of operations to perform
   */
  operations: ContentOperation[];
}

/**
 * Result of a batch operation
 */
export interface BatchContentResult extends CommonResult {
  data?: {
    /**
     * Array of operation results
     */
    results: Array<{
      /**
       * Whether the operation succeeded
       */
      success: boolean;
      
      /**
       * Error message if success is false
       */
      error?: string;
      
      /**
       * Operation-specific result data
       */
      data?: any;
      
      /**
       * Type of operation
       */
      type: ContentOperation['type'];
      
      /**
       * File path for the operation
       */
      filePath: string;
    }>;
  };
}
```

## agents/contentManager/utils/ContentOperations.ts

```typescript
import { App, TFile } from 'obsidian';
import { diff_match_patch } from 'diff-match-patch';

/**
 * Utility class for content operations
 */
export class ContentOperations {
  /**
   * Normalize file path by removing any leading slash
   * @param filePath Path to normalize
   * @returns Normalized path
   */
  private static normalizePath(filePath: string): string {
    // Remove leading slash if present
    return filePath.startsWith('/') ? filePath.slice(1) : filePath;
  }

  /**
   * Read the content of a note
   * @param app Obsidian app instance
   * @param filePath Path to the note
   * @returns Promise that resolves with the note content
   */
  static async readContent(app: App, filePath: string): Promise<string> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: ${filePath}`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Not a file: ${filePath}`);
      }
      
      return await app.vault.read(file);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error reading file: ${errorMessage}`);
    }
  }
  
  /**
   * Read the content of a note with line numbers
   * @param app Obsidian app instance
   * @param filePath Path to the note
   * @returns Promise that resolves with the note content including line numbers
   */
  static async readContentWithLineNumbers(app: App, filePath: string): Promise<string> {
    try {
      // Normalize path is handled by readContent internally
      const content = await this.readContent(app, filePath);
      const lines = content.split('\n');
      
      return lines.map((line, index) => `${index + 1}: ${line}`).join('\n');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error reading file with line numbers: ${errorMessage}`);
    }
  }
  
  /**
   * Read specific lines from a note
   * @param app Obsidian app instance
   * @param filePath Path to the note
   * @param startLine Start line (1-based)
   * @param endLine End line (1-based, inclusive)
   * @param includeLineNumbers Whether to include line numbers in output
   * @returns Promise that resolves with the specified lines
   */
  static async readLines(
    app: App, 
    filePath: string, 
    startLine: number, 
    endLine: number,
    includeLineNumbers = false
  ): Promise<string[]> {
    try {
      // Normalize path is handled by readContent internally
      const content = await this.readContent(app, filePath);
      const lines = content.split('\n');
      
      // Adjust for 1-based line numbers
      startLine = Math.max(1, startLine);
      endLine = Math.min(lines.length, endLine);
      
      if (startLine > endLine) {
        throw new Error('Start line cannot be greater than end line');
      }
      
      const selectedLines = lines.slice(startLine - 1, endLine);
      
      if (includeLineNumbers) {
        return selectedLines.map((line, index) => `${startLine + index}: ${line}`);
      }
      
      return selectedLines;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error reading lines: ${errorMessage}`);
    }
  }
  
  /**
   * Create a new file with content
   * @param app Obsidian app instance
   * @param filePath Path to the new file
   * @param content Content for the new file
   * @returns Promise that resolves with the created file
   */
  static async createContent(app: App, filePath: string, content: string): Promise<TFile> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (file) {
        throw new Error(`File already exists: ${filePath}`);
      }
      
      // Ensure parent folders exist
      const folderPath = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));
      if (folderPath) {
        // Normalize the folder path as well
        await app.vault.createFolder(folderPath).catch(() => {
          // Folder might already exist, ignore error
        });
      }
      
      return await app.vault.create(normalizedPath, content);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error creating file: ${errorMessage}`);
    }
  }
  
  /**
   * Append content to a file
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param content Content to append
   * @returns Promise that resolves when the content is appended
   */
  static async appendContent(app: App, filePath: string, content: string): Promise<{
    appendedLength: number;
    totalLength: number;
  }> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: ${filePath}`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Not a file: ${filePath}`);
      }
      
      const existingContent = await app.vault.read(file);
      const newContent = existingContent + content;
      
      await app.vault.modify(file, newContent);
      
      return {
        appendedLength: content.length,
        totalLength: newContent.length
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error appending to file: ${errorMessage}`);
    }
  }
  
  /**
   * Prepend content to a file
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param content Content to prepend
   * @returns Promise that resolves when the content is prepended
   */
  static async prependContent(app: App, filePath: string, content: string): Promise<{
    prependedLength: number;
    totalLength: number;
  }> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: ${filePath}`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Not a file: ${filePath}`);
      }
      
      const existingContent = await app.vault.read(file);
      const newContent = content + existingContent;
      
      await app.vault.modify(file, newContent);
      
      return {
        prependedLength: content.length,
        totalLength: newContent.length
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error prepending to file: ${errorMessage}`);
    }
  }
  
  /**
   * Replace content in a file using fuzzy matching
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param oldContent Content to replace
   * @param newContent Content to replace with
   * @param similarityThreshold Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)
   * @returns Promise that resolves with the number of replacements made
   */
  static async replaceContent(
    app: App,
    filePath: string,
    oldContent: string,
    newContent: string,
    similarityThreshold = 0.95
  ): Promise<number> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: ${filePath}`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Not a file: ${filePath}`);
      }
      
      const existingContent = await app.vault.read(file);
      
      // Try exact match first
      const regex = new RegExp(this.escapeRegExp(oldContent), 'g');
      const exactMatches = (existingContent.match(regex) || []).length;
      
      if (exactMatches > 0) {
        // Perform exact replacement if found
        const modifiedContent = existingContent.replace(regex, newContent);
        await app.vault.modify(file, modifiedContent);
        return exactMatches;
      }
      
      // If no exact match, try fuzzy matching
      const dmp = new diff_match_patch();
      
      // Configure the matcher
      dmp.Match_Threshold = similarityThreshold;
      dmp.Match_Distance = 1000; // Maximum distance to search
      
      // Find the best match position
      const matchPosition = dmp.match_main(existingContent, oldContent, 0);
      
      if (matchPosition === -1) {
        // No match found even with fuzzy matching
        throw new Error(`Content to replace not found in file, even with fuzzy matching at ${similarityThreshold * 100}% threshold`);
      }
      
      // Extract the actual matched text for informational purposes
      const matchedLength = oldContent.length;
      const actualMatchedText = existingContent.substring(matchPosition, matchPosition + matchedLength);
      
      
      // Create a clean replacement by slicing the original content
      const beforeMatch = existingContent.substring(0, matchPosition);
      const afterMatch = existingContent.substring(matchPosition + matchedLength);
      const modifiedContent = beforeMatch + newContent + afterMatch;
      
      // Modify the file
      await app.vault.modify(file, modifiedContent);
      
      return 1; // One fuzzy replacement made
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error replacing content: ${errorMessage}`);
    }
  }
  
  /**
   * Replace specific lines in a file
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param startLine Start line (1-based)
   * @param endLine End line (1-based, inclusive)
   * @param newContent Content to replace with
   * @returns Promise that resolves with the number of lines replaced
   */
  static async replaceByLine(
    app: App,
    filePath: string,
    startLine: number,
    endLine: number,
    newContent: string
  ): Promise<number> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: ${filePath}`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Not a file: ${filePath}`);
      }
      
      const existingContent = await app.vault.read(file);
      const lines = existingContent.split('\n');
      
      // Adjust for 1-based line numbers
      startLine = Math.max(1, startLine);
      endLine = Math.min(lines.length, endLine);
      
      if (startLine > endLine) {
        throw new Error('Start line cannot be greater than end line');
      }
      
      const linesReplaced = endLine - startLine + 1;
      
      // Replace lines
      const beforeLines = lines.slice(0, startLine - 1);
      const afterLines = lines.slice(endLine);
      
      const newLines = newContent.split('\n');
      
      const modifiedContent = [
        ...beforeLines,
        ...newLines,
        ...afterLines
      ].join('\n');
      
      await app.vault.modify(file, modifiedContent);
      
      return linesReplaced;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error replacing lines: ${errorMessage}`);
    }
  }
  
  /**
   * Delete content from a file with fuzzy matching support
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param content Content to delete
   * @param similarityThreshold Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)
   * @returns Promise that resolves with the number of deletions made
   */
  static async deleteContent(
    app: App,
    filePath: string,
    content: string,
    similarityThreshold = 0.95
  ): Promise<number> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: ${filePath}`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Not a file: ${filePath}`);
      }
      
      const existingContent = await app.vault.read(file);
      
      // Try exact match first
      const regex = new RegExp(this.escapeRegExp(content), 'g');
      const exactMatches = (existingContent.match(regex) || []).length;
      
      if (exactMatches > 0) {
        // Perform exact deletion if found
        const modifiedContent = existingContent.replace(regex, '');
        await app.vault.modify(file, modifiedContent);
        return exactMatches;
      }
      
      // If no exact match, try fuzzy matching
      const dmp = new diff_match_patch();
      
      // Configure the matcher
      dmp.Match_Threshold = similarityThreshold;
      dmp.Match_Distance = 1000; // Maximum distance to search
      
      // Find the best match position
      const matchPosition = dmp.match_main(existingContent, content, 0);
      
      if (matchPosition === -1) {
        // No match found even with fuzzy matching
        throw new Error(`Content to delete not found in file, even with fuzzy matching at ${similarityThreshold * 100}% threshold`);
      }
      
      // Extract the actual matched text for informational purposes
      const matchedLength = content.length;
      const actualMatchedText = existingContent.substring(matchPosition, matchPosition + matchedLength);
      
      
      // Create a clean deletion by slicing the original content
      const beforeMatch = existingContent.substring(0, matchPosition);
      const afterMatch = existingContent.substring(matchPosition + matchedLength);
      const modifiedContent = beforeMatch + afterMatch;
      
      // Modify the file
      await app.vault.modify(file, modifiedContent);
      
      return 1; // One fuzzy deletion made
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error deleting content: ${errorMessage}`);
    }
  }
  
  /**
   * Find and replace text in a file
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param findText Text to find
   * @param replaceText Text to replace with
   * @param replaceAll Whether to replace all occurrences or just the first one
   * @param caseSensitive Whether the search should be case sensitive
   * @param wholeWord Whether to use whole word matching
   * @returns Promise that resolves with the number of replacements made
   */
  static async findReplaceContent(
    app: App,
    filePath: string,
    findText: string,
    replaceText: string,
    replaceAll = false,
    caseSensitive = true,
    wholeWord = false
  ): Promise<number> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: ${filePath}`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Not a file: ${filePath}`);
      }
      
      const existingContent = await app.vault.read(file);
      
      // Build regex pattern
      let pattern = this.escapeRegExp(findText);
      
      // Add word boundaries if wholeWord is true
      if (wholeWord) {
        pattern = `\\b${pattern}\\b`;
      }
      
      // Create regex with appropriate flags
      const flags = (caseSensitive ? '' : 'i') + (replaceAll ? 'g' : '');
      const regex = new RegExp(pattern, flags);
      
      // Count matches before replacement
      const matches = existingContent.match(regex);
      const matchCount = matches ? matches.length : 0;
      
      if (matchCount === 0) {
        // No matches found
        return 0;
      }
      
      // Perform replacement
      const modifiedContent = existingContent.replace(regex, replaceText);
      await app.vault.modify(file, modifiedContent);
      
      return matchCount;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error in find and replace: ${errorMessage}`);
    }
  }

  /**
   * Escape special characters in a string for use in a regular expression
   * @param string String to escape
   * @returns Escaped string
   */
  private static escapeRegExp(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
  
  /**
   * Calculate similarity between two strings (0.0 to 1.0)
   * @param str1 First string
   * @param str2 Second string
   * @returns Similarity score between 0.0 and 1.0
   */
  private static calculateSimilarity(str1: string, str2: string): number {
    if (str1 === str2) return 1.0;
    if (str1.length === 0 || str2.length === 0) return 0.0;
    
    const dmp = new diff_match_patch();
    const diffs = dmp.diff_main(str1, str2);
    dmp.diff_cleanupSemantic(diffs);
    
    // Calculate similarity based on edit distance
    const levenshtein = dmp.diff_levenshtein(diffs);
    const maxLength = Math.max(str1.length, str2.length);
    
    // Return similarity as 1 - (edit distance / max length)
    return 1.0 - (levenshtein / maxLength);
  }
}
```

## agents/index.ts

```typescript
// Core agents in the new agent structure
export * from './contentManager/contentManager';
export * from './commandManager/commandManager';
export * from './vaultManager/vaultManager';
export * from './vaultLibrarian/vaultLibrarian';
export * from './memoryManager/memoryManager';
export * from './agentManager/agentManager';
// Chat agent removed - using native chatbot UI instead
```

## agents/interfaces/IAgent.ts

```typescript
// Import IMode from separate file
import { IMode } from './IMode';

/**
 * Interface for agents in the MCP plugin
 * Each agent is responsible for a specific domain and provides a set of modes
 */
export interface IAgent {
  /**
   * Name of the agent
   */
  name: string;
  
  /**
   * Description of the agent
   */
  description: string;
  
  /**
   * Version of the agent
   */
  version: string;
  
  /**
   * Get all modes provided by this agent
   * @returns Array of modes
   */
  getModes(): IMode[];
  
  /**
   * Get a specific mode by slug
   * @param modeSlug Slug of the mode to get
   * @returns Mode with the specified slug or undefined if not found
   */
  getMode(modeSlug: string): IMode | undefined;
  
  /**
   * Initialize the agent
   * @returns Promise that resolves when initialization is complete
   */
  initialize(): Promise<void>;
  
  /**
   * Execute a mode with parameters
   * @param modeSlug Slug of the mode to execute
   * @param params Parameters to pass to the mode
   * @returns Promise that resolves with the mode's result
   */
  executeMode(modeSlug: string, params: any): Promise<any>;
  
  /**
   * Set the agent manager reference
   * @param agentManager Agent manager instance
   */
  setAgentManager(agentManager: any): void;
  
}
```

## agents/interfaces/IMode.ts

```typescript
/**
 * Interface for modes in the MCP plugin
 * Each mode provides a specific functionality within an agent's domain
 */
export interface IMode<T = any, R = any> {
  /**
   * Slug of the mode (used for identification)
   */
  slug: string;
  
  /**
   * Name of the mode
   */
  name: string;
  
  /**
   * Description of the mode
   */
  description: string;
  
  /**
   * Version of the mode
   */
  version: string;
  
  /**
   * Execute the mode with parameters
   * @param params Parameters for the mode
   * @returns Promise that resolves with the mode's result
   */
  execute(params: T): Promise<R>;
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any;
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): any;
}
```

## agents/memoryManager/memoryManager.ts

```typescript
import { App } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import { MemoryManagerConfig } from '../../config/agents';
import { parseWorkspaceContext } from '../../utils/contextUtils';
import { MemoryService } from "./services/MemoryService";
import { WorkspaceService } from "./services/WorkspaceService";
import { getErrorMessage } from '../../utils/errorUtils';
import { sanitizeVaultName } from '../../utils/vaultUtils';

// Import consolidated modes
import { CreateSessionMode } from './modes/sessions/CreateSessionMode';
import { ListSessionsMode } from './modes/sessions/ListSessionsMode';
import { LoadSessionMode } from './modes/sessions/LoadSessionMode';
import { UpdateSessionMode } from './modes/sessions/UpdateSessionMode';
import { CreateStateMode } from './modes/states/CreateStateMode';
import { ListStatesMode } from './modes/states/ListStatesMode';
import { LoadStateMode } from './modes/states/LoadStateMode';
import { UpdateStateMode } from './modes/states/UpdateStateMode';
import { CreateWorkspaceMode } from './modes/workspaces/CreateWorkspaceMode';
import { ListWorkspacesMode } from './modes/workspaces/ListWorkspacesMode';
import { LoadWorkspaceMode } from './modes/workspaces/LoadWorkspaceMode';
import { UpdateWorkspaceMode } from './modes/workspaces/UpdateWorkspaceMode';

/**
 * Agent for managing workspace memory, sessions, and state snapshots
 * 
 * CONSOLIDATED ARCHITECTURE:
 * - 15 files total (down from 50+)
 * - 3 session modes: create/load/manage
 * - 3 state modes: create/load/manage  
 * - 4 workspace modes: create/load/manage/associated-notes
 * - 3 services: ValidationService/ContextBuilder/MemoryTraceService
 */
export class MemoryManagerAgent extends BaseAgent {
  /**
   * Memory service instance
   */
  private memoryService!: MemoryService;

  /**
   * Workspace service instance
   */
  private workspaceService!: WorkspaceService;
  
  /**
   * App instance
   */
  private app: App;

  /**
   * Vault name for multi-vault support
   */
  private vaultName: string;

  /**
   * Flag to prevent infinite recursion in description getter
   */
  private isGettingDescription = false;

  /**
   * Create a new MemoryManagerAgent with consolidated modes
   * @param app Obsidian app instance
   * @param plugin Plugin instance for accessing shared services
   */
  constructor(app: App, public plugin?: any) {
    super(
      MemoryManagerConfig.name,
      MemoryManagerConfig.description,
      MemoryManagerConfig.version
    );
    
    this.app = app;
    this.vaultName = sanitizeVaultName(app.vault.getName());
    
    // Services will be accessed dynamically when needed
    
    // Register session modes (4 modes: create, list, load, update - following workspace pattern)
    this.registerMode(new CreateSessionMode(this));
    this.registerMode(new ListSessionsMode(this));
    this.registerMode(new LoadSessionMode(this));
    this.registerMode(new UpdateSessionMode(this));
    
    // Register state modes (4 modes: create, list, load, update - following workspace pattern) 
    this.registerMode(new CreateStateMode(this));
    this.registerMode(new ListStatesMode(this));
    this.registerMode(new LoadStateMode(this));
    this.registerMode(new UpdateStateMode(this));
    
    // Register consolidated workspace modes (5 modes instead of 7)
    this.registerMode(new CreateWorkspaceMode(this));
    this.registerMode(new ListWorkspacesMode(this));
    this.registerMode(new LoadWorkspaceMode(this));
    this.registerMode(new UpdateWorkspaceMode(this));
  }

  /**
   * Dynamic description that includes current workspace information
   */
  get description(): string {
    const baseDescription = MemoryManagerConfig.description;
    
    // Prevent infinite recursion
    if (this.isGettingDescription) {
      return `[${this.vaultName}] ${baseDescription}`;
    }
    
    this.isGettingDescription = true;
    try {
      const workspaceContext = this.getWorkspacesSummary();
      return `[${this.vaultName}] ${baseDescription}\n\n${workspaceContext}`;
    } finally {
      this.isGettingDescription = false;
    }
  }
  
  /**
   * Initialize the agent
   */
  async initialize(): Promise<void> {
    await super.initialize();
    // No additional initialization needed
  }
  
  /**
   * Get the memory service instance synchronously - uses ServiceContainer
   */
  getMemoryService(): MemoryService | null {
    console.log(`[MemoryManagerAgent] üîç DEBUG: getMemoryService called`);
    const plugin = this.app.plugins.getPlugin('claudesidian-mcp') as any;
    console.log(`[MemoryManagerAgent] üîç DEBUG: Plugin found: ${!!plugin}`);
    
    if (!plugin) {
      console.log(`[MemoryManagerAgent] üîç DEBUG: No plugin found`);
      return null;
    }
    
    // FIX: Use direct property access instead of serviceContainer
    console.log(`[MemoryManagerAgent] üîç DEBUG: Accessing memoryService directly from plugin`);
    const memoryService = plugin.memoryService;
    console.log(`[MemoryManagerAgent] üîç DEBUG: Memory service from plugin: ${!!memoryService}`);
    
    if (!memoryService) {
      console.log(`[MemoryManagerAgent] üîç DEBUG: Plugin properties:`, Object.keys(plugin));
    }
    
    return memoryService || null;
  }
  
  /**
   * Get the workspace service instance synchronously - uses ServiceContainer
   */
  getWorkspaceService(): WorkspaceService | null {
    const plugin = this.app.plugins.getPlugin('claudesidian-mcp') as any;
    if (!plugin) {
      return null;
    }
    // FIX: Use direct property access instead of serviceContainer
    return plugin.workspaceService || null;
  }
  
  /**
   * Get the memory service instance asynchronously - waits for service initialization
   */
  async getMemoryServiceAsync(): Promise<MemoryService | null> {
    const plugin = this.app.plugins.getPlugin('claudesidian-mcp') as any;
    if (!plugin) {
      return null;
    }
    
    try {
      return await (plugin as any).getService('memoryService') as MemoryService;
    } catch (error) {
      console.warn('[MemoryManagerAgent] Failed to get memory service:', error);
      return null;
    }
  }
  
  /**
   * Get the workspace service instance asynchronously - waits for service initialization
   */
  async getWorkspaceServiceAsync(): Promise<WorkspaceService | null> {
    const plugin = this.app.plugins.getPlugin('claudesidian-mcp') as any;
    if (!plugin) {
      return null;
    }
    
    try {
      return await (plugin as any).getService('workspaceService') as WorkspaceService;
    } catch (error) {
      console.warn('[MemoryManagerAgent] Failed to get workspace service:', error);
      return null;
    }
  }
  
  /**
   * Get the Obsidian app instance
   */
  getApp() {
    return this.app;
  }
  
  /**
   * Execute a mode with automatic session context tracking
   * @param modeSlug The mode to execute
   * @param params Parameters for the mode
   * @returns Result from mode execution
   */
  async executeMode(modeSlug: string, params: any): Promise<any> {
    // If there's a workspace context but no session ID, try to get or create a session
    if (params.workspaceContext?.workspaceId && !params.workspaceContext.sessionId) {
      try {
        const workspaceId = parseWorkspaceContext(params.workspaceContext)?.workspaceId;
        if (workspaceId) {
          // Try to get an active session
          let sessionId: string | null = null;
          
          // Get memory service and then get the most recent active session for this workspace
          const memoryService = await this.getMemoryServiceAsync();
          if (!memoryService) {
            console.warn('[MemoryManagerAgent] Memory service not available for session management');
            return super.executeMode(modeSlug, params);
          }
          
          const activeSessions = await memoryService.getSessions(workspaceId);
          
          if (activeSessions && activeSessions.length > 0) {
            sessionId = activeSessions[0].id;
          }
          
          // If no active session, create one automatically for non-session modes
          // (for session creation, we don't want to create a session automatically)
          if (!sessionId && !modeSlug.startsWith('createSession')) {
            const newSession = await memoryService.createSession({
              workspaceId: workspaceId,
              name: `Auto-created session for ${modeSlug}`,
              description: `Automatically created for ${modeSlug} operation`
            });
            
            sessionId = newSession.id;
            console.log(`Created new session ${sessionId} for workspace ${workspaceId}`);
          }
          
          if (sessionId) {
            // Add the session ID to the parameters
            params.workspaceContext.sessionId = sessionId;
          }
        }
      } catch (error) {
        console.error('Failed to get/create session:', getErrorMessage(error));
      }
    }
    
    // Call the parent executeMode method
    return super.executeMode(modeSlug, params);
  }

  /**
   * Get a summary of available workspaces
   * @returns Formatted string with workspace information
   * @private
   */
  private getWorkspacesSummary(): string {
    try {
      // Check if workspace service is available using ServiceContainer
      const workspaceService = this.getWorkspaceService();
      if (!workspaceService) {
        return `üèóÔ∏è Workspaces: Service not available (initializing...)`;
      }

      // Service is available - return success message
      return `üèóÔ∏è Workspaces: Available (use listWorkspaces mode to see details)`;
      
    } catch (error) {
      return `üèóÔ∏è Workspaces: Error loading workspace information (${error})`;
    }
  }
}
```

## agents/memoryManager/modes/index.ts

```typescript
// Session modes (4 modes following workspace pattern)
export { CreateSessionMode } from './sessions/CreateSessionMode';
export { ListSessionsMode } from './sessions/ListSessionsMode';
export { LoadSessionMode } from './sessions/LoadSessionMode';
export { UpdateSessionMode } from './sessions/UpdateSessionMode';

// State modes (4 modes following workspace pattern)
export { CreateStateMode } from './states/CreateStateMode';
export { ListStatesMode } from './states/ListStatesMode';
export { LoadStateMode } from './states/LoadStateMode';
export { UpdateStateMode } from './states/UpdateStateMode';

// Workspace modes
export * from './workspaces';
```

## agents/memoryManager/modes/sessions/CreateSessionMode.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/sessions/CreateSessionMode.ts
 * Purpose: Consolidated session creation mode combining all create functionality from the original 15+ session files
 * 
 * This file consolidates:
 * - Original createSessionMode.ts functionality
 * - WorkspaceResolver service logic
 * - SessionCreator service logic  
 * - ContextBuilder service logic
 * - MemoryTracer service logic
 * - SessionInstructionManager service logic
 * 
 * Used by: MemoryManager agent for session creation operations
 */

import { App } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { MemoryManagerAgent } from '../../memoryManager'
import { CreateSessionParams, SessionResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams, WorkspaceContext } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService, GLOBAL_WORKSPACE_ID } from "../../services/WorkspaceService";
import { createServiceIntegration } from '../../services/ValidationService';
import { SchemaBuilder, SchemaType } from '../../../../utils/schemas/SchemaBuilder';

/**
 * Consolidated CreateSessionMode - combines all session creation functionality
 */
export class CreateSessionMode extends BaseMode<CreateSessionParams, SessionResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    private schemaBuilder: SchemaBuilder;

    constructor(private agent: MemoryManagerAgent) {
        super(
            'createSession',
            'Create Session', 
            'Creates a new tool activity tracking session with memory context',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
        this.schemaBuilder = new SchemaBuilder();
    }

    /**
     * Execute session creation with consolidated logic
     */
    async execute(params: CreateSessionParams): Promise<SessionResult> {
        try {
            // Phase 1: Get services and validate
            const servicesResult = await this.getServices();
            if (!servicesResult.success) {
                return this.prepareResult(false, undefined, servicesResult.error);
            }

            const { memoryService, workspaceService } = servicesResult;

            // Phase 2: Resolve workspace context (consolidated WorkspaceResolver logic)  
            const workspaceResult = await this.resolveWorkspaceContext(params, workspaceService!);
            if (!workspaceResult.success) {
                return this.prepareResult(false, undefined, workspaceResult.error, extractContextFromParams(params));
            }

            // Phase 3: Create session (consolidated SessionCreator logic)
            const sessionResult = await this.createSession(params, workspaceResult.data, memoryService!);
            if (!sessionResult.success) {
                return this.prepareResult(false, undefined, sessionResult.error);
            }

            // Phase 4: Build session context (consolidated ContextBuilder logic)
            const contextResult = await this.buildSessionContext(params, workspaceResult.data, sessionResult.data, workspaceService!);

            // Phase 5: Create memory traces (consolidated MemoryTracer logic)
            if (params.generateContextTrace !== false) {
                await this.createMemoryTraces(params, workspaceResult.data, sessionResult.data, contextResult, memoryService!);
            }

            // Phase 6: Process session instructions (consolidated SessionInstructionManager logic)
            const instructionResult = this.processSessionInstructions(
                sessionResult.data.id,
                this.extractContextString(params),
                sessionResult.data.name
            );

            // Phase 7: Prepare final result
            return this.prepareFinalResult(
                sessionResult.data,
                contextResult,
                instructionResult,
                workspaceResult.data
            );

        } catch (error) {
            return this.prepareResult(false, undefined, createErrorMessage('Error creating session: ', error));
        }
    }

    /**
     * Get required services with validation
     */
    private async getServices(): Promise<{success: boolean; error?: string; memoryService?: MemoryService; workspaceService?: WorkspaceService}> {
        const [memoryResult, workspaceResult] = await Promise.all([
            this.serviceIntegration.getMemoryService(),
            this.serviceIntegration.getWorkspaceService()
        ]);

        if (!memoryResult.success || !memoryResult.service) {
            return { success: false, error: `Memory service not available: ${memoryResult.error}` };
        }

        if (!workspaceResult.success || !workspaceResult.service) {
            return { success: false, error: `Workspace service not available: ${workspaceResult.error}` };
        }

        return { 
            success: true, 
            memoryService: memoryResult.service, 
            workspaceService: workspaceResult.service 
        };
    }

    /**
     * Resolve workspace context (consolidated from WorkspaceResolver service)
     */
    private async resolveWorkspaceContext(params: CreateSessionParams, workspaceService: WorkspaceService): Promise<{success: boolean; error?: string; data?: any}> {
        try {
            let workspaceId: string;
            let workspace: any;

            // Get workspace from params or inherited context
            const inheritedContext = this.getInheritedWorkspaceContext(params);
            const paramWorkspaceContext = params.workspaceContext;

            if (paramWorkspaceContext) {
                // Parse workspace context if it's a string
                let contextData: WorkspaceContext;
                if (typeof paramWorkspaceContext === 'string') {
                    try {
                        contextData = JSON.parse(paramWorkspaceContext);
                    } catch {
                        return { success: false, error: 'Invalid workspace context JSON format' };
                    }
                } else {
                    contextData = paramWorkspaceContext;
                }

                if (contextData.workspaceId) {
                    workspaceId = contextData.workspaceId;
                } else {
                    workspaceId = GLOBAL_WORKSPACE_ID;
                }
            } else if (inheritedContext?.workspaceId) {
                workspaceId = inheritedContext.workspaceId;
            } else {
                workspaceId = GLOBAL_WORKSPACE_ID;
            }

            // Get the workspace
            workspace = await workspaceService.getWorkspace(workspaceId);
            if (!workspace) {
                return { success: false, error: `Workspace not found: ${workspaceId}` };
            }

            return { success: true, data: { workspaceId, workspace } };

        } catch (error) {
            return { success: false, error: createErrorMessage('Error resolving workspace: ', error) };
        }
    }

    /**
     * Create session (consolidated from SessionCreator service)
     */
    private async createSession(params: CreateSessionParams, workspaceData: any, memoryService: MemoryService): Promise<{success: boolean; error?: string; data?: any}> {
        try {
            const sessionData = {
                workspaceId: workspaceData.workspaceId,
                name: params.name || `Session ${new Date().toLocaleString()}`,
                description: params.description || ''
            };

            // Use specific session ID if provided
            if (params.newSessionId) {
                (sessionData as any).id = params.newSessionId;
            }

            const session = await memoryService.createSession(sessionData);
            
            return { success: true, data: session };

        } catch (error) {
            return { success: false, error: createErrorMessage('Error creating session: ', error) };
        }
    }

    /**
     * Build session context (consolidated from ContextBuilder service)
     */
    private async buildSessionContext(params: CreateSessionParams, workspaceData: any, sessionData: any, workspaceService: WorkspaceService): Promise<any> {
        try {
            // Get previous session info if applicable
            let previousSessionInfo = '';
            if (params.previousSessionId) {
                try {
                    const prevSession = await workspaceService.getWorkspace(params.previousSessionId);
                    if (prevSession) {
                        previousSessionInfo = `Previous session: ${prevSession.name}`;
                    }
                } catch {
                    // Ignore errors getting previous session
                }
            }

            // Build context summary
            const summary = this.buildContextSummary(
                workspaceData.workspace,
                params.sessionGoal,
                params.contextDepth || 'standard',
                previousSessionInfo
            );

            return {
                summary,
                associatedNotes: [],
                sessionCreatedAt: new Date().toISOString()
            };

        } catch (error) {
            console.warn('Error building session context:', error);
            return {
                summary: 'Session created successfully',
                associatedNotes: [],
                sessionCreatedAt: new Date().toISOString()
            };
        }
    }

    /**
     * Create memory traces (consolidated from MemoryTracer service)
     */
    private async createMemoryTraces(
        params: CreateSessionParams,
        workspaceData: any,
        sessionData: any,
        contextResult: any,
        memoryService: MemoryService
    ): Promise<void> {
        try {
            const contextString = this.extractContextString(params);
            
            const traceContent = this.buildContextTraceContent(
                contextResult.summary,
                contextString,
                params.sessionGoal,
                params.previousSessionId
            );

            // Create memory trace
            await memoryService.createMemoryTrace({
                sessionId: sessionData.id,
                workspaceId: workspaceData.workspaceId,
                content: traceContent,
                type: 'session_creation',
                timestamp: Date.now(),
                metadata: {
                    tool: 'createSession',
                    params: { sessionName: params.name },
                    result: { sessionId: sessionData.id },
                    relatedFiles: []
                }
            });

        } catch (error) {
            console.warn('Warning creating memory traces:', error);
            // Don't fail session creation if memory trace fails
        }
    }

    /**
     * Process session instructions (consolidated from SessionInstructionManager service)
     */
    private processSessionInstructions(sessionId: string, contextString: string, sessionName: string): any {
        const shouldInclude = contextString && contextString.includes('instruction');
        
        return {
            shouldIncludeInstructions: shouldInclude,
            sessionInstructions: shouldInclude ? `Session "${sessionName}" created with context instructions` : undefined,
            finalContextString: contextString
        };
    }

    /**
     * Prepare final result
     */
    private prepareFinalResult(sessionData: any, contextResult: any, instructionResult: any, workspaceData: any): SessionResult {
        const resultData: any = {
            sessionId: sessionData.id,
            name: sessionData.name,
            description: sessionData.description,
            workspaceId: workspaceData.workspaceId,
            sessionContext: contextResult
        };

        if (instructionResult.shouldIncludeInstructions) {
            resultData.sessionInstructions = instructionResult.sessionInstructions;
        }

        return this.prepareResult(
            true,
            resultData,
            undefined,
            instructionResult.finalContextString
        );
    }

    /**
     * Helper methods (consolidated from various services)
     */
    private extractContextString(params: CreateSessionParams): string {
        if (params.context) {
            // Handle both string and object context types
            if (typeof params.context === 'string') {
                return params.context;
            } else {
                // Convert context object to string
                const parts: string[] = [];
                if (params.context.primaryGoal) parts.push(`Goal: ${params.context.primaryGoal}`);
                if (params.context.sessionMemory) parts.push(`Memory: ${params.context.sessionMemory}`);
                if (params.context.toolContext) parts.push(`Context: ${params.context.toolContext}`);
                if (params.context.subgoal) parts.push(`Subgoal: ${params.context.subgoal}`);
                return parts.join('. ');
            }
        }
        
        const parts: string[] = [];
        if (params.sessionGoal) parts.push(`Goal: ${params.sessionGoal}`);
        if (params.description) parts.push(`Description: ${params.description}`);
        if (params.previousSessionId) parts.push(`Continuation from: ${params.previousSessionId}`);
        
        return parts.join('. ');
    }

    private buildContextSummary(workspace: any, sessionGoal?: string, contextDepth: string = 'standard', previousSessionInfo?: string): string {
        const parts: string[] = [];
        
        parts.push(`Session started in workspace: ${workspace.name}`);
        if (sessionGoal) parts.push(`Goal: ${sessionGoal}`);
        if (previousSessionInfo) parts.push(previousSessionInfo);
        
        if (contextDepth === 'comprehensive' && workspace.context) {
            parts.push(`Workspace purpose: ${workspace.context.purpose}`);
            if (workspace.context.currentGoal) {
                parts.push(`Workspace goal: ${workspace.context.currentGoal}`);
            }
        }
        
        return parts.join('. ');
    }

    private buildContextTraceContent(summary: string, contextString: string, sessionGoal?: string, previousSessionId?: string): string {
        const parts: string[] = [];
        
        parts.push(`Session Context: ${summary}`);
        if (contextString) parts.push(`Details: ${contextString}`);
        if (sessionGoal) parts.push(`Session Goal: ${sessionGoal}`);
        if (previousSessionId) parts.push(`Continues from session: ${previousSessionId}`);
        
        return parts.join('\n\n');
    }

    /**
     * Schema methods using consolidated logic
     */
    getParameterSchema(): any {
        const baseSchema = this.schemaBuilder.buildParameterSchema(SchemaType.Session, {
            mode: 'createSession'
        });
        return this.getMergedSchema(baseSchema);
    }

    getResultSchema(): any {
        return this.schemaBuilder.buildResultSchema(SchemaType.Session, {
            mode: 'createSession'
        });
    }
}
```

## agents/memoryManager/modes/sessions/ListSessionsMode.ts

```typescript
/**
 * ListSessionsMode - Lists sessions with filtering and sorting capabilities
 * Following the same pattern as ListWorkspacesMode for consistency
 */

import { BaseMode } from '../../../baseMode';
import { MemoryManagerAgent } from '../../memoryManager'
import { ListSessionsParams, SessionResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService } from "../../services/WorkspaceService";

/**
 * Mode for listing sessions with filtering and sorting
 */
export class ListSessionsMode extends BaseMode<ListSessionsParams, SessionResult> {
  private agent: MemoryManagerAgent;

  constructor(agent: MemoryManagerAgent) {
    super(
      'listSessions',
      'List Sessions',
      'List sessions with optional filtering and sorting',
      '2.0.0'
    );
    this.agent = agent;
  }

  async execute(params: ListSessionsParams): Promise<SessionResult> {
    try {
      // Get services from agent
      const memoryService = await this.agent.getMemoryServiceAsync();
      const workspaceService = await this.agent.getWorkspaceServiceAsync();
      
      if (!memoryService) {
        return this.prepareResult(false, undefined, 'Memory service not available');
      }

      // Get workspace ID from context
      let workspaceId: string | undefined;
      const inheritedContext = this.getInheritedWorkspaceContext(params);
      if (inheritedContext?.workspaceId) {
        workspaceId = inheritedContext.workspaceId;
      }
      
      // Ensure workspaceId is defined
      const finalWorkspaceId = workspaceId || 'global-workspace-default';

      // Get sessions
      const sessions = await memoryService.getSessions(finalWorkspaceId);

      // No tag filtering needed since tags are not part of sessions anymore
      const filteredSessions = sessions;

      // Sort sessions
      const sortedSessions = this.sortSessions(filteredSessions, params.order || 'desc');

      // Apply limit
      const limitedSessions = params.limit ? sortedSessions.slice(0, params.limit) : sortedSessions;

      // Enhance session data with workspace names
      const enhancedSessions = workspaceService 
        ? await this.enhanceSessionsWithWorkspaceNames(limitedSessions, workspaceService)
        : limitedSessions.map(session => ({
            ...session,
            workspaceName: 'Unknown Workspace'
          }));

      // Prepare result
      const contextString = workspaceId 
        ? `Found ${limitedSessions.length} session(s) in workspace ${workspaceId}`
        : `Found ${limitedSessions.length} session(s) across all workspaces`;

      return this.prepareResult(
        true,
        {
          sessions: enhancedSessions,
          total: sessions.length,
          filtered: limitedSessions.length,
          workspaceId: workspaceId,
          filters: {
            order: params.order || 'desc',
            limit: params.limit
          }
        },
        undefined,
        contextString,
        inheritedContext || undefined
      );

    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error listing sessions: ', error));
    }
  }

  /**
   * Sort sessions by the specified order (by name since we don't have timestamps)
   */
  private sortSessions(sessions: any[], order: 'asc' | 'desc'): any[] {
    return sessions.sort((a, b) => {
      const nameA = (a.name || '').toLowerCase();
      const nameB = (b.name || '').toLowerCase();
      return order === 'asc' ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
    });
  }

  /**
   * Enhance sessions with workspace names
   */
  private async enhanceSessionsWithWorkspaceNames(sessions: any[], workspaceService: WorkspaceService): Promise<any[]> {
    const workspaceCache = new Map<string, string>();
    
    const enhanced = await Promise.all(sessions.map(async (session) => {
      let workspaceName = 'Unknown Workspace';
      
      if (!workspaceCache.has(session.workspaceId)) {
        try {
          const workspace = await workspaceService.getWorkspace(session.workspaceId);
          workspaceName = workspace?.name || 'Unknown Workspace';
          workspaceCache.set(session.workspaceId, workspaceName);
        } catch {
          workspaceCache.set(session.workspaceId, 'Unknown Workspace');
        }
      } else {
        workspaceName = workspaceCache.get(session.workspaceId)!;
      }

      return {
        ...session,
        workspaceName
      };
    }));

    return enhanced;
  }


  /**
   * Get workspace context from inherited parameters
   */
  protected getInheritedWorkspaceContext(params: ListSessionsParams): any {
    return extractContextFromParams(params);
  }

  /**
   * Prepare standardized result format
   */
  protected prepareResult(success: boolean, data?: any, contextData?: any, message?: string, workspaceContext?: any): SessionResult {
    return {
      success,
      data: data || {},
      workspaceContext
    };
  }

  getParameterSchema(): any {
    const customSchema = {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Maximum number of sessions to return'
        },
        order: {
          type: 'string',
          enum: ['asc', 'desc'],
          description: 'Sort order by name'
        }
      },
      additionalProperties: false
    };
    
    return this.getMergedSchema(customSchema);
  }

  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation was successful'
        },
        data: {
          type: 'object',
          description: 'Session data'
        },
        message: {
          type: 'string',
          description: 'Result message'
        },
        workspaceContext: {
          type: 'object',
          description: 'Workspace context'
        }
      },
      required: ['success'],
      additionalProperties: false
    };
  }
}
```

## agents/memoryManager/modes/sessions/LoadSessionMode.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/sessions/LoadSessionMode.ts
 * Purpose: Consolidated session loading mode combining all load functionality from original session files
 * 
 * This file consolidates:
 * - Original loadSessionMode.ts functionality
 * - LoadStateMode restoration logic
 * - SessionManager restoration logic
 * - WorkspaceContextBuilder logic
 * - RestorationTracer and RestorationSummaryGenerator logic
 * 
 * Used by: MemoryManager agent for session loading and continuation operations
 */

import { App } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { MemoryManagerAgent } from '../../memoryManager'
import { LoadSessionParams, SessionResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService } from "../../services/WorkspaceService";
import { createServiceIntegration } from '../../services/ValidationService';
import { SchemaBuilder, SchemaType } from '../../../../utils/schemas/SchemaBuilder';

/**
 * Consolidated LoadSessionMode - combines all session loading functionality
 */
export class LoadSessionMode extends BaseMode<LoadSessionParams, SessionResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    private schemaBuilder: SchemaBuilder;

    constructor(private agent: MemoryManagerAgent) {
        super(
            'loadSession',
            'Load Session',
            'Load an existing session and optionally create a continuation session',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
        this.schemaBuilder = new SchemaBuilder();
    }

    /**
     * Execute session loading with consolidated logic
     */
    async execute(params: LoadSessionParams): Promise<SessionResult> {
        try {
            // Phase 1: Get services and validate
            const servicesResult = await this.getServices();
            if (!servicesResult.success) {
                return this.prepareResult(false, undefined, servicesResult.error);
            }

            const { memoryService, workspaceService } = servicesResult;
            
            // Type assertions - services are guaranteed to be defined when success is true
            if (!memoryService || !workspaceService) {
                return this.prepareResult(false, undefined, 'Services not available after successful retrieval');
            }

            // Phase 2: Get target session ID (consolidated from parameter handling)
            const targetSessionId = params.targetSessionId || params.sessionId;
            if (!targetSessionId) {
                return this.prepareResult(false, undefined, 'No session ID provided to load');
            }

            // Phase 3: Load session data (consolidated from StateRetriever logic)
            const sessionResult = await this.loadSessionData(targetSessionId, memoryService);
            if (!sessionResult.success) {
                return this.prepareResult(false, undefined, sessionResult.error, extractContextFromParams(params));
            }

            // Phase 4: Build session context (consolidated from WorkspaceContextBuilder logic)
            const contextResult = await this.buildSessionContext(sessionResult.data, workspaceService, memoryService);

            // Phase 5: Create continuation session if requested (consolidated from SessionManager logic)
            let continuationSessionId: string | undefined;
            if (params.createContinuationSession !== false) {
                const continuationResult = await this.createContinuationSession(
                    params,
                    sessionResult.data,
                    contextResult,
                    memoryService
                );
                if (continuationResult.success) {
                    continuationSessionId = continuationResult.sessionId;
                }
            }

            // Phase 6: Generate restoration summary (consolidated from RestorationSummaryGenerator logic)
            const summaryResult = this.generateRestorationSummary(
                sessionResult.data,
                contextResult,
                continuationSessionId
            );

            // Phase 7: Create restoration trace (consolidated from RestorationTracer logic)
            if (continuationSessionId) {
                await this.createRestorationTrace(
                    sessionResult.data,
                    contextResult,
                    continuationSessionId,
                    memoryService
                );
            }

            // Phase 8: Prepare final result
            return this.prepareFinalResult(
                sessionResult.data,
                contextResult,
                summaryResult,
                continuationSessionId
            );

        } catch (error) {
            return this.prepareResult(false, undefined, createErrorMessage('Error loading session: ', error));
        }
    }

    /**
     * Get required services with validation
     */
    private async getServices(): Promise<{success: boolean; error?: string; memoryService?: MemoryService; workspaceService?: WorkspaceService}> {
        const [memoryResult, workspaceResult] = await Promise.all([
            this.serviceIntegration.getMemoryService(),
            this.serviceIntegration.getWorkspaceService()
        ]);

        if (!memoryResult.success || !memoryResult.service) {
            return { success: false, error: `Memory service not available: ${memoryResult.error}` };
        }

        if (!workspaceResult.success || !workspaceResult.service) {
            return { success: false, error: `Workspace service not available: ${workspaceResult.error}` };
        }

        return { 
            success: true, 
            memoryService: memoryResult.service, 
            workspaceService: workspaceResult.service 
        };
    }

    /**
     * Load session data (consolidated from StateRetriever logic)
     */
    private async loadSessionData(sessionId: string, memoryService: MemoryService): Promise<{success: boolean; error?: string; data?: any}> {
        try {
            // Get session from memory service
            const session = await memoryService.getSession(sessionId);
            if (!session) {
                return { success: false, error: `Session not found: ${sessionId}` };
            }

            // Get session traces for context
            const traces = await memoryService.getSessionTraces(sessionId);

            return { 
                success: true, 
                data: { 
                    session,
                    traces: traces || []
                }
            };

        } catch (error) {
            return { success: false, error: createErrorMessage('Error loading session data: ', error) };
        }
    }

    /**
     * Build session context (consolidated from WorkspaceContextBuilder logic)
     */
    private async buildSessionContext(sessionData: any, workspaceService: WorkspaceService, memoryService: MemoryService): Promise<any> {
        try {
            const { session, traces } = sessionData;
            
            // Get workspace for context
            let workspace: any;
            try {
                workspace = await workspaceService.getWorkspace(session.workspaceId);
            } catch {
                workspace = { name: 'Unknown Workspace' };
            }

            // Build context summary
            const summary = this.buildContextSummary(session, workspace, traces);

            // Get associated notes (files that were mentioned in traces)
            const associatedNotes = this.extractAssociatedNotes(traces);

            return {
                summary,
                associatedNotes,
                sessionCreatedAt: new Date(session.startTime).toISOString(),
                originalSessionId: session.id,
                traces: traces.slice(0, 10).map((trace: any) => ({
                    timestamp: trace.timestamp,
                    content: trace.content.substring(0, 200) + (trace.content.length > 200 ? '...' : ''),
                    type: trace.type,
                    importance: trace.importance
                })),
                tags: session.tags || []
            };

        } catch (error) {
            console.warn('Error building session context:', error);
            return {
                summary: `Session "${sessionData.session.name}" loaded successfully`,
                associatedNotes: [],
                sessionCreatedAt: new Date().toISOString(),
                originalSessionId: sessionData.session.id,
                traces: [],
                tags: []
            };
        }
    }

    /**
     * Create continuation session (consolidated from SessionManager logic)
     */
    private async createContinuationSession(
        params: LoadSessionParams,
        sessionData: any,
        contextResult: any,
        memoryService: MemoryService
    ): Promise<{success: boolean; error?: string; sessionId?: string}> {
        try {
            const originalSession = sessionData.session;

            // Create continuation session
            const continuationData = {
                workspaceId: originalSession.workspaceId,
                name: params.sessionName || `Continuation of "${originalSession.name}"`,
                description: params.sessionDescription || `Continuing session from previous session: ${originalSession.name}`
            };

            const continuationSession = await memoryService.createSession(continuationData);

            return { success: true, sessionId: continuationSession.id };

        } catch (error) {
            console.warn('Warning creating continuation session:', error);
            return { success: false, error: createErrorMessage('Error creating continuation session: ', error) };
        }
    }

    /**
     * Generate restoration summary (consolidated from RestorationSummaryGenerator logic)
     */
    private generateRestorationSummary(sessionData: any, contextResult: any, continuationSessionId?: string): any {
        const originalSession = sessionData.session;
        const traces = sessionData.traces || [];

        const summary = {
            sessionName: originalSession.name,
            originalStartTime: new Date(originalSession.startTime).toLocaleString(),
            workspaceId: originalSession.workspaceId,
            traceCount: traces.length,
            continuationSessionId,
            restorationTime: new Date().toLocaleString(),
            contextSummary: contextResult.summary,
            continuationHistory: undefined as any[] | undefined
        };

        // Add continuation history if applicable
        if (originalSession.previousSessionId) {
            summary['continuationHistory'] = [{
                timestamp: originalSession.startTime,
                description: `Originally continued from session ${originalSession.previousSessionId}`
            }];
        }

        return summary;
    }

    /**
     * Create restoration trace (consolidated from RestorationTracer logic)
     */
    private async createRestorationTrace(
        sessionData: any,
        contextResult: any,
        continuationSessionId: string,
        memoryService: MemoryService
    ): Promise<void> {
        try {
            const originalSession = sessionData.session;
            
            const traceContent = this.buildRestorationTraceContent(
                originalSession,
                contextResult,
                continuationSessionId
            );

            // Create restoration memory trace
            await memoryService.createMemoryTrace({
                sessionId: continuationSessionId,
                workspaceId: originalSession.workspaceId,
                content: traceContent,
                type: 'session_restoration',
                timestamp: Date.now(),
                metadata: {
                    tool: 'loadSession',
                    params: { originalSessionId: originalSession.id },
                    result: { continuationSessionId },
                    relatedFiles: []
                }
            });

        } catch (error) {
            console.warn('Warning creating restoration trace:', error);
            // Don't fail session loading if trace creation fails
        }
    }

    /**
     * Prepare final result
     */
    private prepareFinalResult(sessionData: any, contextResult: any, summaryResult: any, continuationSessionId?: string): SessionResult {
        const originalSession = sessionData.session;
        
        const resultData: any = {
            sessionId: originalSession.id,
            name: originalSession.name,
            workspaceId: originalSession.workspaceId,
            startTime: originalSession.startTime,
            endTime: originalSession.endTime,
            isActive: originalSession.isActive,
            newSessionId: continuationSessionId,
            sessionContext: contextResult,
            restoredContext: {
                summary: contextResult.summary,
                associatedNotes: contextResult.associatedNotes,
                stateCreatedAt: contextResult.sessionCreatedAt,
                originalSessionId: originalSession.id,
                continuationHistory: summaryResult.continuationHistory,
                tags: contextResult.tags
            }
        };

        const contextString = continuationSessionId 
            ? `Loaded session "${originalSession.name}" and created continuation session ${continuationSessionId}`
            : `Loaded session "${originalSession.name}"`;

        return this.prepareResult(
            true,
            resultData,
            undefined,
            contextString
        );
    }

    /**
     * Helper methods (consolidated from various services)
     */
    private buildContextSummary(session: any, workspace: any, traces: any[]): string {
        const parts: string[] = [];
        
        parts.push(`Loaded session: "${session.name}"`);
        parts.push(`Workspace: ${workspace.name}`);
        
        if (session.description) {
            parts.push(`Description: ${session.description}`);
        }
        
        if (session.sessionGoal) {
            parts.push(`Goal: ${session.sessionGoal}`);
        }
        
        if (traces.length > 0) {
            parts.push(`${traces.length} memory traces available`);
        }
        
        const sessionAge = Date.now() - session.startTime;
        const daysAgo = Math.floor(sessionAge / (1000 * 60 * 60 * 24));
        if (daysAgo > 0) {
            parts.push(`Created ${daysAgo} day${daysAgo === 1 ? '' : 's'} ago`);
        } else {
            const hoursAgo = Math.floor(sessionAge / (1000 * 60 * 60));
            if (hoursAgo > 0) {
                parts.push(`Created ${hoursAgo} hour${hoursAgo === 1 ? '' : 's'} ago`);
            } else {
                parts.push('Created recently');
            }
        }
        
        return parts.join('. ');
    }

    private extractAssociatedNotes(traces: any[]): string[] {
        const noteSet = new Set<string>();
        
        traces.forEach(trace => {
            if (trace.content && typeof trace.content === 'string') {
                // Extract file references from trace content
                const fileMatches = trace.content.match(/\b[\w-]+\.md\b/g);
                if (fileMatches) {
                    fileMatches.forEach((match: string) => noteSet.add(match));
                }
            }
        });
        
        return Array.from(noteSet).slice(0, 10); // Limit to 10 notes
    }

    private buildRestorationTraceContent(originalSession: any, contextResult: any, continuationSessionId: string): string {
        const parts: string[] = [];
        
        parts.push(`Session Restoration: Loaded session "${originalSession.name}"`);
        parts.push(`Original session created: ${new Date(originalSession.startTime).toLocaleString()}`);
        parts.push(`Continuation session created: ${continuationSessionId}`);
        parts.push(`Context: ${contextResult.summary}`);
        
        if (contextResult.associatedNotes.length > 0) {
            parts.push(`Associated files: ${contextResult.associatedNotes.slice(0, 5).join(', ')}`);
        }
        
        return parts.join('\n\n');
    }

    /**
     * Schema methods using consolidated logic
     */
    getParameterSchema(): any {
        const baseSchema = this.schemaBuilder.buildParameterSchema(SchemaType.Session, {
            mode: 'loadSession'
        });
        return this.getMergedSchema(baseSchema);
    }

    getResultSchema(): any {
        return this.schemaBuilder.buildResultSchema(SchemaType.Session, {
            mode: 'loadSession'
        });
    }
}
```

## agents/memoryManager/modes/sessions/UpdateSessionMode.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/sessions/ManageSessionMode.ts
 * Purpose: Consolidated session management mode combining edit, delete, and list functionality
 * 
 * This file consolidates:
 * - Original editSessionMode.ts functionality
 * - Original deleteSessionMode.ts functionality  
 * - Original listSessionsMode.ts functionality
 * - Session validation and management logic
 * 
 * Used by: MemoryManager agent for session management operations
 */

import { App } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { MemoryManagerAgent } from '../../memoryManager'
import { EditSessionParams, SessionResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService } from "../../services/WorkspaceService";
import { createServiceIntegration } from '../../services/ValidationService';
import { SchemaBuilder, SchemaType } from '../../../../utils/schemas/SchemaBuilder';

/**
 * Union type for all management parameters
 */
type UpdateSessionParams = EditSessionParams;

/**
 * Consolidated UpdateSessionMode - combines all session update functionality
 */
export class UpdateSessionMode extends BaseMode<UpdateSessionParams, SessionResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    private schemaBuilder: SchemaBuilder;

    constructor(private agent: MemoryManagerAgent) {
        super(
            'updateSession',
            'Update Session',
            'Edit, delete, or list sessions with comprehensive update capabilities',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
        this.schemaBuilder = new SchemaBuilder();
    }

    /**
     * Execute session management based on operation type
     */
    async execute(params: UpdateSessionParams): Promise<SessionResult> {
        try {
            // Determine operation type based on parameters
            const operation = this.determineOperation(params);
            
            // Only edit operation supported
            return this.executeEdit(params);

        } catch (error) {
            return this.prepareResult(false, undefined, createErrorMessage('Error managing session: ', error));
        }
    }

    /**
     * Determine operation type from parameters
     */
    private determineOperation(params: UpdateSessionParams): 'edit' {
        // Only edit operation supported
        return 'edit';
    }

    /**
     * Execute edit session operation (consolidated from editSessionMode.ts)
     */
    private async executeEdit(params: EditSessionParams): Promise<SessionResult> {
        // Phase 1: Get services and validate
        const servicesResult = await this.getServices();
        if (!servicesResult.success) {
            return this.prepareResult(false, undefined, servicesResult.error);
        }

        const { memoryService } = servicesResult;
        if (!memoryService) {
            return this.prepareResult(false, undefined, 'Memory service not available');
        }

        // Phase 2: Get target session ID
        const targetSessionId = params.targetSessionId || params.sessionId;
        if (!targetSessionId) {
            return this.prepareResult(false, undefined, 'No session ID provided for editing');
        }

        // Phase 3: Load existing session
        const existingSession = await memoryService.getSession(targetSessionId);
        if (!existingSession) {
            return this.prepareResult(false, undefined, `Session not found: ${targetSessionId}`, extractContextFromParams(params));
        }

        // Phase 4: Prepare updates
        const updates: any = {};
        let hasUpdates = false;

        if (params.name !== undefined) {
            updates.name = params.name;
            hasUpdates = true;
        }

        if (params.description !== undefined) {
            updates.description = params.description;
            hasUpdates = true;
        }

        if (params.sessionGoal !== undefined) {
            updates.sessionGoal = params.sessionGoal;
            hasUpdates = true;
        }

        if (!hasUpdates) {
            return this.prepareResult(false, undefined, 'No updates provided for session');
        }

        // Phase 5: Get current session and apply updates
        const currentSession = await memoryService.getSession(targetSessionId);
        if (!currentSession) {
            return this.prepareResult(false, undefined, `Session ${targetSessionId} not found`);
        }

        const updatedSession = { ...currentSession, ...updates };
        await memoryService.updateSession(updatedSession);

        // Phase 6: Prepare result
        return this.prepareResult(
            true,
            {
                sessionId: updatedSession.id,
                name: updatedSession.name,
                description: updatedSession.description,
                workspaceId: updatedSession.workspaceId
            },
            undefined,
            `Session "${updatedSession.name}" updated successfully`
        );
    }



    /**
     * Get required services with validation
     */
    private async getServices(): Promise<{success: boolean; error?: string; memoryService?: MemoryService; workspaceService?: WorkspaceService}> {
        const [memoryResult, workspaceResult] = await Promise.all([
            this.serviceIntegration.getMemoryService(),
            this.serviceIntegration.getWorkspaceService()
        ]);

        if (!memoryResult.success || !memoryResult.service) {
            return { success: false, error: `Memory service not available: ${memoryResult.error}` };
        }

        if (!workspaceResult.success || !workspaceResult.service) {
            return { success: false, error: `Workspace service not available: ${workspaceResult.error}` };
        }

        return { 
            success: true, 
            memoryService: memoryResult.service, 
            workspaceService: workspaceResult.service 
        };
    }


    /**
     * Schema methods - returns combined schema for all operations
     */
    getParameterSchema(): any {
        // Combined schema that supports edit and delete operations
        const customSchema = {
            type: 'object',
            properties: {
                // Common parameters
                sessionId: {
                    type: 'string',
                    description: 'Session ID for tracking this operation'
                },
                workspaceContext: {
                    type: 'object',
                    description: 'Workspace context for scoping operations'
                },

                // Edit operation parameters
                targetSessionId: {
                    type: 'string',
                    description: 'ID of session to edit'
                },
                name: {
                    type: 'string',
                    description: 'New session name (for edit operations)'
                },
                description: {
                    type: 'string',
                    description: 'New session description (for edit operations)'
                },
                sessionGoal: {
                    type: 'string',
                    description: 'New session goal (for edit operations)'
                },
                isActive: {
                    type: 'boolean',
                    description: 'Whether session is active (for edit operations)'
                },
                addTags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Tags to add to session (for edit operations)'
                },
                removeTags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Tags to remove from session (for edit operations)'
                }
            },
            additionalProperties: false
        };
        
        return this.getMergedSchema(customSchema);
    }

    getResultSchema(): any {
        return this.schemaBuilder.buildResultSchema(SchemaType.Session, {
            mode: 'manageSessions'
        });
    }
}
```

## agents/memoryManager/modes/states/CreateStateMode.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/states/CreateStateMode.ts
 * Purpose: Consolidated state creation mode combining all create functionality from original state files
 * 
 * This file consolidates:
 * - Original createStateMode.ts functionality
 * - StateCreator service logic
 * - Parameter validation logic
 * - Context building and tracing logic
 * 
 * Used by: MemoryManager agent for state creation operations
 */

import { App } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { MemoryManagerAgent } from '../../memoryManager'
import { CreateStateParams, StateResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService, GLOBAL_WORKSPACE_ID } from "../../services/WorkspaceService";
import { createServiceIntegration, ValidationError } from '../../services/ValidationService';
import { SchemaBuilder, SchemaType } from '../../../../utils/schemas/SchemaBuilder';
import { CommonParameters } from '../../../../types/mcp/AgentTypes';
import { addRecommendations } from '../../../../utils/recommendationUtils';

/**
 * Consolidated CreateStateMode - combines all state creation functionality
 */
export class CreateStateMode extends BaseMode<CreateStateParams, StateResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    private schemaBuilder: SchemaBuilder;

    constructor(private agent: MemoryManagerAgent) {
        super(
            'createState',
            'Create State',
            'Create a state with restoration context for later resumption',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 3,
            fallbackBehavior: 'warn'
        });
        this.schemaBuilder = new SchemaBuilder();
    }

    /**
     * Execute state creation with consolidated logic
     */
    async execute(params: CreateStateParams): Promise<StateResult> {
        const startTime = Date.now();
        
        try {
            // Phase 1: Get services and validate
            const servicesResult = await this.getServices();
            if (!servicesResult.success) {
                return this.prepareResult(false, undefined, servicesResult.error);
            }

            const { memoryService, workspaceService } = servicesResult;
            
            // Ensure services are available
            if (!memoryService || !workspaceService) {
                return this.prepareResult(false, undefined, 'Required services not available');
            }

            // Phase 2: Validate parameters (consolidated validation logic)
            const validationErrors = this.validateParameters(params);
            if (validationErrors.length > 0) {
                const firstError = validationErrors[0];
                return this.prepareResult(
                    false, 
                    undefined, 
                    `Validation error - ${firstError.field}: ${firstError.requirement}`,
                    extractContextFromParams(params)
                );
            }

            // Phase 3: Resolve workspace context (consolidated workspace resolution)
            const workspaceResult = await this.resolveWorkspaceContext(params, workspaceService);
            if (!workspaceResult.success) {
                return this.prepareResult(false, undefined, workspaceResult.error, extractContextFromParams(params));
            }

            // Phase 4: Build state snapshot (consolidated from StateCreator logic)
            const snapshotResult = await this.buildStateSnapshot(params, workspaceResult.data, workspaceService);

            // Phase 5: Create and persist state (consolidated persistence logic)
            const persistResult = await this.createAndPersistState(params, workspaceResult.data, snapshotResult, memoryService);
            if (!persistResult.success) {
                return this.prepareResult(false, undefined, persistResult.error, extractContextFromParams(params));
            }
            
            // Ensure stateId is available
            if (!persistResult.stateId) {
                return this.prepareResult(false, undefined, 'State creation failed - no state ID returned', extractContextFromParams(params));
            }

            // Phase 6: Verify persistence (data integrity check)
            const verificationResult = await this.verifyStatePersistence(persistResult.stateId, memoryService);
            if (!verificationResult.success) {
                // Rollback if verification fails
                await this.rollbackState(persistResult.stateId, memoryService);
                return this.prepareResult(false, undefined, `State verification failed: ${verificationResult.error}`, extractContextFromParams(params));
            }

            // Phase 7: Prepare final result
            return this.prepareFinalResult(
                persistResult.stateId,
                persistResult.savedSnapshot,
                snapshotResult,
                workspaceResult.data,
                startTime,
                params
            );

        } catch (error) {
            return this.prepareResult(false, undefined, createErrorMessage('Error creating state: ', error));
        }
    }

    /**
     * Get required services with validation
     */
    private async getServices(): Promise<{success: boolean; error?: string; memoryService?: MemoryService; workspaceService?: WorkspaceService}> {
        const [memoryResult, workspaceResult] = await Promise.all([
            this.serviceIntegration.getMemoryService(),
            this.serviceIntegration.getWorkspaceService()
        ]);

        if (!memoryResult.success || !memoryResult.service) {
            return { success: false, error: `Memory service not available: ${memoryResult.error}` };
        }

        if (!workspaceResult.success || !workspaceResult.service) {
            return { success: false, error: `Workspace service not available: ${workspaceResult.error}` };
        }

        return { 
            success: true, 
            memoryService: memoryResult.service, 
            workspaceService: workspaceResult.service 
        };
    }

    /**
     * Validate state creation parameters (consolidated validation logic)
     */
    private validateParameters(params: CreateStateParams): ValidationError[] {
        // Use consolidated validation service
        const errors = this.serviceIntegration.validateStateCreationParams(params);
        
        // Add any additional state-specific validations
        if (params.maxFiles !== undefined && params.maxFiles < 0) {
            errors.push({
                field: 'maxFiles',
                value: params.maxFiles,
                requirement: 'Maximum files must be a non-negative number'
            });
        }

        if (params.maxTraces !== undefined && params.maxTraces < 0) {
            errors.push({
                field: 'maxTraces',
                value: params.maxTraces,
                requirement: 'Maximum traces must be a non-negative number'
            });
        }

        return errors;
    }

    /**
     * Resolve workspace context (consolidated workspace resolution)
     */
    private async resolveWorkspaceContext(params: CreateStateParams, workspaceService: WorkspaceService): Promise<{success: boolean; error?: string; data?: any}> {
        try {
            // Get workspace from inherited context or use global workspace
            const inheritedContext = this.getInheritedWorkspaceContext(params);
            let workspaceId: string;
            
            if (inheritedContext?.workspaceId) {
                workspaceId = inheritedContext.workspaceId;
            } else {
                workspaceId = GLOBAL_WORKSPACE_ID;
            }

            // Get the workspace to capture its current context
            const workspace = await workspaceService.getWorkspace(workspaceId);
            if (!workspace) {
                return { success: false, error: `Workspace not found: ${workspaceId}` };
            }

            return { success: true, data: { workspaceId, workspace } };

        } catch (error) {
            return { success: false, error: createErrorMessage('Error resolving workspace: ', error) };
        }
    }

    /**
     * Build state snapshot (consolidated from StateCreator logic)
     */
    private async buildStateSnapshot(params: CreateStateParams, workspaceData: any, workspaceService: WorkspaceService): Promise<any> {
        const { workspace } = workspaceData;
        
        // Extract or create workspace context
        let currentWorkspaceContext;
        if (workspace.context) {
            currentWorkspaceContext = workspace.context;
        } else {
            // Create basic context for legacy workspace
            currentWorkspaceContext = {
                purpose: workspace.description || `Work in ${workspace.name}`,
                currentGoal: 'Continue workspace tasks',
                status: 'In progress',
                workflows: [],
                keyFiles: [],
                preferences: [],
                agents: [],
            };
        }

        // Build the state snapshot from LLM input
        const snapshot = {
            workspaceContext: currentWorkspaceContext,
            conversationContext: params.conversationContext,
            activeTask: params.activeTask,
            activeFiles: params.activeFiles || [],
            nextSteps: params.nextSteps || [],
            reasoning: params.reasoning
        };

        return {
            snapshot,
            workspaceContext: currentWorkspaceContext
        };
    }

    /**
     * Create and persist state (consolidated persistence logic)
     */
    private async createAndPersistState(
        params: CreateStateParams,
        workspaceData: any,
        snapshotResult: any,
        memoryService: MemoryService
    ): Promise<{success: boolean; error?: string; stateId?: string; savedSnapshot?: any}> {
        try {
            const { workspaceId, workspace } = workspaceData;
            const { snapshot } = snapshotResult;
            const now = Date.now();

            // Build WorkspaceStateSnapshot for storage following the architecture design
            const snapshotData = {
                name: params.name,
                workspaceId: workspaceId,
                created: now,
                snapshot: snapshot,
                sessionId: params.targetSessionId || params.context.sessionId || 'current',
                timestamp: now,
                description: `${params.activeTask} - ${params.reasoning}`,
                state: {
                    workspace,
                    recentTraces: [], // Could be populated from current session
                    contextFiles: params.activeFiles || [],
                    metadata: {
                        createdBy: 'CreateStateMode',
                        version: '2.0.0',
                        creationMethod: 'manual',
                        includeSummary: params.includeSummary || false,
                        includeFileContents: params.includeFileContents || false,
                        maxFiles: params.maxFiles,
                        maxTraces: params.maxTraces,
                        reason: params.reason,
                        tags: params.tags || []
                    }
                }
            };

            // Persist to MemoryService
            const savedSnapshot = await memoryService.createSnapshot(snapshotData);
            
            return { success: true, stateId: savedSnapshot.id, savedSnapshot };

        } catch (error) {
            return { success: false, error: createErrorMessage('Error persisting state: ', error) };
        }
    }

    /**
     * Verify that a state was properly persisted
     */
    private async verifyStatePersistence(stateId: string, memoryService: MemoryService): Promise<{success: boolean; error?: string}> {
        try {
            const retrieved = await memoryService.getSnapshot(stateId);
            if (!retrieved) {
                return { success: false, error: 'State not found after creation' };
            }

            if (!retrieved.snapshot || !retrieved.snapshot.activeTask) {
                return { success: false, error: 'State data incomplete after persistence' };
            }

            if (!retrieved.workspaceId || !retrieved.name) {
                return { success: false, error: 'Critical state fields missing after persistence' };
            }

            return { success: true };
        } catch (error) {
            return { success: false, error: createErrorMessage('Verification failed: ', error) };
        }
    }

    /**
     * Rollback a state creation if verification fails
     */
    private async rollbackState(stateId: string, memoryService: MemoryService): Promise<void> {
        try {
            await memoryService.deleteSnapshot(stateId);
            console.warn(`[CreateStateMode] Rolled back state ${stateId} due to verification failure`);
        } catch (error) {
            console.error(`[CreateStateMode] Failed to rollback state ${stateId}:`, error);
            // Don't throw here - verification failure is the primary issue
        }
    }

    /**
     * Prepare final result
     */
    private prepareFinalResult(
        stateId: string,
        savedSnapshot: any,
        snapshotResult: any,
        workspaceData: any,
        startTime: number,
        params: CreateStateParams
    ): StateResult {
        const { workspace } = workspaceData;
        
        const resultData = {
            stateId: savedSnapshot.id,
            name: savedSnapshot.name,
            workspaceId: savedSnapshot.workspaceId,
            sessionId: savedSnapshot.sessionId,
            timestamp: savedSnapshot.timestamp,
            created: savedSnapshot.created,
            summary: `State "${savedSnapshot.name}" saved successfully. Task: ${snapshotResult.snapshot.activeTask}`,
            metadata: {
                persistenceVerified: true,
                workspaceName: workspace.name,
                totalActiveFiles: snapshotResult.snapshot.activeFiles.length,
                nextStepsCount: snapshotResult.snapshot.nextSteps.length
            },
            capturedContext: {
                summary: `${snapshotResult.snapshot.activeTask} - ${snapshotResult.snapshot.reasoning}`,
                conversationContext: snapshotResult.snapshot.conversationContext,
                activeFiles: snapshotResult.snapshot.activeFiles,
                nextSteps: snapshotResult.snapshot.nextSteps
            },
            performance: {
                totalDuration: Date.now() - startTime,
                persistenceVerified: true
            }
        };

        const contextString = `State "${savedSnapshot.name}" created and persisted successfully with ID: ${savedSnapshot.id}`;
        const workspaceContext = this.getInheritedWorkspaceContext({ 
            context: { 
                sessionId: params.context.sessionId,
                sessionDescription: params.context.sessionDescription,
                sessionMemory: params.context.sessionMemory,
                toolContext: params.context.toolContext,
                primaryGoal: params.context.primaryGoal,
                subgoal: params.context.subgoal
            },
            workspaceContext: { workspaceId: workspaceData.workspaceId } 
        } as CommonParameters);

        const result = this.prepareResult(
            true,
            resultData,
            undefined,
            contextString,
            workspaceContext || undefined
        );

        // Add standardized recommendation
        return addRecommendations(result, [
            {
                type: "workspace_update",
                message: "STRONGLY RECOMMENDED: Use the updateWorkspace tool to ensure you have the latest workspace information (such as preferences, workflow, etc.) based on this conversation before proceeding with any tasks."
            }
        ]);
    }

    /**
     * Schema methods using consolidated logic
     */
    getParameterSchema(): any {
        const customSchema = {
            type: 'object',
            properties: {
                name: {
                    type: 'string',
                    description: 'State name (REQUIRED)'
                },
                conversationContext: {
                    type: 'string',
                    description: 'What was happening when you decided to save this state? (REQUIRED) Provide a summary of the conversation and what you were working on. Example: "We were customizing the cover letter for Google\'s Marketing Manager position. We researched their team and identified key requirements."'
                },
                activeTask: {
                    type: 'string',
                    description: 'What task were you actively working on? (REQUIRED) Be specific about the current task. Example: "Finishing the cover letter paragraph about data-driven campaign optimization results"'
                },
                activeFiles: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Which files were you working with? (REQUIRED) List the files that were being edited or referenced. Example: ["cover-letter-google.md", "application-tracker.md"]'
                },
                nextSteps: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'What are the immediate next steps when you resume? (REQUIRED) Provide specific actionable next steps. Example: ["Complete cover letter customization", "Review resume for Google-specific keywords", "Submit application"]'
                },
                reasoning: {
                    type: 'string',
                    description: 'Why are you saving this state right now? (REQUIRED) Explain the reason for saving at this point. Example: "Saving before context limit, about to submit application"'
                },
                
                // Optional fields
                description: { 
                    type: 'string', 
                    description: 'Optional description for the state' 
                },
                targetSessionId: { 
                    type: 'string', 
                    description: 'Target session ID (optional, defaults to current session)' 
                },
                includeSummary: { 
                    type: 'boolean', 
                    description: 'Whether to include a summary (default: false)' 
                },
                includeFileContents: { 
                    type: 'boolean', 
                    description: 'Whether to include file contents (default: false)' 
                },
                maxFiles: { 
                    type: 'number', 
                    description: 'Maximum number of files to include' 
                },
                maxTraces: { 
                    type: 'number', 
                    description: 'Maximum number of memory traces to include' 
                },
                tags: { 
                    type: 'array', 
                    items: { type: 'string' }, 
                    description: 'Tags to associate with the state' 
                },
                reason: { 
                    type: 'string', 
                    description: 'Additional reason for creating this state' 
                }
            },
            required: ['name', 'conversationContext', 'activeTask', 'activeFiles', 'nextSteps', 'reasoning'],
            additionalProperties: false
        };
        
        return this.getMergedSchema(customSchema);
    }

    getResultSchema(): any {
        return this.schemaBuilder.buildResultSchema(SchemaType.State, {
            mode: 'createState'
        });
    }
}
```

## agents/memoryManager/modes/states/ListStatesMode.ts

```typescript
/**
 * ListStatesMode - Lists state snapshots with filtering and sorting capabilities
 * Following the same pattern as ListWorkspacesMode for consistency
 */

import { BaseMode } from '../../../baseMode';
import { MemoryManagerAgent } from '../../memoryManager'
import { ListStatesParams, StateResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService } from "../../services/WorkspaceService";

/**
 * Mode for listing state snapshots with filtering and sorting
 */
export class ListStatesMode extends BaseMode<ListStatesParams, StateResult> {
  private agent: MemoryManagerAgent;

  constructor(agent: MemoryManagerAgent) {
    super(
      'listStates',
      'List States',
      'List state snapshots with optional filtering and sorting',
      '2.0.0'
    );
    this.agent = agent;
  }

  async execute(params: ListStatesParams): Promise<StateResult> {
    try {
      // Get services from agent
      const memoryService = await this.agent.getMemoryServiceAsync();
      const workspaceService = await this.agent.getWorkspaceServiceAsync();
      
      if (!memoryService) {
        return this.prepareResult(false, undefined, 'Memory service not available');
      }

      // Get workspace ID from context
      let workspaceId: string | undefined;
      const inheritedContext = this.getInheritedWorkspaceContext(params);
      if (inheritedContext?.workspaceId) {
        workspaceId = inheritedContext.workspaceId;
      }

      // Get states
      const states = await memoryService.getStates(workspaceId);

      // Filter by session ID if provided
      let filteredStates = states;
      if (params.context.sessionId) {
        filteredStates = states.filter(state => state.sessionId === params.context.sessionId);
      }

      // Filter by tags if provided
      if (params.tags && params.tags.length > 0) {
        filteredStates = filteredStates.filter(state => {
          const stateTags = state.state?.metadata?.tags || [];
          return params.tags!.some(tag => stateTags.includes(tag));
        });
      }

      // Sort states
      const sortedStates = this.sortStates(filteredStates, params.order || 'desc');

      // Apply limit
      const limitedStates = params.limit ? sortedStates.slice(0, params.limit) : sortedStates;

      // Enhance state data
      const enhancedStates = workspaceService
        ? await this.enhanceStatesWithContext(limitedStates, workspaceService, params.includeContext)
        : limitedStates.map(state => ({
            ...state,
            workspaceName: 'Unknown Workspace',
            created: state.created || state.timestamp
          }));

      // Prepare result
      const contextString = workspaceId 
        ? `Found ${limitedStates.length} state(s) in workspace ${workspaceId}`
        : `Found ${limitedStates.length} state(s) across all workspaces`;

      return this.prepareResult(
        true,
        {
          states: enhancedStates,
          total: states.length,
          filtered: limitedStates.length,
          workspaceId: workspaceId,
          filters: {
            sessionId: params.context.sessionId,
            tags: params.tags || [],
            order: params.order || 'desc',
            limit: params.limit,
            includeContext: params.includeContext
          }
        },
        undefined,
        contextString,
        inheritedContext || undefined
      );

    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error listing states: ', error));
    }
  }

  /**
   * Sort states by creation date
   */
  private sortStates(states: any[], order: 'asc' | 'desc'): any[] {
    return states.sort((a, b) => {
      const timeA = a.timestamp || a.created || 0;
      const timeB = b.timestamp || b.created || 0;
      return order === 'asc' ? timeA - timeB : timeB - timeA;
    });
  }

  /**
   * Enhance states with workspace names and context
   */
  private async enhanceStatesWithContext(states: any[], workspaceService: WorkspaceService, includeContext?: boolean): Promise<any[]> {
    const workspaceCache = new Map<string, string>();
    
    return await Promise.all(states.map(async (state) => {
      let workspaceName = 'Unknown Workspace';
      
      if (!workspaceCache.has(state.workspaceId)) {
        try {
          const workspace = await workspaceService.getWorkspace(state.workspaceId);
          workspaceName = workspace?.name || 'Unknown Workspace';
          workspaceCache.set(state.workspaceId, workspaceName);
        } catch {
          workspaceCache.set(state.workspaceId, 'Unknown Workspace');
        }
      } else {
        workspaceName = workspaceCache.get(state.workspaceId)!;
      }

      const enhanced: any = {
        ...state,
        workspaceName,
        created: state.created || state.timestamp
      };

      if (includeContext && state.snapshot) {
        enhanced.context = {
          files: state.snapshot.activeFiles || [],
          traceCount: 0, // Could be enhanced to count related traces
          tags: state.state?.metadata?.tags || [],
          summary: state.snapshot.activeTask || 'No active task recorded'
        };
      }

      return enhanced;
    }));
  }


  /**
   * Get workspace context from inherited parameters
   */
  protected getInheritedWorkspaceContext(params: ListStatesParams): any {
    return extractContextFromParams(params);
  }

  /**
   * Prepare standardized result format
   */
  protected prepareResult(success: boolean, data?: any, contextData?: any, message?: string, workspaceContext?: any): StateResult {
    return {
      success,
      data: data || {},
      workspaceContext
    };
  }

  getParameterSchema(): any {
    const customSchema = {
      type: 'object',
      properties: {
        sessionId: {
          type: 'string',
          description: 'Filter by session ID'
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Filter by tags'
        },
        limit: {
          type: 'number',
          description: 'Maximum number of states to return'
        },
        order: {
          type: 'string',
          enum: ['asc', 'desc'],
          description: 'Sort order by creation date'
        },
        includeContext: {
          type: 'boolean',
          description: 'Include context information'
        }
      },
      additionalProperties: false
    };
    
    return this.getMergedSchema(customSchema);
  }

  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation was successful'
        },
        data: {
          type: 'object',
          description: 'State data'
        },
        message: {
          type: 'string',
          description: 'Result message'
        },
        workspaceContext: {
          type: 'object',
          description: 'Workspace context'
        }
      },
      required: ['success'],
      additionalProperties: false
    };
  }
}
```

## agents/memoryManager/modes/states/LoadStateMode.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/states/LoadStateMode.ts
 * Purpose: Consolidated state loading mode combining all load functionality from original state files
 * 
 * This file consolidates:
 * - Original loadStateMode.ts functionality
 * - StateRetriever and restoration logic
 * - FileCollector and TraceProcessor logic
 * - SessionManager and WorkspaceContextBuilder logic
 * - RestorationSummaryGenerator and RestorationTracer logic
 * 
 * Used by: MemoryManager agent for state loading and restoration operations
 */

import { App } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { MemoryManagerAgent } from '../../memoryManager'
import { LoadStateParams, StateResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService } from "../../services/WorkspaceService";
import { createServiceIntegration } from '../../services/ValidationService';
import { SchemaBuilder, SchemaType } from '../../../../utils/schemas/SchemaBuilder';

/**
 * Consolidated LoadStateMode - combines all state loading functionality
 */
export class LoadStateMode extends BaseMode<LoadStateParams, StateResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    private schemaBuilder: SchemaBuilder;

    constructor(private agent: MemoryManagerAgent) {
        super(
            'loadState',
            'Load State',
            'Load a saved state and optionally create a continuation session with restored context',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
        this.schemaBuilder = new SchemaBuilder();
    }

    /**
     * Execute state loading with consolidated logic
     */
    async execute(params: LoadStateParams): Promise<StateResult> {
        try {
            // Phase 1: Get services and validate
            const servicesResult = await this.getServices();
            if (!servicesResult.success) {
                return this.prepareResult(false, undefined, servicesResult.error);
            }

            const { memoryService, workspaceService } = servicesResult;

            // Phase 2: Load state data (consolidated from StateRetriever logic)
            if (!memoryService) {
                return this.prepareResult(false, undefined, 'Memory service not available', extractContextFromParams(params));
            }
            const stateResult = await this.loadStateData(params.stateId, memoryService);
            if (!stateResult.success) {
                return this.prepareResult(false, undefined, stateResult.error, extractContextFromParams(params));
            }

            // Phase 3: Process and restore context (consolidated from FileCollector and TraceProcessor logic)
            if (!workspaceService) {
                return this.prepareResult(false, undefined, 'Workspace service not available', extractContextFromParams(params));
            }
            const contextResult = await this.processAndRestoreContext(stateResult.data, workspaceService, memoryService);

            // Phase 4: Handle session continuation (consolidated from SessionManager logic)
            let continuationSessionId: string | undefined;
            if (params.continueExistingSession !== false) {
                // Continue with original session ID
                continuationSessionId = stateResult.data.stateSnapshot.sessionId;
            } else {
                // Create new continuation session
                const continuationResult = await this.createContinuationSession(
                    params,
                    stateResult.data,
                    contextResult,
                    memoryService
                );
                if (continuationResult.success) {
                    continuationSessionId = continuationResult.sessionId;
                }
            }

            // Phase 5: Generate restoration summary (consolidated from RestorationSummaryGenerator logic)
            const summaryResult = this.generateRestorationSummary(
                stateResult.data,
                contextResult,
                continuationSessionId,
                params.restorationGoal
            );

            // Phase 6: Create restoration trace (consolidated from RestorationTracer logic)
            if (continuationSessionId && memoryService) {
                await this.createRestorationTrace(
                    stateResult.data,
                    contextResult,
                    continuationSessionId,
                    params.restorationGoal,
                    memoryService
                );
            }

            // Phase 7: Prepare final result
            return this.prepareFinalResult(
                stateResult.data,
                contextResult,
                summaryResult,
                continuationSessionId
            );

        } catch (error) {
            return this.prepareResult(false, undefined, createErrorMessage('Error loading state: ', error));
        }
    }

    /**
     * Get required services with validation
     */
    private async getServices(): Promise<{success: boolean; error?: string; memoryService?: MemoryService; workspaceService?: WorkspaceService}> {
        const [memoryResult, workspaceResult] = await Promise.all([
            this.serviceIntegration.getMemoryService(),
            this.serviceIntegration.getWorkspaceService()
        ]);

        if (!memoryResult.success || !memoryResult.service) {
            return { success: false, error: `Memory service not available: ${memoryResult.error}` };
        }

        if (!workspaceResult.success || !workspaceResult.service) {
            return { success: false, error: `Workspace service not available: ${workspaceResult.error}` };
        }

        return { 
            success: true, 
            memoryService: memoryResult.service, 
            workspaceService: workspaceResult.service 
        };
    }

    /**
     * Load state data (consolidated from StateRetriever logic)
     */
    private async loadStateData(stateId: string, memoryService: MemoryService): Promise<{success: boolean; error?: string; data?: any}> {
        try {
            // Get state snapshot from memory service
            const stateSnapshot = await memoryService.getSnapshot(stateId);
            if (!stateSnapshot) {
                return { success: false, error: `State not found: ${stateId}` };
            }

            // Get related traces if available
            let relatedTraces: any[] = [];
            try {
                if (stateSnapshot.sessionId && stateSnapshot.sessionId !== 'current') {
                    relatedTraces = await memoryService.getSessionTraces(stateSnapshot.sessionId);
                }
            } catch {
                // Ignore errors getting traces - not critical for state loading
            }

            return { 
                success: true, 
                data: { 
                    stateSnapshot,
                    relatedTraces: relatedTraces || []
                }
            };

        } catch (error) {
            return { success: false, error: createErrorMessage('Error loading state data: ', error) };
        }
    }

    /**
     * Process and restore context (consolidated from FileCollector and TraceProcessor logic)
     */
    private async processAndRestoreContext(stateData: any, workspaceService: WorkspaceService, memoryService: MemoryService): Promise<any> {
        try {
            const { stateSnapshot, relatedTraces } = stateData;
            
            // Get workspace for context
            let workspace: any;
            try {
                workspace = await workspaceService.getWorkspace(stateSnapshot.workspaceId);
            } catch {
                workspace = { name: 'Unknown Workspace' };
            }

            // Extract state snapshot details
            const snapshot = stateSnapshot.snapshot || {};
            
            // Build context summary (consolidated from FileCollector logic)
            const summary = this.buildContextSummary(stateSnapshot, workspace, snapshot);

            // Process active files (consolidated file collection logic)
            const activeFiles = snapshot.activeFiles || [];
            const associatedNotes = this.processActiveFiles(activeFiles);

            // Process memory traces (consolidated from TraceProcessor logic)
            const processedTraces = this.processMemoryTraces(relatedTraces);

            return {
                summary,
                associatedNotes,
                stateCreatedAt: new Date(stateSnapshot.created).toISOString(),
                originalSessionId: stateSnapshot.sessionId,
                workspace,
                restoredContext: {
                    conversationContext: snapshot.conversationContext,
                    activeTask: snapshot.activeTask,
                    activeFiles,
                    nextSteps: snapshot.nextSteps || [],
                    reasoning: snapshot.reasoning,
                    workspaceContext: snapshot.workspaceContext
                },
                traces: processedTraces
            };

        } catch (error) {
            console.warn('Error processing context:', error);
            return {
                summary: `State "${stateData.stateSnapshot.name}" loaded successfully`,
                associatedNotes: [],
                stateCreatedAt: new Date().toISOString(),
                originalSessionId: stateData.stateSnapshot.sessionId,
                workspace: { name: 'Unknown Workspace' },
                restoredContext: {
                    conversationContext: 'Context restoration incomplete',
                    activeTask: 'Resume from saved state',
                    activeFiles: [],
                    nextSteps: [],
                    reasoning: 'State loaded with limited context'
                },
                traces: []
            };
        }
    }

    /**
     * Create continuation session (consolidated from SessionManager logic)
     */
    private async createContinuationSession(
        params: LoadStateParams,
        stateData: any,
        contextResult: any,
        memoryService: MemoryService
    ): Promise<{success: boolean; error?: string; sessionId?: string}> {
        try {
            const stateSnapshot = stateData.stateSnapshot;
            const snapshot = stateSnapshot.snapshot || {};

            // Create continuation session
            const continuationData = {
                workspaceId: stateSnapshot.workspaceId,
                name: params.sessionName || `Restored from "${stateSnapshot.name}"`,
                description: params.sessionDescription || `Resuming work from state saved on ${new Date(stateSnapshot.created).toLocaleDateString()}`,
                sessionGoal: params.restorationGoal || `Resume: ${snapshot.activeTask}`,
                previousSessionId: stateSnapshot.sessionId !== 'current' ? stateSnapshot.sessionId : undefined,
                isActive: true,
                toolCalls: 0,
                startTime: Date.now()
            };

            const continuationSession = await memoryService.createSession(continuationData);

            return { success: true, sessionId: continuationSession.id };

        } catch (error) {
            console.warn('Warning creating continuation session:', error);
            return { success: false, error: createErrorMessage('Error creating continuation session: ', error) };
        }
    }

    /**
     * Generate restoration summary (consolidated from RestorationSummaryGenerator logic)
     */
    private generateRestorationSummary(stateData: any, contextResult: any, continuationSessionId?: string, restorationGoal?: string): any {
        const stateSnapshot = stateData.stateSnapshot;
        const snapshot = stateSnapshot.snapshot || {};

        const summary = {
            stateName: stateSnapshot.name,
            originalCreationTime: new Date(stateSnapshot.created).toLocaleString(),
            workspaceId: stateSnapshot.workspaceId,
            workspaceName: contextResult.workspace.name,
            originalSessionId: stateSnapshot.sessionId,
            continuationSessionId,
            restorationTime: new Date().toLocaleString(),
            restorationGoal,
            contextSummary: contextResult.summary,
            activeTask: snapshot.activeTask,
            activeFiles: snapshot.activeFiles || [],
            nextSteps: snapshot.nextSteps || [],
            reasoning: snapshot.reasoning,
            continuationHistory: undefined as any[] | undefined
        };

        // Add continuation history if applicable
        const continuationHistory = [];
        if (stateSnapshot.sessionId !== 'current') {
            continuationHistory.push({
                timestamp: stateSnapshot.created,
                description: `Originally saved from session ${stateSnapshot.sessionId}`
            });
        }
        
        if (continuationSessionId) {
            continuationHistory.push({
                timestamp: Date.now(),
                description: `Restored in continuation session ${continuationSessionId}`
            });
        }

        if (continuationHistory.length > 0) {
            summary['continuationHistory'] = continuationHistory;
        }

        return summary;
    }

    /**
     * Create restoration trace (consolidated from RestorationTracer logic)
     */
    private async createRestorationTrace(
        stateData: any,
        contextResult: any,
        continuationSessionId: string,
        restorationGoal: string | undefined,
        memoryService: MemoryService
    ): Promise<void> {
        try {
            const stateSnapshot = stateData.stateSnapshot;
            const snapshot = stateSnapshot.snapshot || {};
            
            const traceContent = this.buildRestorationTraceContent(
                stateSnapshot,
                snapshot,
                contextResult,
                continuationSessionId,
                restorationGoal
            );

            // Create restoration memory trace
            await memoryService.createMemoryTrace({
                sessionId: continuationSessionId,
                workspaceId: stateSnapshot.workspaceId,
                content: traceContent,
                type: 'state_restoration',
                timestamp: Date.now(),
                metadata: {
                    tool: 'LoadStateMode',
                    params: { stateId: stateData.stateSnapshot.stateId },
                    result: { continuationSessionId },
                    relatedFiles: contextResult.associatedNotes || []
                }
            });

        } catch (error) {
            console.warn('Warning creating restoration trace:', error);
            // Don't fail state loading if trace creation fails
        }
    }

    /**
     * Prepare final result
     * 
     * Result structure explanation:
     * - summary: Generated by buildContextSummary() from state snapshot and workspace data
     * - associatedNotes: Processed active files (limited to 20) from processActiveFiles()
     * - continuationHistory: Restoration timeline from generateRestorationSummary()
     * - activeTask, activeFiles, nextSteps, reasoning: Direct from state snapshot.snapshot
     */
    private prepareFinalResult(stateData: any, contextResult: any, summaryResult: any, continuationSessionId?: string): StateResult {
        const stateSnapshot = stateData.stateSnapshot;
        
        const resultData: any = {
            stateId: stateSnapshot.id,
            name: stateSnapshot.name,
            workspaceId: stateSnapshot.workspaceId,
            sessionId: stateSnapshot.sessionId,
            created: stateSnapshot.created,
            newSessionId: continuationSessionId,
            restoredContext: {
                summary: contextResult.summary,                    // From buildContextSummary()
                associatedNotes: contextResult.associatedNotes,   // From processActiveFiles()
                stateCreatedAt: contextResult.stateCreatedAt,     // ISO string of state creation
                originalSessionId: stateSnapshot.sessionId,      // Original session ID
                continuationHistory: summaryResult.continuationHistory, // From generateRestorationSummary()
                activeTask: summaryResult.activeTask,            // From state snapshot.activeTask
                activeFiles: summaryResult.activeFiles,          // From state snapshot.activeFiles
                nextSteps: summaryResult.nextSteps,              // From state snapshot.nextSteps
                reasoning: summaryResult.reasoning,              // From state snapshot.reasoning
                restorationGoal: summaryResult.restorationGoal  // From input params
            }
        };

        const contextString = continuationSessionId 
            ? `Loaded state "${stateSnapshot.name}" and created continuation session ${continuationSessionId}. Ready to resume: ${summaryResult.activeTask}`
            : `Loaded state "${stateSnapshot.name}". Context restored: ${summaryResult.activeTask}`;

        return this.prepareResult(
            true,
            resultData,
            undefined,
            contextString
        );
    }

    /**
     * Helper methods (consolidated from various services)
     */
    private buildContextSummary(stateSnapshot: any, workspace: any, snapshot: any): string {
        const parts: string[] = [];
        
        parts.push(`Loaded state: "${stateSnapshot.name}"`);
        parts.push(`Workspace: ${workspace.name}`);
        
        if (snapshot.activeTask) {
            parts.push(`Active task: ${snapshot.activeTask}`);
        }
        
        if (snapshot.conversationContext) {
            const contextPreview = snapshot.conversationContext.length > 100 
                ? snapshot.conversationContext.substring(0, 100) + '...'
                : snapshot.conversationContext;
            parts.push(`Context: ${contextPreview}`);
        }
        
        if (snapshot.activeFiles && snapshot.activeFiles.length > 0) {
            parts.push(`${snapshot.activeFiles.length} active file${snapshot.activeFiles.length === 1 ? '' : 's'}`);
        }
        
        if (snapshot.nextSteps && snapshot.nextSteps.length > 0) {
            parts.push(`${snapshot.nextSteps.length} next step${snapshot.nextSteps.length === 1 ? '' : 's'} defined`);
        }
        
        const stateAge = Date.now() - stateSnapshot.created;
        const daysAgo = Math.floor(stateAge / (1000 * 60 * 60 * 24));
        if (daysAgo > 0) {
            parts.push(`Created ${daysAgo} day${daysAgo === 1 ? '' : 's'} ago`);
        } else {
            const hoursAgo = Math.floor(stateAge / (1000 * 60 * 60));
            if (hoursAgo > 0) {
                parts.push(`Created ${hoursAgo} hour${hoursAgo === 1 ? '' : 's'} ago`);
            } else {
                parts.push('Created recently');
            }
        }
        
        return parts.join('. ');
    }

    private processActiveFiles(activeFiles: string[]): string[] {
        // Filter and validate active files
        return activeFiles
            .filter(file => file && typeof file === 'string')
            .slice(0, 20); // Limit to 20 files for performance
    }

    private processMemoryTraces(traces: any[]): any[] {
        // Process and format traces for display
        return traces
            .slice(0, 5) // Limit to 5 most recent traces
            .map(trace => ({
                timestamp: trace.timestamp,
                content: trace.content.substring(0, 150) + (trace.content.length > 150 ? '...' : ''),
                type: trace.type,
                importance: trace.importance
            }));
    }

    private buildRestorationTraceContent(
        stateSnapshot: any,
        snapshot: any,
        contextResult: any,
        continuationSessionId: string,
        restorationGoal?: string
    ): string {
        const parts: string[] = [];
        
        parts.push(`State Restoration: Loaded state "${stateSnapshot.name}"`);
        parts.push(`Original state created: ${new Date(stateSnapshot.created).toLocaleString()}`);
        parts.push(`Continuation session created: ${continuationSessionId}`);
        
        if (restorationGoal) {
            parts.push(`Restoration goal: ${restorationGoal}`);
        }
        
        parts.push(`Active task: ${snapshot.activeTask}`);
        
        if (snapshot.conversationContext) {
            parts.push(`Previous context: ${snapshot.conversationContext}`);
        }
        
        if (snapshot.nextSteps && snapshot.nextSteps.length > 0) {
            parts.push(`Next steps: ${snapshot.nextSteps.slice(0, 3).join(', ')}${snapshot.nextSteps.length > 3 ? '...' : ''}`);
        }
        
        if (snapshot.activeFiles && snapshot.activeFiles.length > 0) {
            parts.push(`Active files: ${snapshot.activeFiles.slice(0, 5).join(', ')}`);
        }
        
        return parts.join('\n\n');
    }

    /**
     * Schema methods using consolidated logic
     */
    getParameterSchema(): any {
        const customSchema = {
            type: 'object',
            properties: {
                stateId: {
                    type: 'string',
                    description: 'ID of the state to load (REQUIRED)'
                },
                sessionName: {
                    type: 'string',
                    description: 'Custom name for the new continuation session (only used when continueExistingSession=false)'
                },
                sessionDescription: {
                    type: 'string',
                    description: 'Custom description for the new continuation session (only used when continueExistingSession=false)'
                },
                restorationGoal: {
                    type: 'string',
                    description: 'What do you intend to do after restoring this state? (optional)'
                },
                continueExistingSession: {
                    type: 'boolean',
                    description: 'Whether to continue with the original session ID (default: true). Set to false to create a new continuation session.'
                },
            },
            required: ['stateId'],
            additionalProperties: false
        };
        
        return this.getMergedSchema(customSchema);
    }

    getResultSchema(): any {
        return this.schemaBuilder.buildResultSchema(SchemaType.State, {
            mode: 'loadState'
        });
    }
}
```

## agents/memoryManager/modes/states/UpdateStateMode.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/states/ManageStateMode.ts
 * Purpose: Consolidated state management mode combining edit, delete, and list functionality
 * 
 * This file consolidates:
 * - Original editStateMode.ts functionality
 * - Original deleteStateMode.ts functionality  
 * - Original listStatesMode.ts functionality
 * - State validation and management logic
 * 
 * Used by: MemoryManager agent for state management operations
 */

import { App } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { MemoryManagerAgent } from '../../memoryManager'
import { EditStateParams, StateResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService } from "../../services/WorkspaceService";
import { createServiceIntegration } from '../../services/ValidationService';
import { SchemaBuilder, SchemaType } from '../../../../utils/schemas/SchemaBuilder';

type UpdateStateParams = EditStateParams;

/**
 * Consolidated UpdateStateMode - combines all state update functionality
 */
export class UpdateStateMode extends BaseMode<UpdateStateParams, StateResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    private schemaBuilder: SchemaBuilder;

    constructor(private agent: MemoryManagerAgent) {
        super(
            'updateState',
            'Update State',
            'Edit, delete, or list states with comprehensive update capabilities',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
        this.schemaBuilder = new SchemaBuilder();
    }

    async execute(params: UpdateStateParams): Promise<StateResult> {
        try {
            const operation = this.determineOperation(params);
            
            // Only edit operation supported
            return this.executeEdit(params);
        } catch (error) {
            return this.prepareResult(false, undefined, createErrorMessage('Error managing state: ', error));
        }
    }

    private determineOperation(params: UpdateStateParams): 'edit' {
        // Only edit operation supported
        return 'edit';
    }

    private async executeEdit(params: EditStateParams): Promise<StateResult> {
        const servicesResult = await this.getServices();
        if (!servicesResult.success) {
            return this.prepareResult(false, undefined, servicesResult.error);
        }

        const { memoryService } = servicesResult;
        if (!memoryService) {
            return this.prepareResult(false, undefined, 'Memory service not available');
        }
        const existingState = await memoryService.getSnapshot(params.stateId);
        if (!existingState) {
            return this.prepareResult(false, undefined, `State not found: ${params.stateId}`);
        }

        const updates: any = {};
        let hasUpdates = false;

        if (params.name !== undefined) {
            updates.name = params.name;
            hasUpdates = true;
        }

        if (params.description !== undefined) {
            updates.description = params.description;
            hasUpdates = true;
        }

        // Handle tags
        let updatedTags = existingState.state?.metadata?.tags || [];
        if (params.addTags && params.addTags.length > 0) {
            updatedTags = [...new Set([...updatedTags, ...params.addTags])];
            hasUpdates = true;
        }
        if (params.removeTags && params.removeTags.length > 0) {
            updatedTags = updatedTags.filter((tag: string) => !params.removeTags!.includes(tag));
            hasUpdates = true;
        }
        if (hasUpdates && (params.addTags || params.removeTags)) {
            updates['state.metadata.tags'] = updatedTags;
        }

        if (!hasUpdates) {
            return this.prepareResult(false, undefined, 'No updates provided for state');
        }

        // Get current snapshot and apply updates
        const currentSnapshot = await memoryService.getSnapshot(params.stateId);
        if (!currentSnapshot) {
            return this.prepareResult(false, undefined, `State ${params.stateId} not found`);
        }

        const updatedSnapshot = { ...currentSnapshot, ...updates };
        await memoryService.updateSnapshot(updatedSnapshot);

        // Use updated snapshot for result
        const updatedState = await memoryService.getSnapshot(params.stateId);
        if (!updatedState) {
            return this.prepareResult(false, undefined, 'Failed to retrieve updated state');
        }
        
        return this.prepareResult(true, {
            stateId: updatedState.id,
            name: updatedState.name,
            description: updatedState.description,
            workspaceId: updatedState.workspaceId,
            timestamp: updatedState.timestamp || updatedState.created,
            tags: updatedTags
        }, undefined, `State "${updatedState.name}" updated successfully`);
    }


    private async getServices(): Promise<{success: boolean; error?: string; memoryService?: MemoryService; workspaceService?: WorkspaceService}> {
        const [memoryResult, workspaceResult] = await Promise.all([
            this.serviceIntegration.getMemoryService(),
            this.serviceIntegration.getWorkspaceService()
        ]);

        if (!memoryResult.success || !memoryResult.service) {
            return { success: false, error: `Memory service not available: ${memoryResult.error}` };
        }

        if (!workspaceResult.success || !workspaceResult.service) {
            return { success: false, error: `Workspace service not available: ${workspaceResult.error}` };
        }

        return { 
            success: true, 
            memoryService: memoryResult.service, 
            workspaceService: workspaceResult.service 
        };
    }

    private sortStates(states: any[], order: 'asc' | 'desc'): any[] {
        return states.sort((a, b) => {
            const timeA = a.timestamp || a.created || 0;
            const timeB = b.timestamp || b.created || 0;
            return order === 'asc' ? timeA - timeB : timeB - timeA;
        });
    }

    private async enhanceStatesWithContext(states: any[], workspaceService: WorkspaceService, includeContext?: boolean): Promise<any[]> {
        const workspaceCache = new Map<string, string>();
        
        return await Promise.all(states.map(async (state) => {
            let workspaceName = 'Unknown Workspace';
            
            if (!workspaceCache.has(state.workspaceId)) {
                try {
                    const workspace = await workspaceService.getWorkspace(state.workspaceId);
                    workspaceName = workspace?.name || 'Unknown Workspace';
                    workspaceCache.set(state.workspaceId, workspaceName);
                } catch {
                    workspaceCache.set(state.workspaceId, 'Unknown Workspace');
                }
            } else {
                workspaceName = workspaceCache.get(state.workspaceId)!;
            }

            const enhanced: any = {
                ...state,
                workspaceName,
                age: this.calculateStateAge(state.created || state.timestamp)
            };

            if (includeContext && state.snapshot) {
                enhanced.context = {
                    files: state.snapshot.activeFiles || [],
                    traceCount: 0, // Could be enhanced to count related traces
                    tags: state.state?.metadata?.tags || [],
                    summary: state.snapshot.activeTask || 'No active task recorded'
                };
            }

            return enhanced;
        }));
    }

    private calculateStateAge(timestamp: number): string {
        const now = Date.now();
        const age = now - timestamp;
        
        const days = Math.floor(age / (1000 * 60 * 60 * 24));
        if (days > 0) return `${days} day${days === 1 ? '' : 's'} ago`;
        
        const hours = Math.floor(age / (1000 * 60 * 60));
        if (hours > 0) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
        
        const minutes = Math.floor(age / (1000 * 60));
        if (minutes > 0) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
        
        return 'Just now';
    }

    getParameterSchema(): any {
        const customSchema = {
            type: 'object',
            properties: {
                // Edit parameters
                stateId: { type: 'string', description: 'ID of state to edit or delete' },
                name: { type: 'string', description: 'New state name (for edit operations)' },
                description: { type: 'string', description: 'New state description (for edit operations)' },
                addTags: { type: 'array', items: { type: 'string' }, description: 'Tags to add (for edit operations)' },
                removeTags: { type: 'array', items: { type: 'string' }, description: 'Tags to remove (for edit operations)' },

                // List parameters
                includeContext: { type: 'boolean', description: 'Include context information (for list operations)' },
                limit: { type: 'number', description: 'Maximum number of states to return (for list operations)' },
                targetSessionId: { type: 'string', description: 'Filter by session ID (for list operations)' },
                order: { type: 'string', enum: ['asc', 'desc'], description: 'Sort order (for list operations)' },
                tags: { type: 'array', items: { type: 'string' }, description: 'Filter by tags (for list operations)' }
            },
            additionalProperties: false
        };
        
        return this.getMergedSchema(customSchema);
    }

    getResultSchema(): any {
        return this.schemaBuilder.buildResultSchema(SchemaType.State, {
            mode: 'manageStates'
        });
    }
}
```

## agents/memoryManager/modes/utils/pluginTypes.ts

```typescript
import { Plugin } from 'obsidian';
import { WorkspaceService } from "../../services/WorkspaceService";
import { MemoryService } from "../../services/MemoryService";

/**
 * Custom interface for the Claudesidian plugin with services
 */
export interface ClaudesidianPlugin extends Plugin {
  services: {
    workspaceService: WorkspaceService;
    memoryService: MemoryService;
    [key: string]: any;
  };
  getService<T>(serviceName: string): Promise<T | null>;
}
```

## agents/memoryManager/modes/workspaces/CreateWorkspaceMode.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/workspaces/CreateWorkspaceMode.ts
 * Purpose: Consolidated workspace creation mode
 * 
 * This file consolidates the original createWorkspaceMode.ts functionality
 * 
 * Used by: MemoryManager agent for workspace creation operations
 */

import { App } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { MemoryManagerAgent } from '../../memoryManager'
import { createServiceIntegration } from '../../services/ValidationService';

// Import types from existing workspace mode
import { 
    CreateWorkspaceParameters, 
    CreateWorkspaceResult
} from '../../../../database/types/workspace/ParameterTypes';
import { ProjectWorkspace, WorkspaceContext } from '../../../../database/types/workspace/WorkspaceTypes';
import { WorkspaceService } from "../../services/WorkspaceService";
import { createErrorMessage } from '../../../../utils/errorUtils';

/**
 * Consolidated CreateWorkspaceMode - simplified from original
 */
export class CreateWorkspaceMode extends BaseMode<CreateWorkspaceParameters, CreateWorkspaceResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    
    constructor(private agent: MemoryManagerAgent) {
        super(
            'createWorkspace',
            'Create Workspace',
            'Create a new workspace with structured context data',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
    }
    
    async execute(params: CreateWorkspaceParameters): Promise<CreateWorkspaceResult> {
        const startTime = Date.now();
        
        try {
            // Get workspace service
            const serviceResult = await this.serviceIntegration.getWorkspaceService();
            if (!serviceResult.success || !serviceResult.service) {
                return this.prepareResult(false, {}, `Workspace service not available: ${serviceResult.error}`);
            }
            
            const workspaceService = serviceResult.service;
            
            // Validate required fields
            const validationErrors = this.serviceIntegration.validateWorkspaceCreationParams(params);
            if (validationErrors.length > 0) {
                const firstError = validationErrors[0];
                return this.prepareResult(false, {}, `Validation error - ${firstError.field}: ${firstError.requirement}`);
            }
            
            // Ensure root folder exists
            try {
                const folder = this.app.vault.getAbstractFileByPath(params.rootFolder);
                if (!folder) {
                    await this.app.vault.createFolder(params.rootFolder);
                }
            } catch (folderError) {
                console.warn(`Could not create root folder: ${folderError}`);
            }
            
            // Handle dedicated agent setup
            let dedicatedAgent: { agentId: string; agentName: string } | undefined = undefined;
            if (params.dedicatedAgentId) {
                try {
                    // Get the agent name from CustomPromptStorageService
                    const plugin = this.app.plugins.getPlugin('claudesidian-mcp') as any;
                    if (plugin?.agentManager) {
                        const agentManagerAgent = plugin.agentManager.getAgent('agentManager');
                        if (agentManagerAgent?.storageService) {
                            const agent = agentManagerAgent.storageService.getPromptById(params.dedicatedAgentId);
                            if (agent) {
                                dedicatedAgent = {
                                    agentId: agent.id,
                                    agentName: agent.name
                                };
                            }
                        }
                    }
                } catch (error) {
                    console.warn(`Could not retrieve agent name for ID ${params.dedicatedAgentId}:`, error);
                }
            }

            // Combine provided key files with auto-detected ones
            const providedKeyFiles = params.keyFiles || [];
            const autoDetectedKeyFiles = await this.detectSimpleKeyFiles(params.rootFolder);
            const allKeyFiles = [...new Set([...providedKeyFiles, ...autoDetectedKeyFiles])]; // Remove duplicates

            // Build workspace context
            const context: WorkspaceContext = {
                purpose: params.purpose,
                currentGoal: params.currentGoal,
                workflows: params.workflows,
                keyFiles: allKeyFiles,
                preferences: params.preferences || '',
                ...(dedicatedAgent && { dedicatedAgent })
            };
            
            // Create workspace data
            const now = Date.now();
            const workspaceData: Omit<ProjectWorkspace, 'id'> = {
                name: params.name,
                context: context,
                rootFolder: params.rootFolder,
                created: now,
                lastAccessed: now,
                description: params.description,
                relatedFolders: params.relatedFolders || [],
                relatedFiles: params.relatedFiles || [],
                associatedNotes: [],
                keyFileInstructions: params.keyFileInstructions,
                activityHistory: [{
                    timestamp: now,
                    action: 'create',
                    toolName: 'CreateWorkspaceMode',
                    context: `Created workspace: ${params.purpose}`
                }],
                preferences: undefined, // Legacy field - preferences now stored in context
                projectPlan: undefined,
                checkpoints: [],
                completionStatus: {}
            };
            
            // Save workspace
            const newWorkspace = await workspaceService.createWorkspace(workspaceData);
            
            // Generate validation prompt
            const validationPrompt = this.generatePostCreationPrompt(params, allKeyFiles);
            
            return this.prepareResult(true, {
                workspaceId: newWorkspace.id,
                workspace: newWorkspace,
                validationPrompt: validationPrompt
            }, undefined, `Created workspace "${params.name}" with purpose: ${params.purpose}`);
            
        } catch (error) {
            return this.prepareResult(false, {}, createErrorMessage('Error creating workspace: ', error));
        }
    }
    
    /**
     * Auto-detect key files in workspace folder (simple array format)
     */
    private async detectSimpleKeyFiles(rootFolder: string): Promise<string[]> {
        try {
            const detectedFiles: string[] = [];

            const folder = this.app.vault.getAbstractFileByPath(rootFolder);
            if (folder && 'children' in folder && Array.isArray(folder.children)) {
                for (const child of folder.children as any[]) {
                    if (child.path.endsWith('.md')) {
                        const fileName = child.name.toLowerCase();

                        // Auto-detect common key files
                        if (['index.md', 'readme.md', 'summary.md', 'moc.md', 'overview.md'].includes(fileName)) {
                            detectedFiles.push(child.path);
                        }

                        try {
                            // Check for frontmatter key: true
                            if ('cachedData' in child && child.cachedData?.frontmatter?.key === true) {
                                detectedFiles.push(child.path);
                            }
                        } catch (error) {
                            // Ignore frontmatter parsing errors
                        }
                    }
                }
            }

            return detectedFiles;

        } catch (error) {
            console.warn('Error detecting key files:', error);
            return [];
        }
    }

    private generatePostCreationPrompt(params: CreateWorkspaceParameters, allKeyFiles: string[]): string {
        const prompts: string[] = [];

        if (allKeyFiles.length > 0) {
            prompts.push(`Setup complete with ${allKeyFiles.length} key files identified.`);
        } else {
            prompts.push('No key files detected. Create index.md, readme.md, or add "key: true" to file frontmatter to designate key files.');
        }

        if (!params.preferences || params.preferences.length === 0) {
            prompts.push('Consider adding user preferences as you work in this workspace.');
        }

        if (!params.dedicatedAgentId) {
            prompts.push('You can assign a dedicated AI agent to this workspace for specialized assistance.');
        } else {
            prompts.push('Dedicated agent configured for this workspace.');
        }

        prompts.push('Load the workspace to see the current directory structure and validate the setup.');

        return prompts.length > 0
            ? `Workspace created successfully! ${prompts.join(' ')}`
            : 'Workspace created successfully! Load it to see the current directory structure.';
    }

    getParameterSchema(): any {
        const customSchema = {
            type: 'object',
            properties: {
                name: { type: 'string', description: 'Workspace name (REQUIRED)' },
                rootFolder: { type: 'string', description: 'Root folder path for this workspace (REQUIRED)' },
                purpose: { type: 'string', description: 'What is this workspace for? (REQUIRED)' },
                currentGoal: { type: 'string', description: 'What are you trying to accomplish right now? (REQUIRED)' },
                workflows: {
                    type: 'array',
                    description: 'Workflows for different situations (REQUIRED)',
                    items: {
                        type: 'object',
                        properties: {
                            name: { type: 'string' },
                            when: { type: 'string' },
                            steps: { type: 'array', items: { type: 'string' } }
                        },
                        required: ['name', 'when', 'steps']
                    },
                    minItems: 1
                },
                keyFiles: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Simple list of key file paths for this workspace'
                },
                preferences: {
                    type: 'string',
                    description: 'User preferences as a single text field'
                },
                dedicatedAgentId: {
                    type: 'string',
                    description: 'ID of dedicated agent for this workspace (systemPrompt included when loading)'
                },
                description: { type: 'string' },
                relatedFolders: { type: 'array', items: { type: 'string' } },
                relatedFiles: { type: 'array', items: { type: 'string' } },
                keyFileInstructions: { type: 'string' }
            },
            required: ['name', 'rootFolder', 'purpose', 'currentGoal', 'workflows']
        };
        
        return this.getMergedSchema(customSchema);
    }
    
    getResultSchema(): any {
        return {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                data: {
                    type: 'object',
                    properties: {
                        workspaceId: { type: 'string' },
                        workspace: { type: 'object' },
                        validationPrompt: { type: 'string' }
                    }
                }
            }
        };
    }
}
```

## agents/memoryManager/modes/workspaces/ListWorkspacesMode.ts

```typescript
/**
 * Location: src/agents/memoryManager/modes/workspaces/ListWorkspacesMode.ts
 * 
 * Purpose: Implements the listWorkspaces mode for the consolidated MemoryManager
 * This mode lists available workspaces with filtering and sorting options.
 * 
 * Used by: MemoryManagerAgent for workspace listing operations
 * Integrates with: WorkspaceService for accessing workspace data
 */

import { BaseMode } from '../../../baseMode';
import { 
  ListWorkspacesParameters, 
  ListWorkspacesResult
} from '../../../../database/workspace-types';
import { WorkspaceService } from "../../services/WorkspaceService";
import { parseWorkspaceContext } from '../../../../utils/contextUtils';

/**
 * Mode to list available workspaces with filtering and sorting
 */
export class ListWorkspacesMode extends BaseMode<ListWorkspacesParameters, ListWorkspacesResult> {
  private agent: any;
  
  /**
   * Create a new ListWorkspacesMode for the consolidated MemoryManager
   * @param agent The MemoryManagerAgent instance
   */
  constructor(agent: any) {
    super(
      'listWorkspaces',
      'List Workspaces',
      'List available workspaces with filters and sorting',
      '1.0.0'
    );
    this.agent = agent;
  }
  
  /**
   * Execute the mode to list workspaces
   * @param params Mode parameters
   * @returns Promise resolving to the result
   */
  async execute(params: ListWorkspacesParameters): Promise<ListWorkspacesResult> {
    const startTime = Date.now();
    
    try {
      // Get workspace service from agent
      const workspaceService = await this.agent.getWorkspaceServiceAsync();
      if (!workspaceService) {
        console.error('[ListWorkspacesMode] WorkspaceService not available');
        return {
          success: false,
          error: 'WorkspaceService not available',
          data: { workspaces: [] },
          workspaceContext: typeof params.workspaceContext === 'string' 
            ? parseWorkspaceContext(params.workspaceContext) || undefined
            : params.workspaceContext
        };
      }
      
      // Get workspaces with optional filtering and sorting
      const queryParams = {
        sortBy: params.sortBy as 'name' | 'created' | 'lastAccessed',
        sortOrder: params.order as 'asc' | 'desc'
      };
      
      
      let workspaces;
      try {
        workspaces = await workspaceService.getWorkspaces(queryParams);
      } catch (queryError) {
        console.error('[ListWorkspacesMode] Failed to query workspaces:', queryError);
        return {
          success: false,
          error: `Failed to query workspaces: ${queryError instanceof Error ? queryError.message : String(queryError)}`,
          data: { workspaces: [] },
          workspaceContext: typeof params.workspaceContext === 'string' 
            ? parseWorkspaceContext(params.workspaceContext) || undefined
            : params.workspaceContext
        };
      }
      
      // Log detailed workspace information for debugging
      if (workspaces.length > 0) {
        workspaces.forEach((ws: any, index: number) => {
          console.log(`  ${index + 1}. ID: ${ws.id}, Name: ${ws.name}, Status: ${ws.status}`);
        });
      } else {
        console.warn('[ListWorkspacesMode] No workspaces found');
        
        // Enhanced diagnostic: Use workspace collection diagnostic service if available
        try {
          const diagnostics = await workspaceService.getDiagnostics();
          
          if (diagnostics.totalItems > 0) {
            console.warn('[ListWorkspacesMode] Collection contains data but getWorkspaces() returned empty');
            console.warn('[ListWorkspacesMode] Format analysis:', diagnostics.formatAnalysis);
            
            if (diagnostics.sampleItems.length > 0) {
              diagnostics.sampleItems.forEach((item: any, index: number) => {
                console.log(`  ${index + 1}. ID: ${item.id}, Legacy: ${item.isLegacy}, Metadata keys: ${Object.keys(item.metadata)}`);
              });
            }
          }
        } catch (diagError) {
          console.error('[ListWorkspacesMode] Diagnostic check failed:', diagError);
        }
      }
      
      // Format the results
      const formattedWorkspaces = workspaces.map((ws: any, index: number) => {
        const formatted = {
          id: ws.id,
          name: ws.name || `Workspace ${index + 1}`,
          description: ws.description || undefined,
          rootFolder: ws.rootFolder || '/',
          lastAccessed: ws.lastAccessed || Date.now(),
          status: ws.status || 'active'
        };
        
        return formatted;
      });
      
      // Ensure workspaceContext has required workspaceId
      const workspaceContext = params.workspaceContext 
        ? { 
            workspaceId: parseWorkspaceContext(params.workspaceContext)?.workspaceId || workspaces[0]?.id || '',
            workspacePath: parseWorkspaceContext(params.workspaceContext)?.workspacePath 
          }
        : undefined;
      
      
      const result = {
        success: true,
        data: {
          workspaces: formattedWorkspaces,
          performance: {
            totalDuration: Date.now() - startTime,
            serviceAccessTime: 0, // Simplified for consolidated version
            queryTime: Date.now() - startTime,
            workspaceCount: formattedWorkspaces.length
          }
        },
        workspaceContext: workspaceContext
      };
      
      return result;
      
    } catch (error: any) {
      console.error(`[ListWorkspacesMode] Unexpected error after ${Date.now() - startTime}ms:`, {
        message: error.message,
        stack: error.stack,
        params: params
      });
      
      return {
        success: false,
        error: `Unexpected error: ${error.message || String(error)}`,
        data: { workspaces: [] },
        workspaceContext: typeof params.workspaceContext === 'string' 
          ? parseWorkspaceContext(params.workspaceContext) || undefined
          : params.workspaceContext
      };
    }
  }
  
  /**
   * Get the parameter schema
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        sortBy: {
          type: 'string',
          enum: ['name', 'created', 'lastAccessed'],
          description: 'Field to sort workspaces by'
        },
        order: {
          type: 'string',
          enum: ['asc', 'desc'],
          description: 'Sort order (ascending or descending)'
        },
      }
    };
    
    // Merge with common schema (adds sessionId, workspaceContext)
    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the result schema
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation was successful'
        },
        error: {
          type: 'string',
          description: 'Error message if operation failed'
        },
        data: {
          type: 'object',
          properties: {
            workspaces: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                    description: 'Workspace identifier'
                  },
                  name: {
                    type: 'string',
                    description: 'Workspace name'
                  },
                  description: {
                    type: 'string',
                    description: 'Workspace description'
                  },
                  rootFolder: {
                    type: 'string',
                    description: 'Root folder for the workspace'
                  },
                  lastAccessed: {
                    type: 'number',
                    description: 'Timestamp of last access'
                  },
                  status: {
                    type: 'string',
                    enum: ['active', 'paused', 'completed'],
                    description: 'Workspace status'
                  }
                }
              }
            }
          }
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'Current workspace ID'
            },
            workspacePath: {
              type: 'array',
              items: { type: 'string' },
              description: 'Full path from root workspace'
            }
          }
        }
      },
      required: ['success']
    };
  }
}
```

## agents/memoryManager/modes/workspaces/LoadWorkspaceMode.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/workspaces/LoadWorkspaceMode.ts
 * Purpose: Consolidated workspace loading mode for MemoryManager
 * 
 * This file handles loading a workspace by ID and restoring workspace context
 * and state for the user session. It automatically collects all files in the
 * workspace directory recursively and provides comprehensive workspace information.
 * 
 * Used by: MemoryManager agent for workspace loading operations
 * Integrates with: WorkspaceService for accessing workspace data
 */

import { BaseMode } from '../../../baseMode';
import { 
  LoadWorkspaceParameters, 
  LoadWorkspaceResult 
} from '../../../../database/types/workspace/ParameterTypes';
import { ProjectWorkspace } from '../../../../database/types/workspace/WorkspaceTypes';
import { parseWorkspaceContext } from '../../../../utils/contextUtils';
import { createErrorMessage } from '../../../../utils/errorUtils';

/**
 * Mode to load and restore a workspace by ID
 * Automatically collects all files in the workspace directory and provides complete workspace information
 */
export class LoadWorkspaceMode extends BaseMode<LoadWorkspaceParameters, LoadWorkspaceResult> {
  private agent: any;
  
  /**
   * Create a new LoadWorkspaceMode for the consolidated MemoryManager
   * @param agent The MemoryManagerAgent instance
   */
  constructor(agent: any) {
    super(
      'loadWorkspace',
      'Load Workspace',
      'Load a workspace by ID and restore context and state',
      '2.0.0'
    );
    this.agent = agent;
  }
  
  /**
   * Execute the mode to load a workspace
   * @param params Mode parameters
   * @returns Promise resolving to the result
   */
  async execute(params: LoadWorkspaceParameters): Promise<LoadWorkspaceResult> {
    const startTime = Date.now();
    
    try {
      // Get workspace service from agent
      const workspaceService = await this.agent.getWorkspaceServiceAsync();
      if (!workspaceService) {
        console.error('[LoadWorkspaceMode] WorkspaceService not available');
        return {
          success: false,
          error: 'WorkspaceService not available',
          data: {
            context: {
              name: 'Unknown',
              rootFolder: '',
              recentActivity: ['WorkspaceService not available']
            },
            workflow: '',
            keyFiles: {},
            preferences: '',
            sessions: [],
            states: [],
          },
          workspaceContext: typeof params.workspaceContext === 'string' 
            ? parseWorkspaceContext(params.workspaceContext) || undefined
            : params.workspaceContext
        };
      }
      
      // Get the workspace by ID
      let workspace: ProjectWorkspace | undefined;
      try {
        workspace = await workspaceService.getWorkspace(params.id);
      } catch (queryError) {
        console.error('[LoadWorkspaceMode] Failed to load workspace:', queryError);
        return {
          success: false,
          error: `Failed to load workspace: ${queryError instanceof Error ? queryError.message : String(queryError)}`,
          data: {
            context: {
              name: 'Unknown',
              rootFolder: '',
              recentActivity: ['Failed to load workspace']
            },
            workflow: '',
            keyFiles: {},
            preferences: '',
            sessions: [],
            states: [],
          },
          workspaceContext: typeof params.workspaceContext === 'string' 
            ? parseWorkspaceContext(params.workspaceContext) || undefined
            : params.workspaceContext
        };
      }
      
      if (!workspace) {
        console.error('[LoadWorkspaceMode] Workspace not found:', params.id);
        return {
          success: false,
          error: `Workspace with ID '${params.id}' not found`,
          data: {
            context: {
              name: 'Unknown',
              rootFolder: '',
              recentActivity: ['Workspace not found']
            },
            workflow: '',
            keyFiles: {},
            preferences: '',
            sessions: [],
            states: [],
          },
          workspaceContext: typeof params.workspaceContext === 'string' 
            ? parseWorkspaceContext(params.workspaceContext) || undefined
            : params.workspaceContext
        };
      }
      
      
      // Update last accessed timestamp
      try {
        await workspaceService.updateLastAccessed(params.id);
      } catch (updateError) {
        console.warn('[LoadWorkspaceMode] Failed to update last accessed timestamp:', updateError);
        // Continue - this is not critical
      }
      
      // Build actionable context briefing
      const context = await this.buildContextBriefing(workspace);
      
      // Build workflow summary
      const workflow = this.buildWorkflowSummary(workspace);
      
      // Extract key files
      const keyFiles = this.extractKeyFiles(workspace);
      
      // Build preferences summary
      const preferences = this.buildPreferences(workspace);
      
      // Get memory service for sessions and states data
      const memoryService = this.agent.getMemoryService();
      
      // Fetch sessions for this workspace
      const sessions = await this.fetchWorkspaceSessions(workspace.id, memoryService);
      
      // Fetch states for this workspace
      const states = await this.fetchWorkspaceStates(workspace.id, memoryService);
      
      // Fetch agent data if workspace has associated agents
      const agent = await this.fetchWorkspaceAgent(workspace);
      
      // Update workspace context
      const workspacePathResult = await this.buildWorkspacePath(workspace.rootFolder);
      const workspaceContext = {
        workspaceId: workspace.id,
        workspacePath: workspacePathResult.path
      };
      
      const result = {
        success: true,
        data: {
          context: context,
          workflow: workflow,
          keyFiles: keyFiles,
          preferences: preferences,
          sessions: sessions,
          states: states,
          ...(agent && { agent: agent })
        },
        workspaceContext: workspaceContext
      };

      // Add navigation fallback message if workspace path building failed
      if (workspacePathResult.failed) {
        (result.data.context as any).recentActivity.push("Note: Workspace directory navigation unavailable. Use vaultManager listDirectoryMode to explore the workspace folder structure.");
      }
      
      // CRITICAL: Force memory cleanup after workspace loading
      // This is essential because memory traces can consume significant memory
      this.forceMemoryCleanup(`LoadWorkspaceMode completed for workspace ${params.id}`);
      
      return result;
      
    } catch (error: any) {
      console.error(`[LoadWorkspaceMode] Unexpected error after ${Date.now() - startTime}ms:`, {
        message: error.message,
        stack: error.stack,
        params: params
      });
      
      // CRITICAL: Force cleanup even on error to prevent memory leaks
      this.forceMemoryCleanup(`LoadWorkspaceMode error cleanup for workspace ${params.id}`);
      
      return {
        success: false,
        error: createErrorMessage('Unexpected error loading workspace: ', error),
        data: {
          context: {
            name: 'Unknown',
            rootFolder: '',
            recentActivity: ['Unexpected error loading workspace']
          },
          workflow: '',
          keyFiles: {},
          preferences: '',
          sessions: [],
          states: [],
        },
        workspaceContext: typeof params.workspaceContext === 'string' 
          ? parseWorkspaceContext(params.workspaceContext) || undefined
          : params.workspaceContext
      };
    }
  }
  
  /**
   * Build a contextual briefing for the workspace as JSON object
   */
  private async buildContextBriefing(workspace: ProjectWorkspace): Promise<{
    name: string;
    description?: string;
    purpose?: string;
    rootFolder: string;
    recentActivity: string[];
  }> {
    
    // Get memory service for recent activity
    const memoryService = this.agent.getMemoryService();
    
    let recentActivity: string[] = [];
    
    if (memoryService) {
      try {
        recentActivity = await this.getRecentActivity(workspace.id, memoryService);
      } catch (error) {
        console.error(`[LoadWorkspaceMode] getRecentActivity failed:`, error);
        recentActivity = [`Recent activity error: ${error instanceof Error ? error.message : String(error)}`];
      }
    } else {
      recentActivity = ["No recent activity"];
    }
    
    const finalActivity = recentActivity.length > 0 ? recentActivity : ["No recent activity"];

    return {
      name: workspace.name,
      description: workspace.description || undefined,
      purpose: workspace.context?.purpose || undefined,
      rootFolder: workspace.rootFolder,
      recentActivity: finalActivity
    };
  }
  
  /**
   * Build a workflow summary
   */
  private buildWorkflowSummary(workspace: ProjectWorkspace): string {
    if (!workspace.context?.workflows || workspace.context.workflows.length === 0) {
      return 'No workflows defined';
    }
    
    const workflows = workspace.context.workflows.map(workflow => {
      const steps = workflow.steps.map(step => `  - ${step}`).join('\n');
      return `**${workflow.name}** (${workflow.when}):\n${steps}`;
    }).join('\n\n');
    
    return workflows;
  }
  
  /**
   * Extract key files into a flat structure
   */
  private extractKeyFiles(workspace: ProjectWorkspace): Record<string, string> {
    const keyFiles: Record<string, string> = {};

    if (workspace.context?.keyFiles) {
      // New format: simple array of file paths
      if (Array.isArray(workspace.context.keyFiles)) {
        workspace.context.keyFiles.forEach((filePath, index) => {
          // Extract filename without extension as key
          const fileName = filePath.split('/').pop()?.replace(/\.[^/.]+$/, '') || `file_${index}`;
          keyFiles[fileName] = filePath;
        });
      }
      // Legacy format: array of categorized files (for backward compatibility)
      else if (typeof workspace.context.keyFiles === 'object' && 'length' in workspace.context.keyFiles) {
        (workspace.context.keyFiles as any).forEach((category: any) => {
          if (category.files) {
            Object.entries(category.files).forEach(([name, path]) => {
              keyFiles[name] = path as string;
            });
          }
        });
      }
    }

    return keyFiles;
  }
  
  /**
   * Build preferences summary
   */
  private buildPreferences(workspace: ProjectWorkspace): string {
    // Preferences is now a string, not an array
    if (workspace.context?.preferences && workspace.context.preferences.trim()) {
      return workspace.context.preferences;
    }

    // Legacy support for userPreferences (if still exists)
    if (workspace.preferences?.userPreferences && Array.isArray(workspace.preferences.userPreferences)) {
      return workspace.preferences.userPreferences.join('. ') + '.';
    }

    return 'No preferences set';
  }
  
  
  
  /**
   * Build workspace path with folder path and flat files list
   */
  private async buildWorkspacePath(rootFolder: string): Promise<{path: any, failed: boolean}> {
    try {
      const app = this.agent.getApp();
      const folder = app.vault.getAbstractFileByPath(rootFolder);
      
      if (!folder || !('children' in folder)) {
        console.warn('[LoadWorkspaceMode] Workspace root folder not found or empty:', rootFolder);
        return { path: { folder: rootFolder, files: [] }, failed: true };
      }
      
      // Collect all files recursively with relative paths
      const files = this.collectAllFiles(folder as any, rootFolder);
      
      return { 
        path: {
          folder: rootFolder,
          files: files
        }, 
        failed: false 
      };
      
    } catch (error) {
      console.warn('[LoadWorkspaceMode] Failed to build workspace path:', error);
      return { path: { folder: rootFolder, files: [] }, failed: true };
    }
  }

  /**
   * Collect all files recursively as flat list with relative paths
   */
  private collectAllFiles(folder: any, basePath: string): string[] {
    const files: string[] = [];
    
    if (!folder.children) {
      return files;
    }
    
    for (const child of folder.children) {
      if ('children' in child) {
        // It's a folder - recurse into it
        const subFiles = this.collectAllFiles(child, basePath);
        files.push(...subFiles);
      } else {
        // It's a file - add with relative path from base
        const relativePath = child.path.replace(basePath + '/', '');
        files.push(relativePath);
      }
    }
    
    return files.sort();
  }

  /**
   * Get recent activity from memory traces
   */
  private async getRecentActivity(workspaceId: string, memoryService: any): Promise<string[]> {
    let traces: any[] = [];
    try {
      traces = await memoryService.getMemoryTraces(workspaceId, 5);
      
      if (traces.length > 0) {
      }
      
      const sessionMemories = this.extractSessionMemories(traces);
      
      // CRITICAL MEMORY CLEANUP: Clear large trace data immediately after processing
      this.cleanupTraceMemory(traces);
      
      return sessionMemories;
    } catch (error) {
      console.warn('[LoadWorkspaceMode] Failed to get recent activity:', error);
      // Cleanup traces even on error
      if (traces.length > 0) {
        this.cleanupTraceMemory(traces);
      }
      return ["Recent activity unavailable"];
    }
  }

  /**
   * Clean up memory trace data to prevent memory leaks
   * This is critical because traces can contain large data arrays
   */
  private cleanupTraceMemory(traces: any[]): void {
    if (!traces || traces.length === 0) return;
    
    // Clear large data arrays
    traces.forEach(trace => {
      
      // Clear large document content after we've extracted what we need
      if (trace.content && trace.content.length > 1000) {
        trace.content = null;
      }
      
      // Clear large metadata objects
      if (trace.metadata) {
        // Keep essential fields, clear large ones
        if (trace.metadata.params) trace.metadata.params = null;
        if (trace.metadata.result) trace.metadata.result = null;
      }
    });
    
    // Clear the array itself
    traces.length = 0;
  }

  /**
   * Force garbage collection and memory cleanup
   * This is critical after loading memory traces to prevent memory bloat
   */
  private forceMemoryCleanup(operation: string): void {
    try {
      // Log memory usage before cleanup (if available)
      if (typeof (global as any).gc === 'function') {
        console.debug(`[LoadWorkspaceMode] ${operation} - Forcing garbage collection`);
        (global as any).gc();
      } else if (typeof window !== 'undefined' && (window as any).gc) {
        console.debug(`[LoadWorkspaceMode] ${operation} - Forcing browser garbage collection`);
        (window as any).gc();
      }
      
      // Additional cleanup hints
      if (typeof global !== 'undefined' && global.gc) {
        global.gc();
      }
      
      // Schedule delayed cleanup to catch any remaining references
      setTimeout(() => {
        try {
          if (typeof (global as any).gc === 'function') {
            (global as any).gc();
          }
        } catch (e) {
          // Ignore GC errors
        }
      }, 100);
      
    } catch (error) {
      // Garbage collection is not always available, that's fine
      console.debug(`[LoadWorkspaceMode] ${operation} - GC not available, relying on natural cleanup`);
    }
  }

  /**
   * Extract sessionMemory values from memory traces
   */
  private extractSessionMemories(traces: any[]): string[] {
    const sessionMemories: string[] = [];
    
    for (let i = 0; i < traces.length; i++) {
      const trace = traces[i];
      
      try {
        // Parse the structured document from content
        let document: any;
        try {
          document = JSON.parse(trace.content);
        } catch (parseError) {
          continue;
        }
        
        // Extract sessionMemory from structured document
        if (document.request?.context?.sessionMemory) {
          const sessionMemory = document.request.context.sessionMemory;
          sessionMemories.push(sessionMemory);
        } else {
        }
      } catch (error) {
        continue;
      }
    }
    
    return sessionMemories.slice(0, 5);
  }

  
  /**
   * Fetch sessions for a workspace
   */
  private async fetchWorkspaceSessions(workspaceId: string, memoryService: any): Promise<Array<{
    id: string;
    name: string;
    description?: string;
    created: number;
  }>> {
    try {
      if (!memoryService) {
        return [];
      }
      
      // Validate workspace ID
      if (!workspaceId || workspaceId === 'unknown') {
        console.warn('[LoadWorkspaceMode] Invalid workspace ID for session fetching');
        return [];
      }
      
      const sessions = await memoryService.getSessions(workspaceId); // Get sessions for workspace
      
      
      // Defensive validation: ensure all sessions belong to workspace
      const validSessions = sessions.filter((session: any) => session.workspaceId === workspaceId);
      
      if (validSessions.length !== sessions.length) {
        console.error(`[LoadWorkspaceMode] Database filtering failed! Retrieved ${sessions.length} sessions, only ${validSessions.length} belong to workspace ${workspaceId}`);
      }
      
      return validSessions.map((session: any) => ({
        id: session.id,
        name: session.name,
        description: session.description,
        created: session.startTime,
        workspaceId: session.workspaceId // Include for validation
      }));
      
    } catch (error) {
      console.error('[LoadWorkspaceMode] Failed to fetch workspace sessions:', error);
      return [];
    }
  }

  /**
   * Fetch states for a workspace with defensive filtering
   */
  private async fetchWorkspaceStates(workspaceId: string, memoryService: any): Promise<Array<{
    id: string;
    name: string;
    description?: string;
    sessionId: string;
    created: number;
    tags?: string[];
  }>> {
    try {
      if (!memoryService) {
        return [];
      }
      
      // Validate workspace ID
      if (!workspaceId || workspaceId === 'unknown') {
        console.warn('[LoadWorkspaceMode] Invalid workspace ID for state fetching');
        return [];
      }
      
      const states = await memoryService.getStates(workspaceId);
      
      // Defensive validation: ensure all states belong to workspace
      const validStates = states.filter((state: any) => state.workspaceId === workspaceId);
      
      if (validStates.length !== states.length) {
        console.error(`[LoadWorkspaceMode] Filtered ${states.length - validStates.length} cross-workspace states`);
      }
      
      return validStates.map((state: any) => ({
        id: state.id,
        name: state.name,
        description: state.description,
        sessionId: state.sessionId,
        created: state.created || state.timestamp,
        tags: state.state?.metadata?.tags || [],
        workspaceId: state.workspaceId // Include for validation
      }));
      
    } catch (error) {
      console.error('[LoadWorkspaceMode] Failed to fetch workspace states:', error);
      return [];
    }
  }

  /**
   * Fetch workspace agent data if available
   */
  private async fetchWorkspaceAgent(workspace: ProjectWorkspace): Promise<{
    id: string;
    name: string;
    systemPrompt: string;
  } | null> {
    try {
      // Check if workspace has a dedicated agent
      if (!workspace.context?.dedicatedAgent) {
        // Fall back to legacy agents array for backward compatibility
        const legacyAgents = (workspace.context as any)?.agents;
        if (legacyAgents && Array.isArray(legacyAgents) && legacyAgents.length > 0) {
          const legacyAgentRef = legacyAgents[0];
          if (legacyAgentRef && legacyAgentRef.name) {
            return await this.fetchAgentByName(legacyAgentRef.name);
          }
        }
        return null;
      }

      // Use the new dedicated agent structure
      const { agentId, agentName } = workspace.context.dedicatedAgent;
      return await this.fetchAgentById(agentId, agentName);

    } catch (error) {
      console.warn('[LoadWorkspaceMode] Failed to fetch workspace agent:', error);
      return null;
    }
  }

  /**
   * Fetch agent by ID (preferred method)
   */
  private async fetchAgentById(agentId: string, agentName: string): Promise<{
    id: string;
    name: string;
    systemPrompt: string;
  } | null> {
    try {
      // Get CustomPromptStorageService through plugin's agentManager
      const plugin = this.agent.getApp().plugins.getPlugin('claudesidian-mcp') as any;
      if (!plugin || !plugin.agentManager) {
        console.warn('[LoadWorkspaceMode] AgentManager not available');
        return null;
      }

      const agentManagerAgent = plugin.agentManager.getAgent('agentManager');
      if (!agentManagerAgent || !agentManagerAgent.storageService) {
        console.warn('[LoadWorkspaceMode] AgentManagerAgent or storage service not available');
        return null;
      }

      // Fetch agent by ID (more reliable)
      const agent = agentManagerAgent.storageService.getPromptById(agentId);
      if (!agent) {
        console.warn(`[LoadWorkspaceMode] Agent with ID '${agentId}' not found in storage`);
        return null;
      }

      return {
        id: agent.id,
        name: agent.name,
        systemPrompt: agent.prompt
      };

    } catch (error) {
      console.warn(`[LoadWorkspaceMode] Failed to fetch agent by ID '${agentId}':`, error);
      return null;
    }
  }

  /**
   * Fetch agent by name (legacy fallback)
   */
  private async fetchAgentByName(agentName: string): Promise<{
    id: string;
    name: string;
    systemPrompt: string;
  } | null> {
    try {
      // Get CustomPromptStorageService through plugin's agentManager
      const plugin = this.agent.getApp().plugins.getPlugin('claudesidian-mcp') as any;
      if (!plugin || !plugin.agentManager) {
        console.warn('[LoadWorkspaceMode] AgentManager not available');
        return null;
      }

      const agentManagerAgent = plugin.agentManager.getAgent('agentManager');
      if (!agentManagerAgent || !agentManagerAgent.storageService) {
        console.warn('[LoadWorkspaceMode] AgentManagerAgent or storage service not available');
        return null;
      }

      // Fetch agent by name (legacy method)
      const agent = agentManagerAgent.storageService.getPromptByName(agentName);
      if (!agent) {
        console.warn(`[LoadWorkspaceMode] Agent '${agentName}' not found in storage`);
        return null;
      }

      return {
        id: agent.id,
        name: agent.name,
        systemPrompt: agent.prompt
      };

    } catch (error) {
      console.warn(`[LoadWorkspaceMode] Failed to fetch agent by name '${agentName}':`, error);
      return null;
    }
  }
  
  /**
   * Get the parameter schema
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'Workspace ID to load (REQUIRED)'
        }
      },
      required: ['id']
    };
    
    // Merge with common schema (adds sessionId, workspaceContext)
    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the result schema
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation was successful'
        },
        error: {
          type: 'string',
          description: 'Error message if operation failed'
        },
        data: {
          type: 'object',
          properties: {
            context: {
              type: 'string',
              description: 'Formatted contextual briefing about the workspace'
            },
            workflow: {
              type: 'string',
              description: 'Formatted workflow information'
            },
            keyFiles: {
              type: 'object',
              additionalProperties: {
                type: 'string'
              },
              description: 'Key files as name-path pairs'
            },
            preferences: {
              type: 'string',
              description: 'Formatted user preferences'
            },
            sessions: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                    description: 'Session ID'
                  },
                  name: {
                    type: 'string',
                    description: 'Session name'
                  },
                  description: {
                    type: 'string',
                    description: 'Session description'
                  },
                  created: {
                    type: 'number',
                    description: 'Session creation timestamp'
                  }
                },
                required: ['id', 'name', 'created']
              },
              description: 'Sessions in this workspace'
            },
            states: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                    description: 'State ID'
                  },
                  name: {
                    type: 'string',
                    description: 'State name'
                  },
                  description: {
                    type: 'string',
                    description: 'State description'
                  },
                  sessionId: {
                    type: 'string',
                    description: 'Session ID this state belongs to'
                  },
                  created: {
                    type: 'number',
                    description: 'State creation timestamp'
                  },
                  tags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'State tags'
                  }
                },
                required: ['id', 'name', 'sessionId', 'created']
              },
              description: 'States in this workspace'
            },
            agent: {
              type: 'object',
              properties: {
                id: {
                  type: 'string',
                  description: 'Agent ID'
                },
                name: {
                  type: 'string',
                  description: 'Agent name'
                },
                systemPrompt: {
                  type: 'string',
                  description: 'Agent system prompt'
                }
              },
              required: ['id', 'name', 'systemPrompt'],
              description: 'Associated workspace agent (if available)'
            }
          }
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'Current workspace ID'
            },
            workspacePath: {
              type: 'array',
              items: { type: 'string' },
              description: 'Full path from root workspace'
            }
          }
        }
      },
      required: ['success']
    };
  }
}
```

## agents/memoryManager/modes/workspaces/UpdateWorkspaceMode.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/workspaces/UpdateWorkspaceMode.ts
 * Purpose: Update existing workspace properties and context
 * 
 * This mode allows updating various aspects of an existing workspace including
 * name, description, context, and other metadata without recreating it.
 * 
 * Used by: MemoryManager agent for workspace modification operations
 */

import { App } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { MemoryManagerAgent } from '../../memoryManager';
import { createServiceIntegration } from '../../services/ValidationService';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { CommonResult, CommonParameters } from '../../../../types/mcp/AgentTypes';

// Define parameter and result types for workspace updates
export interface UpdateWorkspaceParameters extends CommonParameters {
    workspaceId: string;
    fieldPath: string; // e.g., 'name', 'context.purpose', 'context.workflows[0].name'
    newValue: any; // The new value to set at the field path
}

export interface UpdateWorkspaceResult extends CommonResult {
    workspaceId: string;
    updated: boolean;
    fieldPath: string;
    oldValue?: any;
    newValue: any;
    workspace?: any;
}

/**
 * UpdateWorkspaceMode - Modify existing workspace properties
 */
export class UpdateWorkspaceMode extends BaseMode<UpdateWorkspaceParameters, UpdateWorkspaceResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    
    constructor(private agent: MemoryManagerAgent) {
        super(
            'updateWorkspace',
            'Update Workspace',
            'Update an existing workspace with new properties, context, or metadata',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
    }
    
    async execute(params: UpdateWorkspaceParameters): Promise<UpdateWorkspaceResult> {
        try {
            // Get workspace service
            const serviceResult = await this.serviceIntegration.getWorkspaceService();
            if (!serviceResult.success || !serviceResult.service) {
                return this.prepareResult(false, {
                    workspaceId: params.workspaceId,
                    updated: false,
                    fieldPath: params.fieldPath,
                    newValue: params.newValue
                }, `Workspace service not available: ${serviceResult.error}`);
            }
            
            const workspaceService = serviceResult.service;
            
            // Validate workspace exists
            const existingWorkspace = await workspaceService.getWorkspace(params.workspaceId);
            if (!existingWorkspace) {
                return this.prepareResult(false, {
                    workspaceId: params.workspaceId,
                    updated: false,
                    fieldPath: params.fieldPath,
                    newValue: params.newValue
                }, `Workspace with ID ${params.workspaceId} not found`);
            }

            // Validate field path
            const pathValidation = this.validateFieldPath(params.fieldPath);
            if (!pathValidation.isValid) {
                return this.prepareResult(false, {
                    workspaceId: params.workspaceId,
                    updated: false,
                    fieldPath: params.fieldPath,
                    newValue: params.newValue
                }, `Invalid field path: ${pathValidation.error}`);
            }

            // Get current value at field path
            const oldValue = this.getValueAtPath(existingWorkspace, params.fieldPath);
            
            // Check if value actually changed
            if (this.deepEqual(oldValue, params.newValue)) {
                return this.prepareResult(true, {
                    workspaceId: params.workspaceId,
                    updated: false,
                    fieldPath: params.fieldPath,
                    oldValue: oldValue,
                    newValue: params.newValue,
                    workspace: existingWorkspace
                }, undefined, 'No changes detected - field value is already up to date');
            }

            // Special handling for rootFolder - ensure it exists
            if (params.fieldPath === 'rootFolder' && typeof params.newValue === 'string') {
                try {
                    const folder = this.app.vault.getAbstractFileByPath(params.newValue);
                    if (!folder) {
                        await this.app.vault.createFolder(params.newValue);
                    }
                } catch (folderError) {
                    console.warn(`Could not create new root folder: ${folderError}`);
                }
            }

            // Create a deep copy and update the field
            const workspaceCopy = JSON.parse(JSON.stringify(existingWorkspace));
            this.setValueAtPath(workspaceCopy, params.fieldPath, params.newValue);

            // Add activity history entry
            const now = Date.now();
            const activityEntry = {
                timestamp: now,
                action: 'update' as const,
                toolName: 'UpdateWorkspaceMode',
                context: `Updated ${params.fieldPath}: ${this.formatValueForLog(oldValue)} ‚Üí ${this.formatValueForLog(params.newValue)}`
            };

            workspaceCopy.activityHistory = [
                ...(existingWorkspace.activityHistory || []),
                activityEntry
            ];
            workspaceCopy.lastAccessed = now;

            // Perform the update
            await workspaceService.updateWorkspace(params.workspaceId, workspaceCopy);
            
            // Get the updated workspace
            const updatedWorkspace = await workspaceService.getWorkspace(params.workspaceId);

            return this.prepareResult(true, {
                workspaceId: params.workspaceId,
                updated: true,
                fieldPath: params.fieldPath,
                oldValue: oldValue,
                newValue: params.newValue,
                workspace: updatedWorkspace
            }, undefined, `Successfully updated ${params.fieldPath} in workspace "${existingWorkspace.name}"`);
            
        } catch (error) {
            return this.prepareResult(false, {
                workspaceId: params.workspaceId,
                updated: false,
                fieldPath: params.fieldPath,
                newValue: params.newValue
            }, createErrorMessage('Error updating workspace: ', error));
        }
    }

    getParameterSchema(): any {
        const customSchema = {
            type: 'object',
            properties: {
                workspaceId: { 
                    type: 'string', 
                    description: 'ID of the workspace to update (REQUIRED)' 
                },
                fieldPath: {
                    type: 'string',
                    description: 'Path to the field to update. Supports nested paths with dot notation and array indices in brackets. Examples: "name", "description", "context.purpose", "context.workflows[0].name", "context.keyFiles[0].files.resume"',
                    pattern: '^[a-zA-Z][a-zA-Z0-9_]*(?:\\.[a-zA-Z][a-zA-Z0-9_]*|\\[[0-9]+\\])*$'
                },
                newValue: {
                    description: 'The new value to set at the specified field path. Can be any type (string, number, boolean, array, object).'
                }
            },
            required: ['workspaceId', 'fieldPath', 'newValue']
        };
        
        return this.getMergedSchema(customSchema);
    }
    
    getResultSchema(): any {
        return {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                data: {
                    type: 'object',
                    properties: {
                        workspaceId: { type: 'string' },
                        updated: { type: 'boolean' },
                        fieldPath: { 
                            type: 'string', 
                            description: 'The field path that was updated'
                        },
                        oldValue: {
                            description: 'The previous value at the field path'
                        },
                        newValue: {
                            description: 'The new value that was set'
                        },
                        workspace: { 
                            type: 'object',
                            description: 'Updated workspace object'
                        }
                    },
                    required: ['workspaceId', 'updated', 'fieldPath', 'newValue']
                }
            }
        };
    }

    /**
     * Validate field path format and allowed fields
     */
    private validateFieldPath(path: string): { isValid: boolean; error?: string } {
        if (!path || path.trim() === '') {
            return { isValid: false, error: 'Field path cannot be empty' };
        }

        // Check basic pattern
        const validPattern = /^[a-zA-Z][a-zA-Z0-9_]*(?:\.[a-zA-Z][a-zA-Z0-9_]*|\[[0-9]+\])*$/;
        if (!validPattern.test(path)) {
            return { 
                isValid: false, 
                error: 'Invalid path format. Use dot notation for nested fields and [index] for arrays. Example: "context.workflows[0].name"' 
            };
        }

        // Parse and validate allowed root fields
        const keys = this.parseFieldPath(path);
        const rootField = keys[0];
        
        const allowedRootFields = [
            'name', 'description', 'rootFolder', 'relatedFolders', 'relatedFiles', 
            'associatedNotes', 'keyFileInstructions', 'preferences', 'projectPlan',
            'context', 'activityHistory', 'checkpoints', 'completionStatus'
        ];
        
        if (!allowedRootFields.includes(rootField)) {
            return { 
                isValid: false, 
                error: `Invalid root field "${rootField}". Allowed fields: ${allowedRootFields.join(', ')}` 
            };
        }

        // Special validation for context fields
        if (rootField === 'context' && keys.length > 1) {
            const contextField = keys[1];
            const allowedContextFields = [
                'purpose', 'currentGoal', 'status', 'workflows', 'keyFiles', 'preferences', 'agents'
            ];
            
            if (!allowedContextFields.includes(contextField)) {
                return { 
                    isValid: false, 
                    error: `Invalid context field "${contextField}". Allowed context fields: ${allowedContextFields.join(', ')}` 
                };
            }
        }

        // Validate array indices are reasonable (0-999)
        for (const key of keys) {
            if (this.isArrayIndex(key)) {
                const index = parseInt(key, 10);
                if (index < 0 || index > 999) {
                    return { 
                        isValid: false, 
                        error: `Array index ${index} is out of reasonable range (0-999)` 
                    };
                }
            }
        }

        return { isValid: true };
    }

    /**
     * Get value at a nested field path (e.g., 'context.purpose', 'context.workflows[0].name')
     */
    private getValueAtPath(obj: any, path: string): any {
        if (!path) return obj;
        
        const keys = this.parseFieldPath(path);
        let current = obj;
        
        for (const key of keys) {
            if (current === null || current === undefined) {
                return undefined;
            }
            current = current[key];
        }
        
        return current;
    }

    /**
     * Set value at a nested field path, creating intermediate objects/arrays as needed
     */
    private setValueAtPath(obj: any, path: string, value: any): void {
        if (!path) return;
        
        const keys = this.parseFieldPath(path);
        let current = obj;
        
        for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            const nextKey = keys[i + 1];
            
            if (!(key in current) || current[key] === null || current[key] === undefined) {
                // Create object or array based on next key
                current[key] = this.isArrayIndex(nextKey) ? [] : {};
            }
            
            current = current[key];
        }
        
        const finalKey = keys[keys.length - 1];
        current[finalKey] = value;
    }

    /**
     * Parse field path into individual keys, handling array indices
     * e.g., 'context.workflows[0].name' -> ['context', 'workflows', '0', 'name']
     */
    private parseFieldPath(path: string): string[] {
        const keys: string[] = [];
        let current = '';
        let i = 0;
        
        while (i < path.length) {
            const char = path[i];
            
            if (char === '.') {
                if (current) {
                    keys.push(current);
                    current = '';
                }
            } else if (char === '[') {
                if (current) {
                    keys.push(current);
                    current = '';
                }
                // Find closing bracket
                i++;
                while (i < path.length && path[i] !== ']') {
                    current += path[i];
                    i++;
                }
                if (current) {
                    keys.push(current);
                    current = '';
                }
            } else if (char !== ']') {
                current += char;
            }
            
            i++;
        }
        
        if (current) {
            keys.push(current);
        }
        
        return keys;
    }

    /**
     * Check if a key looks like an array index (all digits)
     */
    private isArrayIndex(key: string): boolean {
        return /^\d+$/.test(key);
    }

    /**
     * Deep equality check for values
     */
    private deepEqual(a: any, b: any): boolean {
        if (a === b) return true;
        
        if (a === null || b === null || a === undefined || b === undefined) {
            return a === b;
        }
        
        if (typeof a !== typeof b) return false;
        
        if (typeof a !== 'object') return a === b;
        
        if (Array.isArray(a) !== Array.isArray(b)) return false;
        
        if (Array.isArray(a)) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (!this.deepEqual(a[i], b[i])) return false;
            }
            return true;
        }
        
        const keysA = Object.keys(a);
        const keysB = Object.keys(b);
        
        if (keysA.length !== keysB.length) return false;
        
        for (const key of keysA) {
            if (!keysB.includes(key)) return false;
            if (!this.deepEqual(a[key], b[key])) return false;
        }
        
        return true;
    }

    /**
     * Format value for logging (truncate if too long)
     */
    private formatValueForLog(value: any): string {
        if (value === null) return 'null';
        if (value === undefined) return 'undefined';
        
        let str: string;
        if (typeof value === 'string') {
            str = `"${value}"`;
        } else if (typeof value === 'object') {
            str = JSON.stringify(value);
        } else {
            str = String(value);
        }
        
        return str.length > 100 ? str.substring(0, 97) + '...' : str;
    }
}
```

## agents/memoryManager/modes/workspaces/index.ts

```typescript
export * from './CreateWorkspaceMode';
export * from './ListWorkspacesMode';
export * from './LoadWorkspaceMode';
export * from './UpdateWorkspaceMode';
```

## agents/memoryManager/services/MemoryService.ts

```typescript
import { Plugin } from 'obsidian';
import { WorkspaceMemoryTrace, WorkspaceSession, WorkspaceStateSnapshot } from '../../../database/workspace-types';
import { FileSystemService } from '../../../services/migration/FileSystemService';
import { WorkspaceDataStructure, ConversationDataStructure } from '../../../types/migration/MigrationTypes';

/**
 * Location: src/agents/memoryManager/services/MemoryService.ts
 *
 * MemoryService using the new FileSystemService and nested JSON structure.
 * Manages memory traces, sessions, and snapshots stored within the hierarchical
 * workspace data structure: workspaces ‚Üí sessions ‚Üí traces/states.
 *
 * Used by: MemoryManager agent modes for memory operations
 * Integrates with: FileSystemService for data persistence, WorkspaceService for workspace context
 */
export class MemoryService {
  private plugin: Plugin;
  private fileSystem: FileSystemService;

  constructor(plugin: Plugin) {
    this.plugin = plugin;
    this.fileSystem = new FileSystemService(plugin);
  }

  // Memory Traces
  async getMemoryTraces(workspaceId: string, sessionId?: string): Promise<WorkspaceMemoryTrace[]> {
    const data = await this.loadWorkspaceData();
    const workspace = data.workspaces[workspaceId];

    if (!workspace) return [];

    if (sessionId) {
      const session = workspace.sessions[sessionId];
      return session ? Object.values(session.memoryTraces).map(trace => ({
        ...trace,
        workspaceId: workspaceId,
        sessionId: sessionId
      })) : [];
    }

    // Return all traces from all sessions in workspace
    return Object.values(workspace.sessions)
      .flatMap(session => Object.values(session.memoryTraces).map(trace => ({
        ...trace,
        workspaceId: workspaceId,
        sessionId: session.id
      })));
  }

  async recordActivityTrace(trace: Omit<WorkspaceMemoryTrace, 'id'>): Promise<string> {
    const data = await this.loadWorkspaceData();

    // Ensure workspace exists
    if (!data.workspaces[trace.workspaceId]) {
      throw new Error(`Workspace ${trace.workspaceId} not found`);
    }

    // Ensure session exists (create default if needed)
    const sessionId = trace.sessionId || 'default-session';
    const workspace = data.workspaces[trace.workspaceId];

    if (!workspace.sessions[sessionId]) {
      workspace.sessions[sessionId] = {
        id: sessionId,
        name: 'Default Session',
        startTime: Date.now(),
        isActive: true,
        memoryTraces: {},
        states: {}
      };
    }

    // Add trace
    const traceId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
    const newTrace = { ...trace, id: traceId };

    workspace.sessions[sessionId].memoryTraces[traceId] = newTrace;

    await this.saveWorkspaceData(data);
    return traceId;
  }

  // Backward compatibility methods
  async createMemoryTrace(trace: Omit<WorkspaceMemoryTrace, 'id'>): Promise<WorkspaceMemoryTrace> {
    const traceId = await this.recordActivityTrace(trace);
    const data = await this.loadWorkspaceData();

    // Find and return the created trace
    const workspace = data.workspaces[trace.workspaceId];
    const sessionId = trace.sessionId || 'default-session';
    const session = workspace?.sessions[sessionId];

    if (!session || !session.memoryTraces[traceId]) {
      throw new Error('Failed to create memory trace');
    }

    return {
      ...session.memoryTraces[traceId],
      workspaceId: trace.workspaceId,
      sessionId: sessionId
    };
  }

  async storeMemoryTrace(trace: Omit<WorkspaceMemoryTrace, 'id'>): Promise<WorkspaceMemoryTrace> {
    return await this.createMemoryTrace(trace);
  }

  // Sessions
  async createSession(session: Omit<WorkspaceSession, 'id'>): Promise<WorkspaceSession> {
    const data = await this.loadWorkspaceData();

    // Ensure workspace exists
    if (!data.workspaces[session.workspaceId]) {
      throw new Error(`Workspace ${session.workspaceId} not found`);
    }

    const sessionId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
    const newSession = { ...session, id: sessionId };

    // Add to nested structure
    data.workspaces[session.workspaceId].sessions[sessionId] = {
      ...newSession,
      startTime: Date.now(),
      isActive: true,
      memoryTraces: {},
      states: {}
    };

    await this.saveWorkspaceData(data);
    return {
      ...newSession,
      workspaceId: session.workspaceId
    };
  }

  async getSession(id: string): Promise<WorkspaceSession | undefined> {
    const data = await this.loadWorkspaceData();

    // Search through all workspaces for the session
    for (const [workspaceId, workspace] of Object.entries(data.workspaces)) {
      if (workspace.sessions[id]) {
        return {
          ...workspace.sessions[id],
          workspaceId: workspaceId
        };
      }
    }

    return undefined;
  }

  async updateSession(session: WorkspaceSession): Promise<void> {
    const data = await this.loadWorkspaceData();

    // Find the session and update it
    for (const workspace of Object.values(data.workspaces)) {
      if (workspace.sessions[session.id]) {
        // Preserve the nested structure while updating session properties
        Object.assign(workspace.sessions[session.id], {
          name: session.name,
          description: session.description
        });
        await this.saveWorkspaceData(data);
        return;
      }
    }

    throw new Error(`Session ${session.id} not found`);
  }

  async getSessions(workspaceId?: string): Promise<WorkspaceSession[]> {
    const data = await this.loadWorkspaceData();

    if (workspaceId) {
      const workspace = data.workspaces[workspaceId];
      return workspace ? Object.values(workspace.sessions).map(session => ({
        ...session,
        workspaceId: workspaceId
      })) : [];
    }

    // Return all sessions from all workspaces
    return Object.entries(data.workspaces)
      .flatMap(([wId, workspace]) => Object.values(workspace.sessions).map(session => ({
        ...session,
        workspaceId: wId
      })));
  }

  async getSessionTraces(sessionId: string): Promise<WorkspaceMemoryTrace[]> {
    const data = await this.loadWorkspaceData();

    // Search through all workspaces for the session
    for (const [workspaceId, workspace] of Object.entries(data.workspaces)) {
      if (workspace.sessions[sessionId]) {
        return Object.values(workspace.sessions[sessionId].memoryTraces).map(trace => ({
          ...trace,
          workspaceId: workspaceId,
          sessionId: sessionId
        }));
      }
    }

    return [];
  }

  // Snapshots/States
  async saveSnapshot(snapshot: Omit<WorkspaceStateSnapshot, 'id'>): Promise<WorkspaceStateSnapshot> {
    const data = await this.loadWorkspaceData();

    // Find session or default
    const workspace = data.workspaces[snapshot.workspaceId];
    if (!workspace) {
      throw new Error(`Workspace ${snapshot.workspaceId} not found`);
    }

    const sessionId = snapshot.sessionId || 'default-session';
    if (!workspace.sessions[sessionId]) {
      throw new Error(`Session ${sessionId} not found`);
    }

    const stateId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
    const newSnapshot = { ...snapshot, id: stateId };

    workspace.sessions[sessionId].states[stateId] = {
      id: stateId,
      name: newSnapshot.name,
      created: newSnapshot.created || Date.now(),
      snapshot: newSnapshot
    };

    await this.saveWorkspaceData(data);
    return {
      ...newSnapshot,
      id: stateId,
      workspaceId: snapshot.workspaceId,
      sessionId: sessionId
    };
  }

  async createSnapshot(snapshot: Omit<WorkspaceStateSnapshot, 'id'>): Promise<WorkspaceStateSnapshot> {
    return await this.saveSnapshot(snapshot);
  }

  async getSnapshot(id: string): Promise<WorkspaceStateSnapshot | undefined> {
    const data = await this.loadWorkspaceData();

    // Search through all workspaces and sessions for the snapshot
    for (const [workspaceId, workspace] of Object.entries(data.workspaces)) {
      for (const [sessionId, session] of Object.entries(workspace.sessions)) {
        if (session.states[id]) {
          const state = session.states[id];
          return {
            ...state.snapshot,
            id: state.id,
            workspaceId: workspaceId,
            sessionId: sessionId
          };
        }
      }
    }

    return undefined;
  }

  async updateSnapshot(snapshot: WorkspaceStateSnapshot): Promise<void> {
    const data = await this.loadWorkspaceData();

    // Find the snapshot and update it
    for (const workspace of Object.values(data.workspaces)) {
      for (const session of Object.values(workspace.sessions)) {
        if (session.states[snapshot.id]) {
          session.states[snapshot.id] = {
            id: snapshot.id,
            name: snapshot.name,
            created: snapshot.created,
            snapshot: snapshot
          };
          await this.saveWorkspaceData(data);
          return;
        }
      }
    }

    throw new Error(`Snapshot ${snapshot.id} not found`);
  }

  async deleteSnapshot(id: string): Promise<void> {
    const data = await this.loadWorkspaceData();

    // Find and delete the snapshot
    for (const workspace of Object.values(data.workspaces)) {
      for (const session of Object.values(workspace.sessions)) {
        if (session.states[id]) {
          delete session.states[id];
          await this.saveWorkspaceData(data);
          return;
        }
      }
    }

    throw new Error(`Snapshot ${id} not found`);
  }

  async getStates(workspaceId?: string, sessionId?: string): Promise<WorkspaceStateSnapshot[]> {
    const data = await this.loadWorkspaceData();

    if (workspaceId && sessionId) {
      const session = data.workspaces[workspaceId]?.sessions[sessionId];
      return session ? Object.values(session.states).map(state => ({
        ...state.snapshot,
        id: state.id,
        workspaceId: workspaceId,
        sessionId: sessionId
      })) : [];
    }

    if (workspaceId) {
      const workspace = data.workspaces[workspaceId];
      return workspace ?
        Object.entries(workspace.sessions).flatMap(([sId, session]) =>
          Object.values(session.states).map(state => ({
            ...state.snapshot,
            id: state.id,
            workspaceId: workspaceId,
            sessionId: sId
          }))
        ) : [];
    }

    // Return all states from all workspaces
    return Object.entries(data.workspaces)
      .flatMap(([wId, workspace]) =>
        Object.entries(workspace.sessions).flatMap(([sId, session]) =>
          Object.values(session.states).map(state => ({
            ...state.snapshot,
            id: state.id,
            workspaceId: wId,
            sessionId: sId
          }))
        )
      );
  }

  async getSnapshots(workspaceId?: string, sessionId?: string): Promise<WorkspaceStateSnapshot[]> {
    return await this.getStates(workspaceId, sessionId);
  }

  // Memory search
  async searchMemoryTraces(workspaceId: string, query?: string, limit?: number): Promise<WorkspaceMemoryTrace[]> {
    const traces = await this.getMemoryTraces(workspaceId);

    if (!query) {
      return limit ? traces.slice(0, limit) : traces;
    }

    const filtered = traces.filter(trace =>
      trace.content.toLowerCase().includes(query.toLowerCase()) ||
      trace.type.toLowerCase().includes(query.toLowerCase())
    );

    return limit ? filtered.slice(0, limit) : filtered;
  }

  private async loadWorkspaceData(): Promise<WorkspaceDataStructure> {
    const data = await this.fileSystem.readJSON('workspace-data.json');

    if (!data) {
      return {
        workspaces: {},
        metadata: { version: '2.0.0', lastUpdated: Date.now() }
      };
    }

    return data;
  }

  private async saveWorkspaceData(data: WorkspaceDataStructure): Promise<void> {
    data.metadata.lastUpdated = Date.now();
    await this.fileSystem.writeJSON('workspace-data.json', data);
  }
}
```

## agents/memoryManager/services/MemoryService.ts.backup

```text
import { Plugin } from 'obsidian';
import { WorkspaceMemoryTrace, WorkspaceSession, WorkspaceStateSnapshot } from '../../../database/workspace-types';

/**
 * MemoryService using direct Obsidian data storage
 */
export class MemoryService {
  private plugin: Plugin;
  private readonly TRACES_KEY = 'memoryTraces';
  private readonly SESSIONS_KEY = 'sessions';
  private readonly SNAPSHOTS_KEY = 'snapshots';

  constructor(plugin: Plugin) {
    this.plugin = plugin;
  }

  // Memory Traces
  async createMemoryTrace(trace: Omit<WorkspaceMemoryTrace, 'id'>): Promise<WorkspaceMemoryTrace> {
    const traces = await this.getAllTraces();
    const newTrace = {
      ...trace,
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9)
    };

    traces.push(newTrace);
    await this.saveTraces(traces);
    return newTrace;
  }

  async getMemoryTraces(workspaceId: string): Promise<WorkspaceMemoryTrace[]> {
    const traces = await this.getAllTraces();
    return traces.filter(t => t.workspaceId === workspaceId);
  }

  async recordActivityTrace(trace: Omit<WorkspaceMemoryTrace, 'id'>): Promise<string> {
    const newTrace = await this.createMemoryTrace(trace);
    return newTrace.id;
  }

  async storeMemoryTrace(trace: Omit<WorkspaceMemoryTrace, 'id'>): Promise<WorkspaceMemoryTrace> {
    return await this.createMemoryTrace(trace);
  }

  // Sessions
  async createSession(session: Omit<WorkspaceSession, 'id'>): Promise<WorkspaceSession> {
    const sessions = await this.getAllSessions();
    const newSession = {
      ...session,
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9)
    };

    sessions.push(newSession);
    await this.saveSessions(sessions);
    return newSession;
  }

  async getSession(id: string): Promise<WorkspaceSession | undefined> {
    const sessions = await this.getAllSessions();
    return sessions.find(s => s.id === id);
  }

  async updateSession(session: WorkspaceSession): Promise<void> {
    const sessions = await this.getAllSessions();
    const index = sessions.findIndex(s => s.id === session.id);

    if (index === -1) {
      throw new Error(`Session ${session.id} not found`);
    }

    sessions[index] = session;
    await this.saveSessions(sessions);
  }

  async getSessions(workspaceId?: string): Promise<WorkspaceSession[]> {
    const sessions = await this.getAllSessions();
    if (workspaceId) {
      return sessions.filter(s => s.workspaceId === workspaceId);
    }
    return sessions;
  }

  async getSessionTraces(sessionId: string): Promise<WorkspaceMemoryTrace[]> {
    const traces = await this.getAllTraces();
    return traces.filter(t => t.sessionId === sessionId);
  }

  // Snapshots
  async createSnapshot(snapshot: Omit<WorkspaceStateSnapshot, 'id'>): Promise<WorkspaceStateSnapshot> {
    const snapshots = await this.getAllSnapshots();
    const newSnapshot = {
      ...snapshot,
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9)
    };

    snapshots.push(newSnapshot);
    await this.saveSnapshots(snapshots);
    return newSnapshot;
  }

  async getSnapshot(id: string): Promise<WorkspaceStateSnapshot | undefined> {
    const snapshots = await this.getAllSnapshots();
    return snapshots.find(s => s.id === id);
  }

  async updateSnapshot(snapshot: WorkspaceStateSnapshot): Promise<void> {
    const snapshots = await this.getAllSnapshots();
    const index = snapshots.findIndex(s => s.id === snapshot.id);

    if (index === -1) {
      throw new Error(`Snapshot ${snapshot.id} not found`);
    }

    snapshots[index] = snapshot;
    await this.saveSnapshots(snapshots);
  }

  async getStates(workspaceId?: string): Promise<WorkspaceStateSnapshot[]> {
    const snapshots = await this.getAllSnapshots();
    if (workspaceId) {
      return snapshots.filter(s => s.workspaceId === workspaceId);
    }
    return snapshots;
  }

  async deleteSnapshot(id: string): Promise<void> {
    const snapshots = await this.getAllSnapshots();
    const filtered = snapshots.filter(s => s.id !== id);
    await this.saveSnapshots(filtered);
  }

  async getSnapshots(workspaceId?: string, sessionId?: string): Promise<WorkspaceStateSnapshot[]> {
    const snapshots = await this.getAllSnapshots();
    let filtered = snapshots;

    if (workspaceId) {
      filtered = filtered.filter(s => s.workspaceId === workspaceId);
    }

    if (sessionId) {
      filtered = filtered.filter(s => s.sessionId === sessionId);
    }

    return filtered;
  }

  // Memory search methods
  async searchMemoryTraces(workspaceId: string, query?: string, limit?: number): Promise<WorkspaceMemoryTrace[]> {
    const traces = await this.getMemoryTraces(workspaceId);
    if (!query) {
      return limit ? traces.slice(0, limit) : traces;
    }

    const filtered = traces.filter(trace =>
      trace.content.toLowerCase().includes(query.toLowerCase()) ||
      trace.type.toLowerCase().includes(query.toLowerCase())
    );

    return limit ? filtered.slice(0, limit) : filtered;
  }

  // Private helpers
  private async getAllTraces(): Promise<WorkspaceMemoryTrace[]> {
    const data = await this.plugin.loadData();
    return data?.[this.TRACES_KEY] || [];
  }

  private async saveTraces(traces: WorkspaceMemoryTrace[]): Promise<void> {
    const data = await this.plugin.loadData() || {};
    data[this.TRACES_KEY] = traces;
    await this.plugin.saveData(data);
  }

  private async getAllSessions(): Promise<WorkspaceSession[]> {
    const data = await this.plugin.loadData();
    return data?.[this.SESSIONS_KEY] || [];
  }

  private async saveSessions(sessions: WorkspaceSession[]): Promise<void> {
    const data = await this.plugin.loadData() || {};
    data[this.SESSIONS_KEY] = sessions;
    await this.plugin.saveData(data);
  }

  private async getAllSnapshots(): Promise<WorkspaceStateSnapshot[]> {
    const data = await this.plugin.loadData();
    return data?.[this.SNAPSHOTS_KEY] || [];
  }

  private async saveSnapshots(snapshots: WorkspaceStateSnapshot[]): Promise<void> {
    const data = await this.plugin.loadData() || {};
    data[this.SNAPSHOTS_KEY] = snapshots;
    await this.plugin.saveData(data);
  }
}
```

## agents/memoryManager/services/ValidationService.ts

```typescript
/**
 * Location: /src/agents/memoryManager/services/ValidationService.ts
 * Purpose: Consolidated validation service combining all validation logic from memory manager modes
 * 
 * This file consolidates:
 * - ServiceIntegration.ts (service access and validation)
 * - All parameter validators from various modes
 * - Error handling and retry logic
 * - Service status monitoring and diagnostics
 * 
 * Used by: All consolidated memory manager modes for service access and validation
 */

import { App } from 'obsidian';
import { MemoryService } from "./MemoryService";
import { WorkspaceService } from "./WorkspaceService";
import { getErrorMessage } from '../../../utils/errorUtils';

/**
 * Service availability status
 */
export interface ServiceStatus {
  available: boolean;
  initialized: boolean;
  lastError?: string;
  lastCheck: number;
  retryCount: number;
}

/**
 * Service integration configuration
 */
export interface ServiceIntegrationConfig {
  maxRetries: number;
  retryDelayMs: number;
  timeoutMs: number;
  enableHealthCheck: boolean;
  fallbackBehavior: 'fail' | 'warn' | 'silent';
  logLevel: 'debug' | 'info' | 'warn' | 'error';
}

/**
 * Service access result with detailed error information
 */
export interface ServiceAccessResult<T> {
  success: boolean;
  service: T | null;
  error?: string;
  status: ServiceStatus;
  diagnostics?: {
    pluginFound: boolean;
    serviceContainerAvailable: boolean;
    serviceFound: boolean;
    methodUsed: string;
    duration: number;
  };
}

/**
 * Plugin interface for service access
 */
export interface ClaudesidianPlugin {
  services?: {
    memoryService?: MemoryService;
    workspaceService?: WorkspaceService;
  };
  serviceContainer?: {
    getIfReady<T>(serviceName: string): T | null;
  };
  getService?<T>(serviceName: string): Promise<T>;
}

/**
 * Validation error structure
 */
export interface ValidationError {
  field: string;
  value: any;
  requirement: string;
}

/**
 * Consolidated validation service for memory manager operations
 */
export class ValidationService {
  private static readonly DEFAULT_CONFIG: ServiceIntegrationConfig = {
    maxRetries: 3,
    retryDelayMs: 500,
    timeoutMs: 5000,
    enableHealthCheck: true,
    fallbackBehavior: 'warn',
    logLevel: 'warn'
  };

  private app: App;
  private config: ServiceIntegrationConfig;
  private serviceStatuses: Map<string, ServiceStatus> = new Map();

  constructor(app: App, config: Partial<ServiceIntegrationConfig> = {}) {
    this.app = app;
    this.config = { ...ValidationService.DEFAULT_CONFIG, ...config };
  }

  /**
   * Get memory service with robust error handling and retry logic
   */
  async getMemoryService(): Promise<ServiceAccessResult<MemoryService>> {
    return this.getService<MemoryService>('memoryService', 'MemoryService');
  }

  /**
   * Get workspace service with robust error handling and retry logic
   */
  async getWorkspaceService(): Promise<ServiceAccessResult<WorkspaceService>> {
    return this.getService<WorkspaceService>('workspaceService', 'WorkspaceService');
  }

  /**
   * Get memory service synchronously (for immediate availability checks)
   */
  getMemoryServiceSync(): ServiceAccessResult<MemoryService> {
    return this.getServiceSync<MemoryService>('memoryService', 'MemoryService');
  }

  /**
   * Get workspace service synchronously (for immediate availability checks)
   */
  getWorkspaceServiceSync(): ServiceAccessResult<WorkspaceService> {
    return this.getServiceSync<WorkspaceService>('workspaceService', 'WorkspaceService');
  }

  /**
   * Validate session creation parameters
   */
  validateSessionCreationParams(params: any): ValidationError[] {
    const errors: ValidationError[] = [];

    // Session name validation
    if (params.name && typeof params.name !== 'string') {
      errors.push({
        field: 'name',
        value: params.name,
        requirement: 'Session name must be a string if provided'
      });
    }

    // Session goal validation
    if (params.sessionGoal && typeof params.sessionGoal !== 'string') {
      errors.push({
        field: 'sessionGoal',
        value: params.sessionGoal,
        requirement: 'Session goal must be a string if provided'
      });
    }

    // Tags validation
    if (params.tags && (!Array.isArray(params.tags) || !params.tags.every((tag: any) => typeof tag === 'string'))) {
      errors.push({
        field: 'tags',
        value: params.tags,
        requirement: 'Tags must be an array of strings if provided'
      });
    }

    return errors;
  }

  /**
   * Validate state creation parameters
   */
  validateStateCreationParams(params: any): ValidationError[] {
    const errors: ValidationError[] = [];

    if (!params.name) {
      errors.push({
        field: 'name',
        value: params.name,
        requirement: 'State name is required and must be a descriptive, non-empty string'
      });
    }

    if (!params.conversationContext) {
      errors.push({
        field: 'conversationContext',
        value: params.conversationContext,
        requirement: 'Conversation context is required. Provide a summary of what was happening when you decided to save this state'
      });
    }

    if (!params.activeTask) {
      errors.push({
        field: 'activeTask',
        value: params.activeTask,
        requirement: 'Active task description is required. Be specific about the current task you were working on'
      });
    }

    if (!params.activeFiles || !Array.isArray(params.activeFiles) || params.activeFiles.length === 0) {
      errors.push({
        field: 'activeFiles',
        value: params.activeFiles,
        requirement: 'Active files list is required. Specify which files were being edited or referenced'
      });
    }

    if (!params.nextSteps || !Array.isArray(params.nextSteps) || params.nextSteps.length === 0) {
      errors.push({
        field: 'nextSteps',
        value: params.nextSteps,
        requirement: 'Next steps are required. Provide specific actionable steps for when you resume'
      });
    }

    if (!params.reasoning) {
      errors.push({
        field: 'reasoning',
        value: params.reasoning,
        requirement: 'Reasoning for saving state is required. Explain why you are saving the state at this point'
      });
    }

    return errors;
  }

  /**
   * Validate workspace creation parameters
   */
  validateWorkspaceCreationParams(params: any): ValidationError[] {
    const errors: ValidationError[] = [];

    if (!params.name) {
      errors.push({
        field: 'name',
        value: params.name,
        requirement: 'Workspace name is required and must be a non-empty string'
      });
    }

    if (!params.rootFolder) {
      errors.push({
        field: 'rootFolder',
        value: params.rootFolder,
        requirement: 'Root folder path is required for workspace organization'
      });
    }

    if (!params.purpose) {
      errors.push({
        field: 'purpose',
        value: params.purpose,
        requirement: 'Workspace purpose is required. Provide a clear description of what this workspace is for'
      });
    }

    if (!params.currentGoal) {
      errors.push({
        field: 'currentGoal',
        value: params.currentGoal,
        requirement: 'Current goal is required. Specify what you are trying to accomplish right now'
      });
    }

    if (!params.workflows || !Array.isArray(params.workflows) || params.workflows.length === 0) {
      errors.push({
        field: 'workflows',
        value: params.workflows,
        requirement: 'At least one workflow is required. Provide workflows with name, when to use, and steps'
      });
    }


    return errors;
  }

  /**
   * Core service access method with comprehensive error handling
   */
  private async getService<T>(serviceName: string, displayName: string): Promise<ServiceAccessResult<T>> {
    const startTime = Date.now();
    const status = this.getServiceStatus(serviceName);
    
    // If service was recently checked and failed, return cached failure
    if (!status.available && (Date.now() - status.lastCheck) < this.config.retryDelayMs) {
      this.log('debug', `[ValidationService] Using cached failure for ${displayName}`);
      return this.createResult<T>(false, null, status.lastError || 'Service unavailable', status, {
        pluginFound: false,
        serviceContainerAvailable: false,
        serviceFound: false,
        methodUsed: 'cached',
        duration: Date.now() - startTime
      });
    }

    let attempts = 0;
    let lastError = '';

    while (attempts <= this.config.maxRetries) {
      try {
        attempts++;
        this.log('debug', `[ValidationService] Attempting to get ${displayName} (attempt ${attempts}/${this.config.maxRetries + 1})`);

        const plugin = this.app.plugins.getPlugin('claudesidian-mcp') as ClaudesidianPlugin;
        if (!plugin) {
          lastError = `Plugin 'claudesidian-mcp' not found`;
          this.log('error', `[ValidationService] ${lastError}`);
          
          if (attempts <= this.config.maxRetries) {
            await this.delay(this.config.retryDelayMs);
            continue;
          }
          break;
        }

        const diagnostics = {
          pluginFound: true,
          serviceContainerAvailable: false,
          serviceFound: false,
          methodUsed: '',
          duration: 0
        };

        // Try ServiceContainer first (preferred method)
        if (plugin.serviceContainer) {
          this.log('debug', `[ValidationService] Trying ServiceContainer for ${displayName}`);
          diagnostics.serviceContainerAvailable = true;
          diagnostics.methodUsed = 'serviceContainer';

          const service = plugin.serviceContainer.getIfReady<T>(serviceName);
          if (service) {
            this.log('debug', `[ValidationService] Successfully got ${displayName} via ServiceContainer`);
            diagnostics.serviceFound = true;
            diagnostics.duration = Date.now() - startTime;
            
            const successStatus = this.updateServiceStatus(serviceName, true, undefined);
            return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
          }
        }

        // Try async getService method
        if (plugin.getService) {
          this.log('debug', `[ValidationService] Trying async getService for ${displayName}`);
          diagnostics.methodUsed = diagnostics.methodUsed ? `${diagnostics.methodUsed}+async` : 'async';

          try {
            const service = await this.withTimeout(plugin.getService<T>(serviceName), this.config.timeoutMs);
            if (service) {
              this.log('debug', `[ValidationService] Successfully got ${displayName} via async method`);
              diagnostics.serviceFound = true;
              diagnostics.duration = Date.now() - startTime;
              
              const successStatus = this.updateServiceStatus(serviceName, true, undefined);
              return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
            }
          } catch (asyncError) {
            this.log('warn', `[ValidationService] Async service access failed for ${displayName}:`, asyncError);
            lastError = getErrorMessage(asyncError);
          }
        }

        // Try direct services access (fallback)
        if (plugin.services && plugin.services[serviceName as keyof typeof plugin.services]) {
          this.log('debug', `[ValidationService] Trying direct services access for ${displayName}`);
          diagnostics.methodUsed = diagnostics.methodUsed ? `${diagnostics.methodUsed}+direct` : 'direct';

          const service = plugin.services[serviceName as keyof typeof plugin.services] as T;
          if (service) {
            this.log('debug', `[ValidationService] Successfully got ${displayName} via direct access`);
            diagnostics.serviceFound = true;
            diagnostics.duration = Date.now() - startTime;
            
            const successStatus = this.updateServiceStatus(serviceName, true, undefined);
            return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
          }
        }

        lastError = `${displayName} not available through any access method`;
        this.log('warn', `[ValidationService] ${lastError} (attempt ${attempts})`);

        if (attempts <= this.config.maxRetries) {
          await this.delay(this.config.retryDelayMs);
        }

      } catch (error) {
        lastError = getErrorMessage(error);
        this.log('error', `[ValidationService] Error accessing ${displayName} (attempt ${attempts}):`, error);
        
        if (attempts <= this.config.maxRetries) {
          await this.delay(this.config.retryDelayMs);
        }
      }
    }

    // All attempts failed
    const failureStatus = this.updateServiceStatus(serviceName, false, lastError);
    const diagnostics = {
      pluginFound: false,
      serviceContainerAvailable: false,
      serviceFound: false,
      methodUsed: 'failed',
      duration: Date.now() - startTime
    };

    this.handleServiceFailure(displayName, lastError, attempts);
    return this.createResult<T>(false, null, lastError, failureStatus, diagnostics);
  }

  /**
   * Synchronous service access for immediate availability checks
   */
  private getServiceSync<T>(serviceName: string, displayName: string): ServiceAccessResult<T> {
    const startTime = Date.now();
    
    try {
      const plugin = this.app.plugins.getPlugin('claudesidian-mcp') as ClaudesidianPlugin;
      if (!plugin) {
        const error = `Plugin 'claudesidian-mcp' not found`;
        const status = this.updateServiceStatus(serviceName, false, error);
        return this.createResult<T>(false, null, error, status, {
          pluginFound: false,
          serviceContainerAvailable: false,
          serviceFound: false,
          methodUsed: 'sync',
          duration: Date.now() - startTime
        });
      }

      const diagnostics = {
        pluginFound: true,
        serviceContainerAvailable: !!plugin.serviceContainer,
        serviceFound: false,
        methodUsed: 'sync',
        duration: 0
      };

      // Try ServiceContainer first
      if (plugin.serviceContainer) {
        const service = plugin.serviceContainer.getIfReady<T>(serviceName);
        if (service) {
          diagnostics.serviceFound = true;
          diagnostics.duration = Date.now() - startTime;
          const status = this.updateServiceStatus(serviceName, true, undefined);
          return this.createResult<T>(true, service, undefined, status, diagnostics);
        }
      }

      // Try direct access
      if (plugin.services && plugin.services[serviceName as keyof typeof plugin.services]) {
        const service = plugin.services[serviceName as keyof typeof plugin.services] as T;
        if (service) {
          diagnostics.serviceFound = true;
          diagnostics.methodUsed = 'direct';
          diagnostics.duration = Date.now() - startTime;
          const status = this.updateServiceStatus(serviceName, true, undefined);
          return this.createResult<T>(true, service, undefined, status, diagnostics);
        }
      }

      const error = `${displayName} not available synchronously`;
      const status = this.updateServiceStatus(serviceName, false, error);
      return this.createResult<T>(false, null, error, status, diagnostics);

    } catch (error) {
      const errorMessage = getErrorMessage(error);
      const status = this.updateServiceStatus(serviceName, false, errorMessage);
      return this.createResult<T>(false, null, errorMessage, status, {
        pluginFound: false,
        serviceContainerAvailable: false,
        serviceFound: false,
        methodUsed: 'sync-failed',
        duration: Date.now() - startTime
      });
    }
  }

  /**
   * Get or create service status tracking
   */
  private getServiceStatus(serviceName: string): ServiceStatus {
    if (!this.serviceStatuses.has(serviceName)) {
      this.serviceStatuses.set(serviceName, {
        available: false,
        initialized: false,
        lastCheck: 0,
        retryCount: 0
      });
    }
    return this.serviceStatuses.get(serviceName)!;
  }

  /**
   * Update service status tracking
   */
  private updateServiceStatus(serviceName: string, available: boolean, error?: string): ServiceStatus {
    const status = this.getServiceStatus(serviceName);
    
    status.available = available;
    status.initialized = available;
    status.lastError = error;
    status.lastCheck = Date.now();
    
    if (available) {
      status.retryCount = 0;
    } else {
      status.retryCount++;
    }

    this.serviceStatuses.set(serviceName, status);
    return status;
  }

  /**
   * Create standardized service access result
   */
  private createResult<T>(
    success: boolean,
    service: T | null,
    error?: string,
    status?: ServiceStatus,
    diagnostics?: any
  ): ServiceAccessResult<T> {
    return {
      success,
      service,
      error,
      status: status || {
        available: success,
        initialized: success,
        lastError: error,
        lastCheck: Date.now(),
        retryCount: 0
      },
      diagnostics
    };
  }

  /**
   * Handle service failure with appropriate logging and fallback behavior
   */
  private handleServiceFailure(serviceName: string, error: string, attempts: number): void {
    const message = `${serviceName} unavailable after ${attempts} attempts: ${error}`;
    
    switch (this.config.fallbackBehavior) {
      case 'fail':
        this.log('error', `[ValidationService] CRITICAL: ${message}`);
        break;
      case 'warn':
        this.log('warn', `[ValidationService] WARNING: ${message} - operations will be limited`);
        break;
      case 'silent':
        this.log('debug', `[ValidationService] ${message}`);
        break;
    }
  }

  /**
   * Timeout wrapper for promises
   */
  private withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
    return Promise.race([
      promise,
      new Promise<T>((_, reject) => 
        setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs)
      )
    ]);
  }

  /**
   * Delay utility for retry logic
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Configurable logging
   */
  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string, ...args: any[]): void {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    const configLevel = levels[this.config.logLevel];
    const messageLevel = levels[level];
    
    if (messageLevel >= configLevel) {
      console[level](message, ...args);
    }
  }

  /**
   * Reset service status (for testing or manual intervention)
   */
  resetServiceStatus(serviceName?: string): void {
    if (serviceName) {
      this.serviceStatuses.delete(serviceName);
    } else {
      this.serviceStatuses.clear();
    }
  }

  /**
   * Get comprehensive service diagnostics
   */
  getDiagnostics(): Record<string, ServiceStatus> {
    const diagnostics: Record<string, ServiceStatus> = {};
    
    for (const [serviceName, status] of this.serviceStatuses.entries()) {
      diagnostics[serviceName] = { ...status };
    }
    
    return diagnostics;
  }
}

/**
 * Default service integration instance factory
 * Creates a standard service integration with recommended settings
 */
export function createServiceIntegration(app: App, config?: Partial<ServiceIntegrationConfig>): ValidationService {
  return new ValidationService(app, {
    maxRetries: 2,
    retryDelayMs: 300,
    timeoutMs: 3000,
    enableHealthCheck: true,
    fallbackBehavior: 'warn',
    logLevel: 'warn',
    ...config
  });
}
```

## agents/memoryManager/services/WorkspaceService.ts

```typescript
import { Plugin } from 'obsidian';
import { ProjectWorkspace } from '../../../database/workspace-types';
import { FileSystemService } from '../../../services/migration/FileSystemService';
import { WorkspaceDataStructure } from '../../../types/migration/MigrationTypes';
import { v4 as uuidv4 } from 'uuid';

export const GLOBAL_WORKSPACE_ID = 'global-workspace';

/**
 * Location: src/agents/memoryManager/services/WorkspaceService.ts
 *
 * WorkspaceService using the new FileSystemService and nested JSON structure.
 * Manages workspace data stored in .data/workspace-data.json with hierarchical
 * organization: workspaces ‚Üí sessions ‚Üí traces/states.
 *
 * Used by: MemoryManager agent modes for workspace operations
 * Integrates with: FileSystemService for data persistence, MemoryService for nested data
 */
export class WorkspaceService {
  private plugin: Plugin;
  private fileSystem: FileSystemService;

  constructor(plugin: Plugin) {
    this.plugin = plugin;
    this.fileSystem = new FileSystemService(plugin);
  }

  async getAllWorkspaces(): Promise<ProjectWorkspace[]> {
    try {
      console.log('[Claudesidian] Loading all workspaces...');
      const data = await this.loadWorkspaceData();
      const workspaces = Object.values(data.workspaces);
      console.log(`[Claudesidian] Loaded ${workspaces.length} workspaces`);
      return workspaces;
    } catch (error) {
      console.error('[Claudesidian] Error loading workspaces:', error);
      throw error;
    }
  }

  async getWorkspace(id: string): Promise<ProjectWorkspace | undefined> {
    const data = await this.loadWorkspaceData();
    return data.workspaces[id];
  }

  async createWorkspace(workspaceData: Omit<ProjectWorkspace, 'id'> | string, description?: string): Promise<ProjectWorkspace> {
    const data = await this.loadWorkspaceData();

    let newWorkspace: ProjectWorkspace;

    if (typeof workspaceData === 'string') {
      newWorkspace = {
        id: uuidv4(),
        name: workspaceData,
        description: description || '',
        rootFolder: '/',
        created: Date.now(),
        lastAccessed: Date.now(),
        isActive: true
      };
    } else {
      newWorkspace = {
        ...workspaceData,
        id: uuidv4(),
        created: Date.now(),
        lastAccessed: Date.now()
      };
    }

    // Add to nested structure
    data.workspaces[newWorkspace.id] = {
      ...newWorkspace,
      sessions: {} // Initialize empty sessions
    };

    await this.saveWorkspaceData(data);
    return newWorkspace;
  }

  async updateWorkspace(id: string, updates: Partial<ProjectWorkspace>): Promise<void> {
    const data = await this.loadWorkspaceData();

    if (!data.workspaces[id]) {
      throw new Error(`Workspace ${id} not found`);
    }

    // Update workspace data
    Object.assign(data.workspaces[id], updates, { lastAccessed: Date.now() });

    await this.saveWorkspaceData(data);
  }

  async deleteWorkspace(id: string): Promise<void> {
    const data = await this.loadWorkspaceData();

    if (!data.workspaces[id]) {
      throw new Error(`Workspace ${id} not found`);
    }

    delete data.workspaces[id];
    await this.saveWorkspaceData(data);
  }

  /**
   * Get all workspaces (alias for getAllWorkspaces for backward compatibility)
   */
  async getWorkspaces(): Promise<ProjectWorkspace[]> {
    return this.getAllWorkspaces();
  }

  /**
   * Add activity to workspace (legacy compatibility method)
   */
  async addActivity(workspaceId: string, activity: any): Promise<void> {
    // In the new structure, activities are stored as memory traces
    // This method maintains backward compatibility by creating a memory trace
    console.warn('[Claudesidian] addActivity is deprecated, use MemoryService.recordActivityTrace instead');

    const workspace = await this.getWorkspace(workspaceId);
    if (!workspace) {
      throw new Error(`Workspace ${workspaceId} not found`);
    }

    // Update last accessed time
    await this.updateWorkspace(workspaceId, { lastAccessed: Date.now() });
  }

  private async loadWorkspaceData(): Promise<WorkspaceDataStructure> {
    const data = await this.fileSystem.readJSON('workspace-data.json');

    if (!data) {
      // Return empty structure
      return {
        workspaces: {},
        metadata: {
          version: '2.0.0',
          lastUpdated: Date.now()
        }
      };
    }

    return data;
  }

  private async saveWorkspaceData(data: WorkspaceDataStructure): Promise<void> {
    data.metadata.lastUpdated = Date.now();
    await this.fileSystem.writeJSON('workspace-data.json', data);
  }
}
```

## agents/memoryManager/services/WorkspaceService.ts.backup

```text
import { Plugin } from 'obsidian';
import { ProjectWorkspace, ItemStatus } from '../../../database/workspace-types';
import { v4 as uuidv4 } from 'uuid';

export const GLOBAL_WORKSPACE_ID = 'global-workspace';

/**
 * WorkspaceService using direct Obsidian data storage
 */
export class WorkspaceService {
  private plugin: Plugin;
  private readonly STORAGE_KEY = 'workspaces';

  constructor(plugin: Plugin) {
    this.plugin = plugin;
  }

  /**
   * Get all workspaces
   */
  async getAllWorkspaces(): Promise<ProjectWorkspace[]> {
    const data = await this.plugin.loadData();
    return data?.[this.STORAGE_KEY] || [];
  }

  /**
   * Get workspace by ID
   */
  async getWorkspace(id: string): Promise<ProjectWorkspace | undefined> {
    const workspaces = await this.getAllWorkspaces();
    return workspaces.find(w => w.id === id);
  }

  /**
   * Create a new workspace
   */
  async createWorkspace(workspaceData: Omit<ProjectWorkspace, 'id'> | string, description?: string): Promise<ProjectWorkspace> {
    let newWorkspace: ProjectWorkspace;

    if (typeof workspaceData === 'string') {
      // Legacy interface - create from name and description
      newWorkspace = {
        id: uuidv4(),
        name: workspaceData,
        description: description || '',
        rootFolder: '/',
        created: Date.now(),
        lastAccessed: Date.now(),
        activityHistory: [],
        checkpoints: [],
        completionStatus: {},
        associatedNotes: []
      };
    } else {
      // New interface - create from workspace object
      newWorkspace = {
        id: uuidv4(),
        ...workspaceData
      };
    }

    const workspaces = await this.getAllWorkspaces();
    workspaces.push(newWorkspace);
    await this.saveWorkspaces(workspaces);

    return newWorkspace;
  }

  /**
   * Update workspace
   */
  async updateWorkspace(id: string, updates: Partial<ProjectWorkspace>): Promise<void> {
    const workspaces = await this.getAllWorkspaces();
    const index = workspaces.findIndex(w => w.id === id);

    if (index === -1) {
      throw new Error(`Workspace ${id} not found`);
    }

    workspaces[index] = { ...workspaces[index], ...updates, lastAccessed: Date.now() };
    await this.saveWorkspaces(workspaces);
  }

  /**
   * Delete workspace
   */
  async deleteWorkspace(id: string): Promise<void> {
    const workspaces = await this.getAllWorkspaces();
    const filtered = workspaces.filter(w => w.id !== id);
    await this.saveWorkspaces(filtered);
  }

  /**
   * Get all workspaces (alias for getAllWorkspaces for backward compatibility)
   */
  async getWorkspaces(): Promise<ProjectWorkspace[]> {
    return this.getAllWorkspaces();
  }

  /**
   * Add activity to workspace
   */
  async addActivity(workspaceId: string, activity: any): Promise<void> {
    const workspace = await this.getWorkspace(workspaceId);
    if (workspace) {
      if (!workspace.activityHistory) {
        workspace.activityHistory = [];
      }
      workspace.activityHistory.push(activity);
      await this.updateWorkspace(workspaceId, workspace);
    }
  }

  /**
   * Save workspaces to storage
   */
  private async saveWorkspaces(workspaces: ProjectWorkspace[]): Promise<void> {
    const data = await this.plugin.loadData() || {};
    data[this.STORAGE_KEY] = workspaces;
    await this.plugin.saveData(data);
  }
}
```

## agents/memoryManager/services/index.ts

```typescript
export { MemoryService } from './MemoryService';
export { WorkspaceService } from './WorkspaceService';
export { ValidationService } from './ValidationService';
```

## agents/memoryManager/types.ts

```typescript
import { CommonResult, CommonParameters } from '../../types';
import { WorkspaceContext } from '../../utils/contextUtils';

/**
 * Base parameters for memory management operations
 */
export interface MemoryParameters extends CommonParameters {
  /**
   * Optional context depth for memory operations
   * - minimal: Just basic information
   * - standard: Regular level of detail (default)
   * - comprehensive: Maximum detail and context
   */
  contextDepth?: 'minimal' | 'standard' | 'comprehensive';
}

/**
 * Base result for memory management operations
 */
export interface MemoryResult extends CommonResult {
  /**
   * Optional contextual information about the memory operation
   */
  memoryContext?: {
    /**
     * When the operation occurred
     */
    timestamp: number;
    
    /**
     * Tags associated with this memory operation
     */
    tags?: string[];
  };
}

/**
 * Session-related parameter and result types
 */

// Parameters for creating a session
export interface CreateSessionParams extends MemoryParameters {
  /**
   * Session name (optional, generates default if not provided)
   */
  name?: string;
  
  /**
   * Session description (optional)
   */
  description?: string;
  
  /**
   * Whether to generate an initial memory trace with session context (default: true)
   */
  generateContextTrace?: boolean;
  
  /**
   * The goal or purpose of this session (for memory context)
   */
  sessionGoal?: string;
  
  /**
   * Reference to previous session ID to establish continuity
   */
  previousSessionId?: string;
  
  /**
   * Override for the session ID from MemoryParameters.
   * This allows creating a session with a specific session ID rather than using the tracking ID.
   * Note: This is distinct from the required sessionId in MemoryParameters which tracks the tool call itself.
   */
  newSessionId?: string;
  
  /**
   * Workspace context (optional)
   * If provided, should contain a workspaceId; if not provided, defaults to the first workspace or creates a default workspace
   * This can also be a JSON string with the same structure
   */
  workspaceContext?: WorkspaceContext | string;
}

// Parameters for listing sessions
export interface ListSessionsParams extends MemoryParameters {
  /**
   * Maximum number of sessions to return
   */
  limit?: number;
  
  /**
   * Sort order for sessions (default: desc - newest first)
   */
  order?: 'asc' | 'desc';
}

// Parameters for editing a session  
export interface EditSessionParams extends Omit<MemoryParameters, 'sessionId'> {
  /**
   * Session ID for tracking this tool call
   */
  sessionId: string;
  
  /**
   * ID of the session to edit (same as sessionId for backward compatibility)
   */
  targetSessionId?: string;
  
  /**
   * New session name (optional)
   */
  name?: string;
  
  /**
   * New session description (optional)
   */
  description?: string;
  
  /**
   * New session goal (optional)
   */
  sessionGoal?: string;
}

// Parameters for deleting a session
export interface DeleteSessionParams extends Omit<MemoryParameters, 'sessionId'> {
  /**
   * Session ID for tracking this tool call
   */
  sessionId: string;
  
  /**
   * ID of the session to delete (same as sessionId for backward compatibility)
   */
  targetSessionId?: string;
  
  /**
   * Whether to also delete associated memory traces
   */
  deleteMemoryTraces?: boolean;
  
  /**
   * Whether to also delete associated states/snapshots
   */
  deleteAssociatedStates?: boolean;
}

// Result for session operations
export interface SessionResult extends MemoryResult {
  data?: {
    /**
     * Session ID
     */
    sessionId?: string;
    
    /**
     * Session name
     */
    name?: string;
    
    /**
     * Session description
     */
    description?: string;
    
    /**
     * Workspace ID
     */
    workspaceId?: string;
    
    /**
     * ID of the new continuation session (when loading a session)
     */
    newSessionId?: string;
    
    /**
     * List of sessions (for listing operations)
     */
    sessions?: Array<{
      id: string;
      name?: string;
      workspaceId: string;
      description?: string;
    }>;
    
    /**
     * Context information for the loaded session
     */
    sessionContext?: {
      summary: string;
      associatedNotes: string[];
      sessionCreatedAt: string;
      traces?: Array<{
        timestamp: number;
        content: string;
        type: string;
        importance: number;
      }>;
    };
  };
}

/**
 * Parameters for loading a session
 */
export interface LoadSessionParams extends Omit<MemoryParameters, 'sessionId'> {
  /**
   * Session ID for tracking this tool call
   */
  sessionId: string;
  
  /**
   * ID of the session to load (same as sessionId for backward compatibility)
   */
  targetSessionId?: string;
  
  /**
   * Custom name for the new continuation session (optional)
   */
  sessionName?: string;
  
  /**
   * Custom description for the new continuation session (optional)
   */
  sessionDescription?: string;
  
  /**
   * Whether to automatically start a new session if the original is inactive (default: true)
   */
  createContinuationSession?: boolean;
}

/**
 * State-related parameter and result types
 */

// Parameters for creating a state
export interface CreateStateParams extends MemoryParameters {
  /**
   * State name
   */
  name: string;
  
  /**
   * State description (optional)
   */
  description?: string;
  
  /**
   * Target session ID (optional, uses active session if not provided)
   * This is different from the top-level sessionId which is for tracking tool calls
   */
  targetSessionId?: string;
  
  /**
   * Whether to include state summary
   */
  includeSummary?: boolean;
  
  /**
   * Whether to include files content in the state
   */
  includeFileContents?: boolean;
  
  /**
   * Maximum number of files to include
   */
  maxFiles?: number;
  
  /**
   * Maximum number of memory traces to include
   */
  maxTraces?: number;
  
  /**
   * Tags to associate with this state
   */
  tags?: string[];
  
  /**
   * Reason for creating this state
   */
  reason?: string;
  
  /**
   * Conversation context for this state
   */
  conversationContext?: string;
  
  /**
   * Currently active task
   */
  activeTask?: string;
  
  /**
   * List of active files
   */
  activeFiles?: string[];
  
  /**
   * Next steps for the workflow
   */
  nextSteps?: string[];
  
  /**
   * Reasoning behind the state creation
   */
  reasoning?: string;
}

// Parameters for listing states
export interface ListStatesParams extends MemoryParameters {
  /**
   * Whether to include state context information
   */
  includeContext?: boolean;
  
  /**
   * Maximum number of states to return
   */
  limit?: number;
  
  /**
   * Filter states by target session ID
   */
  targetSessionId?: string;
  
  /**
   * Sort order for states (default: desc - newest first)
   */
  order?: 'asc' | 'desc';
  
  /**
   * Filter states by tags
   */
  tags?: string[];
}

// Parameters for loading a state
export interface LoadStateParams extends MemoryParameters {
  /**
   * ID of the state to load
   */
  stateId: string;
  
  /**
   * Custom name for the new continuation session (optional)
   */
  sessionName?: string;
  
  /**
   * Custom description for the new continuation session (optional)
   */
  sessionDescription?: string;
  
  /**
   * Restoration goal - what the user intends to do after restoring
   */
  restorationGoal?: string;
  
  /**
   * Whether to continue with the original session ID (default: true). Set to false to create a new continuation session.
   */
  continueExistingSession?: boolean;
}

// Parameters for editing a state
export interface EditStateParams extends MemoryParameters {
  /**
   * ID of the state to edit
   */
  stateId: string;
  
  /**
   * New state name (optional)
   */
  name?: string;
  
  /**
   * New state description (optional)
   */
  description?: string;
  
  /**
   * Add additional tags to state
   */
  addTags?: string[];
  
  /**
   * Remove specific tags from state
   */
  removeTags?: string[];
}

// Parameters for deleting a state
export interface DeleteStateParams extends MemoryParameters {
  /**
   * ID of the state to delete
   */
  stateId: string;
}

// Result for state operations
export interface StateResult extends MemoryResult {
  data?: {
    /**
     * State ID
     */
    stateId?: string;
    
    /**
     * State name
     */
    name?: string;
    
    /**
     * State description
     */
    description?: string;
    
    /**
     * Workspace ID
     */
    workspaceId?: string;
    
    /**
     * Session ID
     */
    sessionId?: string;
    
    /**
     * Creation timestamp
     */
    created?: number;
    
    /**
     * New session ID when loading a state
     */
    newSessionId?: string;
    
    /**
     * List of states (for listing operations)
     */
    states?: Array<{
      id: string;
      name: string;
      workspaceId: string;
      sessionId: string;
      timestamp: number;
      description?: string;
      context?: {
        files: string[];
        traceCount: number;
        tags: string[];
        summary?: string;
      };
    }>;
    
    /**
     * Total number of states matching criteria before limit applied
     */
    total?: number;
    
    /**
     * Context information for the restored state
     */
    restoredContext?: {
      summary: string;
      associatedNotes: string[];
      stateCreatedAt: string;
      originalSessionId: string;
      continuationHistory?: Array<{
        timestamp: number;
        description: string;
      }>;
    };
  };
}
```

## agents/memoryManager/utils/ErrorHandling.ts

```typescript
/**
 * Location: /src/agents/memoryManager/utils/ErrorHandling.ts
 * Purpose: Standardized error handling patterns for memory manager operations
 * 
 * This utility provides:
 * - Consistent error categorization and response formatting
 * - Context-aware error messages with actionable suggestions
 * - Error recovery strategies and fallback mechanisms
 * - Performance and operation logging
 * - User-friendly error reporting
 * 
 * Used by: All memory manager modes for consistent error handling and user experience
 */

import { getErrorMessage } from '../../../utils/errorUtils';
import { CommonResult } from '../../../types';

/**
 * Error categories for memory manager operations
 */
export enum ErrorCategory {
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  NOT_FOUND = 'NOT_FOUND',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  DATA_CORRUPTION = 'DATA_CORRUPTION',
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT = 'TIMEOUT',
  UNKNOWN = 'UNKNOWN'
}

/**
 * Error severity levels
 */
export enum ErrorSeverity {
  LOW = 'LOW',        // User can continue with limited functionality
  MEDIUM = 'MEDIUM',  // Feature unavailable but other features work
  HIGH = 'HIGH',      // Major functionality broken
  CRITICAL = 'CRITICAL' // System unusable
}

/**
 * Structured error information
 */
export interface MemoryManagerError {
  category: ErrorCategory;
  severity: ErrorSeverity;
  message: string;
  userMessage: string;
  technicalDetails: string;
  suggestions: string[];
  recoveryActions: string[];
  context: {
    operation: string;
    mode: string;
    timestamp: number;
    parameters?: any;
    stackTrace?: string;
  };
}

/**
 * Error handling result with recovery options
 */
export interface ErrorHandlingResult<T> extends CommonResult {
  success: false;
  error: string;
  data?: any;
  errorDetails?: MemoryManagerError;
  recoveryOptions?: {
    canRetry: boolean;
    alternativeActions: Array<{
      name: string;
      description: string;
      parameters?: any;
    }>;
  };
}

/**
 * Recovery strategy interface
 */
export interface RecoveryStrategy {
  name: string;
  description: string;
  canApply(error: MemoryManagerError): boolean;
  apply(error: MemoryManagerError, context: any): Promise<any>;
}

/**
 * Standardized error handling utility for memory manager operations
 */
export class MemoryManagerErrorHandler {
  private recoveryStrategies: RecoveryStrategy[] = [];

  constructor() {
    this.initializeDefaultRecoveryStrategies();
  }

  /**
   * Handle service unavailable errors
   */
  handleServiceUnavailable(
    operation: string,
    mode: string,
    serviceName: string,
    error?: unknown,
    parameters?: any
  ): MemoryManagerError {
    const technicalError = error ? getErrorMessage(error) : 'Service not accessible';
    
    return {
      category: ErrorCategory.SERVICE_UNAVAILABLE,
      severity: ErrorSeverity.HIGH,
      message: `${serviceName} is not available`,
      userMessage: `Unable to ${operation.toLowerCase()} because the ${serviceName.replace('Service', '').toLowerCase()} system is not ready. This may be temporary during plugin initialization.`,
      technicalDetails: `Service access failed: ${technicalError}`,
      suggestions: [
        'Wait a few moments and try again',
        'Check if the plugin is fully loaded',
        'Restart Obsidian if the issue persists',
        'Check the console for initialization errors'
      ],
      recoveryActions: [
        'retry_after_delay',
        'check_plugin_status',
        'use_alternative_method'
      ],
      context: {
        operation,
        mode,
        timestamp: Date.now(),
        parameters,
        stackTrace: error instanceof Error ? error.stack : undefined
      }
    };
  }

  /**
   * Handle validation errors with specific field information
   */
  handleValidationError(
    operation: string,
    mode: string,
    field: string,
    value: any,
    requirement: string,
    parameters?: any
  ): MemoryManagerError {
    return {
      category: ErrorCategory.VALIDATION_ERROR,
      severity: ErrorSeverity.LOW,
      message: `Invalid ${field}: ${requirement}`,
      userMessage: `The ${field} you provided doesn't meet the requirements. ${requirement}`,
      technicalDetails: `Validation failed for field '${field}' with value '${JSON.stringify(value)}': ${requirement}`,
      suggestions: [
        `Provide a valid ${field} that ${requirement.toLowerCase()}`,
        'Check the parameter schema for exact requirements',
        'Review examples of valid values'
      ],
      recoveryActions: [
        'fix_parameter',
        'show_examples',
        'use_default_value'
      ],
      context: {
        operation,
        mode,
        timestamp: Date.now(),
        parameters
      }
    };
  }

  /**
   * Handle not found errors (workspace, state, session)
   */
  handleNotFound(
    operation: string,
    mode: string,
    resourceType: string,
    resourceId: string,
    parameters?: any
  ): MemoryManagerError {
    return {
      category: ErrorCategory.NOT_FOUND,
      severity: ErrorSeverity.MEDIUM,
      message: `${resourceType} '${resourceId}' not found`,
      userMessage: `The ${resourceType.toLowerCase()} you're looking for doesn't exist or may have been deleted.`,
      technicalDetails: `Resource lookup failed: ${resourceType} with ID '${resourceId}' not found in storage`,
      suggestions: [
        `Check if the ${resourceType.toLowerCase()} ID is correct`,
        `List available ${resourceType.toLowerCase()}s to find the right one`,
        `Create a new ${resourceType.toLowerCase()} if needed`
      ],
      recoveryActions: [
        'list_available',
        'create_new',
        'search_similar'
      ],
      context: {
        operation,
        mode,
        timestamp: Date.now(),
        parameters
      }
    };
  }

  /**
   * Handle data corruption or integrity errors
   */
  handleDataCorruption(
    operation: string,
    mode: string,
    description: string,
    error?: unknown,
    parameters?: any
  ): MemoryManagerError {
    return {
      category: ErrorCategory.DATA_CORRUPTION,
      severity: ErrorSeverity.HIGH,
      message: `Data integrity issue: ${description}`,
      userMessage: `There's an issue with the stored data that prevents this operation. The data may be corrupted or in an unexpected format.`,
      technicalDetails: `Data validation failed: ${description}. ${error ? getErrorMessage(error) : ''}`,
      suggestions: [
        'Try recreating the affected data',
        'Check for recent changes that might have caused this',
        'Contact support if this persists',
        'Consider backing up and resetting the workspace'
      ],
      recoveryActions: [
        'recreate_data',
        'repair_data',
        'use_backup'
      ],
      context: {
        operation,
        mode,
        timestamp: Date.now(),
        parameters,
        stackTrace: error instanceof Error ? error.stack : undefined
      }
    };
  }

  /**
   * Handle timeout errors
   */
  handleTimeout(
    operation: string,
    mode: string,
    timeoutMs: number,
    error?: unknown,
    parameters?: any
  ): MemoryManagerError {
    return {
      category: ErrorCategory.TIMEOUT,
      severity: ErrorSeverity.MEDIUM,
      message: `Operation timed out after ${timeoutMs}ms`,
      userMessage: `The operation took too long to complete and was cancelled. This might be due to a large amount of data or system load.`,
      technicalDetails: `Timeout after ${timeoutMs}ms: ${error ? getErrorMessage(error) : 'No response'}`,
      suggestions: [
        'Try again with a smaller data set',
        'Wait for system load to decrease',
        'Check your network connection',
        'Increase timeout if possible'
      ],
      recoveryActions: [
        'retry_with_timeout',
        'split_operation',
        'check_system_load'
      ],
      context: {
        operation,
        mode,
        timestamp: Date.now(),
        parameters,
        stackTrace: error instanceof Error ? error.stack : undefined
      }
    };
  }

  /**
   * Handle unexpected errors with fallback information
   */
  handleUnexpected(
    operation: string,
    mode: string,
    error: unknown,
    parameters?: any
  ): MemoryManagerError {
    return {
      category: ErrorCategory.UNKNOWN,
      severity: ErrorSeverity.HIGH,
      message: `Unexpected error during ${operation}`,
      userMessage: `An unexpected error occurred. This is likely a bug or system issue that needs investigation.`,
      technicalDetails: `Unhandled error: ${getErrorMessage(error)}`,
      suggestions: [
        'Try the operation again',
        'Check the browser console for more details',
        'Report this issue with the error details',
        'Try an alternative approach if available'
      ],
      recoveryActions: [
        'retry_operation',
        'report_bug',
        'use_fallback'
      ],
      context: {
        operation,
        mode,
        timestamp: Date.now(),
        parameters,
        stackTrace: error instanceof Error ? error.stack : undefined
      }
    };
  }

  /**
   * Create error handling result with recovery options and appropriate data defaults
   */
  createErrorResult<T>(
    error: MemoryManagerError,
    workspaceContext?: any,
    defaultData?: any
  ): T {
    const recoveryOptions = this.generateRecoveryOptions(error);
    
    // Determine appropriate default data based on the operation
    let data = defaultData;
    if (!data) {
      if (error.context.mode.includes('list') && error.context.mode.includes('Workspace')) {
        data = { workspaces: [] };
      } else if (error.context.mode.includes('list') && error.context.mode.includes('State')) {
        data = { states: [], total: 0 };
      } else {
        data = {};
      }
    }
    
    return {
      success: false,
      error: error.userMessage,
      data,
      errorDetails: error,
      recoveryOptions,
      workspaceContext,
      sessionId: workspaceContext?.sessionId
    } as T;
  }

  /**
   * Generate recovery options based on error type
   */
  private generateRecoveryOptions(error: MemoryManagerError): {
    canRetry: boolean;
    alternativeActions: Array<{
      name: string;
      description: string;
      parameters?: any;
    }>;
  } {
    const canRetry = [
      ErrorCategory.SERVICE_UNAVAILABLE,
      ErrorCategory.NETWORK_ERROR,
      ErrorCategory.TIMEOUT
    ].includes(error.category);

    const alternativeActions: Array<{
      name: string;
      description: string;
      parameters?: any;
    }> = [];

    switch (error.category) {
      case ErrorCategory.SERVICE_UNAVAILABLE:
        alternativeActions.push(
          {
            name: 'check_service_status',
            description: 'Check if services are available now'
          },
          {
            name: 'use_fallback_method',
            description: 'Try alternative approach without this service'
          }
        );
        break;

      case ErrorCategory.VALIDATION_ERROR:
        alternativeActions.push(
          {
            name: 'show_parameter_help',
            description: 'Show parameter requirements and examples'
          },
          {
            name: 'use_wizard',
            description: 'Use step-by-step guided input'
          }
        );
        break;

      case ErrorCategory.NOT_FOUND:
        alternativeActions.push(
          {
            name: 'list_available',
            description: 'Show available options'
          },
          {
            name: 'create_new',
            description: 'Create a new item instead'
          }
        );
        break;

      case ErrorCategory.DATA_CORRUPTION:
        alternativeActions.push(
          {
            name: 'validate_data',
            description: 'Run data validation and repair'
          },
          {
            name: 'reset_workspace',
            description: 'Reset workspace to clean state'
          }
        );
        break;
    }

    return {
      canRetry,
      alternativeActions
    };
  }

  /**
   * Log error with appropriate level and context
   */
  logError(error: MemoryManagerError): void {
    const logLevel = this.getLogLevel(error.severity);
    const logMessage = `[${error.context.mode}] ${error.message}`;
    const logDetails = {
      category: error.category,
      severity: error.severity,
      operation: error.context.operation,
      technicalDetails: error.technicalDetails,
      parameters: error.context.parameters
    };

    switch (logLevel) {
      case 'error':
        console.error(logMessage, logDetails);
        break;
      case 'warn':
        console.warn(logMessage, logDetails);
        break;
      case 'info':
        console.info(logMessage, logDetails);
        break;
      default:
        console.log(logMessage, logDetails);
        break;
    }
  }

  /**
   * Get appropriate log level for error severity
   */
  private getLogLevel(severity: ErrorSeverity): 'error' | 'warn' | 'info' | 'log' {
    switch (severity) {
      case ErrorSeverity.CRITICAL:
      case ErrorSeverity.HIGH:
        return 'error';
      case ErrorSeverity.MEDIUM:
        return 'warn';
      case ErrorSeverity.LOW:
        return 'info';
      default:
        return 'log';
    }
  }

  /**
   * Initialize default recovery strategies
   */
  private initializeDefaultRecoveryStrategies(): void {
    // Implementation would include actual recovery strategy classes
    // For now, this is a placeholder for the recovery system
  }

  /**
   * Add custom recovery strategy
   */
  addRecoveryStrategy(strategy: RecoveryStrategy): void {
    this.recoveryStrategies.push(strategy);
  }

  /**
   * Apply recovery strategy if available
   */
  async applyRecovery(error: MemoryManagerError, context: any): Promise<any> {
    for (const strategy of this.recoveryStrategies) {
      if (strategy.canApply(error)) {
        try {
          return await strategy.apply(error, context);
        } catch (recoveryError) {
          console.warn(`Recovery strategy '${strategy.name}' failed:`, recoveryError);
        }
      }
    }
    return null;
  }
}

/**
 * Global error handler instance for memory manager operations
 */
export const memoryManagerErrorHandler = new MemoryManagerErrorHandler();

/**
 * Convenience function to create error results with proper data defaults
 */
export function createMemoryManagerError<T>(
  operation: string,
  mode: string,
  error: unknown,
  workspaceContext?: any,
  parameters?: any
): T {
  let memoryError: MemoryManagerError;

  if (typeof error === 'string' && error.includes('not available')) {
    memoryError = memoryManagerErrorHandler.handleServiceUnavailable(
      operation,
      mode,
      'Service',
      error,
      parameters
    );
  } else if (typeof error === 'string' && error.includes('not found')) {
    memoryError = memoryManagerErrorHandler.handleNotFound(
      operation,
      mode,
      'Resource',
      'unknown',
      parameters
    );
  } else if (typeof error === 'string' && error.includes('timeout')) {
    memoryError = memoryManagerErrorHandler.handleTimeout(
      operation,
      mode,
      5000,
      error,
      parameters
    );
  } else {
    memoryError = memoryManagerErrorHandler.handleUnexpected(
      operation,
      mode,
      error,
      parameters
    );
  }

  memoryManagerErrorHandler.logError(memoryError);
  
  // Create error result with proper type-specific defaults
  const baseErrorResult = {
    success: false as const,
    error: memoryError.userMessage,
    errorDetails: memoryError,
    workspaceContext,
    sessionId: workspaceContext?.sessionId
  };
  
  // Add appropriate default data based on the mode type
  if (mode.includes('Workspace') || mode.includes('workspace')) {
    if (mode.includes('list') || mode.includes('List')) {
      return { ...baseErrorResult, data: { workspaces: [] } } as T;
    } else {
      return { ...baseErrorResult, data: {} } as T;
    }
  } else if (mode.includes('State') || mode.includes('state')) {
    if (mode.includes('list') || mode.includes('List')) {
      return { ...baseErrorResult, data: { states: [], total: 0 } } as T;
    } else {
      return { ...baseErrorResult, data: {} } as T;
    }
  }
  
  // Default fallback
  return { ...baseErrorResult, data: {} } as T;
}
```

## agents/memoryManager/utils/ServiceIntegration.ts

```typescript
/**
 * Location: /src/agents/memoryManager/utils/ServiceIntegration.ts
 * Purpose: Robust service integration patterns for memory manager operations
 * 
 * This utility provides standardized service access patterns with:
 * - Consistent error handling and logging
 * - Service availability validation
 * - Graceful fallback mechanisms
 * - Retry logic and timeout handling
 * - Health monitoring and diagnostics
 * 
 * Used by: All workspace and state management modes for reliable service access
 */

import { App } from 'obsidian';
import { MemoryService } from "../services/MemoryService";
import { WorkspaceService } from "../services/WorkspaceService";
import { getErrorMessage } from '../../../utils/errorUtils';

/**
 * Service availability status
 */
export interface ServiceStatus {
  available: boolean;
  initialized: boolean;
  lastError?: string;
  lastCheck: number;
  retryCount: number;
}

/**
 * Service integration configuration
 */
export interface ServiceIntegrationConfig {
  maxRetries: number;
  retryDelayMs: number;
  timeoutMs: number;
  enableHealthCheck: boolean;
  fallbackBehavior: 'fail' | 'warn' | 'silent';
  logLevel: 'debug' | 'info' | 'warn' | 'error';
}

/**
 * Service access result with detailed error information
 */
export interface ServiceAccessResult<T> {
  success: boolean;
  service: T | null;
  error?: string;
  status: ServiceStatus;
  diagnostics?: {
    pluginFound: boolean;
    serviceContainerAvailable: boolean;
    serviceFound: boolean;
    methodUsed: string;
    duration: number;
  };
}

/**
 * Plugin interface for service access
 */
export interface ClaudesidianPlugin {
  services?: {
    memoryService?: MemoryService;
    workspaceService?: WorkspaceService;
  };
  serviceContainer?: {
    getIfReady<T>(serviceName: string): T | null;
  };
  getService?<T>(serviceName: string): Promise<T>;
}

/**
 * Robust service integration utility for memory manager operations
 */
export class ServiceIntegration {
  private static readonly DEFAULT_CONFIG: ServiceIntegrationConfig = {
    maxRetries: 3,
    retryDelayMs: 500,
    timeoutMs: 5000,
    enableHealthCheck: true,
    fallbackBehavior: 'warn',
    logLevel: 'warn'
  };

  private app: App;
  private config: ServiceIntegrationConfig;
  private serviceStatuses: Map<string, ServiceStatus> = new Map();

  constructor(app: App, config: Partial<ServiceIntegrationConfig> = {}) {
    this.app = app;
    this.config = { ...ServiceIntegration.DEFAULT_CONFIG, ...config };
  }

  /**
   * Get memory service with robust error handling and retry logic
   */
  async getMemoryService(): Promise<ServiceAccessResult<MemoryService>> {
    return this.getService<MemoryService>('memoryService', 'MemoryService');
  }

  /**
   * Get workspace service with robust error handling and retry logic
   */
  async getWorkspaceService(): Promise<ServiceAccessResult<WorkspaceService>> {
    return this.getService<WorkspaceService>('workspaceService', 'WorkspaceService');
  }

  /**
   * Get memory service synchronously (for immediate availability checks)
   */
  getMemoryServiceSync(): ServiceAccessResult<MemoryService> {
    return this.getServiceSync<MemoryService>('memoryService', 'MemoryService');
  }

  /**
   * Get workspace service synchronously (for immediate availability checks)
   */
  getWorkspaceServiceSync(): ServiceAccessResult<WorkspaceService> {
    return this.getServiceSync<WorkspaceService>('workspaceService', 'WorkspaceService');
  }

  /**
   * Core service access method with comprehensive error handling
   */
  private async getService<T>(serviceName: string, displayName: string): Promise<ServiceAccessResult<T>> {
    const startTime = Date.now();
    const status = this.getServiceStatus(serviceName);
    
    // If service was recently checked and failed, return cached failure
    if (!status.available && (Date.now() - status.lastCheck) < this.config.retryDelayMs) {
      this.log('debug', `[ServiceIntegration] Using cached failure for ${displayName}`);
      return this.createResult<T>(false, null, status.lastError || 'Service unavailable', status, {
        pluginFound: false,
        serviceContainerAvailable: false,
        serviceFound: false,
        methodUsed: 'cached',
        duration: Date.now() - startTime
      });
    }

    let attempts = 0;
    let lastError = '';

    while (attempts <= this.config.maxRetries) {
      try {
        attempts++;
        this.log('debug', `[ServiceIntegration] Attempting to get ${displayName} (attempt ${attempts}/${this.config.maxRetries + 1})`);

        const plugin = this.app.plugins.getPlugin('claudesidian-mcp') as ClaudesidianPlugin;
        if (!plugin) {
          lastError = `Plugin 'claudesidian-mcp' not found`;
          this.log('error', `[ServiceIntegration] ${lastError}`);
          
          if (attempts <= this.config.maxRetries) {
            await this.delay(this.config.retryDelayMs);
            continue;
          }
          break;
        }

        const diagnostics = {
          pluginFound: true,
          serviceContainerAvailable: false,
          serviceFound: false,
          methodUsed: '',
          duration: 0
        };

        // Try ServiceContainer first (preferred method)
        if (plugin.serviceContainer) {
          this.log('debug', `[ServiceIntegration] Trying ServiceContainer for ${displayName}`);
          diagnostics.serviceContainerAvailable = true;
          diagnostics.methodUsed = 'serviceContainer';

          const service = plugin.serviceContainer.getIfReady<T>(serviceName);
          if (service) {
            this.log('debug', `[ServiceIntegration] Successfully got ${displayName} via ServiceContainer`);
            diagnostics.serviceFound = true;
            diagnostics.duration = Date.now() - startTime;
            
            const successStatus = this.updateServiceStatus(serviceName, true, undefined);
            return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
          }
        }

        // Try async getService method
        if (plugin.getService) {
          this.log('debug', `[ServiceIntegration] Trying async getService for ${displayName}`);
          diagnostics.methodUsed = diagnostics.methodUsed ? `${diagnostics.methodUsed}+async` : 'async';

          try {
            const service = await this.withTimeout(plugin.getService<T>(serviceName), this.config.timeoutMs);
            if (service) {
              this.log('debug', `[ServiceIntegration] Successfully got ${displayName} via async method`);
              diagnostics.serviceFound = true;
              diagnostics.duration = Date.now() - startTime;
              
              const successStatus = this.updateServiceStatus(serviceName, true, undefined);
              return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
            }
          } catch (asyncError) {
            this.log('warn', `[ServiceIntegration] Async service access failed for ${displayName}:`, asyncError);
            lastError = getErrorMessage(asyncError);
          }
        }

        // Try direct services access (fallback)
        if (plugin.services && plugin.services[serviceName as keyof typeof plugin.services]) {
          this.log('debug', `[ServiceIntegration] Trying direct services access for ${displayName}`);
          diagnostics.methodUsed = diagnostics.methodUsed ? `${diagnostics.methodUsed}+direct` : 'direct';

          const service = plugin.services[serviceName as keyof typeof plugin.services] as T;
          if (service) {
            this.log('debug', `[ServiceIntegration] Successfully got ${displayName} via direct access`);
            diagnostics.serviceFound = true;
            diagnostics.duration = Date.now() - startTime;
            
            const successStatus = this.updateServiceStatus(serviceName, true, undefined);
            return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
          }
        }

        lastError = `${displayName} not available through any access method`;
        this.log('warn', `[ServiceIntegration] ${lastError} (attempt ${attempts})`);

        if (attempts <= this.config.maxRetries) {
          await this.delay(this.config.retryDelayMs);
        }

      } catch (error) {
        lastError = getErrorMessage(error);
        this.log('error', `[ServiceIntegration] Error accessing ${displayName} (attempt ${attempts}):`, error);
        
        if (attempts <= this.config.maxRetries) {
          await this.delay(this.config.retryDelayMs);
        }
      }
    }

    // All attempts failed
    const failureStatus = this.updateServiceStatus(serviceName, false, lastError);
    const diagnostics = {
      pluginFound: false,
      serviceContainerAvailable: false,
      serviceFound: false,
      methodUsed: 'failed',
      duration: Date.now() - startTime
    };

    this.handleServiceFailure(displayName, lastError, attempts);
    return this.createResult<T>(false, null, lastError, failureStatus, diagnostics);
  }

  /**
   * Synchronous service access for immediate availability checks
   */
  private getServiceSync<T>(serviceName: string, displayName: string): ServiceAccessResult<T> {
    const startTime = Date.now();
    
    try {
      const plugin = this.app.plugins.getPlugin('claudesidian-mcp') as ClaudesidianPlugin;
      if (!plugin) {
        const error = `Plugin 'claudesidian-mcp' not found`;
        const status = this.updateServiceStatus(serviceName, false, error);
        return this.createResult<T>(false, null, error, status, {
          pluginFound: false,
          serviceContainerAvailable: false,
          serviceFound: false,
          methodUsed: 'sync',
          duration: Date.now() - startTime
        });
      }

      const diagnostics = {
        pluginFound: true,
        serviceContainerAvailable: !!plugin.serviceContainer,
        serviceFound: false,
        methodUsed: 'sync',
        duration: 0
      };

      // Try ServiceContainer first
      if (plugin.serviceContainer) {
        const service = plugin.serviceContainer.getIfReady<T>(serviceName);
        if (service) {
          diagnostics.serviceFound = true;
          diagnostics.duration = Date.now() - startTime;
          const status = this.updateServiceStatus(serviceName, true, undefined);
          return this.createResult<T>(true, service, undefined, status, diagnostics);
        }
      }

      // Try direct access
      if (plugin.services && plugin.services[serviceName as keyof typeof plugin.services]) {
        const service = plugin.services[serviceName as keyof typeof plugin.services] as T;
        if (service) {
          diagnostics.serviceFound = true;
          diagnostics.methodUsed = 'direct';
          diagnostics.duration = Date.now() - startTime;
          const status = this.updateServiceStatus(serviceName, true, undefined);
          return this.createResult<T>(true, service, undefined, status, diagnostics);
        }
      }

      const error = `${displayName} not available synchronously`;
      const status = this.updateServiceStatus(serviceName, false, error);
      return this.createResult<T>(false, null, error, status, diagnostics);

    } catch (error) {
      const errorMessage = getErrorMessage(error);
      const status = this.updateServiceStatus(serviceName, false, errorMessage);
      return this.createResult<T>(false, null, errorMessage, status, {
        pluginFound: false,
        serviceContainerAvailable: false,
        serviceFound: false,
        methodUsed: 'sync-failed',
        duration: Date.now() - startTime
      });
    }
  }

  /**
   * Get or create service status tracking
   */
  private getServiceStatus(serviceName: string): ServiceStatus {
    if (!this.serviceStatuses.has(serviceName)) {
      this.serviceStatuses.set(serviceName, {
        available: false,
        initialized: false,
        lastCheck: 0,
        retryCount: 0
      });
    }
    return this.serviceStatuses.get(serviceName)!;
  }

  /**
   * Update service status tracking
   */
  private updateServiceStatus(serviceName: string, available: boolean, error?: string): ServiceStatus {
    const status = this.getServiceStatus(serviceName);
    
    status.available = available;
    status.initialized = available;
    status.lastError = error;
    status.lastCheck = Date.now();
    
    if (available) {
      status.retryCount = 0;
    } else {
      status.retryCount++;
    }

    this.serviceStatuses.set(serviceName, status);
    return status;
  }

  /**
   * Create standardized service access result
   */
  private createResult<T>(
    success: boolean,
    service: T | null,
    error?: string,
    status?: ServiceStatus,
    diagnostics?: any
  ): ServiceAccessResult<T> {
    return {
      success,
      service,
      error,
      status: status || {
        available: success,
        initialized: success,
        lastError: error,
        lastCheck: Date.now(),
        retryCount: 0
      },
      diagnostics
    };
  }

  /**
   * Handle service failure with appropriate logging and fallback behavior
   */
  private handleServiceFailure(serviceName: string, error: string, attempts: number): void {
    const message = `${serviceName} unavailable after ${attempts} attempts: ${error}`;
    
    switch (this.config.fallbackBehavior) {
      case 'fail':
        this.log('error', `[ServiceIntegration] CRITICAL: ${message}`);
        break;
      case 'warn':
        this.log('warn', `[ServiceIntegration] WARNING: ${message} - operations will be limited`);
        break;
      case 'silent':
        this.log('debug', `[ServiceIntegration] ${message}`);
        break;
    }
  }

  /**
   * Timeout wrapper for promises
   */
  private withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
    return Promise.race([
      promise,
      new Promise<T>((_, reject) => 
        setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs)
      )
    ]);
  }

  /**
   * Delay utility for retry logic
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Configurable logging
   */
  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string, ...args: any[]): void {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    const configLevel = levels[this.config.logLevel];
    const messageLevel = levels[level];
    
    if (messageLevel >= configLevel) {
      console[level](message, ...args);
    }
  }

  /**
   * Reset service status (for testing or manual intervention)
   */
  resetServiceStatus(serviceName?: string): void {
    if (serviceName) {
      this.serviceStatuses.delete(serviceName);
    } else {
      this.serviceStatuses.clear();
    }
  }

  /**
   * Get comprehensive service diagnostics
   */
  getDiagnostics(): Record<string, ServiceStatus> {
    const diagnostics: Record<string, ServiceStatus> = {};
    
    for (const [serviceName, status] of this.serviceStatuses.entries()) {
      diagnostics[serviceName] = { ...status };
    }
    
    return diagnostics;
  }
}

/**
 * Default service integration instance factory
 * Creates a standard service integration with recommended settings
 */
export function createServiceIntegration(app: App, config?: Partial<ServiceIntegrationConfig>): ServiceIntegration {
  return new ServiceIntegration(app, {
    maxRetries: 2,
    retryDelayMs: 300,
    timeoutMs: 3000,
    enableHealthCheck: true,
    fallbackBehavior: 'warn',
    logLevel: 'warn',
    ...config
  });
}
```

## agents/vaultLibrarian/modes/batchMode.ts

```typescript
import { Plugin } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { MemoryService } from "../../memoryManager/services/MemoryService";
import { WorkspaceService } from "../../memoryManager/services/WorkspaceService";
import { 
  BatchUniversalSearchParams, 
  BatchUniversalSearchResult,
  UniversalSearchResult
} from '../types';
import { getErrorMessage } from '../../../utils/errorUtils';
import { UniversalSearchService } from './services/universal/UniversalSearchService';

/**
 * Batch mode for executing multiple universal searches concurrently
 * Updated to use vector search for semantic search
 */
export class BatchMode extends BaseMode<BatchUniversalSearchParams, BatchUniversalSearchResult> {
  private universalSearchService: UniversalSearchService;

  constructor(
    plugin: Plugin,
    memoryService?: MemoryService,
    workspaceService?: WorkspaceService
  ) {
    super('batch', 'Batch Universal Search', 'Execute multiple universal searches concurrently. Each search automatically covers all content types (files, folders, content, workspaces, sessions, etc.). Use this for complex multi-query operations.', '2.0.0');
    
    this.universalSearchService = new UniversalSearchService(
      plugin,
      memoryService,
      workspaceService
    );
  }

  /**
   * Execute multiple universal searches concurrently
   */
  async execute(params: BatchUniversalSearchParams): Promise<BatchUniversalSearchResult> {
    try {
      // Validate parameters
      if (!params.searches || params.searches.length === 0) {
        return this.prepareResult(false, undefined, 'At least one search query is required', params.context);
      }

      if (params.searches.length > (params.maxConcurrency || 10)) {
        return this.prepareResult(false, undefined, `Too many searches requested. Maximum allowed: ${params.maxConcurrency || 10}`, params.context);
      }

      const startTime = performance.now();
      const maxConcurrency = params.maxConcurrency || 5;
      
      // Execute searches with concurrency control
      const results = await this.executeConcurrentSearches(params.searches, maxConcurrency);
      
      const totalExecutionTimeMS = performance.now() - startTime;
      const successful = results.filter(r => r.success);
      const failed = results.filter(r => !r.success);

      // Build response based on merge preference
      if (params.mergeResults) {
        const merged = this.mergeSearchResults(successful);
        
        return {
          success: true,
          merged: {
            totalQueries: params.searches.length,
            totalResults: merged.totalResults,
            combinedCategories: merged.categories!
          },
          stats: {
            totalExecutionTimeMS,
            queriesExecuted: params.searches.length,
            queriesFailed: failed.length,
            avgExecutionTimeMS: totalExecutionTimeMS / params.searches.length
          }
        };
      } else {
        return {
          success: true,
          searches: results,
          stats: {
            totalExecutionTimeMS,
            queriesExecuted: params.searches.length,
            queriesFailed: failed.length,
            avgExecutionTimeMS: totalExecutionTimeMS / params.searches.length
          }
        };
      }
      
    } catch (error) {
      return this.prepareResult(false, undefined, `Batch search failed: ${getErrorMessage(error)}`, params.context);
    }
  }

  /**
   * Execute searches with concurrency control
   */
  private async executeConcurrentSearches(
    searches: BatchUniversalSearchParams['searches'],
    maxConcurrency: number
  ): Promise<UniversalSearchResult[]> {
    const results: UniversalSearchResult[] = [];
    
    // Process searches in batches to control concurrency
    for (let i = 0; i < searches.length; i += maxConcurrency) {
      const batch = searches.slice(i, i + maxConcurrency);
      
      const batchPromises = batch.map(async (searchParams, index) => {
        try {
          // Add a small delay between concurrent searches to avoid overwhelming the system
          if (index > 0) {
            await new Promise(resolve => setTimeout(resolve, index * 50));
          }
          
          return await this.universalSearchService.executeUniversalSearch(searchParams);
        } catch (error) {
          return {
            success: false,
            error: `Search failed: ${getErrorMessage(error)}`
          } as UniversalSearchResult;
        }
      });
      
      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);
    }
    
    return results;
  }

  /**
   * Merge multiple search results into a single unified result
   */
  private mergeSearchResults(results: UniversalSearchResult[]): {
    totalResults: number;
    categories: NonNullable<BatchUniversalSearchResult['merged']>['combinedCategories'];
  } {
    const combinedCategories: NonNullable<BatchUniversalSearchResult['merged']>['combinedCategories'] = {};
    let totalResults = 0;

    // Combine results from each category across all searches
    const categoryNames = ['files', 'folders', 'content', 'workspaces', 'sessions', 'snapshots', 'memory_traces', 'tags', 'properties'] as const;
    
    for (const categoryName of categoryNames) {
      const categoryResults = results
        .map(result => result.categories[categoryName])
        .filter(Boolean);
      
      if (categoryResults.length > 0) {
        // Combine all results from this category
        const allResults = categoryResults.flatMap(cat => cat!.results);
        
        // Remove duplicates based on ID
        const uniqueResults = allResults.filter((result, index, arr) => 
          arr.findIndex(r => r.id === result.id) === index
        );
        
        // Sort by score and take top results
        uniqueResults.sort((a, b) => b.score - a.score);
        const topResults = uniqueResults.slice(0, 10); // Limit merged results
        
        combinedCategories[categoryName] = {
          count: uniqueResults.length,
          results: topResults,
          hasMore: uniqueResults.length > 10,
          searchMethod: categoryResults[0]!.searchMethod,
          semanticAvailable: categoryResults[0]!.semanticAvailable
        };
        
        totalResults += uniqueResults.length;
      }
    }

    return {
      totalResults,
      categories: combinedCategories
    };
  }

  /**
   * Get parameter schema for MCP tool definition
   */
  getParameterSchema() {
    const batchSchema = {
      type: 'object',
      title: 'Batch Universal Search Parameters',
      description: 'Execute multiple universal searches concurrently. Each search automatically covers all content types. Use this when you need to run several different searches at once.',
      properties: {
        searches: {
          type: 'array',
          description: 'Array of universal search queries to execute concurrently. Each search automatically covers all content types.',
          items: {
            type: 'object',
            title: 'Individual Universal Search',
            description: 'A single universal search that automatically searches across all categories (files, folders, content, workspaces, sessions, etc.)',
            properties: {
              query: {
                type: 'string',
                description: 'Search query to find content across all categories. No type parameter needed - automatically searches everything.',
                examples: [
                  'project planning',
                  'machine learning notes',
                  'typescript documentation'
                ]
              },
              limit: {
                type: 'number',
                description: 'Maximum number of results per category (default: 5)',
                minimum: 1,
                maximum: 20,
                default: 5
              },
              excludeCategories: {
                type: 'array',
                description: 'Categories to exclude from this search',
                items: {
                  type: 'string',
                  enum: ['files', 'folders', 'content', 'workspaces', 'sessions', 'snapshots', 'memory_traces', 'tags', 'properties']
                }
              },
              prioritizeCategories: {
                type: 'array',
                description: 'Categories to prioritize for this search',
                items: {
                  type: 'string',
                  enum: ['files', 'folders', 'content', 'workspaces', 'sessions', 'snapshots', 'memory_traces', 'tags', 'properties']
                }
              },
              paths: {
                type: 'array',
                description: 'Restrict this search to specific folder paths',
                items: { type: 'string' }
              },
              includeContent: {
                type: 'boolean',
                description: 'Whether to include full content in results',
                default: true
              },
              forceSemanticSearch: {
                type: 'boolean',
                description: 'Force semantic search for this query',
                default: false
              }
            },
            required: ['query']
          },
          minItems: 1,
          maxItems: 100
        },
        mergeResults: {
          type: 'boolean',
          description: 'Whether to merge all search results into a single unified response (default: false)',
          default: false
        },
        maxConcurrency: {
          type: 'number',
          description: 'Maximum number of concurrent searches to execute (default: 5)',
          minimum: 1,
          maximum: 10,
          default: 5
        }
      },
      required: ['searches'],
      additionalProperties: false
    };
    
    // Merge with common schema (sessionId and context)
    return this.getMergedSchema(batchSchema);
  }

  /**
   * Get result schema for MCP tool definition
   */
  getResultSchema() {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the batch search was successful'
        },
        searches: {
          type: 'array',
          description: 'Individual search results (if mergeResults is false)',
          items: {
            $ref: '#/definitions/UniversalSearchResult'
          }
        },
        merged: {
          type: 'object',
          description: 'Merged search results (if mergeResults is true)',
          properties: {
            totalQueries: {
              type: 'number',
              description: 'Total number of queries executed'
            },
            totalResults: {
              type: 'number',
              description: 'Total number of unique results across all searches'
            },
            combinedCategories: {
              type: 'object',
              description: 'Combined results organized by category'
            }
          }
        },
        stats: {
          type: 'object',
          description: 'Execution statistics',
          properties: {
            totalExecutionTimeMS: {
              type: 'number',
              description: 'Total execution time in milliseconds'
            },
            queriesExecuted: {
              type: 'number',
              description: 'Number of queries executed'
            },
            queriesFailed: {
              type: 'number',
              description: 'Number of queries that failed'
            },
            avgExecutionTimeMS: {
              type: 'number',
              description: 'Average execution time per query'
            }
          }
        },
        error: {
          type: 'string',
          description: 'Error message if batch search failed'
        }
      },
      required: ['success'],
      additionalProperties: false
    };
  }
}
```

## agents/vaultLibrarian/modes/index.ts

```typescript
// Export all search modes
export * from './searchContentMode';
export * from './searchDirectoryMode';
export * from './searchMemoryMode';
export * from './batchMode';
```

## agents/vaultLibrarian/modes/searchContentMode.ts

```typescript
import { Plugin, TFile, prepareFuzzySearch } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { getErrorMessage } from '../../../utils/errorUtils';

export interface ContentSearchParams {
  query: string;
  limit?: number;
  includeContent?: boolean;
  snippetLength?: number;
  paths?: string[];
  context: {
    sessionId: string;
    workspaceId?: string;
    sessionDescription: string;
    sessionMemory: string;
    toolContext: string;
    primaryGoal: string;
    subgoal: string;
  };
  sessionId?: string;
}

export interface ContentSearchResult {
  success: boolean;
  query: string;
  results: Array<{
    filePath: string;
    title: string;
    content: string;
    score: number;
    searchMethod: 'fuzzy' | 'keyword' | 'combined';
    frontmatter?: Record<string, any>;
    metadata?: {
      fileExtension: string;
      parentFolder: string;
      modifiedTime: number;
    };
  }>;
  totalResults: number;
  executionTime: number;
  error?: string;
}

/**
 * Content search mode using native Obsidian fuzzy search and keyword search APIs
 * Combines fuzzy matching for file names with keyword search in content
 */
export class SearchContentMode extends BaseMode<ContentSearchParams, ContentSearchResult> {
  private plugin: Plugin;

  constructor(plugin: Plugin) {
    super(
      'searchContent',
      'Content Search',
      'Search vault files using native Obsidian fuzzy search for file names combined with keyword search in content. Results include file frontmatter (tags, properties, metadata) and are ranked by relevance.',
      '1.0.0'
    );
    this.plugin = plugin;
  }

  async execute(params: ContentSearchParams): Promise<ContentSearchResult> {
    const startTime = performance.now();

    try {
      if (!params.query || params.query.trim().length === 0) {
        return this.prepareResult(false, undefined, 'Query parameter is required and cannot be empty', params.context);
      }

      const searchParams = {
        query: params.query.trim(),
        limit: params.limit || 10,
        includeContent: params.includeContent !== false,
        snippetLength: params.snippetLength || 200,
        paths: params.paths || [],
        context: params.context
      };

      console.log('[Claudesidian] Starting content search:', { query: searchParams.query, limit: searchParams.limit });

      // Get all markdown files
      let allFiles = this.plugin.app.vault.getMarkdownFiles();

      // Filter by paths if specified
      if (searchParams.paths.length > 0) {
        allFiles = allFiles.filter(file =>
          searchParams.paths.some(path => file.path.startsWith(path))
        );
      }

      // Perform combined fuzzy + keyword search
      const searchResults = await this.performCombinedSearch(
        searchParams.query,
        allFiles,
        searchParams.limit,
        searchParams.includeContent,
        searchParams.snippetLength
      );

      const executionTime = performance.now() - startTime;

      console.log('[Claudesidian] Content search completed:', {
        resultsCount: searchResults.length,
        executionTime: Math.round(executionTime)
      });

      return {
        success: true,
        query: searchParams.query,
        results: searchResults,
        totalResults: searchResults.length,
        executionTime: Math.round(executionTime)
      };

    } catch (error) {
      const executionTime = performance.now() - startTime;
      console.error('[Claudesidian] Content search failed:', error);

      return this.prepareResult(false, undefined, `Search failed: ${getErrorMessage(error)}`, params.context);
    }
  }

  /**
   * Perform combined fuzzy and keyword search with result ranking
   */
  private async performCombinedSearch(
    query: string,
    files: TFile[],
    limit: number,
    includeContent: boolean,
    snippetLength: number
  ): Promise<ContentSearchResult['results']> {
    const normalizedQuery = query.toLowerCase();
    const fuzzySearch = prepareFuzzySearch(normalizedQuery);
    const allResults: ContentSearchResult['results'] = [];

    for (const file of files) {
      const results = await this.searchInFile(
        file,
        query,
        normalizedQuery,
        fuzzySearch,
        includeContent,
        snippetLength
      );
      allResults.push(...results);
    }

    // Sort by score (higher is better) and take top results
    allResults.sort((a, b) => b.score - a.score);
    return allResults.slice(0, limit);
  }

  /**
   * Search within a single file using multiple methods
   */
  private async searchInFile(
    file: TFile,
    originalQuery: string,
    normalizedQuery: string,
    fuzzySearch: (text: string) => { score: number } | null,
    includeContent: boolean,
    snippetLength: number
  ): Promise<ContentSearchResult['results']> {
    const results: ContentSearchResult['results'] = [];
    let maxScore = 0;
    let bestMethod: 'fuzzy' | 'keyword' | 'combined' = 'fuzzy';
    let contentSnippet = '';

    // 1. Fuzzy search on filename
    const filename = file.basename;
    const fuzzyResult = fuzzySearch(filename);
    let fuzzyScore = 0;

    if (fuzzyResult) {
      // Normalize fuzzy score (fuzzy scores are negative, closer to 0 is better)
      fuzzyScore = Math.max(0, Math.min(1, 1 + (fuzzyResult.score / 100)));
      maxScore = Math.max(maxScore, fuzzyScore);
      bestMethod = 'fuzzy';
    }

    // 2. Keyword search in file content and extract frontmatter
    let keywordScore = 0;
    let frontmatter: Record<string, any> | undefined = undefined;

    if (includeContent) {
      try {
        const fileContent = await this.plugin.app.vault.read(file);

        // Extract frontmatter using Obsidian's metadata cache
        const fileCache = this.plugin.app.metadataCache.getFileCache(file);
        if (fileCache?.frontmatter) {
          frontmatter = { ...fileCache.frontmatter };
          // Remove the position property as it's internal metadata
          delete frontmatter.position;
        }

        const keywordResult = this.performKeywordSearch(originalQuery, normalizedQuery, fileContent, snippetLength);

        if (keywordResult.found) {
          keywordScore = keywordResult.score;
          contentSnippet = keywordResult.snippet;

          if (keywordScore > maxScore) {
            maxScore = keywordScore;
            bestMethod = 'keyword';
          }
        }
      } catch (error) {
        console.warn('[Claudesidian] Failed to read file content:', file.path, error);
      }
    } else {
      // Even if not including content, still extract frontmatter
      try {
        const fileCache = this.plugin.app.metadataCache.getFileCache(file);
        if (fileCache?.frontmatter) {
          frontmatter = { ...fileCache.frontmatter };
          delete frontmatter.position;
        }
      } catch (error) {
        console.warn('[Claudesidian] Failed to extract frontmatter:', file.path, error);
      }
    }

    // 3. Combined scoring for files that match both fuzzy and keyword
    if (fuzzyScore > 0 && keywordScore > 0) {
      // Weighted combination: 60% keyword + 40% fuzzy
      maxScore = (keywordScore * 0.6) + (fuzzyScore * 0.4);
      bestMethod = 'combined';
    }

    // Only include files with matches
    if (maxScore > 0) {
      // If no content snippet from keyword search, use file path
      if (!contentSnippet && includeContent) {
        contentSnippet = `File: ${file.path}`;
      }

      results.push({
        filePath: file.path,
        title: filename,
        content: contentSnippet,
        score: maxScore,
        searchMethod: bestMethod,
        frontmatter,
        metadata: {
          fileExtension: file.extension,
          parentFolder: file.parent?.path || '',
          modifiedTime: file.stat.mtime
        }
      });
    }

    return results;
  }

  /**
   * Perform keyword search in file content
   */
  private performKeywordSearch(
    originalQuery: string,
    normalizedQuery: string,
    content: string,
    snippetLength: number
  ): { found: boolean; score: number; snippet: string } {
    const normalizedContent = content.toLowerCase();

    // Look for exact phrase match first (highest score)
    const exactIndex = normalizedContent.indexOf(normalizedQuery);
    if (exactIndex !== -1) {
      return {
        found: true,
        score: 0.9,
        snippet: this.extractSnippet(content, exactIndex, originalQuery.length, snippetLength)
      };
    }

    // Look for individual word matches
    const queryWords = normalizedQuery.split(/\s+/).filter(word => word.length > 2);
    const wordMatches = queryWords.filter(word => normalizedContent.includes(word));

    if (wordMatches.length === 0) {
      return { found: false, score: 0, snippet: '' };
    }

    // Score based on word match ratio
    const matchRatio = wordMatches.length / queryWords.length;
    const score = Math.max(0.3, matchRatio * 0.8);

    // Find snippet around first word match
    const firstMatch = wordMatches[0];
    const firstMatchIndex = normalizedContent.indexOf(firstMatch);

    return {
      found: true,
      score,
      snippet: this.extractSnippet(content, firstMatchIndex, firstMatch.length, snippetLength)
    };
  }

  /**
   * Extract content snippet around a match
   */
  private extractSnippet(content: string, matchIndex: number, matchLength: number, snippetLength: number): string {
    const halfSnippet = Math.floor(snippetLength / 2);
    const start = Math.max(0, matchIndex - halfSnippet);
    const end = Math.min(content.length, matchIndex + matchLength + halfSnippet);

    let snippet = content.substring(start, end);

    // Add ellipsis if truncated
    if (start > 0) snippet = '...' + snippet;
    if (end < content.length) snippet = snippet + '...';

    return snippet.trim();
  }

  /**
   * Get parameter schema for MCP tool definition
   */
  getParameterSchema() {
    const schema = {
      type: 'object',
      title: 'Content Search Parameters',
      description: 'Search vault files using native Obsidian fuzzy search for file names combined with keyword search in content. Results are ranked by relevance.',
      properties: {
        query: {
          type: 'string',
          description: 'Search query to find files and content. Uses fuzzy matching for file names and keyword search in content.',
          examples: ['project planning', 'typescript', 'notes', 'README']
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results to return (default: 10)',
          minimum: 1,
          maximum: 50,
          default: 10
        },
        includeContent: {
          type: 'boolean',
          description: 'Whether to search within file content and include snippets (default: true)',
          default: true
        },
        snippetLength: {
          type: 'number',
          description: 'Length of content snippets around matches (default: 200)',
          minimum: 50,
          maximum: 1000,
          default: 200
        },
        paths: {
          type: 'array',
          description: 'Restrict search to specific folder paths',
          items: { type: 'string' }
        }
      },
      required: ['query'],
      additionalProperties: false
    };

    return this.getMergedSchema(schema);
  }

  /**
   * Get result schema for MCP tool definition
   */
  getResultSchema() {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the search was successful'
        },
        query: {
          type: 'string',
          description: 'Original search query'
        },
        results: {
          type: 'array',
          description: 'Search results ranked by relevance',
          items: {
            type: 'object',
            properties: {
              filePath: {
                type: 'string',
                description: 'Path to the file'
              },
              title: {
                type: 'string',
                description: 'File name without extension'
              },
              content: {
                type: 'string',
                description: 'Content snippet around the match'
              },
              score: {
                type: 'number',
                description: 'Relevance score (0-1, higher is better)'
              },
              searchMethod: {
                type: 'string',
                enum: ['fuzzy', 'keyword', 'combined'],
                description: 'Search method that found this result'
              },
              frontmatter: {
                type: 'object',
                description: 'File frontmatter including tags, properties, and other YAML metadata',
                additionalProperties: true
              },
              metadata: {
                type: 'object',
                properties: {
                  fileExtension: { type: 'string' },
                  parentFolder: { type: 'string' },
                  modifiedTime: { type: 'number' }
                }
              }
            },
            required: ['filePath', 'title', 'content', 'score', 'searchMethod']
          }
        },
        totalResults: {
          type: 'number',
          description: 'Total number of results found'
        },
        executionTime: {
          type: 'number',
          description: 'Search execution time in milliseconds'
        },
        error: {
          type: 'string',
          description: 'Error message if search failed'
        }
      },
      required: ['success', 'query', 'results', 'totalResults', 'executionTime'],
      additionalProperties: false
    };
  }
}
```

## agents/vaultLibrarian/modes/searchDirectoryMode.ts

```typescript
import { Plugin, TFile, TFolder, TAbstractFile, prepareFuzzySearch } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { getErrorMessage } from '../../../utils/errorUtils';
import { CommonParameters } from '../../../types/mcp/AgentTypes';
import { WorkspaceService } from "../../memoryManager/services/WorkspaceService";

/**
 * Directory search parameters interface
 */
export interface SearchDirectoryParams extends CommonParameters {
  // REQUIRED PARAMETERS
  query: string;
  paths: string[];  // Cannot be empty - this is the key requirement

  // OPTIONAL PARAMETERS
  searchType?: 'files' | 'folders' | 'both';
  fileTypes?: string[];
  depth?: number;
  includeContent?: boolean;
  limit?: number;
  pattern?: string;
  dateRange?: {
    start?: string;
    end?: string;
  };
  workspaceId?: string;
}

interface SearchModeCapabilities {
  semanticSearch: boolean;
  workspaceFiltering: boolean;
  memorySearch: boolean;
  hybridSearch: boolean;
}

export interface DirectoryItem {
  path: string;
  name: string;
  type: 'file' | 'folder';
  score: number;
  searchMethod: string;
  snippet?: string;
  metadata: {
    fileType?: string;
    created?: number;
    modified?: number;
    size?: number;
    depth?: number;
    fileCount?: number;
    folderCount?: number;
  };
}

export interface SearchDirectoryResult {
  success: boolean;
  query: string;
  searchedPaths?: string[];
  results: DirectoryItem[];
  totalResults: number;
  executionTime?: number;
  searchCapabilities?: SearchModeCapabilities;
  error?: string;
}

/**
 * Unified search mode for both files and folders using fuzzy matching
 */
export class SearchDirectoryMode extends BaseMode<SearchDirectoryParams, SearchDirectoryResult> {
  private plugin: Plugin;
  private workspaceService?: WorkspaceService;

  constructor(plugin: Plugin, workspaceService?: WorkspaceService) {
    super(
      'searchDirectoryMode', 
      'Search Directory', 
      'FOCUSED directory search with REQUIRED paths parameter. Search for files and/or folders within specific directory paths using fuzzy matching and optional workspace context. Requires: query (search terms) and paths (directory paths to search - cannot be empty).', 
      '2.0.0'
    );
    
    this.plugin = plugin;
    this.workspaceService = workspaceService;
  }

  async execute(params: SearchDirectoryParams): Promise<SearchDirectoryResult> {
    const startTime = Date.now();

    try {
      // Simple parameter validation
      if (!params.query || params.query.trim().length === 0) {
        return this.prepareResult(false, {
          query: params.query || '',
          results: [],
          totalResults: 0,
          executionTime: Date.now() - startTime,
          searchCapabilities: this.getCapabilities()
        }, 'Query parameter is required and cannot be empty', params.context);
      }

      if (!params.paths || params.paths.length === 0) {
        return this.prepareResult(false, {
          query: params.query,
          results: [],
          totalResults: 0,
          executionTime: Date.now() - startTime,
          searchCapabilities: this.getCapabilities()
        }, 'Paths parameter is required and cannot be empty - specify directories to search', params.context);
      }

      const query = params.query.trim();
      const limit = params.limit || 20;
      const searchType = params.searchType || 'both';
      
      // Get items from specified directories
      const items = await this.getDirectoryItems(params.paths, searchType, params);
      
      // Apply workspace context if available
      const contextualItems = await this.applyWorkspaceContext(items, params.workspaceId);
      
      // Apply additional filters
      const filteredItems = this.applyFilters(contextualItems, params);
      
      // Perform fuzzy search
      const matches = this.performFuzzySearch(filteredItems, query);
      
      // Sort and limit results
      matches.sort((a, b) => b.score - a.score);
      const topMatches = matches.slice(0, limit);
      
      // Transform to enhanced format
      const results = await this.transformResults(topMatches, params);

      return {
        success: true,
        query: params.query,
        searchedPaths: params.paths,
        results: results,
        totalResults: matches.length,
        executionTime: Date.now() - startTime,
        searchCapabilities: this.getCapabilities()
      };
      
    } catch (error) {
      return this.prepareResult(false, {
        query: params.query || '',
        searchedPaths: params.paths || [],
        results: [],
        totalResults: 0,
        executionTime: Date.now() - startTime,
        searchCapabilities: this.getCapabilities()
      }, `Directory search failed: ${getErrorMessage(error)}`, params.context);
    }
  }

  private async getDirectoryItems(
    paths: string[], 
    searchType: 'files' | 'folders' | 'both',
    params: SearchDirectoryParams
  ): Promise<(TFile | TFolder)[]> {
    const allItems: (TFile | TFolder)[] = [];

    for (const path of paths) {
      const normalizedPath = this.normalizePath(path);
      
      if (normalizedPath === '/' || normalizedPath === '') {
        // Root path - get all vault items
        const vaultItems = this.plugin.app.vault.getAllLoadedFiles()
          .filter(file => this.matchesSearchType(file, searchType)) as (TFile | TFolder)[];
        allItems.push(...vaultItems);
      } else {
        // Specific directory
        const directoryItems = await this.getItemsInDirectory(normalizedPath, searchType, params);
        allItems.push(...directoryItems);
      }
    }

    // Remove duplicates
    return Array.from(new Map(allItems.map(item => [item.path, item])).values());
  }

  private applyFilters(items: (TFile | TFolder)[], params: SearchDirectoryParams): (TFile | TFolder)[] {
    let filtered = items;

    // File type filter (only applies to files)
    if (params.fileTypes && params.fileTypes.length > 0) {
      const allowedTypes = params.fileTypes.map(type => type.toLowerCase());
      filtered = filtered.filter(item => {
        if (item instanceof TFile) {
          return allowedTypes.includes(item.extension.toLowerCase());
        }
        return true; // Keep folders when file type filter is applied
      });
    }

    // Depth filter
    if (params.depth !== undefined) {
      filtered = filtered.filter(item => {
        const pathDepth = item.path.split('/').filter(p => p.length > 0).length;
        return pathDepth <= params.depth!;
      });
    }

    // Pattern filter
    if (params.pattern) {
      try {
        const regex = new RegExp(params.pattern, 'i');
        filtered = filtered.filter(item => {
          const name = item instanceof TFile ? item.basename : item.name;
          return regex.test(item.path) || regex.test(name);
        });
      } catch (error) {
      }
    }

    // Date range filter (only applies to files)
    if (params.dateRange) {
      const startDate = params.dateRange.start ? new Date(params.dateRange.start).getTime() : 0;
      const endDate = params.dateRange.end ? new Date(params.dateRange.end).getTime() : Date.now();
      
      filtered = filtered.filter(item => {
        if (item instanceof TFile) {
          const modified = item.stat.mtime;
          return modified >= startDate && modified <= endDate;
        }
        return true; // Keep folders when date filter is applied
      });
    }

    return filtered;
  }

  private performFuzzySearch(items: (TFile | TFolder)[], query: string): Array<{ item: TFile | TFolder; score: number; matchType: string }> {
    const fuzzySearch = prepareFuzzySearch(query);
    const matches: Array<{ item: TFile | TFolder; score: number; matchType: string }> = [];

    for (const item of items) {
      let bestScore = 0;
      let bestMatchType = '';

      // Get appropriate name for search
      const itemName = item instanceof TFile ? item.basename : item.name;

      // Search by name
      const nameResult = fuzzySearch(itemName);
      if (nameResult) {
        const normalizedScore = Math.max(0, Math.min(1, 1 + (nameResult.score / 100)));
        if (normalizedScore > bestScore) {
          bestScore = normalizedScore;
          bestMatchType = 'name';
        }
      }

      // Search by full path
      const pathResult = fuzzySearch(item.path);
      if (pathResult) {
        const normalizedScore = Math.max(0, Math.min(1, 1 + (pathResult.score / 100))) * 0.8; // Lower weight for path matches
        if (normalizedScore > bestScore) {
          bestScore = normalizedScore;
          bestMatchType = 'path';
        }
      }

      // Include item if it has any match
      if (bestScore > 0) {
        matches.push({ item, score: bestScore, matchType: bestMatchType });
      }
    }

    return matches;
  }

  private async transformResults(matches: Array<{ item: TFile | TFolder; score: number; matchType: string }>, params: SearchDirectoryParams): Promise<DirectoryItem[]> {
    const results: DirectoryItem[] = [];

    for (const match of matches) {
      const item = match.item;
      const isFile = item instanceof TFile;

      let snippet = '';
      if (isFile && params.includeContent !== false) {
        try {
          const content = await this.plugin.app.vault.read(item);
          const lines = content.split('\n');
          const firstFewLines = lines.slice(0, 3).join(' ');
          snippet = firstFewLines.length > 200 ? firstFewLines.substring(0, 200) + '...' : firstFewLines;
        } catch (error) {
          snippet = 'Content not available';
        }
      }

      const result: DirectoryItem = {
        path: item.path,
        name: isFile ? item.basename : item.name,
        type: isFile ? 'file' : 'folder',
        score: match.score,
        searchMethod: `fuzzy_${match.matchType}`,
        snippet: snippet || undefined,
        metadata: {}
      };

      // Add file-specific metadata
      if (isFile) {
        result.metadata = {
          fileType: item.extension,
          created: item.stat.ctime,
          modified: item.stat.mtime,
          size: item.stat.size
        };
      } else {
        // Add folder-specific metadata
        const folder = item as TFolder;
        const children = folder.children || [];
        const fileCount = children.filter(child => child instanceof TFile).length;
        const folderCount = children.filter(child => child instanceof TFolder).length;
        
        result.metadata = {
          depth: folder.path.split('/').filter(p => p.length > 0).length,
          fileCount: fileCount,
          folderCount: folderCount
        };
      }

      results.push(result);
    }

    return results;
  }

  private async getItemsInDirectory(
    directoryPath: string,
    searchType: 'files' | 'folders' | 'both',
    params: SearchDirectoryParams
  ): Promise<(TFile | TFolder)[]> {
    const folder = this.plugin.app.vault.getAbstractFileByPath(directoryPath);
    
    if (!folder || !('children' in folder)) {
      return [];
    }

    const items: (TFile | TFolder)[] = [];

    const collectItems = (currentFolder: TFolder, currentDepth: number = 0) => {
      if (params.depth && currentDepth >= params.depth) {
        return;
      }

      for (const child of currentFolder.children) {
        if (this.matchesSearchType(child, searchType)) {
          items.push(child as TFile | TFolder);
        }
        
        // Recursive traversal for folders
        if ('children' in child) {
          collectItems(child as TFolder, currentDepth + 1);
        }
      }
    };

    collectItems(folder as TFolder);
    return items;
  }

  private matchesSearchType(item: TAbstractFile, searchType: 'files' | 'folders' | 'both'): boolean {
    switch (searchType) {
      case 'files':
        return item instanceof TFile;
      case 'folders':
        return item instanceof TFolder;
      case 'both':
      default:
        return item instanceof TFile || item instanceof TFolder;
    }
  }

  private async applyWorkspaceContext(
    items: (TFile | TFolder)[],
    workspaceId?: string
  ): Promise<(TFile | TFolder)[]> {
    if (!this.workspaceService || !workspaceId || workspaceId === 'global-workspace-default') {
      return items;
    }

    try {
      const workspace = await this.workspaceService.getWorkspace(workspaceId);
      if (!workspace) {
        return items; // No workspace context, return all items
      }

      // For directory search, workspace context can boost relevance but doesn't filter
      // This maintains the explicit directory paths while adding workspace awareness
      return items;
      
    } catch (error) {
      console.warn(`Could not apply workspace context for ${workspaceId}:`, error);
      return items;
    }
  }

  private normalizePath(path: string): string {
    return path.replace(/\\/g, '/').replace(/^\/+/, '').replace(/\/+$/, '');
  }

  private getCapabilities(): SearchModeCapabilities {
    return {
      semanticSearch: false,
      workspaceFiltering: !!this.workspaceService,
      memorySearch: false,
      hybridSearch: false
    };
  }

  getParameterSchema() {
    const modeSchema = {
      type: 'object',
      title: 'Focused Directory Search Parameters',
      description: 'FOCUSED directory search with REQUIRED paths parameter. Search within specific directory paths for better organization and navigation.',
      properties: {
        query: {
          type: 'string',
          description: 'REQUIRED: Search query to find in file/folder names and paths',
          minLength: 1,
          examples: ['project', 'meeting notes', 'config', 'README']
        },
        paths: {
          type: 'array',
          items: { type: 'string' },
          minItems: 1,
          description: 'REQUIRED: Directory paths to search within. Cannot be empty. Specify the folder paths where you want to search for focused results.',
          examples: [
            ['Projects/WebApp'],
            ['Notes', 'Archive'], 
            ['/'],  // Search entire vault root
            ['Work/Current Projects', 'Personal/Ideas']
          ]
        },
        searchType: {
          type: 'string',
          enum: ['files', 'folders', 'both'],
          description: 'What to search for within the specified directories',
          default: 'both'
        },
        fileTypes: {
          type: 'array',
          items: { type: 'string' },
          description: 'Filter results by file extensions (e.g., ["md", "txt"])',
          examples: [["md"], ["md", "txt"], ["pdf", "docx"]]
        },
        depth: {
          type: 'number',
          description: 'Maximum directory depth to include in results',
          minimum: 1,
          maximum: 10
        },
        pattern: {
          type: 'string',
          description: 'Regex pattern to filter paths',
          examples: ['^Archive/', '.*Projects.*', '[0-9]{4}']
        },
        dateRange: {
          type: 'object',
          properties: {
            start: {
              type: 'string',
              format: 'date',
              description: 'Start date for filtering results (ISO format)'
            },
            end: {
              type: 'string',
              format: 'date',
              description: 'End date for filtering results (ISO format)'
            }
          },
          description: 'Filter results by modification date range'
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results to return',
          default: 20,
          minimum: 1,
          maximum: 100
        },
        includeContent: {
          type: 'boolean',
          description: 'Include file content snippets in results',
          default: true
        }
      },
      required: ['query', 'paths']
    };
    
    return this.getMergedSchema(modeSchema);
  }

  getResultSchema() {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the search was successful'
        },
        query: {
          type: 'string',
          description: 'The search query'
        },
        searchedPaths: {
          type: 'array',
          items: { type: 'string' },
          description: 'Directory paths that were searched'
        },
        results: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              path: {
                type: 'string',
                description: 'Full path to the item'
              },
              name: {
                type: 'string',
                description: 'Name of the item'
              },
              type: {
                type: 'string',
                enum: ['file', 'folder'],
                description: 'Type of the item'
              },
              score: {
                type: 'number',
                description: 'Search relevance score'
              },
              searchMethod: {
                type: 'string',
                description: 'Method used to find this result'
              },
              snippet: {
                type: 'string',
                description: 'Content snippet (files only)'
              },
              metadata: {
                type: 'object',
                properties: {
                  fileType: {
                    type: 'string',
                    description: 'File extension (files only)'
                  },
                  created: {
                    type: 'number',
                    description: 'Creation timestamp (files only)'
                  },
                  modified: {
                    type: 'number',
                    description: 'Last modified timestamp (files only)'
                  },
                  size: {
                    type: 'number',
                    description: 'File size in bytes (files only)'
                  },
                  depth: {
                    type: 'number',
                    description: 'Folder depth level (folders only)'
                  },
                  fileCount: {
                    type: 'number',
                    description: 'Number of files in folder (folders only)'
                  },
                  folderCount: {
                    type: 'number',
                    description: 'Number of subfolders (folders only)'
                  }
                }
              }
            }
          }
        },
        totalResults: {
          type: 'number',
          description: 'Total number of results found'
        },
        executionTime: {
          type: 'number',
          description: 'Search execution time in milliseconds'
        },
        searchCapabilities: {
          type: 'object',
          properties: {
            semanticSearch: { type: 'boolean' },
            workspaceFiltering: { type: 'boolean' },
            memorySearch: { type: 'boolean' },
            hybridSearch: { type: 'boolean' }
          }
        },
        error: {
          type: 'string',
          description: 'Error message if search failed'
        }
      },
      required: ['success', 'query', 'results', 'totalResults']
    };
  }
}
```

## agents/vaultLibrarian/modes/searchMemoryMode.ts

```typescript
import { Plugin } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { getErrorMessage } from '../../../utils/errorUtils';
import {
  MemorySearchParameters,
  MemorySearchResult,
  SearchMemoryModeResult,
  MemoryFilterOptions,
  FormatOptions,
  DateRange
} from '../../../types/memory/MemorySearchTypes';
import { MemorySearchProcessor, MemorySearchProcessorInterface } from '../services/MemorySearchProcessor';
import { MemorySearchFilters, MemorySearchFiltersInterface } from '../services/MemorySearchFilters';
import { ResultFormatter, ResultFormatterInterface } from '../services/ResultFormatter';
import { CommonParameters } from '../../../types/mcp/AgentTypes';
import { MemoryService } from "../../memoryManager/services/MemoryService";
import { WorkspaceService } from "../../memoryManager/services/WorkspaceService";
import { addRecommendations, Recommendation } from '../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../utils/nudgeHelpers';

/**
 * Memory types available for search (aligned with MemorySearchParameters)
 */
export type MemoryType = 'traces' | 'sessions' | 'states' | 'workspaces' | 'toolCalls';

/**
 * Session filtering options
 */
export interface SessionFilterOptions {
  currentSessionOnly?: boolean;     // Filter to current session (default: false)
  specificSessions?: string[];      // Filter to specific session IDs
  excludeSessions?: string[];       // Exclude specific session IDs
}

/**
 * Temporal filtering options for time-based search
 */
export interface TemporalFilterOptions {
  since?: string | Date;           // Results since this timestamp
  until?: string | Date;           // Results until this timestamp
  lastNHours?: number;             // Results from last N hours
  lastNDays?: number;              // Results from last N days
}

/**
 * Memory search parameters interface (aligned with MemorySearchParameters)
 */
export interface SearchMemoryParams extends CommonParameters {
  // REQUIRED PARAMETERS
  query: string;
  workspaceId: string;  // Defaults to global workspace if not provided

  // OPTIONAL PARAMETERS
  memoryTypes?: MemoryType[];
  searchMethod?: 'semantic' | 'exact' | 'mixed';
  sessionFiltering?: SessionFilterOptions;
  temporalFiltering?: TemporalFilterOptions;
  limit?: number;
  includeMetadata?: boolean;
  includeContent?: boolean;
  
  // Additional properties to match MemorySearchParameters
  workspace?: string;
  dateRange?: DateRange;
  toolCallFilters?: any;
  filterBySession?: boolean;
}

interface SearchModeCapabilities {
  semanticSearch: boolean;
  workspaceFiltering: boolean;
  memorySearch: boolean;
  hybridSearch: boolean;
}

// Enhanced SearchMemoryResult with capabilities and execution time
export interface SearchMemoryResult extends SearchMemoryModeResult {
  searchCapabilities?: SearchModeCapabilities;
  executionTime?: number;
}

// Legacy interface names for backward compatibility
export type { MemorySearchResult };
export type { SearchMemoryModeResult };

/**
 * Search mode focused on memory traces, sessions, states, and workspaces
 * Optimized with extracted services for better maintainability and testability
 */
export class SearchMemoryMode extends BaseMode<SearchMemoryParams, SearchMemoryResult> {
  private plugin: Plugin;
  private processor: MemorySearchProcessorInterface;
  private filters: MemorySearchFiltersInterface;
  private formatter: ResultFormatterInterface;
  private memoryService?: MemoryService;
  private workspaceService?: WorkspaceService;

  constructor(
    plugin: Plugin,
    memoryService?: MemoryService,
    workspaceService?: WorkspaceService,
    processor?: MemorySearchProcessorInterface,
    filters?: MemorySearchFiltersInterface,
    formatter?: ResultFormatterInterface
  ) {
    super(
      'searchMemoryMode', 
      'Search Memory', 
      'MEMORY-FOCUSED search with mandatory workspaceId parameter. Search through memory traces, sessions, states, and activities with workspace context and temporal filtering. Requires: query (search terms) and workspaceId (workspace context - defaults to "global-workspace-default").', 
      '2.0.0'
    );
    
    this.plugin = plugin;
    this.memoryService = memoryService;
    this.workspaceService = workspaceService;
    
    // Initialize services with dependency injection support
    this.processor = processor || new MemorySearchProcessor(plugin);
    this.filters = filters || new MemorySearchFilters();
    this.formatter = formatter || new ResultFormatter();
  }

  async execute(params: SearchMemoryParams): Promise<SearchMemoryResult> {
    const startTime = Date.now();
    
    try {
      // Simple parameter validation
      if (!params.query || params.query.trim().length === 0) {
        return this.prepareResult(false, {
          query: params.query || '',
          results: [],
          totalResults: 0,
          searchCapabilities: this.getCapabilities(),
          executionTime: Date.now() - startTime
        }, 'Query parameter is required and cannot be empty', params.context);
      }

      // Apply default workspace if not provided
      const workspaceId = params.workspaceId || 'global-workspace-default';
      const searchParams = { ...params, workspaceId };

      // Core processing through extracted services
      let results = await this.processor.process(searchParams);
      
      // Apply filters if specified
      if (this.shouldApplyFilters(searchParams)) {
        const filterOptions = this.buildFilterOptions(searchParams);
        results = this.filters.filter(results, filterOptions);
      }
      
      // Format results if needed (currently returns results as-is for compatibility)
      const formatOptions = this.buildFormatOptions(searchParams);
      // Note: Formatting is available but not applied by default to maintain compatibility
      
      // Build summary
      const summary = await this.formatter.buildSummary(results);
      const executionTime = Date.now() - startTime;
      summary.executionTime = executionTime;

      console.log('[SearchMemoryMode] Search completed:', {
        totalResults: results.length,
        executionTime: `${executionTime}ms`,
        query: params.query
      });

      const result = {
        success: true,
        query: params.query,
        results: results,
        totalResults: results.length,
        searchCapabilities: this.getCapabilities(),
        executionTime: Date.now() - startTime
      };

      // Generate nudges based on memory search results
      const nudges = this.generateMemorySearchNudges(results);

      return addRecommendations(result, nudges);
      
    } catch (error) {
      console.error('[SearchMemoryMode] Search error:', error);
      return this.prepareResult(false, {
        query: params.query || '',
        results: [],
        totalResults: 0,
        searchCapabilities: this.getCapabilities(),
        executionTime: Date.now() - startTime
      }, `Memory search failed: ${getErrorMessage(error)}`, params.context);
    }
  }

  getParameterSchema() {
    // Create the enhanced mode-specific schema
    const modeSchema = {
      type: 'object',
      title: 'Memory Search Parameters',
      description: 'MEMORY-FOCUSED search with workspace context. Search through memory traces, sessions, states, and activities with temporal filtering.',
      properties: {
        query: {
          type: 'string',
          description: 'REQUIRED: Search query to find in memory content',
          minLength: 1,
          examples: ['project discussion', 'error handling', 'user feedback', 'deployment process']
        },
        workspaceId: {
          type: 'string',
          description: 'REQUIRED: Workspace context for memory search. IMPORTANT: If not provided or empty, defaults to "global-workspace-default" which has minimal memory content. Specify a proper workspace ID to access workspace-specific memory traces, sessions, and activities.',
          default: 'global-workspace-default',
          examples: ['project-alpha', 'research-workspace', 'global-workspace-default']
        },
        memoryTypes: {
          type: 'array',
          items: {
            type: 'string',
            enum: ['traces', 'toolCalls', 'sessions', 'states', 'workspaces']
          },
          description: 'Types of memory to search (defaults to all)',
          default: ['traces', 'toolCalls', 'sessions', 'states', 'workspaces']
        },
        dateRange: {
          type: 'object',
          properties: {
            start: {
              type: 'string',
              format: 'date',
              description: 'Start date for filtering results (ISO format)'
            },
            end: {
              type: 'string',
              format: 'date',
              description: 'End date for filtering results (ISO format)'
            }
          },
          description: 'Filter results by date range'
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results to return',
          default: 20,
          minimum: 1,
          maximum: 100
        },
        toolCallFilters: {
          type: 'object',
          properties: {
            agent: {
              type: 'string',
              description: 'Filter by agent name (e.g., contentManager, vaultLibrarian)'
            },
            mode: {
              type: 'string',
              description: 'Filter by mode name (e.g., createNote, searchMode)'
            },
            success: {
              type: 'boolean',
              description: 'Filter by success status (true for successful, false for failed)'
            },
            minExecutionTime: {
              type: 'number',
              description: 'Minimum execution time in milliseconds'
            },
            maxExecutionTime: {
              type: 'number',
              description: 'Maximum execution time in milliseconds'
            }
          },
          description: 'Additional filters for tool call traces'
        },
        searchMethod: {
          type: 'string',
          enum: ['semantic', 'exact', 'mixed'],
          description: 'Search method to use',
          default: 'mixed'
        },
        filterBySession: {
          type: 'boolean',
          description: 'If true, only return traces from the current sessionId. If false or omitted, search across all sessions.',
          default: false
        }
      },
      required: ['query', 'workspaceId']
    };
    
    // Merge with common schema (sessionId and context) - removing duplicate definitions
    return this.getMergedSchema(modeSchema);
  }

  getResultSchema() {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the search was successful'
        },
        query: {
          type: 'string',
          description: 'The search query'
        },
        results: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              type: {
                type: 'string',
                enum: ['trace', 'toolCall', 'session', 'state', 'workspace'],
                description: 'Type of memory result'
              },
              id: {
                type: 'string',
                description: 'Unique identifier of the memory item'
              },
              highlight: {
                type: 'string',
                description: 'Relevant snippet from the memory item'
              },
              metadata: {
                type: 'object',
                description: 'Metadata about the memory item'
              },
              context: {
                type: 'object',
                properties: {
                  before: {
                    type: 'string',
                    description: 'Context before the match'
                  },
                  match: {
                    type: 'string',
                    description: 'The matching content'
                  },
                  after: {
                    type: 'string',
                    description: 'Context after the match'
                  }
                }
              },
              score: {
                type: 'number',
                description: 'Search relevance score'
              }
            }
          }
        },
        totalResults: {
          type: 'number',
          description: 'Total number of results found'
        },
        searchCapabilities: {
          type: 'object',
          properties: {
            semanticSearch: { type: 'boolean' },
            workspaceFiltering: { type: 'boolean' },
            memorySearch: { type: 'boolean' },
            hybridSearch: { type: 'boolean' }
          }
        },
        executionTime: {
          type: 'number',
          description: 'Search execution time in milliseconds'
        },
        error: {
          type: 'string',
          description: 'Error message if search failed'
        }
      },
      required: ['success', 'query', 'results', 'totalResults', 'searchCapabilities']
    };
  }

  // Private helper methods for the refactored implementation
  
  /**
   * Determine if filters should be applied
   */
  private shouldApplyFilters(params: SearchMemoryParams): boolean {
    return !!(params.dateRange || 
              params.toolCallFilters || 
              params.filterBySession || 
              params.workspace || params.workspaceId);
  }
  
  /**
   * Build filter options from parameters
   */
  private buildFilterOptions(params: SearchMemoryParams): MemoryFilterOptions {
    return {
      dateRange: params.dateRange,
      toolCallFilters: params.toolCallFilters,
      sessionId: params.context.sessionId,
      workspaceId: params.workspace || params.workspaceId,
      filterBySession: params.filterBySession
    };
  }
  
  /**
   * Build format options from parameters
   */
  private buildFormatOptions(params: SearchMemoryParams): FormatOptions {
    return {
      maxHighlightLength: 200,
      contextLength: 50,
      enhanceToolCallContext: true
    };
  }

  private getCapabilities(): SearchModeCapabilities {
    return {
      semanticSearch: false, // Memory search typically uses exact/fuzzy matching
      workspaceFiltering: !!this.workspaceService,
      memorySearch: !!this.memoryService,
      hybridSearch: false
    };
  }

  /**
   * Generate nudges based on memory search results
   */
  private generateMemorySearchNudges(results: any[]): Recommendation[] {
    const nudges: Recommendation[] = [];

    if (!Array.isArray(results) || results.length === 0) {
      return nudges;
    }

    // Check for previous states in results
    const previousStatesNudge = NudgeHelpers.checkPreviousStates(results);
    if (previousStatesNudge) {
      nudges.push(previousStatesNudge);
    }

    // Check for workspace sessions in results
    const workspaceSessionsNudge = NudgeHelpers.checkWorkspaceSessions(results);
    if (workspaceSessionsNudge) {
      nudges.push(workspaceSessionsNudge);
    }

    return nudges;
  }
}
```

## agents/vaultLibrarian/modes/services/universal/UniversalSearchService.ts

```typescript
/**
 * UniversalSearchService - Refactored following SOLID principles
 * Orchestrates specialized search services for unified search functionality
 */

import { Plugin, TFile } from 'obsidian';
import { MemoryService } from "../../../../memoryManager/services/MemoryService";
import { WorkspaceService } from "../../../../memoryManager/services/WorkspaceService";
import { GraphOperations } from '../../../../../database/utils/graph/GraphOperations';
type MetadataSearchCriteria = any;
import { 
  UniversalSearchParams, 
  UniversalSearchResult, 
  UniversalSearchResultItem 
} from '../../../types';

// Import specialized services
import { QueryParser } from './query/QueryParser';
import { ContentSearchStrategy } from './strategies/ContentSearchStrategy';
import { FileSearchStrategy } from './strategies/FileSearchStrategy';
import { MetadataSearchStrategy } from './strategies/MetadataSearchStrategy';
import { ResultConsolidator, ConsolidatedSearchResult } from './results/ResultConsolidator';
import { ResultFormatter } from './results/ResultFormatter';
import { ServiceInitializer } from './initialization/ServiceInitializer';
import { globalValidationErrorMonitor, ValidationErrorMonitor } from './validation/ValidationErrorMonitor';

/**
 * Refactored UniversalSearchService following SOLID principles
 * Orchestrates specialized search services for unified search functionality
 */
export class UniversalSearchService {
  private plugin: Plugin;
  private graphOperations: GraphOperations;
  
  // Composed services following Dependency Injection principle
  private serviceInitializer: ServiceInitializer;
  private queryParser: QueryParser;
  private contentSearchStrategy: ContentSearchStrategy;
  private fileSearchStrategy: FileSearchStrategy;
  private metadataSearchStrategy: MetadataSearchStrategy;
  private resultConsolidator: ResultConsolidator;
  private resultFormatter: ResultFormatter;
  
  // Service references
  private metadataSearchService?: any;
  private memoryService?: MemoryService;
  private workspaceService?: WorkspaceService;

  constructor(
    plugin: Plugin,
    memoryService?: MemoryService,
    workspaceService?: WorkspaceService
  ) {
    this.plugin = plugin;
    this.graphOperations = new GraphOperations();
    
    // Initialize specialized services
    this.serviceInitializer = new ServiceInitializer(plugin);
    this.queryParser = new QueryParser();
    this.contentSearchStrategy = new ContentSearchStrategy();
    this.fileSearchStrategy = new FileSearchStrategy(plugin);
    this.metadataSearchStrategy = new MetadataSearchStrategy(plugin, null);
    this.resultConsolidator = new ResultConsolidator();
    this.resultFormatter = new ResultFormatter();
    
    // Store provided services
    this.memoryService = memoryService;
    this.workspaceService = workspaceService;
    
    // Initialize services
    this.initializeServices();
  }

  /**
   * Initialize all services
   */
  private async initializeServices(): Promise<void> {
    try {
      const result = await this.serviceInitializer.initializeServices({
        memoryService: this.memoryService,
        workspaceService: this.workspaceService
      });

      if (result.success && result.services) {
        this.metadataSearchService = result.services.metadataSearchService;
        
        // Update search strategies (no services needed for keyword-only search)
        this.contentSearchStrategy.updateServices();
        
        this.metadataSearchStrategy = new MetadataSearchStrategy(
          this.plugin,
          this.metadataSearchService
        );
      }
    } catch (error) {
    }
  }

  /**
   * Populate hybrid search indexes
   */
  async populateHybridSearchIndexes(): Promise<void> {
    try {
      const result = await this.serviceInitializer.populateHybridSearchIndexes();
      if (!result.success) {
      }
    } catch (error) {
    }
  }

  /**
   * Execute consolidated search (returns consolidated results)
   */
  async executeConsolidatedSearch(params: UniversalSearchParams): Promise<ConsolidatedSearchResult[]> {
    try {
      const startTime = performance.now();
      const { query, limit = 10 } = params;


      // 1. Parse query
      const parseStart = performance.now();
      const parseResult = this.queryParser.parseSearchQuery(query);
      const parseTime = performance.now() - parseStart;
      
      if (!parseResult.success) {
        throw new Error(parseResult.error);
      }

      const parsedQuery = parseResult.parsed!;

      // 2. Filter files by metadata if needed
      let filteredFiles: TFile[] | undefined;
      if (parsedQuery.tags.length > 0 || parsedQuery.properties.length > 0) {
        const filterStart = performance.now();
        
        const criteria: MetadataSearchCriteria = {
          tags: parsedQuery.tags,
          properties: parsedQuery.properties,
          matchAll: true
        };
        
        if (this.metadataSearchService) {
          filteredFiles = await this.metadataSearchService.getFilesMatchingMetadata(criteria);
          const filterTime = performance.now() - filterStart;
        }
      }

      // 3. Search content
      const contentStart = performance.now();
      const contentResult = await this.contentSearchStrategy.searchContent(
        parsedQuery.cleanQuery,
        filteredFiles,
        limit,
        params
      );
      const contentTime = performance.now() - contentStart;

      // 4. Consolidate results
      const consolidateStart = performance.now();
      const consolidateResult = await this.resultConsolidator.consolidateResultsByFile(
        contentResult.results || []
      );
      const consolidateTime = performance.now() - consolidateStart;

      if (!consolidateResult.success) {
        throw new Error(consolidateResult.error);
      }

      const totalTime = performance.now() - startTime;

      return consolidateResult.results || [];
    } catch (error) {
      return [];
    }
  }

  /**
   * Execute universal search (returns formatted universal search result)
   */
  async executeUniversalSearch(params: UniversalSearchParams): Promise<UniversalSearchResult> {
    try {
      const startTime = performance.now();
      const { query, limit = 10 } = params;

      // 1. Parse query
      const parseResult = this.queryParser.parseSearchQuery(query);
      if (!parseResult.success) {
        return this.resultFormatter.createErrorResult(query, parseResult.error!);
      }

      const parsedQuery = parseResult.parsed!;

      // 2. Filter files by metadata if needed
      let filteredFiles: TFile[] | undefined;
      if (parsedQuery.tags.length > 0 || parsedQuery.properties.length > 0) {
        const criteria: MetadataSearchCriteria = {
          tags: parsedQuery.tags,
          properties: parsedQuery.properties,
          matchAll: true
        };
        
        if (this.metadataSearchService) {
          filteredFiles = await this.metadataSearchService.getFilesMatchingMetadata(criteria);
        }
      }

      // 3. Execute parallel searches
      const [contentResult, fileResult, tagResult, propertyResult] = await Promise.all([
        this.contentSearchStrategy.searchContent(parsedQuery.cleanQuery, filteredFiles, limit, params),
        this.fileSearchStrategy.searchFiles(query, limit),
        this.metadataSearchStrategy.searchTags(query, limit),
        this.metadataSearchStrategy.searchProperties(query, limit)
      ]);

      // 4. Extract results
      const contentResults = contentResult.results || [];
      const fileResults = fileResult.results || [];
      const tagResults = tagResult.results || [];
      const propertyResults = propertyResult.results || [];

      // 5. Format results
      const executionTime = performance.now() - startTime;
      const semanticAvailable = this.serviceInitializer.isSemanticSearchAvailable();

      const formatResult = this.resultFormatter.formatUniversalSearchResult(
        query,
        contentResults,
        fileResults,
        tagResults,
        propertyResults,
        executionTime,
        limit,
        semanticAvailable,
        {}
      );

      if (!formatResult.success) {
        return this.resultFormatter.createErrorResult(query, formatResult.error!);
      }

      return formatResult.result!;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.resultFormatter.createErrorResult(params.query, errorMessage);
    }
  }

  /**
   * Get service diagnostics
   */
  async getServiceDiagnostics(): Promise<any> {
    try {
      return await this.serviceInitializer.getServiceDiagnostics();
    } catch (error) {
      return {
        services: {
          metadataSearch: false,
          hybridSearch: false,
          memory: false,
          workspace: false
        },
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Check if semantic search is available
   */
  isSemanticSearchAvailable(): boolean {
    return this.serviceInitializer.isSemanticSearchAvailable();
  }

  /**
   * Check if hybrid search is available
   */
  isHybridSearchAvailable(): boolean {
    return this.serviceInitializer.isHybridSearchAvailable();
  }

  /**
   * Get search capabilities
   */
  getSearchCapabilities(): {
    content: boolean;
    files: boolean;
    tags: boolean;
    properties: boolean;
    semantic: boolean;
    hybrid: boolean;
  } {
    return {
      content: true,
      files: true,
      tags: true,
      properties: true,
      semantic: this.isSemanticSearchAvailable(),
      hybrid: this.isHybridSearchAvailable()
    };
  }

  /**
   * Update services (for hot-reloading)
   */
  updateServices(services: {
    memoryService?: MemoryService;
    workspaceService?: WorkspaceService;
  }): void {
    // Update service references

    if (services.memoryService) {
      this.memoryService = services.memoryService;
      this.serviceInitializer.updateService('memoryService', services.memoryService);
    }

    if (services.workspaceService) {
      this.workspaceService = services.workspaceService;
      this.serviceInitializer.updateService('workspaceService', services.workspaceService);
    }

    // Update search strategies (no services needed for keyword-only search)
    this.contentSearchStrategy.updateServices();
  }
}
```

## agents/vaultLibrarian/modes/services/universal/initialization/ServiceInitializer.ts

```typescript
/**
 * ServiceInitializer - Handles service initialization and dependency management
 * Follows Single Responsibility Principle by focusing only on service initialization
 */

import { Plugin } from 'obsidian';
// Search services removed in simplified architecture
type MetadataSearchService = any;
type HybridSearchService = any;
import { MemoryService } from "../../../../../memoryManager/services/MemoryService";
import { WorkspaceService } from "../../../../../memoryManager/services/WorkspaceService";

export interface ServiceInitializationResult {
  success: boolean;
  error?: string;
  services?: {
    metadataSearchService: MetadataSearchService;
    hybridSearchService?: HybridSearchService;
    memoryService?: MemoryService;
    workspaceService?: WorkspaceService;
  };
}

export interface ServiceAvailability {
  metadataSearch: boolean;
  hybridSearch: boolean;
  memory: boolean;
  workspace: boolean;
}

/**
 * Service responsible for initializing and managing search services
 * Follows SRP by focusing only on service initialization operations
 */
export class ServiceInitializer {
  private services: {
    metadataSearchService?: MetadataSearchService;
    hybridSearchService?: HybridSearchService;
    memoryService?: MemoryService;
    workspaceService?: WorkspaceService;
  } = {};

  constructor(private plugin: Plugin) {}

  /**
   * Initialize all available services
   */
  async initializeServices(
    providedServices?: {
      memoryService?: MemoryService;
      workspaceService?: WorkspaceService;
    }
  ): Promise<ServiceInitializationResult> {
    try {
      
      // MetadataSearchService removed in simplified architecture
      this.services.metadataSearchService = null;

      // Initialize provided services
      if (providedServices) {
        this.services.memoryService = providedServices.memoryService;
        this.services.workspaceService = providedServices.workspaceService;
      }

      // Try to get services from plugin if not provided
      await this.tryGetServicesFromPlugin();

      // Initialize search service
      await this.initializeSearchService();

      const availability = this.getServiceAvailability();

      return {
        success: true,
        services: {
          metadataSearchService: this.services.metadataSearchService!,
          hybridSearchService: this.services.hybridSearchService,
          memoryService: this.services.memoryService,
          workspaceService: this.services.workspaceService
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `Service initialization failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Try to get services from plugin
   */
  private async tryGetServicesFromPlugin(): Promise<void> {
    try {
      const plugin = this.plugin as any;

      // Try lazy service manager first
      if (plugin.serviceManager) {
        await this.tryGetServicesFromServiceManager(plugin.serviceManager);
      }
      
      // Try direct services access
      if (plugin.services) {
        await this.tryGetServicesFromDirectAccess(plugin.services);
      }
    } catch (error) {
    }
  }

  /**
   * Try to get services from service manager
   */
  private async tryGetServicesFromServiceManager(serviceManager: any): Promise<void> {
    try {


      // Get memory service
      if (!this.services.memoryService) {
        try {
          this.services.memoryService = await serviceManager.get('memoryService');
        } catch (error) {
        }
      }

      // Get workspace service
      if (!this.services.workspaceService) {
        try {
          this.services.workspaceService = await serviceManager.get('workspaceService');
        } catch (error) {
        }
      }
    } catch (error) {
    }
  }

  /**
   * Try to get services from direct access
   */
  private async tryGetServicesFromDirectAccess(services: any): Promise<void> {
    try {


      // Get memory service
      if (!this.services.memoryService && services.memoryService) {
        this.services.memoryService = services.memoryService;
      }

      // Get workspace service
      if (!this.services.workspaceService && services.workspaceService) {
        this.services.workspaceService = services.workspaceService;
      }
    } catch (error) {
    }
  }

  /**
   * Initialize search service
   */
  private async initializeSearchService(): Promise<void> {
    try {
      if (!this.services.hybridSearchService) {
        
        // Initialize with simplified JSON-based storage
        this.services.hybridSearchService = null; // Search service removed in simplified architecture
      } else {
      }
    } catch (error) {
    }
  }

  /**
   * Get service availability
   */
  getServiceAvailability(): ServiceAvailability {
    return {
      metadataSearch: !!this.services.metadataSearchService,
      hybridSearch: !!this.services.hybridSearchService,
      memory: !!this.services.memoryService,
      workspace: !!this.services.workspaceService
    };
  }

  /**
   * Get initialized services
   */
  getServices(): {
    metadataSearchService?: MetadataSearchService;
    hybridSearchService?: HybridSearchService;
    memoryService?: MemoryService;
    workspaceService?: WorkspaceService;
  } {
    return { ...this.services };
  }

  /**
   * Update a specific service
   */
  updateService(serviceName: string, service: any): void {
    switch (serviceName) {
      case 'memoryService':
        this.services.memoryService = service;
        break;
      case 'workspaceService':
        this.services.workspaceService = service;
        break;
    }
  }

  /**
   * Check if semantic search is available
   */
  isSemanticSearchAvailable(): boolean {
    return !!this.services.hybridSearchService && this.services.hybridSearchService.isSemanticSearchAvailable();
  }

  /**
   * Check if hybrid search is available
   */
  isHybridSearchAvailable(): boolean {
    return !!this.services.hybridSearchService;
  }

  /**
   * Populate hybrid search indexes
   */
  async populateHybridSearchIndexes(): Promise<{
    success: boolean;
    error?: string;
    indexesPopulated?: string[];
  }> {
    try {
      const indexesPopulated: string[] = [];

      // Populate search indexes if available
      if (this.services.hybridSearchService) {
        try {
          // Hybrid search doesn't need explicit population - it uses underlying services
          indexesPopulated.push('Hybrid');
        } catch (error) {
        }
      }

      return {
        success: true,
        indexesPopulated
      };
    } catch (error) {
      return {
        success: false,
        error: `Index population failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Get service diagnostics
   */
  async getServiceDiagnostics(): Promise<{
    services: ServiceAvailability;
    hybridIndexStatus?: string;
    metadataStats?: {
      totalTags: number;
      totalProperties: number;
    };
  }> {
    const diagnostics: any = {
      services: this.getServiceAvailability()
    };

    try {
      // Get search status
      if (this.services.hybridSearchService) {
        try {
          const hybridStats = this.services.hybridSearchService.getStats();
          diagnostics.hybridIndexStatus = `Ready with multiple indexes`;
        } catch (error) {
          diagnostics.hybridIndexStatus = 'Error getting stats';
        }
      }

      // Get metadata stats
      if (this.services.metadataSearchService) {
        try {
          const allTags = await this.services.metadataSearchService.getAllTags();
          const allProperties = await this.services.metadataSearchService.getAllPropertyKeys();
          diagnostics.metadataStats = {
            totalTags: allTags.length,
            totalProperties: allProperties.length
          };
        } catch (error) {
          diagnostics.metadataStats = { totalTags: 0, totalProperties: 0 };
        }
      }
    } catch (error) {
    }

    return diagnostics;
  }
}
```

## agents/vaultLibrarian/modes/services/universal/query/QueryParser.ts

```typescript
/**
 * QueryParser - Handles search query parsing and normalization
 * Follows Single Responsibility Principle by focusing only on query parsing
 */

// PropertyFilter removed in simplified architecture
type PropertyFilter = any;
import { UniversalSearchValidator } from '../validation/UniversalSearchValidator';

export interface ParsedSearchQuery {
  cleanQuery: string;
  tags: string[];
  properties: PropertyFilter[];
}

export interface QueryParsingResult {
  success: boolean;
  error?: string;
  parsed?: ParsedSearchQuery;
}

/**
 * Service responsible for parsing and normalizing search queries
 * Follows SRP by focusing only on query parsing operations
 */
export class QueryParser {
  private validator: UniversalSearchValidator;

  constructor() {
    this.validator = new UniversalSearchValidator();
  }
  /**
   * Parse search query into components
   */
  parseSearchQuery(query: string): QueryParsingResult {
    try {
      if (!query || typeof query !== 'string') {
        return {
          success: false,
          error: 'Query must be a non-empty string'
        };
      }

      const parsed: ParsedSearchQuery = {
        cleanQuery: query.trim(),
        tags: [],
        properties: []
      };

      // Extract tags (e.g., #tag1 #tag2)
      const tagMatches = query.match(/#[\w-]+/g);
      if (tagMatches) {
        parsed.tags = tagMatches.map(tag => tag.substring(1)); // Remove #
        // Remove tags from the clean query
        parsed.cleanQuery = parsed.cleanQuery.replace(/#[\w-]+/g, '').trim();
      }

      // Extract property filters (e.g., property:value)
      const propertyMatches = query.match(/(\w+):([^\s]+)/g);
      if (propertyMatches) {
        const context = this.validator.createValidationContext('QueryParser', 'parseSearchQuery', 'property_parsing');
        
        parsed.properties = propertyMatches.map(match => {
          // MEDIUM RISK FIX: Validate match before split() operation
          const validatedMatch = this.validator.validateQuery(match, context);
          
          if (validatedMatch.length === 0 || !validatedMatch.includes(':')) {
            return { key: '', value: '' };
          }
          
          // Now safe to split - guaranteed valid string
          const [key, value] = validatedMatch.split(':');
          return { key: key || '', value: value || '' };
        }).filter(prop => prop.key.length > 0); // Remove invalid properties
        
        // Remove property filters from the clean query
        parsed.cleanQuery = parsed.cleanQuery.replace(/\w+:[^\s]+/g, '').trim();
      }

      // Clean up extra whitespace
      parsed.cleanQuery = parsed.cleanQuery.replace(/\s+/g, ' ').trim();

      return {
        success: true,
        parsed
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to parse query: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Normalize query for search
   */
  normalizeQuery(query: string): string {
    return query.toLowerCase().trim();
  }

  /**
   * Extract search terms from query with validation to prevent split() errors
   */
  extractSearchTerms(query: string): string[] {
    const context = this.validator.createValidationContext('QueryParser', 'extractSearchTerms', 'term_extraction');
    
    // Validate query before normalization and split()
    const validatedQuery = this.validator.validateQuery(query, context);
    
    if (validatedQuery.length === 0) {
      return [];
    }
    
    const normalized = this.normalizeQuery(validatedQuery);
    
    // Validate normalized query as well (defensive programming)
    const validatedNormalized = this.validator.validateQuery(normalized, context);
    
    if (validatedNormalized.length === 0) {
      return [];
    }
    
    // Now safe to split - guaranteed valid string
    return validatedNormalized.split(/\s+/).filter(term => term.length > 0);
  }

  /**
   * Check if query contains advanced syntax
   */
  hasAdvancedSyntax(query: string): boolean {
    // Check for tags, properties, or other advanced syntax
    return /#[\w-]+/.test(query) || /\w+:[^\s]+/.test(query);
  }

  /**
   * Validate query format
   */
  validateQuery(query: string): {
    valid: boolean;
    error?: string;
  } {
    if (!query || typeof query !== 'string') {
      return {
        valid: false,
        error: 'Query must be a non-empty string'
      };
    }

    if (query.trim().length === 0) {
      return {
        valid: false,
        error: 'Query cannot be empty'
      };
    }

    if (query.length > 1000) {
      return {
        valid: false,
        error: 'Query too long (max 1000 characters)'
      };
    }

    return { valid: true };
  }

  /**
   * Extract quoted phrases from query
   */
  extractQuotedPhrases(query: string): {
    phrases: string[];
    cleanQuery: string;
  } {
    const phrases: string[] = [];
    let cleanQuery = query;

    // Extract quoted phrases
    const quotedMatches = query.match(/"([^"]+)"/g);
    if (quotedMatches) {
      quotedMatches.forEach(match => {
        const phrase = match.substring(1, match.length - 1); // Remove quotes
        phrases.push(phrase);
        cleanQuery = cleanQuery.replace(match, '').trim();
      });
    }

    return {
      phrases,
      cleanQuery: cleanQuery.replace(/\s+/g, ' ').trim()
    };
  }

  /**
   * Build search criteria from parsed query
   */
  buildSearchCriteria(parsed: ParsedSearchQuery): {
    hasMetadataFilters: boolean;
    hasContentQuery: boolean;
    metadataFilters: {
      tags: string[];
      properties: PropertyFilter[];
    };
    contentQuery: string;
  } {
    return {
      hasMetadataFilters: parsed.tags.length > 0 || parsed.properties.length > 0,
      hasContentQuery: parsed.cleanQuery.length > 0,
      metadataFilters: {
        tags: parsed.tags,
        properties: parsed.properties
      },
      contentQuery: parsed.cleanQuery
    };
  }

  /**
   * Get query statistics
   */
  getQueryStatistics(query: string): {
    originalLength: number;
    wordCount: number;
    tagCount: number;
    propertyCount: number;
    hasQuotedPhrases: boolean;
  } {
    const parseResult = this.parseSearchQuery(query);
    const quotedPhrases = this.extractQuotedPhrases(query);
    const words = this.extractSearchTerms(query);

    return {
      originalLength: query.length,
      wordCount: words.length,
      tagCount: parseResult.parsed?.tags.length || 0,
      propertyCount: parseResult.parsed?.properties.length || 0,
      hasQuotedPhrases: quotedPhrases.phrases.length > 0
    };
  }
}
```

## agents/vaultLibrarian/modes/services/universal/results/ResultConsolidator.ts

```typescript
/**
 * ResultConsolidator - Handles result consolidation by file
 * Follows Single Responsibility Principle by focusing only on result consolidation
 */

import { TFile } from 'obsidian';
import { UniversalSearchResultItem } from '../../../../types';
import { UniversalSearchValidator } from '../validation/UniversalSearchValidator';

export interface SearchSnippet {
  content: string;
  searchMethod: 'semantic' | 'keyword' | 'fuzzy' | 'exact' | 'hybrid';
  score: number;
}

export interface ConsolidatedSearchResult {
  filePath: string;
  frontmatter?: Record<string, any>;
  snippets: SearchSnippet[];
  connectedNotes: string[];
  bestScore: number;
  searchMethods: string[];
  metadata: Record<string, any>;
}

export interface ConsolidationResult {
  success: boolean;
  error?: string;
  results?: ConsolidatedSearchResult[];
}

/**
 * Service responsible for consolidating search results by file
 * Follows SRP by focusing only on result consolidation operations
 */
export class ResultConsolidator {
  private validator: UniversalSearchValidator;

  constructor() {
    this.validator = new UniversalSearchValidator();
  }
  /**
   * Consolidate search results by file path
   */
  async consolidateResultsByFile(
    results: UniversalSearchResultItem[],
    connectedNotesMap?: Map<string, string[]>
  ): Promise<ConsolidationResult> {
    try {
      if (!results || results.length === 0) {
        return {
          success: true,
          results: []
        };
      }

      // Group results by file path
      const fileGroups = new Map<string, UniversalSearchResultItem[]>();
      
      for (const result of results) {
        const filePath = result.metadata?.filePath || result.id;
        if (!fileGroups.has(filePath)) {
          fileGroups.set(filePath, []);
        }
        fileGroups.get(filePath)!.push(result);
      }

      // Consolidate each file group
      const consolidatedResults: ConsolidatedSearchResult[] = [];
      
      for (const [filePath, fileResults] of fileGroups) {
        const consolidated = this.consolidateFileResults(filePath, fileResults, connectedNotesMap);
        consolidatedResults.push(consolidated);
      }

      // Sort by best score
      consolidatedResults.sort((a, b) => b.bestScore - a.bestScore);

      return {
        success: true,
        results: consolidatedResults
      };
    } catch (error) {
      return {
        success: false,
        error: `Result consolidation failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Consolidate results for a single file
   */
  private consolidateFileResults(
    filePath: string,
    results: UniversalSearchResultItem[],
    connectedNotesMap?: Map<string, string[]>
  ): ConsolidatedSearchResult {
    // Extract snippets from results
    const snippets: SearchSnippet[] = results.map(result => ({
      content: result.snippet || '',
      searchMethod: result.searchMethod,
      score: result.score
    }));

    // Remove duplicate snippets
    const uniqueSnippets = this.removeDuplicateSnippets(snippets);

    // Get the best score
    const bestScore = Math.max(...results.map(r => r.score));

    // Get unique search methods
    const searchMethods = [...new Set(results.map(r => r.searchMethod))];

    // Combine metadata
    const metadata = this.combineMetadata(results);

    // Get connected notes
    const connectedNotes = connectedNotesMap?.get(filePath) || [];

    // Extract frontmatter if available
    const frontmatter = this.extractFrontmatter(results);

    return {
      filePath,
      frontmatter,
      snippets: uniqueSnippets,
      connectedNotes,
      bestScore,
      searchMethods,
      metadata
    };
  }

  /**
   * Remove duplicate snippets with validation to prevent split() errors
   */
  private removeDuplicateSnippets(snippets: SearchSnippet[]): SearchSnippet[] {
    const context = this.validator.createValidationContext('ResultConsolidator', 'removeDuplicateSnippets', 'content_validation');
    const seen = new Set<string>();
    const unique: SearchSnippet[] = [];

    for (const snippet of snippets) {
      // Validate content before string operations to prevent errors
      const validatedContent = this.validator.validateSnippetContent(snippet.content, context);
      
      if (validatedContent.length === 0) {
        continue;
      }
      
      // Safe to perform string operations - guaranteed valid string
      const key = validatedContent.toLowerCase().trim();
      
      if (key && !seen.has(key)) {
        seen.add(key);
        unique.push({
          ...snippet,
          content: validatedContent // Update with validated content
        });
      }
    }
    
    // Sort by score
    return unique.sort((a, b) => b.score - a.score);
  }

  /**
   * Combine metadata from multiple results
   */
  private combineMetadata(results: UniversalSearchResultItem[]): Record<string, any> {
    const combined: Record<string, any> = {};

    for (const result of results) {
      if (result.metadata) {
        Object.assign(combined, result.metadata);
      }
    }

    return combined;
  }

  /**
   * Extract frontmatter from results
   */
  private extractFrontmatter(results: UniversalSearchResultItem[]): Record<string, any> | undefined {
    for (const result of results) {
      if (result.metadata?.frontmatter) {
        return result.metadata.frontmatter;
      }
    }
    return undefined;
  }

  /**
   * Merge search results from different strategies
   */
  async mergeSearchResults(
    contentResults: UniversalSearchResultItem[],
    fileResults: UniversalSearchResultItem[],
    tagResults: UniversalSearchResultItem[],
    propertyResults: UniversalSearchResultItem[]
  ): Promise<ConsolidationResult> {
    try {
      // Combine all results
      const allResults = [
        ...contentResults,
        ...fileResults,
        ...tagResults,
        ...propertyResults
      ];

      // Remove duplicates based on ID
      const uniqueResults = this.removeDuplicateResults(allResults);

      // Consolidate by file
      return await this.consolidateResultsByFile(uniqueResults);
    } catch (error) {
      return {
        success: false,
        error: `Result merging failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Remove duplicate results based on ID
   */
  private removeDuplicateResults(results: UniversalSearchResultItem[]): UniversalSearchResultItem[] {
    const seen = new Set<string>();
    const unique: UniversalSearchResultItem[] = [];

    for (const result of results) {
      if (!seen.has(result.id)) {
        seen.add(result.id);
        unique.push(result);
      }
    }

    return unique;
  }

  /**
   * Apply diversity penalty to avoid too many results from the same file
   */
  applyDiversityPenalty(
    results: ConsolidatedSearchResult[],
    diversityPenalty = 0.1
  ): ConsolidatedSearchResult[] {
    // Track file count and apply penalty
    const fileCount = new Map<string, number>();
    
    return results.map(result => {
      const currentCount = fileCount.get(result.filePath) || 0;
      fileCount.set(result.filePath, currentCount + 1);
      
      // Apply penalty based on how many results we've seen from this file
      const penalty = currentCount * diversityPenalty;
      const adjustedScore = Math.max(0, result.bestScore - penalty);
      
      return {
        ...result,
        bestScore: adjustedScore
      };
    }).sort((a, b) => b.bestScore - a.bestScore);
  }

  /**
   * Filter results by minimum score
   */
  filterByMinScore(
    results: ConsolidatedSearchResult[],
    minScore = 0.1
  ): ConsolidatedSearchResult[] {
    return results.filter(result => result.bestScore >= minScore);
  }

  /**
   * Get consolidation statistics
   */
  getConsolidationStatistics(
    originalResults: UniversalSearchResultItem[],
    consolidatedResults: ConsolidatedSearchResult[]
  ): {
    originalCount: number;
    consolidatedCount: number;
    averageResultsPerFile: number;
    searchMethodsCovered: string[];
  } {
    const searchMethods = new Set<string>();
    let totalSnippets = 0;

    for (const result of consolidatedResults) {
      result.searchMethods.forEach(method => searchMethods.add(method));
      totalSnippets += result.snippets.length;
    }

    return {
      originalCount: originalResults.length,
      consolidatedCount: consolidatedResults.length,
      averageResultsPerFile: consolidatedResults.length > 0 ? totalSnippets / consolidatedResults.length : 0,
      searchMethodsCovered: Array.from(searchMethods)
    };
  }
}
```

## agents/vaultLibrarian/modes/services/universal/results/ResultFormatter.ts

```typescript
/**
 * ResultFormatter - Handles result formatting and presentation
 * Follows Single Responsibility Principle by focusing only on result formatting
 */

import { UniversalSearchResult, UniversalSearchResultItem, SearchResultCategory } from '../../../../types';
import { ConsolidatedSearchResult } from './ResultConsolidator';
import { UniversalSearchValidator } from '../validation/UniversalSearchValidator';

export interface FormattingOptions {
  includeSnippets?: boolean;
  maxSnippetLength?: number;
  includeMetadata?: boolean;
  includeConnectedNotes?: boolean;
  highlightQuery?: string;
}

export interface FormattingResult {
  success: boolean;
  error?: string;
  result?: UniversalSearchResult;
}

/**
 * Service responsible for formatting search results
 * Follows SRP by focusing only on result formatting operations
 */
export class ResultFormatter {
  private validator: UniversalSearchValidator;

  constructor() {
    this.validator = new UniversalSearchValidator();
  }
  /**
   * Format consolidated results into final universal search result
   */
  formatUniversalSearchResult(
    query: string,
    contentResults: UniversalSearchResultItem[],
    fileResults: UniversalSearchResultItem[],
    tagResults: UniversalSearchResultItem[],
    propertyResults: UniversalSearchResultItem[],
    executionTime: number,
    limit: number,
    semanticAvailable: boolean,
    options: FormattingOptions = {}
  ): FormattingResult {
    try {
      const totalResults = contentResults.length + fileResults.length + tagResults.length + propertyResults.length;

      // Apply formatting options
      const formattedContentResults = this.applyFormattingOptions(contentResults, options);
      const formattedFileResults = this.applyFormattingOptions(fileResults, options);
      const formattedTagResults = this.applyFormattingOptions(tagResults, options);
      const formattedPropertyResults = this.applyFormattingOptions(propertyResults, options);

      const result: UniversalSearchResult = {
        success: true,
        query,
        totalResults,
        executionTime,
        categories: {
          files: {
            count: formattedFileResults.length,
            results: formattedFileResults,
            hasMore: formattedFileResults.length >= limit,
            searchMethod: 'fuzzy',
            semanticAvailable
          },
          content: {
            count: formattedContentResults.length,
            results: formattedContentResults,
            hasMore: formattedContentResults.length >= limit,
            searchMethod: this.determineSearchMethod(formattedContentResults),
            semanticAvailable
          },
          tags: {
            count: formattedTagResults.length,
            results: formattedTagResults,
            hasMore: formattedTagResults.length >= limit,
            searchMethod: 'exact',
            semanticAvailable: false
          },
          properties: {
            count: formattedPropertyResults.length,
            results: formattedPropertyResults,
            hasMore: formattedPropertyResults.length >= limit,
            searchMethod: 'exact',
            semanticAvailable: false
          }
        },
        searchStrategy: {
          semanticAvailable,
          categoriesSearched: ['files', 'content', 'tags', 'properties'],
          categoriesExcluded: [],
          fallbacksUsed: []
        },
        contextPrompt: "To read the full content of multiple relevant files from these search results, consider using the ContentManager's batchContent mode with read operations. This allows you to efficiently gather complete context from the most promising files in a single request."
      };

      return {
        success: true,
        result
      };
    } catch (error) {
      return {
        success: false,
        error: `Result formatting failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Format consolidated results into universal search result
   */
  formatConsolidatedResult(
    query: string,
    consolidatedResults: ConsolidatedSearchResult[],
    executionTime: number,
    options: FormattingOptions = {}
  ): FormattingResult {
    try {
      // Convert consolidated results to universal search result items
      const allResults: UniversalSearchResultItem[] = [];

      for (const consolidated of consolidatedResults) {
        const item: UniversalSearchResultItem = {
          id: consolidated.filePath,
          title: this.extractTitle(consolidated.filePath),
          snippet: this.combineSnippets(consolidated.snippets, options),
          score: consolidated.bestScore,
          searchMethod: this.determineSearchMethodFromArray(consolidated.searchMethods),
          metadata: {
            ...consolidated.metadata,
            filePath: consolidated.filePath,
            searchMethods: consolidated.searchMethods,
            snippetCount: consolidated.snippets.length,
            connectedNotes: consolidated.connectedNotes,
            frontmatter: consolidated.frontmatter
          }
        };

        allResults.push(item);
      }

      // Format as universal search result
      const result: UniversalSearchResult = {
        success: true,
        query,
        totalResults: allResults.length,
        executionTime,
        categories: {
          content: {
            count: allResults.length,
            results: allResults,
            hasMore: false,
            searchMethod: 'hybrid',
            semanticAvailable: true
          },
          files: {
            count: 0,
            results: [],
            hasMore: false,
            searchMethod: 'fuzzy',
            semanticAvailable: true
          },
          tags: {
            count: 0,
            results: [],
            hasMore: false,
            searchMethod: 'exact',
            semanticAvailable: false
          },
          properties: {
            count: 0,
            results: [],
            hasMore: false,
            searchMethod: 'exact',
            semanticAvailable: false
          }
        },
        searchStrategy: {
          semanticAvailable: true,
          categoriesSearched: ['content'],
          categoriesExcluded: [],
          fallbacksUsed: []
        },
        contextPrompt: "To read the full content of multiple relevant files from these search results, consider using the ContentManager's batchContent mode with read operations. This allows you to efficiently gather complete context from the most promising files in a single request."
      };

      return {
        success: true,
        result
      };
    } catch (error) {
      return {
        success: false,
        error: `Consolidated result formatting failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Apply formatting options to results
   */
  private applyFormattingOptions(
    results: UniversalSearchResultItem[],
    options: FormattingOptions
  ): UniversalSearchResultItem[] {
    return results.map(result => {
      let formattedResult = { ...result };

      // Format snippet
      if (options.includeSnippets !== false && result.snippet) {
        formattedResult.snippet = this.formatSnippet(
          result.snippet,
          options.maxSnippetLength,
          options.highlightQuery
        );
      } else if (options.includeSnippets === false) {
        formattedResult.snippet = '';
      }

      // Handle metadata
      if (options.includeMetadata === false) {
        formattedResult.metadata = {};
      } else if (options.includeConnectedNotes === false && formattedResult.metadata) {
        const { connectedNotes, ...metadata } = formattedResult.metadata;
        formattedResult.metadata = metadata;
      }

      return formattedResult;
    });
  }

  /**
   * Format snippet text
   */
  private formatSnippet(
    snippet: string,
    maxLength?: number,
    highlightQuery?: string
  ): string {
    let formatted = snippet;

    // Truncate if needed
    if (maxLength && formatted.length > maxLength) {
      formatted = formatted.substring(0, maxLength) + '...';
    }

    // Highlight query terms
    if (highlightQuery) {
      formatted = this.highlightQueryTerms(formatted, highlightQuery);
    }

    return formatted;
  }

  /**
   * Highlight query terms in text with validation to prevent split() errors
   */
  private highlightQueryTerms(text: string, query: string): string {
    const context = this.validator.createValidationContext('ResultFormatter', 'highlightQueryTerms', 'query_validation');
    
    if (!text) return text;

    // Validate query parameter before string operations to prevent errors
    const validatedQuery = this.validator.validateQuery(query, context);
    
    if (validatedQuery.length === 0) {
      return text;
    }
    
    // Safe to perform string operations - guaranteed valid string
    const terms = validatedQuery.toLowerCase().split(/\s+/).filter(term => term.length > 0);
    let highlighted = text;

    for (const term of terms) {
      const regex = new RegExp(`(${this.escapeRegExp(term)})`, 'gi');
      highlighted = highlighted.replace(regex, '**$1**');
    }

    return highlighted;
  }

  /**
   * Escape special regex characters
   */
  private escapeRegExp(text: string): string {
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * Combine snippets into a single text with content validation
   */
  private combineSnippets(
    snippets: Array<{ content: string; searchMethod: string; score: number }>,
    options: FormattingOptions
  ): string {
    if (!snippets || snippets.length === 0) return '';

    const context = this.validator.createValidationContext('ResultFormatter', 'combineSnippets', 'content_validation');
    
    // Validate all snippet content to prevent undefined values in join()
    const validatedSnippets = this.validator.validateSnippetsArray(snippets, context);
    
    if (validatedSnippets.length === 0) {
      return '';
    }

    // Sort by score
    const sortedSnippets = validatedSnippets.sort((a, b) => b.score - a.score);

    // Take the best snippets
    const topSnippets = sortedSnippets.slice(0, 3);

    // Combine and format - now safe as all content is validated
    let combined = topSnippets.map(s => s.content).join(' ... ');

    // Apply length limit
    if (options.maxSnippetLength && combined.length > options.maxSnippetLength) {
      combined = combined.substring(0, options.maxSnippetLength) + '...';
    }

    return combined;
  }

  /**
   * Extract title from file path
   */
  private extractTitle(filePath: string): string {
    const lastSlash = filePath.lastIndexOf('/');
    const filename = lastSlash !== -1 ? filePath.substring(lastSlash + 1) : filePath;
    const lastDot = filename.lastIndexOf('.');
    return lastDot !== -1 ? filename.substring(0, lastDot) : filename;
  }

  /**
   * Determine search method from results
   */
  private determineSearchMethod(results: UniversalSearchResultItem[]): 'semantic' | 'fuzzy' | 'exact' | 'hybrid' {
    if (results.length === 0) return 'fuzzy';

    const methods = results.map(r => r.searchMethod);
    
    // Priority order: hybrid > semantic > fuzzy > exact
    if (methods.includes('hybrid')) return 'hybrid';
    if (methods.includes('semantic')) return 'semantic';
    if (methods.includes('fuzzy')) return 'fuzzy';
    return 'exact';
  }

  /**
   * Determine search method from array
   */
  private determineSearchMethodFromArray(methods: string[]): 'semantic' | 'fuzzy' | 'exact' | 'hybrid' {
    if (methods.includes('hybrid')) return 'hybrid';
    if (methods.includes('semantic')) return 'semantic';
    if (methods.includes('fuzzy')) return 'fuzzy';
    return 'exact';
  }

  /**
   * Create empty result
   */
  createEmptyResult(query: string, executionTime: number): UniversalSearchResult {
    return {
      success: true,
      query,
      totalResults: 0,
      executionTime,
      categories: {
        files: {
          count: 0,
          results: [],
          hasMore: false,
          searchMethod: 'fuzzy',
          semanticAvailable: false
        },
        content: {
          count: 0,
          results: [],
          hasMore: false,
          searchMethod: 'fuzzy',
          semanticAvailable: false
        },
        tags: {
          count: 0,
          results: [],
          hasMore: false,
          searchMethod: 'exact',
          semanticAvailable: false
        },
        properties: {
          count: 0,
          results: [],
          hasMore: false,
          searchMethod: 'exact',
          semanticAvailable: false
        }
      },
      searchStrategy: {
        semanticAvailable: false,
        categoriesSearched: [],
        categoriesExcluded: [],
        fallbacksUsed: []
      },
      contextPrompt: "To read the full content of multiple relevant files from these search results, consider using the ContentManager's batchContent mode with read operations. This allows you to efficiently gather complete context from the most promising files in a single request."
    };
  }

  /**
   * Create error result
   */
  createErrorResult(query: string, error: string): UniversalSearchResult {
    return {
      success: false,
      query,
      totalResults: 0,
      executionTime: 0,
      error,
      categories: {
        files: {
          count: 0,
          results: [],
          hasMore: false,
          searchMethod: 'fuzzy',
          semanticAvailable: false
        },
        content: {
          count: 0,
          results: [],
          hasMore: false,
          searchMethod: 'fuzzy',
          semanticAvailable: false
        },
        tags: {
          count: 0,
          results: [],
          hasMore: false,
          searchMethod: 'exact',
          semanticAvailable: false
        },
        properties: {
          count: 0,
          results: [],
          hasMore: false,
          searchMethod: 'exact',
          semanticAvailable: false
        }
      },
      searchStrategy: {
        semanticAvailable: false,
        categoriesSearched: [],
        categoriesExcluded: [],
        fallbacksUsed: []
      },
      contextPrompt: "To read the full content of multiple relevant files from these search results, consider using the ContentManager's batchContent mode with read operations. This allows you to efficiently gather complete context from the most promising files in a single request."
    };
  }
}
```

## agents/vaultLibrarian/modes/services/universal/strategies/ContentSearchStrategy.ts

```typescript
/**
 * ContentSearchStrategy - Handles content search
 * Follows Single Responsibility Principle by focusing only on content search
 */

import { TFile } from 'obsidian';
import { UniversalSearchParams, UniversalSearchResultItem } from '../../../../types';

export interface ContentSearchResult {
  success: boolean;
  error?: string;
  results?: UniversalSearchResultItem[];
  searchMethod?: 'keyword' | 'fuzzy';
}

/**
 * Service responsible for content search
 * Follows SRP by focusing only on content search operations
 */
export class ContentSearchStrategy {
  constructor() {}

  /**
   * Update services for runtime service injection (deprecated)
   */
  updateServices(): void {
    // No services needed for keyword-only search
  }

  /**
   * Search content using available search methods
   */
  async searchContent(
    query: string, 
    filteredFiles?: TFile[], 
    limit = 10, 
    params?: UniversalSearchParams
  ): Promise<ContentSearchResult> {
    const searchStartTime = performance.now();
    try {
      if (!query || query.trim().length === 0) {
        return {
          success: true,
          results: [],
          searchMethod: 'fuzzy'
        };
      }

      // Use keyword search (only available search method)
      const keywordResult = await this.performKeywordSearch(query, filteredFiles, limit);
      return keywordResult;
      
    } catch (error) {
      const totalSearchTime = performance.now() - searchStartTime;
      return {
        success: false,
        error: `Content search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }


  /**
   * Perform keyword search as fallback
   */
  private async performKeywordSearch(
    query: string, 
    filteredFiles?: TFile[], 
    limit = 10
  ): Promise<ContentSearchResult> {
    try {
      // Simple keyword search implementation
      // This is a basic fallback when no other search methods are available
      const results: UniversalSearchResultItem[] = [];
      
      // Note: In a real implementation, you would use Obsidian's search API
      // or implement a more sophisticated keyword search
      
      return {
        success: true,
        results,
        searchMethod: 'keyword'
      };
    } catch (error) {
      return {
        success: false,
        error: `Keyword search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Get search capabilities (keyword search only)
   */
  getSearchCapabilities(): {
    keyword: boolean;
  } {
    return {
      keyword: true // Always available
    };
  }

  /**
   * Analyze content retrieval statistics for monitoring full content implementation
   */
  private analyzeContentRetrieval(results: any[]): {
    totalResults: number;
    fullContentResults: number;
    snippetFallbacks: number;
    averageContentLength: number;
    estimatedPayloadIncrease: number;
  } {
    const totalResults = results.length;
    const fullContentResults = results.filter(r => r.content && r.content.length > 0).length;
    const snippetFallbacks = totalResults - fullContentResults;
    
    // Calculate average content lengths
    const contentLengths = results
      .filter(r => r.content)
      .map(r => r.content.length);
    const averageContentLength = contentLengths.length > 0 
      ? Math.round(contentLengths.reduce((sum, len) => sum + len, 0) / contentLengths.length)
      : 0;
    
    // Estimate payload increase compared to 150-char snippets
    const fullContentSize = contentLengths.reduce((sum, len) => sum + len, 0);
    const snippetEquivalentSize = totalResults * 150; // Previous 150-char limit
    const estimatedPayloadIncrease = snippetEquivalentSize > 0 
      ? Math.round((fullContentSize / snippetEquivalentSize) * 100) / 100
      : 0;
    
    return {
      totalResults,
      fullContentResults,
      snippetFallbacks,
      averageContentLength,
      estimatedPayloadIncrease
    };
  }

  /**
   * Content Validation Framework - Prevents "Cannot read properties of undefined (reading 'split')" errors
   * Implements comprehensive type-safe content field processing with minimal performance overhead
   */
  private validateAndSanitizeContent(
    primaryContent: any,
    fallbackSnippet: any,
    fallbackPreview: any
  ): string {
    // Stage 1: Try primary content with comprehensive validation
    if (this.isValidStringContent(primaryContent)) {
      const sanitized = this.sanitizeContent(primaryContent);
      return sanitized;
    }
    
    // Stage 2: Try fallback snippet
    if (this.isValidStringContent(fallbackSnippet)) {
      const sanitized = this.sanitizeContent(fallbackSnippet);
      return sanitized;
    }
    
    // Stage 3: Try fallback preview
    if (this.isValidStringContent(fallbackPreview)) {
      const sanitized = this.sanitizeContent(fallbackPreview);
      return sanitized;
    }
    
    // Stage 4: Safe empty string fallback
    return '';
  }

  /**
   * Type guard with comprehensive string content validation
   * Ensures the content is a valid string with required methods available
   */
  private isValidStringContent(content: any): content is string {
    const isValid = (
      typeof content === 'string' &&
      content !== null &&
      content !== undefined &&
      // Ensure string methods are available (defensive programming)
      typeof content.split === 'function' &&
      typeof content.toLowerCase === 'function' &&
      typeof content.startsWith === 'function'
    );
    
    return isValid;
  }

  /**
   * Content sanitization with safety checks and error prevention
   * Removes problematic characters that might break downstream processing
   */
  private sanitizeContent(content: string): string {
    // Basic safety checks
    if (content.length === 0) {
      return '';
    }
    
    // Hard limit to prevent memory issues
    if (content.length > 50000) {
      content = content.substring(0, 50000) + '...';
    }
    
    // Remove problematic characters that might break processing
    const sanitized = content
      .replace(/\0/g, '') // Remove null bytes
      .replace(/[\x00-\x1F\x7F]/g, ' ') // Replace control characters with spaces
      .trim();
    
    return sanitized;
  }

  // Note: updateServices method defined above (line 29)
}
```

## agents/vaultLibrarian/modes/services/universal/strategies/FileSearchStrategy.ts

```typescript
/**
 * FileSearchStrategy - Handles file name search
 * Follows Single Responsibility Principle by focusing only on file search
 */

import { Plugin, TFile, prepareFuzzySearch } from 'obsidian';
import { UniversalSearchResultItem } from '../../../../types';

export interface FileSearchResult {
  success: boolean;
  error?: string;
  results?: UniversalSearchResultItem[];
}

/**
 * Service responsible for file name search
 * Follows SRP by focusing only on file search operations
 */
export class FileSearchStrategy {
  constructor(private plugin: Plugin) {}

  /**
   * Search files by name using fuzzy search
   */
  async searchFiles(query: string, limit = 10): Promise<FileSearchResult> {
    try {
      if (!query || query.trim().length === 0) {
        return {
          success: true,
          results: []
        };
      }

      const normalizedQuery = query.toLowerCase().trim();
      
      // Get all files
      const allFiles = this.plugin.app.vault.getMarkdownFiles();
      
      // Use Obsidian's fuzzy search for file names
      const fuzzySearch = prepareFuzzySearch(normalizedQuery);
      const matchedFiles: Array<{ file: TFile; score: number }> = [];

      for (const file of allFiles) {
        const filename = file.basename;
        const result = fuzzySearch(filename);
        
        if (result) {
          matchedFiles.push({
            file,
            score: result.score
          });
        }
      }

      // Sort by score (higher is better for fuzzy search)
      matchedFiles.sort((a, b) => b.score - a.score);

      // Take top results and format
      const results = matchedFiles.slice(0, limit).map(({ file, score }) => ({
        id: file.path,
        title: file.basename,
        snippet: `File: ${file.path}`,
        score: this.normalizeScore(score),
        searchMethod: 'fuzzy' as const,
        metadata: {
          filePath: file.path,
          type: 'file',
          searchMethod: 'fuzzy',
          originalScore: score,
          fileExtension: file.extension,
          parentFolder: file.parent?.path || ''
        }
      }));

      return {
        success: true,
        results
      };
    } catch (error) {
      return {
        success: false,
        error: `File search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Search files by path
   */
  async searchFilesByPath(query: string, limit = 10): Promise<FileSearchResult> {
    try {
      if (!query || query.trim().length === 0) {
        return {
          success: true,
          results: []
        };
      }

      const normalizedQuery = query.toLowerCase().trim();
      const allFiles = this.plugin.app.vault.getMarkdownFiles();
      const matchedFiles: Array<{ file: TFile; score: number }> = [];

      for (const file of allFiles) {
        const filePath = file.path.toLowerCase();
        
        if (filePath.includes(normalizedQuery)) {
          // Calculate score based on position and exactness
          const index = filePath.indexOf(normalizedQuery);
          const exactMatch = filePath === normalizedQuery;
          const startsWithMatch = filePath.startsWith(normalizedQuery);
          
          let score = 0.5; // Base score
          if (exactMatch) score = 1.0;
          else if (startsWithMatch) score = 0.8;
          else if (index === 0) score = 0.7;
          else score = Math.max(0.1, 0.5 - (index / filePath.length));

          matchedFiles.push({ file, score });
        }
      }

      // Sort by score
      matchedFiles.sort((a, b) => b.score - a.score);

      // Take top results and format
      const results = matchedFiles.slice(0, limit).map(({ file, score }) => ({
        id: file.path,
        title: file.basename,
        snippet: `Path: ${file.path}`,
        score,
        searchMethod: 'exact' as const,
        metadata: {
          filePath: file.path,
          type: 'file',
          searchMethod: 'path',
          fileExtension: file.extension,
          parentFolder: file.parent?.path || ''
        }
      }));

      return {
        success: true,
        results
      };
    } catch (error) {
      return {
        success: false,
        error: `File path search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Search files by extension
   */
  async searchFilesByExtension(extension: string, limit = 10): Promise<FileSearchResult> {
    try {
      if (!extension || extension.trim().length === 0) {
        return {
          success: true,
          results: []
        };
      }

      const normalizedExtension = extension.toLowerCase().replace(/^\./, ''); // Remove leading dot
      const allFiles = this.plugin.app.vault.getAllLoadedFiles();
      const matchedFiles: TFile[] = [];

      for (const file of allFiles) {
        if (file instanceof TFile && file.extension === normalizedExtension) {
          matchedFiles.push(file);
        }
      }

      // Sort by name
      matchedFiles.sort((a, b) => a.basename.localeCompare(b.basename));

      // Take top results and format
      const results = matchedFiles.slice(0, limit).map(file => ({
        id: file.path,
        title: file.basename,
        snippet: `${file.extension.toUpperCase()} file: ${file.path}`,
        score: 0.8,
        searchMethod: 'exact' as const,
        metadata: {
          filePath: file.path,
          type: 'file',
          searchMethod: 'extension',
          fileExtension: file.extension,
          parentFolder: file.parent?.path || ''
        }
      }));

      return {
        success: true,
        results
      };
    } catch (error) {
      return {
        success: false,
        error: `Extension search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Get recently modified files
   */
  async getRecentFiles(limit = 10): Promise<FileSearchResult> {
    try {
      const allFiles = this.plugin.app.vault.getMarkdownFiles();
      
      // Sort by modification time (newest first)
      const sortedFiles = allFiles.sort((a, b) => b.stat.mtime - a.stat.mtime);

      // Take top results and format
      const results = sortedFiles.slice(0, limit).map(file => ({
        id: file.path,
        title: file.basename,
        snippet: `Modified: ${new Date(file.stat.mtime).toLocaleString()}`,
        score: 0.9,
        searchMethod: 'exact' as const,
        metadata: {
          filePath: file.path,
          type: 'file',
          searchMethod: 'recent',
          fileExtension: file.extension,
          parentFolder: file.parent?.path || '',
          modifiedTime: file.stat.mtime,
          createdTime: file.stat.ctime
        }
      }));

      return {
        success: true,
        results
      };
    } catch (error) {
      return {
        success: false,
        error: `Recent files search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Normalize fuzzy search score to 0-1 range
   */
  private normalizeScore(fuzzyScore: number): number {
    // Fuzzy search scores are negative (closer to 0 is better)
    // Convert to 0-1 range where 1 is best
    return Math.max(0, Math.min(1, 1 + (fuzzyScore / 100)));
  }

  /**
   * Get file statistics
   */
  async getFileStatistics(): Promise<{
    totalFiles: number;
    markdownFiles: number;
    otherFiles: number;
    extensions: Record<string, number>;
  }> {
    try {
      const allFiles = this.plugin.app.vault.getAllLoadedFiles();
      const markdownFiles = this.plugin.app.vault.getMarkdownFiles();
      const extensions: Record<string, number> = {};

      for (const file of allFiles) {
        if (file instanceof TFile) {
          extensions[file.extension] = (extensions[file.extension] || 0) + 1;
        }
      }

      return {
        totalFiles: allFiles.length,
        markdownFiles: markdownFiles.length,
        otherFiles: allFiles.length - markdownFiles.length,
        extensions
      };
    } catch (error) {
      return {
        totalFiles: 0,
        markdownFiles: 0,
        otherFiles: 0,
        extensions: {}
      };
    }
  }
}
```

## agents/vaultLibrarian/modes/services/universal/strategies/MetadataSearchStrategy.ts

```typescript
/**
 * MetadataSearchStrategy - Handles tag and property search
 * Follows Single Responsibility Principle by focusing only on metadata search
 */

import { Plugin, getAllTags } from 'obsidian';
// MetadataSearchService removed in simplified architecture
type MetadataSearchService = any;
import { UniversalSearchResultItem } from '../../../../types';

export interface MetadataSearchResult {
  success: boolean;
  error?: string;
  results?: UniversalSearchResultItem[];
}

/**
 * Service responsible for metadata search (tags and properties)
 * Follows SRP by focusing only on metadata search operations
 */
export class MetadataSearchStrategy {
  constructor(
    private plugin: Plugin,
    private metadataSearchService: MetadataSearchService
  ) {}

  /**
   * Search tags
   */
  async searchTags(query: string, limit = 10): Promise<MetadataSearchResult> {
    try {
      if (!query || query.trim().length === 0) {
        return {
          success: true,
          results: []
        };
      }

      const normalizedQuery = query.toLowerCase().trim();
      
      // Get all tags from the vault
      const allTags = getAllTags(this.plugin.app.metadataCache as any);
      
      if (!allTags || Object.keys(allTags).length === 0) {
        return {
          success: true,
          results: []
        };
      }

      // Ensure allTags is treated as Record<string, number>
      const tagsRecord = allTags as unknown as Record<string, number>;
      
      // Filter tags that match the query
      const matchingTags = Object.keys(tagsRecord)
        .filter(tag => tag.toLowerCase().includes(normalizedQuery))
        .slice(0, limit);

      const results = matchingTags.map(tag => ({
        id: `tag:${tag}`,
        title: `#${tag}`,
        snippet: `Tag: #${tag}`,
        score: tag.toLowerCase() === normalizedQuery ? 1.0 : 0.8,
        searchMethod: 'exact' as const,
        metadata: {
          tagName: tag,
          type: 'tag',
          searchMethod: 'exact',
          usageCount: tagsRecord[tag] || 0
        }
      }));

      return {
        success: true,
        results
      };
    } catch (error) {
      return {
        success: false,
        error: `Tag search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Search properties
   */
  async searchProperties(query: string, limit = 10): Promise<MetadataSearchResult> {
    try {
      if (!query || query.trim().length === 0) {
        return {
          success: true,
          results: []
        };
      }

      const normalizedQuery = query.toLowerCase().trim();
      const allPropertyKeys = await this.metadataSearchService.getAllPropertyKeys();
      
      const matchingProperties = allPropertyKeys
        .filter((key: string) => key.toLowerCase().includes(normalizedQuery))
        .slice(0, limit);

      const results = matchingProperties.map((key: any) => ({
        id: `property:${key}`,
        title: key,
        snippet: `Property: ${key}`,
        score: key.toLowerCase() === normalizedQuery ? 1.0 : 0.8,
        searchMethod: 'exact' as const,
        metadata: {
          propertyKey: key,
          type: 'property',
          searchMethod: 'exact'
        }
      }));

      return {
        success: true,
        results
      };
    } catch (error) {
      return {
        success: false,
        error: `Property search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Search property values
   */
  async searchPropertyValues(propertyKey: string, query: string, limit = 10): Promise<MetadataSearchResult> {
    try {
      if (!propertyKey || !query || query.trim().length === 0) {
        return {
          success: true,
          results: []
        };
      }

      const normalizedQuery = query.toLowerCase().trim();
      const allPropertyValues = await this.metadataSearchService.getPropertyValues(propertyKey);
      
      const matchingValues = allPropertyValues
        .filter((value: any) => String(value).toLowerCase().includes(normalizedQuery))
        .slice(0, limit);

      const results = matchingValues.map((value: any) => ({
        id: `property-value:${propertyKey}:${value}`,
        title: `${propertyKey}: ${value}`,
        snippet: `Property value: ${propertyKey} = ${value}`,
        score: String(value).toLowerCase() === normalizedQuery ? 1.0 : 0.8,
        searchMethod: 'exact' as const,
        metadata: {
          propertyKey,
          propertyValue: value,
          type: 'property-value',
          searchMethod: 'exact'
        }
      }));

      return {
        success: true,
        results
      };
    } catch (error) {
      return {
        success: false,
        error: `Property value search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Get popular tags
   */
  async getPopularTags(limit = 10): Promise<MetadataSearchResult> {
    try {
      const allTags = getAllTags(this.plugin.app.metadataCache as any);
      
      if (!allTags || Object.keys(allTags).length === 0) {
        return {
          success: true,
          results: []
        };
      }

      // Ensure allTags is treated as Record<string, number>
      const tagsRecord = allTags as unknown as Record<string, number>;
      
      // Sort tags by usage count
      const sortedTags = Object.entries(tagsRecord)
        .sort(([, a], [, b]) => b - a)
        .slice(0, limit);

      const results = sortedTags.map(([tag, count]) => ({
        id: `tag:${tag}`,
        title: `#${tag}`,
        snippet: `Tag: #${tag} (used ${count} times)`,
        score: Math.min(1.0, count / 10), // Normalize based on usage
        searchMethod: 'exact' as const,
        metadata: {
          tagName: tag,
          type: 'tag',
          searchMethod: 'popular',
          usageCount: count
        }
      }));

      return {
        success: true,
        results
      };
    } catch (error) {
      return {
        success: false,
        error: `Popular tags search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Get recently used tags
   */
  async getRecentTags(limit = 10): Promise<MetadataSearchResult> {
    try {
      // This is a simplified version - in a full implementation,
      // you would track tag usage timestamps
      const allTags = getAllTags(this.plugin.app.metadataCache as any);
      
      if (!allTags || Object.keys(allTags).length === 0) {
        return {
          success: true,
          results: []
        };
      }

      // Ensure allTags is treated as Record<string, number>
      const tagsRecord = allTags as unknown as Record<string, number>;
      
      // For now, just return tags sorted alphabetically
      const sortedTags = Object.keys(tagsRecord)
        .sort()
        .slice(0, limit);

      const results = sortedTags.map(tag => ({
        id: `tag:${tag}`,
        title: `#${tag}`,
        snippet: `Tag: #${tag}`,
        score: 0.8,
        searchMethod: 'exact' as const,
        metadata: {
          tagName: tag,
          type: 'tag',
          searchMethod: 'recent',
          usageCount: tagsRecord[tag] || 0
        }
      }));

      return {
        success: true,
        results
      };
    } catch (error) {
      return {
        success: false,
        error: `Recent tags search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Get metadata statistics
   */
  async getMetadataStatistics(): Promise<{
    totalTags: number;
    totalProperties: number;
    mostUsedTags: Array<{ tag: string; count: number }>;
    allPropertyKeys: string[];
  }> {
    try {
      const allTags = getAllTags(this.plugin.app.metadataCache as any);
      const allPropertyKeys = await this.metadataSearchService.getAllPropertyKeys();

      // Ensure allTags is treated as Record<string, number>
      const tagsRecord = (allTags as unknown as Record<string, number>) || {};
      
      // Get most used tags
      const mostUsedTags = Object.entries(tagsRecord)
        .sort(([, a], [, b]) => b - a)
        .slice(0, 10)
        .map(([tag, count]) => ({ tag, count }));

      return {
        totalTags: Object.keys(tagsRecord).length,
        totalProperties: allPropertyKeys.length,
        mostUsedTags,
        allPropertyKeys
      };
    } catch (error) {
      return {
        totalTags: 0,
        totalProperties: 0,
        mostUsedTags: [],
        allPropertyKeys: []
      };
    }
  }

  /**
   * Search both tags and properties
   */
  async searchMetadata(query: string, limit = 10): Promise<MetadataSearchResult> {
    try {
      const [tagResults, propertyResults] = await Promise.all([
        this.searchTags(query, Math.ceil(limit / 2)),
        this.searchProperties(query, Math.ceil(limit / 2))
      ]);

      if (!tagResults.success || !propertyResults.success) {
        return {
          success: false,
          error: `Metadata search failed: ${tagResults.error || propertyResults.error}`
        };
      }

      // Combine and sort results
      const allResults = [
        ...(tagResults.results || []),
        ...(propertyResults.results || [])
      ].sort((a, b) => b.score - a.score);

      return {
        success: true,
        results: allResults.slice(0, limit)
      };
    } catch (error) {
      return {
        success: false,
        error: `Metadata search failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
}
```

## agents/vaultLibrarian/modes/services/universal/validation/UniversalSearchValidator.ts

```typescript
/**
 * UniversalSearchValidator - Core validation engine for universal search pipeline
 * 
 * Provides comprehensive validation to prevent split() errors and other string operation
 * failures throughout the universal search processing pipeline.
 * 
 * Design Principles:
 * - Defense in Depth: Multiple validation layers at component boundaries
 * - Fail-Safe Design: Graceful degradation when validation fails
 * - Performance First: Minimal overhead validation with smart caching
 * - Framework Integration: Seamless extension of existing validation patterns
 */

import { ValidationErrorMonitor, ValidationError, globalValidationErrorMonitor } from './ValidationErrorMonitor';

export interface ValidationResult<T> {
  isValid: boolean;
  data: T | null;
  errors: string[];
}

export interface ValidationContext {
  stage: string;
  component: string;
  operation: string;
}

/**
 * Comprehensive validation service for universal search components
 * Prevents undefined/null values from reaching string operations like split(), toLowerCase(), etc.
 */
export class UniversalSearchValidator {
  private validationCache = new Map<string, { result: string; timestamp: number }>();
  private readonly CACHE_SIZE_LIMIT = 1000;
  private readonly CACHE_TTL = 300000; // 5 minutes
  private errorMonitor: ValidationErrorMonitor;

  constructor(errorMonitor?: ValidationErrorMonitor) {
    this.errorMonitor = errorMonitor || globalValidationErrorMonitor;
  }

  /**
   * Validate query parameter with comprehensive type checking
   * Critical for preventing split() errors in ResultFormatter.highlightQueryTerms()
   */
  validateQuery(query: unknown, context?: ValidationContext): string {
    const contextInfo = context ? `[${context.component}:${context.stage}]` : '[QUERY_VALIDATION]';
    
    try {
      // Fast path for valid strings
      if (typeof query === 'string' && query.trim().length > 0) {
        
        // Record successful validation
        if (context) {
          this.errorMonitor.recordValidationSuccess(context.component, context.stage, context.operation);
        }
        
        return query.trim();
      }
      
      // Handle edge cases with defensive conversions
      if (query === null || query === undefined) {
        
        // Record validation error for monitoring
        if (context) {
          this.errorMonitor.recordValidationError(ValidationErrorMonitor.createError(
            context.component,
            context.stage,
            context.operation,
            'null_undefined',
            'high',
            query,
            'string',
            'Used empty string fallback'
          ));
        }
        
        return '';
      }
      
      // Convert numeric/boolean values safely
      if (typeof query === 'number' || typeof query === 'boolean') {
        const converted = String(query);
        return converted;
      }
      
      // Handle objects/arrays safely
      if (typeof query === 'object') {
        return '';
      }
      
      // Fallback for other types
      return '';
      
    } catch (error) {
      return '';
    }
  }

  /**
   * Validate snippet content with integration to existing ContentSearchStrategy validation
   * Critical for preventing toLowerCase() errors in ResultConsolidator.removeDuplicateSnippets()
   */
  validateSnippetContent(content: unknown, context?: ValidationContext): string {
    const contextInfo = context ? `[${context.component}:${context.stage}]` : '[CONTENT_VALIDATION]';
    
    try {
      // Use existing validation patterns from ContentSearchStrategy
      if (this.isValidStringContent(content)) {
        const sanitized = this.sanitizeContent(content as string);
        return sanitized;
      }
      
      // Handle edge cases
      if (content === null || content === undefined) {
        return '';
      }
      
      // Convert other types safely
      if (typeof content === 'number' || typeof content === 'boolean') {
        const converted = String(content);
        return this.sanitizeContent(converted);
      }
      
      // Handle objects that might have useful content
      if (typeof content === 'object' && content !== null) {
        // Try to extract meaningful content from objects
        const obj = content as any;
        if (obj.content && typeof obj.content === 'string') {
          return this.validateSnippetContent(obj.content, context);
        }
        if (obj.text && typeof obj.text === 'string') {
          return this.validateSnippetContent(obj.text, context);
        }
        if (obj.snippet && typeof obj.snippet === 'string') {
          return this.validateSnippetContent(obj.snippet, context);
        }
      }
      
      return '';
      
    } catch (error) {
      return '';
    }
  }

  /**
   * Validate search result objects with comprehensive structure checking
   * Ensures all required fields are present and valid
   */
  validateSearchResult(result: unknown, context?: ValidationContext): ValidationResult<any> {
    const contextInfo = context ? `[${context.component}:${context.stage}]` : '[RESULT_VALIDATION]';
    
    try {
      if (typeof result !== 'object' || result === null) {
        return {
          isValid: false,
          errors: [`Result must be an object, got ${typeof result}`],
          data: null
        };
      }
      
      const r = result as any;
      const errors: string[] = [];
      
      // Validate required fields
      if (!r.id || typeof r.id !== 'string') {
        errors.push('Result must have valid id string');
      }
      
      // Validate snippet content (critical for preventing string operation errors)
      const validatedContent = this.validateSnippetContent(r.snippet, context);
      
      // Validate score
      if (typeof r.score !== 'number' || isNaN(r.score)) {
        errors.push('Result must have valid numeric score');
      }
      
      if (errors.length > 0) {
        return { isValid: false, errors, data: null };
      }
      
      // Return sanitized result
      const sanitizedResult = {
        ...r,
        snippet: validatedContent,
        score: isNaN(r.score) ? 0 : Math.max(0, Math.min(1, r.score))
      };
      
      return { isValid: true, data: sanitizedResult, errors: [] };
      
    } catch (error) {
      return {
        isValid: false,
        errors: [`Validation error: ${error instanceof Error ? error.message : String(error)}`],
        data: null
      };
    }
  }

  /**
   * Validate query type parameter
   */
  validateQueryType(queryType: unknown): ValidationResult<string> {
    const validTypes = ['exact', 'mixed', 'conceptual', 'exploratory'];
    
    if (typeof queryType === 'string' && validTypes.includes(queryType)) {
      return { isValid: true, data: queryType, errors: [] };
    }
    
    // Default fallback
    return { isValid: true, data: 'mixed', errors: ['Invalid queryType, using default: mixed'] };
  }

  /**
   * Validate array of snippets with individual content validation
   * Used by ResultConsolidator to ensure all snippet content is safe
   */
  validateSnippetsArray(snippets: unknown, context?: ValidationContext): Array<{ content: string; searchMethod: string; score: number }> {
    const contextInfo = context ? `[${context.component}:${context.stage}]` : '[SNIPPETS_VALIDATION]';
    
    if (!Array.isArray(snippets)) {
      return [];
    }
    
    const validatedSnippets: Array<{ content: string; searchMethod: string; score: number }> = [];
    
    for (let i = 0; i < snippets.length; i++) {
      const snippet = snippets[i];
      
      if (typeof snippet !== 'object' || snippet === null) {
        continue;
      }
      
      const s = snippet as any;
      
      // Validate and sanitize content (critical for preventing split() errors)
      const validatedContent = this.validateSnippetContent(s.content, context);
      
      // Skip empty content snippets
      if (validatedContent.length === 0) {
        continue;
      }
      
      validatedSnippets.push({
        content: validatedContent,
        searchMethod: typeof s.searchMethod === 'string' ? s.searchMethod : 'unknown',
        score: typeof s.score === 'number' && !isNaN(s.score) ? s.score : 0
      });
    }
    
    return validatedSnippets;
  }

  /**
   * Create validation context for error tracking and logging
   */
  createValidationContext(component: string, stage: string, operation: string = 'unknown'): ValidationContext {
    return { component, stage, operation };
  }

  /**
   * Type guard with comprehensive string content validation
   * Based on existing ContentSearchStrategy validation patterns
   */
  private isValidStringContent(content: any): content is string {
    return (
      typeof content === 'string' &&
      content !== null &&
      content !== undefined &&
      // Ensure string methods are available (defensive programming)
      typeof content.split === 'function' &&
      typeof content.toLowerCase === 'function' &&
      typeof content.trim === 'function'
    );
  }

  /**
   * Content sanitization with safety checks
   * Based on existing ContentSearchStrategy sanitization patterns
   */
  private sanitizeContent(content: string): string {
    // Basic safety checks
    if (content.length === 0) {
      return '';
    }
    
    // Hard limit to prevent memory issues
    if (content.length > 50000) {
      content = content.substring(0, 50000) + '...';
    }
    
    // Remove problematic characters that might break processing
    const sanitized = content
      .replace(/\0/g, '') // Remove null bytes
      .replace(/[\x00-\x1F\x7F]/g, ' ') // Replace control characters with spaces
      .trim();
    
    return sanitized;
  }

  /**
   * Cache validation results for performance optimization
   */
  private validateWithCache(key: string, validator: () => string): string {
    // Check cache first
    const cached = this.validationCache.get(key);
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      return cached.result;
    }
    
    // Perform validation
    const result = validator();
    
    // Cache management
    if (this.validationCache.size >= this.CACHE_SIZE_LIMIT) {
      this.evictOldestEntries();
    }
    
    this.validationCache.set(key, {
      result,
      timestamp: Date.now()
    });
    
    return result;
  }

  /**
   * Evict oldest cache entries to maintain size limit
   */
  private evictOldestEntries(): void {
    const entries = Array.from(this.validationCache.entries());
    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
    
    // Remove oldest 25% of entries
    const removeCount = Math.floor(entries.length * 0.25);
    for (let i = 0; i < removeCount; i++) {
      this.validationCache.delete(entries[i][0]);
    }
  }

  /**
   * Validate file path with comprehensive type checking
   * Critical for preventing split() errors in display operations like SearchMode.execute
   */
  validateFilePath(filePath: unknown, context?: ValidationContext): string {
    const contextInfo = context ? `[${context.component}:${context.operation}]` : '[FILEPATH_VALIDATION]';
    const startTime = performance.now();
    
    try {
      // Fast path for valid strings
      if (typeof filePath === 'string' && filePath.trim().length > 0) {
        
        // Record successful validation
        if (context) {
          this.errorMonitor.recordValidationSuccess(context.component, context.stage, context.operation);
        }
        
        return filePath.trim();
      }
      
      // Handle null/undefined cases
      if (filePath === null || filePath === undefined) {
        
        // Record validation error for monitoring
        if (context) {
          this.errorMonitor.recordValidationError(ValidationErrorMonitor.createError(
            context.component,
            context.stage,
            context.operation,
            'null_undefined',
            'medium',
            filePath,
            'string',
            'Used unknown-file fallback for display'
          ));
        }
        
        return 'unknown-file';
      }
      
      // Handle empty string cases
      if (typeof filePath === 'string' && filePath.trim().length === 0) {
        
        if (context) {
          this.errorMonitor.recordValidationError(ValidationErrorMonitor.createError(
            context.component,
            context.stage,
            context.operation,
            'invalid_structure',
            'medium',
            filePath,
            'string',
            'Used untitled-file fallback for display'
          ));
        }
        
        return 'untitled-file';
      }
      
      // Handle non-string types
      if (typeof filePath !== 'string') {
        
        if (context) {
          this.errorMonitor.recordValidationError(ValidationErrorMonitor.createError(
            context.component,
            context.stage,
            context.operation,
            'type_mismatch',
            'medium',
            filePath,
            'string',
            `Invalid type ${typeof filePath}, used fallback`
          ));
        }
        
        return `invalid-file-${typeof filePath}`;
      }
      
      // Fallback for any other edge cases
      return 'unknown-file';
      
    } catch (error) {
      
      if (context) {
        this.errorMonitor.recordValidationError(ValidationErrorMonitor.createError(
          context.component,
          context.stage,
          context.operation,
          'validation_failure',
          'high',
          filePath,
          'string',
          `Validation error: ${error instanceof Error ? error.message : String(error)}`
        ));
      }
      
      return 'error-file';
    } finally {
      // Record performance metrics
      const validationTime = performance.now() - startTime;
      if (context && validationTime > 1) { // Only log if validation took >1ms
      }
    }
  }

  /**
   * Get validation cache statistics for monitoring
   */
  getCacheStats(): { size: number; hitRate: number; memoryUsage: number } {
    // Simple cache statistics
    return {
      size: this.validationCache.size,
      hitRate: 0.8, // Placeholder - would need actual tracking
      memoryUsage: this.validationCache.size * 100 // Rough estimate
    };
  }
}
```

## agents/vaultLibrarian/modes/services/universal/validation/ValidationErrorMonitor.ts

```typescript
/**
 * ValidationErrorMonitor - Comprehensive error monitoring for universal search validation
 * 
 * Provides error tracking, monitoring, and analytics for validation failures
 * throughout the universal search pipeline.
 */

export interface ValidationError {
  component: string;
  stage: string;
  operation: string;
  errorType: 'type_mismatch' | 'null_undefined' | 'invalid_structure' | 'validation_failure';
  severity: 'low' | 'medium' | 'high' | 'critical';
  input: unknown;
  expectedType: string;
  actualType: string;
  timestamp: number;
  recoveryAction: string;
  stackTrace?: string;
}

export interface ValidationErrorSummary {
  totalErrors: number;
  criticalErrors: number;
  errorsByComponent: Record<string, number>;
  errorsByType: Record<string, number>;
  recentErrors: ValidationError[];
  lastErrorTime: number;
}

/**
 * Monitors and tracks validation errors throughout universal search processing
 */
export class ValidationErrorMonitor {
  private errors: ValidationError[] = [];
  private readonly MAX_STORED_ERRORS = 1000;
  private readonly ERROR_RETENTION_TIME = 24 * 60 * 60 * 1000; // 24 hours

  /**
   * Record a validation error
   */
  recordValidationError(error: ValidationError): void {
    // Add timestamp if not provided
    if (!error.timestamp) {
      error.timestamp = Date.now();
    }

    // Add stack trace for debugging
    if (!error.stackTrace) {
      error.stackTrace = new Error().stack;
    }

    this.errors.push(error);

    // Log immediately for critical errors
    if (this.isCriticalError(error)) {
      console.error('[ValidationErrorMonitor] Critical validation error:', {
        component: error.component,
        stage: error.stage,
        operation: error.operation,
        errorType: error.errorType,
        input: this.sanitizeInputForLogging(error.input),
        recoveryAction: error.recoveryAction,
        timestamp: new Date(error.timestamp).toISOString()
      });
    } else if (error.severity === 'high') {
      console.warn('[ValidationErrorMonitor] High severity validation error:', {
        component: error.component,
        stage: error.stage,
        errorType: error.errorType,
        recoveryAction: error.recoveryAction
      });
    }

    // Cleanup old errors periodically
    this.cleanupOldErrors();
    
    // Ensure we don't exceed storage limits
    if (this.errors.length > this.MAX_STORED_ERRORS) {
      this.errors = this.errors.slice(-this.MAX_STORED_ERRORS);
    }
  }

  /**
   * Record a validation success for monitoring
   */
  recordValidationSuccess(component: string, stage: string, operation: string): void {
    // For now, just log successful validations in debug mode
    // Could be extended to track success rates
  }

  /**
   * Get error summary for monitoring and diagnostics
   */
  getErrorSummary(): ValidationErrorSummary {
    const now = Date.now();
    const recentErrors = this.errors.filter(e => now - e.timestamp < 3600000); // Last hour
    
    const errorsByComponent: Record<string, number> = {};
    const errorsByType: Record<string, number> = {};
    let criticalErrors = 0;
    let lastErrorTime = 0;

    for (const error of this.errors) {
      // Count by component
      errorsByComponent[error.component] = (errorsByComponent[error.component] || 0) + 1;
      
      // Count by type
      errorsByType[error.errorType] = (errorsByType[error.errorType] || 0) + 1;
      
      // Count critical errors
      if (this.isCriticalError(error)) {
        criticalErrors++;
      }
      
      // Track latest error time
      if (error.timestamp > lastErrorTime) {
        lastErrorTime = error.timestamp;
      }
    }

    return {
      totalErrors: this.errors.length,
      criticalErrors,
      errorsByComponent,
      errorsByType,
      recentErrors,
      lastErrorTime
    };
  }

  /**
   * Get recent critical errors for immediate attention
   */
  getRecentCriticalErrors(minutes: number = 60): ValidationError[] {
    const cutoffTime = Date.now() - (minutes * 60 * 1000);
    return this.errors.filter(error => 
      error.timestamp > cutoffTime && this.isCriticalError(error)
    );
  }

  /**
   * Check if there are any active critical issues
   */
  hasCriticalIssues(minutes: number = 10): boolean {
    return this.getRecentCriticalErrors(minutes).length > 0;
  }

  /**
   * Get error patterns for analysis
   */
  getErrorPatterns(): { component: string; stage: string; count: number; lastOccurrence: number }[] {
    const patterns = new Map<string, { count: number; lastOccurrence: number }>();
    
    for (const error of this.errors) {
      const key = `${error.component}:${error.stage}:${error.errorType}`;
      const existing = patterns.get(key);
      
      if (existing) {
        existing.count++;
        if (error.timestamp > existing.lastOccurrence) {
          existing.lastOccurrence = error.timestamp;
        }
      } else {
        patterns.set(key, { count: 1, lastOccurrence: error.timestamp });
      }
    }
    
    return Array.from(patterns.entries()).map(([key, data]) => {
      const [component, stage] = key.split(':');
      return {
        component,
        stage,
        count: data.count,
        lastOccurrence: data.lastOccurrence
      };
    }).sort((a, b) => b.count - a.count);
  }

  /**
   * Clear all stored errors (for testing or reset)
   */
  clearErrors(): void {
    this.errors = [];
  }

  /**
   * Export errors for external analysis
   */
  exportErrors(): ValidationError[] {
    return [...this.errors]; // Return copy to prevent external modification
  }

  /**
   * Check if an error is critical
   */
  private isCriticalError(error: ValidationError): boolean {
    if (error.severity === 'critical') {
      return true;
    }
    
    // Additional logic for determining criticality
    if (error.errorType === 'null_undefined' && 
        (error.operation.includes('split') || error.operation.includes('toLowerCase'))) {
      return true;
    }
    
    return false;
  }

  /**
   * Clean up old errors to prevent memory bloat
   */
  private cleanupOldErrors(): void {
    const cutoffTime = Date.now() - this.ERROR_RETENTION_TIME;
    const initialCount = this.errors.length;
    
    this.errors = this.errors.filter(error => error.timestamp > cutoffTime);
    
    const removedCount = initialCount - this.errors.length;
    if (removedCount > 0) {
    }
  }

  /**
   * Sanitize input for safe logging
   */
  private sanitizeInputForLogging(input: unknown): any {
    if (input === null || input === undefined) {
      return input;
    }
    
    if (typeof input === 'string') {
      // Truncate long strings
      return input.length > 200 ? input.substring(0, 200) + '...' : input;
    }
    
    if (typeof input === 'object' && input !== null) {
      // Provide safe object representation
      try {
        const str = JSON.stringify(input);
        return str.length > 200 ? str.substring(0, 200) + '...' : str;
      } catch {
        return '[Object - cannot serialize]';
      }
    }
    
    return String(input);
  }

  /**
   * Create a validation error object
   */
  static createError(
    component: string,
    stage: string,
    operation: string,
    errorType: ValidationError['errorType'],
    severity: ValidationError['severity'],
    input: unknown,
    expectedType: string,
    recoveryAction: string
  ): ValidationError {
    return {
      component,
      stage,
      operation,
      errorType,
      severity,
      input,
      expectedType,
      actualType: typeof input,
      timestamp: Date.now(),
      recoveryAction
    };
  }
}

// Global instance for universal search validation monitoring
export const globalValidationErrorMonitor = new ValidationErrorMonitor();
```

## agents/vaultLibrarian/modes/services/universal/validation/index.ts

```typescript
/**
 * Universal Search Validation Framework - Public API
 * 
 * Provides a unified interface for universal search validation components.
 * This module exports all validation functionality for easy integration.
 */

import { 
  UniversalSearchValidator, 
  ValidationResult, 
  ValidationContext 
} from './UniversalSearchValidator';

import { 
  ValidationErrorMonitor, 
  ValidationError, 
  ValidationErrorSummary,
  globalValidationErrorMonitor 
} from './ValidationErrorMonitor';

export { UniversalSearchValidator };
export type { ValidationResult, ValidationContext };
export { ValidationErrorMonitor, globalValidationErrorMonitor };
export type { ValidationError, ValidationErrorSummary };

/**
 * Creates a configured UniversalSearchValidator instance
 * for use in universal search components
 */
export function createUniversalSearchValidator(): UniversalSearchValidator {
  return new UniversalSearchValidator();
}

/**
 * Gets the global validation error monitor for system-wide error tracking
 */
export function getGlobalValidationErrorMonitor(): ValidationErrorMonitor {
  return globalValidationErrorMonitor;
}

/**
 * Utility function to create a validation context
 */
export function createValidationContext(
  component: string, 
  stage: string, 
  operation: string = 'unknown'
): ValidationContext {
  return { component, stage, operation };
}

/**
 * Check if the validation system has any critical issues
 */
export function hasCriticalValidationIssues(minutes: number = 10): boolean {
  return globalValidationErrorMonitor.hasCriticalIssues(minutes);
}

/**
 * Get a summary of validation system health
 */
export function getValidationHealthSummary(): ValidationErrorSummary {
  return globalValidationErrorMonitor.getErrorSummary();
}
```

## agents/vaultLibrarian/services/MemorySearchFilters.ts

```typescript
/**
 * Memory Search Filters
 * 
 * Location: src/agents/vaultLibrarian/services/MemorySearchFilters.ts
 * Purpose: Tool call filtering, date ranges, session filtering logic
 * Used by: SearchMemoryMode for applying various filters to search results
 */

import {
  MemorySearchResult,
  MemoryFilterOptions,
  DateRange,
  ToolCallFilter,
  ContentFilterOptions,
  MemoryFilterConfiguration,
  MemoryType
} from '../../../types/memory/MemorySearchTypes';

export interface MemorySearchFiltersInterface {
  filter(results: MemorySearchResult[], options: MemoryFilterOptions): MemorySearchResult[];
  applyDateFilter(results: MemorySearchResult[], dateRange: DateRange): MemorySearchResult[];
  applyContentFilter(results: MemorySearchResult[], pattern: string, options?: ContentFilterOptions): MemorySearchResult[];
  applyToolCallFilter(results: MemorySearchResult[], filter: ToolCallFilter): MemorySearchResult[];
  applyScoreFilter(results: MemorySearchResult[], threshold: number): MemorySearchResult[];
  applySessionFilter(results: MemorySearchResult[], sessionIds: string[]): MemorySearchResult[];
  applyWorkspaceFilter(results: MemorySearchResult[], workspaceIds: string[]): MemorySearchResult[];
  getConfiguration(): MemoryFilterConfiguration;
  updateConfiguration(config: Partial<MemoryFilterConfiguration>): void;
}

export class MemorySearchFilters implements MemorySearchFiltersInterface {
  private configuration: MemoryFilterConfiguration;

  constructor(config?: Partial<MemoryFilterConfiguration>) {
    this.configuration = {
      enableDateFiltering: true,
      enableSessionFiltering: true,
      enableToolCallFiltering: true,
      defaultDateRange: null,
      strictFiltering: false,
      ...config
    };
  }

  /**
   * Apply all configured filters to results
   */
  filter(results: MemorySearchResult[], options: MemoryFilterOptions): MemorySearchResult[] {
    let filtered = results;

    // Apply date filter
    if (this.configuration.enableDateFiltering && options.dateRange) {
      filtered = this.applyDateFilter(filtered, options.dateRange);
    }

    // Apply session filter
    if (this.configuration.enableSessionFiltering && options.filterBySession && options.sessionId) {
      filtered = this.applySessionFilter(filtered, [options.sessionId]);
    }

    // Apply workspace filter
    if (options.workspaceId) {
      filtered = this.applyWorkspaceFilter(filtered, [options.workspaceId]);
    }

    // Apply tool call filters
    if (this.configuration.enableToolCallFiltering && options.toolCallFilters) {
      filtered = this.applyToolCallFilter(filtered, options.toolCallFilters);
    }

    return filtered;
  }

  /**
   * Apply date range filter
   */
  applyDateFilter(results: MemorySearchResult[], dateRange: DateRange): MemorySearchResult[] {
    if (!dateRange) return results;

    const startTime = dateRange.start ? new Date(dateRange.start).getTime() : 0;
    const endTime = dateRange.end ? new Date(dateRange.end).getTime() : Date.now();

    return results.filter(result => {
      try {
        const resultTime = new Date(result.metadata.created).getTime();
        return resultTime >= startTime && resultTime <= endTime;
      } catch (error) {
        // If date parsing fails, include result unless strict filtering is enabled
        return !this.configuration.strictFiltering;
      }
    });
  }

  /**
   * Apply content pattern filter
   */
  applyContentFilter(
    results: MemorySearchResult[], 
    pattern: string, 
    options: ContentFilterOptions = {}
  ): MemorySearchResult[] {
    if (!pattern) return results;

    try {
      const regex = options.regex ? 
        new RegExp(pattern, options.caseSensitive ? 'g' : 'gi') :
        null;
      
      const searchPattern = options.caseSensitive ? pattern : pattern.toLowerCase();

      return results.filter(result => {
        const searchableContent = this.getSearchableContent(result, options.caseSensitive);
        
        if (regex) {
          return regex.test(searchableContent);
        }
        
        if (options.wholeWord) {
          const wordBoundaryPattern = new RegExp(`\\b${this.escapeRegex(searchPattern)}\\b`, 
            options.caseSensitive ? 'g' : 'gi');
          return wordBoundaryPattern.test(searchableContent);
        }
        
        return searchableContent.includes(searchPattern);
      });
    } catch (error) {
      console.warn('[MemorySearchFilters] Content filter error:', error);
      return this.configuration.strictFiltering ? [] : results;
    }
  }

  /**
   * Apply tool call filter
   */
  applyToolCallFilter(results: MemorySearchResult[], filter: ToolCallFilter): MemorySearchResult[] {
    return results.filter(result => {
      // Only apply to tool call results
      if (result.type !== MemoryType.TOOL_CALL) return true;

      return this.matchesToolCallFilter(result, filter);
    });
  }

  /**
   * Apply score threshold filter
   */
  applyScoreFilter(results: MemorySearchResult[], threshold: number): MemorySearchResult[] {
    if (threshold <= 0) return results;
    
    return results.filter(result => result.score >= threshold);
  }

  /**
   * Apply session filter
   */
  applySessionFilter(results: MemorySearchResult[], sessionIds: string[]): MemorySearchResult[] {
    if (!sessionIds || sessionIds.length === 0) return results;

    return results.filter(result => {
      const resultSessionId = result.metadata.sessionId;
      return resultSessionId && sessionIds.includes(resultSessionId);
    });
  }

  /**
   * Apply workspace filter
   */
  applyWorkspaceFilter(results: MemorySearchResult[], workspaceIds: string[]): MemorySearchResult[] {
    if (!workspaceIds || workspaceIds.length === 0) return results;

    return results.filter(result => {
      const resultWorkspaceId = result.metadata.workspaceId;
      return resultWorkspaceId && workspaceIds.includes(resultWorkspaceId);
    });
  }

  /**
   * Apply type filter
   */
  applyTypeFilter(results: MemorySearchResult[], types: MemoryType[]): MemorySearchResult[] {
    if (!types || types.length === 0) return results;

    return results.filter(result => types.includes(result.type as MemoryType));
  }

  /**
   * Apply metadata type filter
   */
  applyMetadataTypeFilter(results: MemorySearchResult[], types: string[]): MemorySearchResult[] {
    if (!types || types.length === 0) return results;

    return results.filter(result => {
      const type = result.metadata.type;
      return type && types.includes(type);
    });
  }

  /**
   * Apply success status filter
   */
  applySuccessFilter(results: MemorySearchResult[], successStatus: boolean): MemorySearchResult[] {
    return results.filter(result => {
      // Only apply to tool call results
      if (result.type !== MemoryType.TOOL_CALL) return true;

      return result.metadata.success === successStatus;
    });
  }

  /**
   * Apply execution time range filter
   */
  applyExecutionTimeFilter(
    results: MemorySearchResult[], 
    minTime?: number, 
    maxTime?: number
  ): MemorySearchResult[] {
    if (minTime === undefined && maxTime === undefined) return results;

    return results.filter(result => {
      // Only apply to tool call results
      if (result.type !== MemoryType.TOOL_CALL) return true;

      const executionTime = result.metadata.executionTime;
      if (executionTime === undefined) return !this.configuration.strictFiltering;

      if (minTime !== undefined && executionTime < minTime) return false;
      if (maxTime !== undefined && executionTime > maxTime) return false;

      return true;
    });
  }

  /**
   * Apply composite filter with multiple criteria
   */
  applyCompositeFilter(
    results: MemorySearchResult[],
    filters: {
      dateRange?: DateRange;
      sessionIds?: string[];
      workspaceIds?: string[];
      types?: MemoryType[];
      metadataTypes?: string[];
      scoreThreshold?: number;
      successStatus?: boolean;
      minExecutionTime?: number;
      maxExecutionTime?: number;
      contentPattern?: string;
      contentOptions?: ContentFilterOptions;
    }
  ): MemorySearchResult[] {
    let filtered = results;

    // Apply each filter in order
    if (filters.dateRange) {
      filtered = this.applyDateFilter(filtered, filters.dateRange);
    }

    if (filters.sessionIds) {
      filtered = this.applySessionFilter(filtered, filters.sessionIds);
    }

    if (filters.workspaceIds) {
      filtered = this.applyWorkspaceFilter(filtered, filters.workspaceIds);
    }

    if (filters.types) {
      filtered = this.applyTypeFilter(filtered, filters.types);
    }

    if (filters.metadataTypes) {
      filtered = this.applyMetadataTypeFilter(filtered, filters.metadataTypes);
    }

    if (filters.scoreThreshold !== undefined) {
      filtered = this.applyScoreFilter(filtered, filters.scoreThreshold);
    }

    if (filters.successStatus !== undefined) {
      filtered = this.applySuccessFilter(filtered, filters.successStatus);
    }

    if (filters.minExecutionTime !== undefined || filters.maxExecutionTime !== undefined) {
      filtered = this.applyExecutionTimeFilter(filtered, filters.minExecutionTime, filters.maxExecutionTime);
    }

    if (filters.contentPattern) {
      filtered = this.applyContentFilter(filtered, filters.contentPattern, filters.contentOptions);
    }

    return filtered;
  }

  /**
   * Get current configuration
   */
  getConfiguration(): MemoryFilterConfiguration {
    return { ...this.configuration };
  }

  /**
   * Update configuration
   */
  updateConfiguration(config: Partial<MemoryFilterConfiguration>): void {
    this.configuration = { ...this.configuration, ...config };
  }

  // Private helper methods

  private matchesToolCallFilter(result: MemorySearchResult, filter: ToolCallFilter): boolean {
    const metadata = result.metadata;

    // Agent filter
    if (filter.agent && metadata.agent !== filter.agent) {
      return false;
    }

    // Mode filter
    if (filter.mode && metadata.mode !== filter.mode) {
      return false;
    }

    // Success filter
    if (filter.success !== undefined && metadata.success !== filter.success) {
      return false;
    }

    // Execution time filters
    const executionTime = metadata.executionTime;
    if (executionTime !== undefined) {
      if (filter.minExecutionTime !== undefined && executionTime < filter.minExecutionTime) {
        return false;
      }
      if (filter.maxExecutionTime !== undefined && executionTime > filter.maxExecutionTime) {
        return false;
      }
    } else if (this.configuration.strictFiltering && 
               (filter.minExecutionTime !== undefined || filter.maxExecutionTime !== undefined)) {
      // In strict mode, reject results without execution time if time filters are specified
      return false;
    }

    return true;
  }

  private getSearchableContent(result: MemorySearchResult, caseSensitive: boolean = false): string {
    const parts = [
      result.highlight,
      result.context.before,
      result.context.match,
      result.context.after,
      JSON.stringify(result.metadata)
    ];

    const content = parts.join(' ');
    return caseSensitive ? content : content.toLowerCase();
  }

  private escapeRegex(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * Get filter statistics
   */
  getFilterStats(originalResults: MemorySearchResult[], filteredResults: MemorySearchResult[]): {
    originalCount: number;
    filteredCount: number;
    removedCount: number;
    filterEfficiency: number;
    typeDistribution: Record<string, number>;
  } {
    const originalCount = originalResults.length;
    const filteredCount = filteredResults.length;
    const removedCount = originalCount - filteredCount;
    const filterEfficiency = originalCount > 0 ? (removedCount / originalCount) * 100 : 0;

    // Calculate type distribution of filtered results
    const typeDistribution: Record<string, number> = {};
    for (const result of filteredResults) {
      const type = result.type;
      typeDistribution[type] = (typeDistribution[type] || 0) + 1;
    }

    return {
      originalCount,
      filteredCount,
      removedCount,
      filterEfficiency: Math.round(filterEfficiency * 100) / 100,
      typeDistribution
    };
  }

  /**
   * Validate filter configuration
   */
  validateFilters(filters: MemoryFilterOptions): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Validate date range
    if (filters.dateRange) {
      if (filters.dateRange.start && filters.dateRange.end) {
        const startDate = new Date(filters.dateRange.start);
        const endDate = new Date(filters.dateRange.end);

        if (isNaN(startDate.getTime())) {
          errors.push('Invalid start date format');
        }
        if (isNaN(endDate.getTime())) {
          errors.push('Invalid end date format');
        }
        if (startDate > endDate) {
          errors.push('Start date must be before end date');
        }
      }
    }

    // Validate tool call filters
    if (filters.toolCallFilters) {
      const tcf = filters.toolCallFilters;
      if (tcf.minExecutionTime !== undefined && tcf.minExecutionTime < 0) {
        errors.push('Minimum execution time must be non-negative');
      }
      if (tcf.maxExecutionTime !== undefined && tcf.maxExecutionTime < 0) {
        errors.push('Maximum execution time must be non-negative');
      }
      if (tcf.minExecutionTime !== undefined && 
          tcf.maxExecutionTime !== undefined && 
          tcf.minExecutionTime > tcf.maxExecutionTime) {
        errors.push('Minimum execution time must be less than maximum execution time');
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Create optimized filter chain for performance
   */
  createFilterChain(options: MemoryFilterOptions): ((results: MemorySearchResult[]) => MemorySearchResult[])[] {
    const chain: ((results: MemorySearchResult[]) => MemorySearchResult[])[] = [];

    // Add filters in order of selectivity (most selective first)
    
    // Session filter (very selective)
    if (options.filterBySession && options.sessionId) {
      chain.push((results) => this.applySessionFilter(results, [options.sessionId!]));
    }

    // Workspace filter (selective)
    if (options.workspaceId) {
      chain.push((results) => this.applyWorkspaceFilter(results, [options.workspaceId!]));
    }

    // Tool call filters (moderately selective)
    if (options.toolCallFilters) {
      const filters = options.toolCallFilters;
      chain.push((results) => this.applyToolCallFilter(results, filters));
    }

    // Date filter (less selective)
    if (options.dateRange) {
      const dateRange = options.dateRange;
      chain.push((results) => this.applyDateFilter(results, dateRange));
    }

    return chain;
  }

  /**
   * Apply filter chain efficiently
   */
  applyFilterChain(
    results: MemorySearchResult[], 
    chain: ((results: MemorySearchResult[]) => MemorySearchResult[])[]
  ): MemorySearchResult[] {
    return chain.reduce((currentResults, filter) => {
      if (currentResults.length === 0) return currentResults; // Short-circuit if no results left
      return filter(currentResults);
    }, results);
  }
}
```

## agents/vaultLibrarian/services/MemorySearchProcessor.ts

```typescript
/**
 * Memory Search Processor
 * 
 * Location: src/agents/vaultLibrarian/services/MemorySearchProcessor.ts
 * Purpose: Core search logic across multiple memory types (traces, sessions, workspaces, etc.)
 * Used by: SearchMemoryMode for processing search requests and enriching results
 */

import { Plugin } from 'obsidian';
import {
  MemorySearchParameters,
  MemorySearchResult,
  RawMemoryResult,
  MemorySearchContext,
  MemorySearchExecutionOptions,
  SearchOptions,
  ValidationResult,
  MemoryProcessorConfiguration,
  SearchMethod,
  MemoryType
} from '../../../types/memory/MemorySearchTypes';
import { MemoryService } from "../../memoryManager/services/MemoryService";
import { WorkspaceService } from "../../memoryManager/services/WorkspaceService";

export interface MemorySearchProcessorInterface {
  process(params: MemorySearchParameters): Promise<MemorySearchResult[]>;
  validateParameters(params: MemorySearchParameters): ValidationResult;
  executeSearch(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]>;
  enrichResults(results: RawMemoryResult[], context: MemorySearchContext): Promise<MemorySearchResult[]>;
  getConfiguration(): MemoryProcessorConfiguration;
  updateConfiguration(config: Partial<MemoryProcessorConfiguration>): Promise<void>;
}

export class MemorySearchProcessor implements MemorySearchProcessorInterface {
  private plugin: Plugin;
  private configuration: MemoryProcessorConfiguration;
  
  constructor(plugin: Plugin, config?: Partial<MemoryProcessorConfiguration>) {
    this.plugin = plugin;
    this.configuration = {
      defaultLimit: 20,
      maxLimit: 100,
      defaultSearchMethod: SearchMethod.EXACT,
      enableSemanticSearch: false,
      enableExactSearch: true,
      timeoutMs: 30000,
      ...config
    };
  }

  /**
   * Main processing entry point
   */
  async process(params: MemorySearchParameters): Promise<MemorySearchResult[]> {
    // Validate parameters
    const validation = this.validateParameters(params);
    if (!validation.isValid) {
      throw new Error(`Invalid parameters: ${validation.errors.join(', ')}`);
    }

    // Build search context
    const context: MemorySearchContext = {
      params,
      timestamp: new Date()
    };

    // Execute search across all specified memory types
    const searchOptions = this.buildSearchOptions(params);
    const rawResults = await this.executeSearch(params.query, searchOptions);

    // Enrich results with metadata and context
    return this.enrichResults(rawResults, context);
  }

  /**
   * Validates search parameters
   */
  validateParameters(params: MemorySearchParameters): ValidationResult {
    const errors: string[] = [];

    // Required fields
    if (!params.query || params.query.trim().length === 0) {
      errors.push('Query parameter is required and cannot be empty');
    }

    // Limit validation
    if (params.limit !== undefined) {
      if (params.limit < 1) {
        errors.push('Limit must be positive');
      }
      if (params.limit > this.configuration.maxLimit) {
        errors.push(`Limit cannot exceed ${this.configuration.maxLimit}`);
      }
    }

    // Date range validation
    if (params.dateRange) {
      if (params.dateRange.start && params.dateRange.end) {
        const startDate = new Date(params.dateRange.start);
        const endDate = new Date(params.dateRange.end);
        
        if (isNaN(startDate.getTime())) {
          errors.push('Invalid start date format');
        }
        if (isNaN(endDate.getTime())) {
          errors.push('Invalid end date format');
        }
        if (startDate > endDate) {
          errors.push('Start date must be before end date');
        }
      }
    }

    // Tool call filters validation
    if (params.toolCallFilters) {
      const filters = params.toolCallFilters;
      if (filters.minExecutionTime !== undefined && filters.minExecutionTime < 0) {
        errors.push('Minimum execution time must be non-negative');
      }
      if (filters.maxExecutionTime !== undefined && filters.maxExecutionTime < 0) {
        errors.push('Maximum execution time must be non-negative');
      }
      if (filters.minExecutionTime !== undefined && 
          filters.maxExecutionTime !== undefined && 
          filters.minExecutionTime > filters.maxExecutionTime) {
        errors.push('Minimum execution time must be less than maximum execution time');
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Execute search across all memory types
   */
  async executeSearch(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    const results: RawMemoryResult[] = [];
    const searchPromises: Promise<RawMemoryResult[]>[] = [];

    // Get default memory types if not specified
    const memoryTypes = (options as any).memoryTypes || ['traces', 'toolCalls', 'sessions', 'states', 'workspaces'];
    const limit = options.limit || this.configuration.defaultLimit;

    // Search legacy traces
    if (memoryTypes.includes('traces')) {
      searchPromises.push(this.searchLegacyTraces(query, options));
    }

    // Search tool call traces
    if (memoryTypes.includes('toolCalls')) {
      searchPromises.push(this.searchToolCallTraces(query, options));
    }

    // Search sessions
    if (memoryTypes.includes('sessions')) {
      searchPromises.push(this.searchSessions(query, options));
    }

    // Search states
    if (memoryTypes.includes('states')) {
      searchPromises.push(this.searchStates(query, options));
    }

    // Search workspaces
    if (memoryTypes.includes('workspaces')) {
      searchPromises.push(this.searchWorkspaces(query, options));
    }

    // Execute all searches in parallel
    const searchResults = await Promise.allSettled(searchPromises);
    
    // Collect results from successful searches
    for (const result of searchResults) {
      if (result.status === 'fulfilled') {
        results.push(...result.value);
      } else {
        console.error('[MemorySearchProcessor] Search error:', result.reason);
      }
    }

    // Sort by score and apply limit
    results.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));
    return results.slice(0, limit);
  }

  /**
   * Enrich raw results with metadata and context
   */
  async enrichResults(results: RawMemoryResult[], context: MemorySearchContext): Promise<MemorySearchResult[]> {
    const enrichedResults: MemorySearchResult[] = [];

    for (const result of results) {
      try {
        const enriched = await this.enrichSingleResult(result, context);
        if (enriched) {
          enrichedResults.push(enriched);
        }
      } catch (error) {
        console.warn('[MemorySearchProcessor] Failed to enrich result:', error);
      }
    }

    return enrichedResults;
  }

  /**
   * Get current configuration
   */
  getConfiguration(): MemoryProcessorConfiguration {
    return { ...this.configuration };
  }

  /**
   * Update configuration
   */
  async updateConfiguration(config: Partial<MemoryProcessorConfiguration>): Promise<void> {
    this.configuration = { ...this.configuration, ...config };
  }

  // Private helper methods

  private buildSearchOptions(params: MemorySearchParameters): MemorySearchExecutionOptions {
    return {
      workspaceId: params.workspace,
      sessionId: params.context.sessionId,
      limit: params.limit || this.configuration.defaultLimit,
      toolCallFilters: params.toolCallFilters
    };
  }

  private async searchLegacyTraces(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    const memoryService = this.getMemoryService();
    if (!memoryService) return [];

    try {
      const results = await memoryService.searchMemoryTraces(
        options.workspaceId || 'default',
        query,
        options.limit
      );

      return results.map(result => ({
        trace: result,
        similarity: 1.0 // Default similarity since we don't have semantic search
      }));
    } catch (error) {
      console.error('[MemorySearchProcessor] Error searching legacy traces:', error);
      return [];
    }
  }

  private async searchToolCallTraces(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    // MemoryTraceService not available in simplified architecture
    console.warn('[MemorySearchProcessor] Tool call trace search not available in simplified architecture');
    return [];
  }

  private async searchSessions(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    const memoryService = this.getMemoryService();
    if (!memoryService) return [];

    try {
      const sessions = await memoryService.getSessions(options.workspaceId);
      const queryLower = query.toLowerCase();
      const results: RawMemoryResult[] = [];

      for (const session of sessions) {
        let score = 0;
        
        // Check name match
        if ((session.name || '').toLowerCase().includes(queryLower)) {
          score += 0.9;
        }
        
        // Check description match
        if (session.description?.toLowerCase().includes(queryLower)) {
          score += 0.8;
        }

        if (score > 0) {
          results.push({
            trace: session,
            similarity: score
          });
        }
      }

      return results;
    } catch (error) {
      console.error('[MemorySearchProcessor] Error searching sessions:', error);
      return [];
    }
  }

  private async searchStates(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    const memoryService = this.getMemoryService();
    if (!memoryService) return [];

    try {
      const states = await memoryService.getSnapshots(options.workspaceId, options.sessionId);
      const queryLower = query.toLowerCase();
      const results: RawMemoryResult[] = [];

      for (const state of states) {
        let score = 0;
        
        // Check name match
        if (state.name.toLowerCase().includes(queryLower)) {
          score += 0.9;
        }
        
        // Check description match
        if (state.description?.toLowerCase().includes(queryLower)) {
          score += 0.8;
        }

        if (score > 0) {
          results.push({
            trace: state,
            similarity: score
          });
        }
      }

      return results;
    } catch (error) {
      console.error('[MemorySearchProcessor] Error searching states:', error);
      return [];
    }
  }

  private async searchWorkspaces(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    const workspaceService = this.getWorkspaceService();
    if (!workspaceService) return [];

    try {
      const workspaces = await workspaceService.getWorkspaces();
      const queryLower = query.toLowerCase();
      const results: RawMemoryResult[] = [];

      for (const workspace of workspaces) {
        let score = 0;
        
        // Check name match
        if (workspace.name.toLowerCase().includes(queryLower)) {
          score += 0.9;
        }
        
        // Check description match
        if (workspace.description?.toLowerCase().includes(queryLower)) {
          score += 0.8;
        }

        if (score > 0) {
          results.push({
            trace: workspace,
            similarity: score
          });
        }
      }

      return results;
    } catch (error) {
      console.error('[MemorySearchProcessor] Error searching workspaces:', error);
      return [];
    }
  }

  private async searchToolCallsExact(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    // MemoryTraceService not available in simplified architecture
    console.warn('[MemorySearchProcessor] Exact tool call search not available in simplified architecture');
    return [];
  }

  private async enrichSingleResult(result: RawMemoryResult, context: MemorySearchContext): Promise<MemorySearchResult | null> {
    const trace = result.trace;
    const query = context.params.query;

    try {
      // Determine result type
      const resultType = this.determineResultType(trace);
      
      // Generate highlight
      const highlight = this.generateHighlight(trace, query);
      
      // Build metadata
      const metadata = this.buildMetadata(trace, resultType);
      
      // Generate context
      const searchContext = this.generateSearchContext(trace, query, resultType);

      return {
        type: resultType,
        id: trace.id,
        highlight,
        metadata,
        context: searchContext,
        score: result.similarity || 0
      };
    } catch (error) {
      console.warn('[MemorySearchProcessor] Failed to enrich result:', error);
      return null;
    }
  }

  private determineResultType(trace: any): MemoryType {
    if ((trace as any).toolCallId) return MemoryType.TOOL_CALL;
    if (trace.name && trace.startTime !== undefined) return MemoryType.SESSION;
    if (trace.name && trace.timestamp !== undefined) return MemoryType.STATE;
    if (trace.name && trace.created !== undefined) return MemoryType.WORKSPACE;
    return MemoryType.TRACE;
  }

  private generateHighlight(trace: any, query: string): string {
    const maxLength = 200;
    const content = trace.content || trace.description || trace.name || '';
    const queryLower = query.toLowerCase();
    const contentLower = content.toLowerCase();
    
    const index = contentLower.indexOf(queryLower);
    if (index === -1) {
      return content.substring(0, maxLength) + (content.length > maxLength ? '...' : '');
    }
    
    const start = Math.max(0, index - 50);
    const end = Math.min(content.length, index + query.length + 50);
    
    let highlight = content.substring(start, end);
    if (start > 0) highlight = '...' + highlight;
    if (end < content.length) highlight = highlight + '...';
    
    return highlight;
  }

  private buildMetadata(trace: any, resultType: MemoryType): any {
    const baseMetadata = {
      created: trace.timestamp ? new Date(trace.timestamp).toISOString() : 
               trace.startTime ? new Date(trace.startTime).toISOString() :
               trace.created ? new Date(trace.created).toISOString() : 
               new Date().toISOString(),
      sessionId: trace.sessionId,
      workspaceId: trace.workspaceId,
      primaryGoal: '',
      filesReferenced: trace.metadata?.relatedFiles || trace.relationships?.relatedFiles || [],
      type: trace.type
    };

    if (resultType === MemoryType.TOOL_CALL) {
      const toolCallTrace = trace as any;
      return {
        ...baseMetadata,
        toolUsed: toolCallTrace.toolName,
        modeUsed: toolCallTrace.mode,
        toolCallId: toolCallTrace.toolCallId,
        agent: toolCallTrace.agent,
        mode: toolCallTrace.mode,
        executionTime: toolCallTrace.executionContext?.timing?.executionTime,
        success: toolCallTrace.metadata?.response?.success,
        errorMessage: toolCallTrace.metadata?.response?.error?.message,
        affectedResources: toolCallTrace.relationships?.affectedResources || []
      };
    }

    return {
      ...baseMetadata,
      toolUsed: trace.metadata?.tool,
      modeUsed: '',
      updated: trace.endTime ? new Date(trace.endTime).toISOString() : 
               trace.lastAccessed ? new Date(trace.lastAccessed).toISOString() : undefined
    };
  }

  private generateSearchContext(trace: any, query: string, resultType: MemoryType): any {
    const content = trace.content || trace.description || trace.name || '';
    const context = this.generateBasicContext(content, query);

    if (resultType === MemoryType.TOOL_CALL) {
      return this.enhanceToolCallContext(context, trace);
    }

    return context;
  }

  private generateBasicContext(content: string, query: string): any {
    const queryLower = query.toLowerCase();
    const contentLower = content.toLowerCase();
    const index = contentLower.indexOf(queryLower);
    
    if (index === -1) {
      return {
        before: '',
        match: content.substring(0, 100),
        after: ''
      };
    }
    
    const matchStart = index;
    const matchEnd = index + query.length;
    
    return {
      before: content.substring(Math.max(0, matchStart - 50), matchStart),
      match: content.substring(matchStart, matchEnd),
      after: content.substring(matchEnd, Math.min(content.length, matchEnd + 50))
    };
  }

  private enhanceToolCallContext(context: any, toolCallTrace: any): any {
    const toolInfo = `${toolCallTrace.agent}.${toolCallTrace.mode}`;
    const statusInfo = toolCallTrace.metadata?.response?.success ? 'SUCCESS' : 'FAILED';
    const executionTime = toolCallTrace.executionContext?.timing?.executionTime;
    
    return {
      before: `[${toolInfo}] ${context.before}`,
      match: context.match,
      after: `${context.after} [${statusInfo}${executionTime ? ` - ${executionTime}ms` : ''}]`
    };
  }

  private deduplicateResults(results: RawMemoryResult[]): RawMemoryResult[] {
    const seen = new Set<string>();
    const unique: RawMemoryResult[] = [];
    
    for (const result of results) {
      const id = result.trace?.id;
      if (id && !seen.has(id)) {
        seen.add(id);
        unique.push(result);
      }
    }
    
    return unique;
  }

  // Service access methods
  private getMemoryService(): MemoryService | undefined {
    try {
      const plugin = (this.plugin as any)?.app?.plugins?.getPlugin('claudesidian-mcp');
      if (plugin?.serviceContainer) {
        return plugin.serviceContainer.getIfReady('memoryService') || undefined;
      }
      return undefined;
    } catch (error) {
      console.warn('[MemorySearchProcessor] Failed to get MemoryService:', error);
      return undefined;
    }
  }


  private getWorkspaceService(): WorkspaceService | undefined {
    try {
      const plugin = (this.plugin as any)?.app?.plugins?.getPlugin('claudesidian-mcp');
      if (plugin?.serviceContainer) {
        return plugin.serviceContainer.getIfReady('workspaceService') || undefined;
      }
      return undefined;
    } catch (error) {
      return undefined;
    }
  }
}
```

## agents/vaultLibrarian/services/ResultFormatter.ts

```typescript
/**
 * Result Formatter
 * 
 * Location: src/agents/vaultLibrarian/services/ResultFormatter.ts
 * Purpose: Result highlighting, metadata processing, response formatting
 * Used by: SearchMemoryMode for formatting search results and building summaries
 */

import {
  MemorySearchResult,
  FormattedMemoryResult,
  FormatOptions,
  MemorySortOption,
  MemoryGroupOption,
  GroupedMemoryResults,
  MemoryResultGroup,
  GroupStatistics,
  PaginatedMemoryResults,
  PaginationOptions,
  MemoryResultSummary,
  SearchHighlight,
  HighlightOptions,
  FormatContext,
  ResultFormatterConfiguration,
  MemoryType
} from '../../../types/memory/MemorySearchTypes';

export interface ResultFormatterInterface {
  format(results: MemorySearchResult[], options: FormatOptions): Promise<FormattedMemoryResult[]>;
  groupResults(results: MemorySearchResult[], groupBy: MemoryGroupOption): Promise<GroupedMemoryResults>;
  sortResults(results: MemorySearchResult[], sortBy: MemorySortOption): MemorySearchResult[];
  buildSummary(results: MemorySearchResult[]): Promise<MemoryResultSummary>;
  paginate(results: MemorySearchResult[], pagination: PaginationOptions): PaginatedMemoryResults;
  addHighlights(results: MemorySearchResult[], query: string, options?: HighlightOptions): Promise<MemorySearchResult[]>;
  getConfiguration(): ResultFormatterConfiguration;
  updateConfiguration(config: Partial<ResultFormatterConfiguration>): void;
}

export class ResultFormatter implements ResultFormatterInterface {
  private configuration: ResultFormatterConfiguration;

  constructor(config?: Partial<ResultFormatterConfiguration>) {
    this.configuration = {
      maxHighlightLength: 200,
      contextLength: 50,
      enableToolCallEnhancement: true,
      dateFormat: 'YYYY-MM-DD',
      timestampFormat: 'YYYY-MM-DD HH:mm:ss',
      ...config
    };
  }

  /**
   * Format search results according to options
   */
  async format(results: MemorySearchResult[], options: FormatOptions): Promise<FormattedMemoryResult[]> {
    const formatted: FormattedMemoryResult[] = [];

    for (const result of results) {
      try {
        const formattedResult = await this.formatSingleResult(result, options);
        formatted.push(formattedResult);
      } catch (error) {
        console.warn('[ResultFormatter] Failed to format result:', error);
      }
    }

    return formatted;
  }

  /**
   * Group results by specified criteria
   */
  async groupResults(results: MemorySearchResult[], groupBy: MemoryGroupOption): Promise<GroupedMemoryResults> {
    const groups = new Map<string, MemorySearchResult[]>();

    // Group results by primary criteria
    for (const result of results) {
      const groupKey = this.getGroupKey(result, groupBy.groupBy);
      const existingGroup = groups.get(groupKey) || [];
      existingGroup.push(result);
      groups.set(groupKey, existingGroup);
    }

    // Apply sub-grouping if specified
    if (groupBy.subGroupBy) {
      const subGroupedResults = new Map<string, MemorySearchResult[]>();
      
      groups.forEach((groupResults, primaryKey) => {
        const subGroups = new Map<string, MemorySearchResult[]>();
        
        for (const result of groupResults) {
          const subGroupKey = this.getGroupKey(result, groupBy.subGroupBy!);
          const combinedKey = `${primaryKey}:${subGroupKey}`;
          const existingSubGroup = subGroups.get(combinedKey) || [];
          existingSubGroup.push(result);
          subGroups.set(combinedKey, existingSubGroup);
        }
        
        subGroups.forEach((subResults, subKey) => {
          subGroupedResults.set(subKey, subResults);
        });
      });
      
      // Replace groups with sub-grouped results
      groups.clear();
      subGroupedResults.forEach((results, key) => {
        groups.set(key, results);
      });
    }

    // Convert to result format
    const resultGroups: MemoryResultGroup[] = [];
    groups.forEach((results, key) => {
      const totalScore = results.reduce((sum, r) => sum + r.score, 0);
      const averageScore = results.length > 0 ? totalScore / results.length : 0;

      resultGroups.push({
        key,
        displayName: this.getDisplayName(key, groupBy),
        results,
        count: results.length,
        totalScore,
        averageScore,
        metadata: this.buildGroupMetadata(results, key)
      });
    });

    // Sort groups by count (descending)
    resultGroups.sort((a, b) => b.count - a.count);

    // Calculate group statistics
    const groupStats = this.calculateGroupStatistics(resultGroups);

    return {
      groups: resultGroups,
      totalGroups: resultGroups.length,
      totalResults: results.length,
      groupedBy: groupBy,
      groupStats
    };
  }

  /**
   * Sort results by specified criteria
   */
  sortResults(results: MemorySearchResult[], sortBy: MemorySortOption): MemorySearchResult[] {
    return [...results].sort((a, b) => {
      let comparison = 0;

      switch (sortBy.field) {
        case 'score':
          comparison = b.score - a.score;
          break;
        
        case 'timestamp':
          const aTime = new Date(a.metadata.created).getTime();
          const bTime = new Date(b.metadata.created).getTime();
          comparison = bTime - aTime;
          break;
        
        case 'relevance':
          comparison = this.compareRelevance(a, b);
          break;
        
        default:
          comparison = 0;
      }

      return sortBy.direction === 'asc' ? -comparison : comparison;
    });
  }

  /**
   * Build result summary statistics
   */
  async buildSummary(results: MemorySearchResult[]): Promise<MemoryResultSummary> {
    const totalResults = results.length;
    const totalScore = results.reduce((sum, r) => sum + r.score, 0);
    const averageScore = totalResults > 0 ? totalScore / totalResults : 0;

    // Calculate type distribution
    const typeDistribution: Record<string, number> = {};
    let oldestTimestamp = new Date();
    let newestTimestamp = new Date(0);

    for (const result of results) {
      // Type distribution
      const type = result.type;
      typeDistribution[type] = (typeDistribution[type] || 0) + 1;

      // Date range
      try {
        const timestamp = new Date(result.metadata.created);
        if (timestamp < oldestTimestamp) {
          oldestTimestamp = timestamp;
        }
        if (timestamp > newestTimestamp) {
          newestTimestamp = timestamp;
        }
      } catch (error) {
        // Ignore invalid dates
      }
    }

    return {
      totalResults,
      averageScore: Math.round(averageScore * 1000) / 1000,
      typeDistribution,
      dateRange: { 
        start: totalResults > 0 ? oldestTimestamp : new Date(), 
        end: totalResults > 0 ? newestTimestamp : new Date() 
      },
      executionTime: 0 // Set by caller
    };
  }

  /**
   * Apply result pagination
   */
  paginate(results: MemorySearchResult[], pagination: PaginationOptions): PaginatedMemoryResults {
    const { page, pageSize, totalItems } = pagination;
    const actualTotalItems = totalItems || results.length;
    const totalPages = Math.ceil(actualTotalItems / pageSize);
    
    const startIndex = page * pageSize;
    const endIndex = Math.min(startIndex + pageSize, results.length);
    const items = results.slice(startIndex, endIndex);

    return {
      items,
      page,
      pageSize,
      totalItems: actualTotalItems,
      totalPages,
      hasNextPage: page < totalPages - 1,
      hasPreviousPage: page > 0
    };
  }

  /**
   * Generate result highlights
   */
  async addHighlights(
    results: MemorySearchResult[], 
    query: string, 
    options: HighlightOptions = {}
  ): Promise<MemorySearchResult[]> {
    const {
      maxHighlights = 3,
      highlightLength = this.configuration.maxHighlightLength,
      caseSensitive = false,
      wholeWord = false
    } = options;

    return results.map(result => {
      const highlights = this.generateHighlights(result, query, {
        maxHighlights,
        highlightLength,
        caseSensitive,
        wholeWord
      });

      return {
        ...result,
        highlights
      } as MemorySearchResult & { highlights: SearchHighlight[] };
    });
  }

  /**
   * Get current configuration
   */
  getConfiguration(): ResultFormatterConfiguration {
    return { ...this.configuration };
  }

  /**
   * Update configuration
   */
  updateConfiguration(config: Partial<ResultFormatterConfiguration>): void {
    this.configuration = { ...this.configuration, ...config };
  }

  // Private helper methods

  private async formatSingleResult(result: MemorySearchResult, options: FormatOptions): Promise<FormattedMemoryResult> {
    const formatContext: FormatContext = {
      searchQuery: '', // Will be set by caller if needed
      resultType: result.type,
      timestamp: new Date()
    };

    // Generate formatted content
    const formattedContent = this.formatContent(result, options);
    
    // Generate preview
    const preview = this.generatePreview(result, options);
    
    // Format timestamp
    const formattedTimestamp = this.formatTimestamp(result.metadata.created);
    
    // Generate title and subtitle
    const title = this.generateTitle(result);
    const subtitle = this.generateSubtitle(result);
    
    // Format metadata
    const formattedMetadata = this.formatMetadata(result.metadata);
    
    // Generate highlights
    const highlights: SearchHighlight[] = [];

    return {
      original: result,
      formattedContent,
      preview,
      formattedTimestamp,
      title,
      subtitle,
      formattedMetadata,
      highlights,
      formatContext
    };
  }

  private formatContent(result: MemorySearchResult, options: FormatOptions): string {
    let content = result.highlight;

    // Apply length limits
    const maxLength = options.maxHighlightLength || this.configuration.maxHighlightLength;
    if (content.length > maxLength) {
      content = content.substring(0, maxLength - 3) + '...';
    }

    // Enhance tool call context if enabled
    if (this.configuration.enableToolCallEnhancement && 
        options.enhanceToolCallContext !== false &&
        result.type === MemoryType.TOOL_CALL) {
      content = this.enhanceToolCallContent(content, result);
    }

    return content;
  }

  private generatePreview(result: MemorySearchResult, options: FormatOptions): string {
    const previewLength = 100;
    const content = result.context.before + result.context.match + result.context.after;
    
    if (content.length <= previewLength) {
      return content;
    }
    
    return content.substring(0, previewLength - 3) + '...';
  }

  private formatTimestamp(timestamp: string): string {
    try {
      const date = new Date(timestamp);
      return date.toLocaleString(); // Could be customized based on configuration
    } catch (error) {
      return timestamp;
    }
  }

  private generateTitle(result: MemorySearchResult): string {
    switch (result.type) {
      case MemoryType.TOOL_CALL:
        return `${result.metadata.agent || 'Unknown'}.${result.metadata.mode || 'Unknown'}`;
      
      case MemoryType.SESSION:
        return `Session: ${result.metadata.sessionId || 'Unknown'}`;
      
      case MemoryType.STATE:
        return `State: ${result.id}`;
      
      case MemoryType.WORKSPACE:
        return `Workspace: ${result.metadata.workspaceId || 'Unknown'}`;
      
      case MemoryType.TRACE:
      default:
        return `Memory Trace: ${result.id}`;
    }
  }

  private generateSubtitle(result: MemorySearchResult): string | undefined {
    const metadata = result.metadata;
    const parts: string[] = [];

    if (metadata.type) {
      parts.push(metadata.type);
    }

    if (result.type === MemoryType.TOOL_CALL) {
      if (metadata.success !== undefined) {
        parts.push(metadata.success ? 'SUCCESS' : 'FAILED');
      }
      if (metadata.executionTime) {
        parts.push(`${metadata.executionTime}ms`);
      }
    }

    if (metadata.filesReferenced && metadata.filesReferenced.length > 0) {
      parts.push(`${metadata.filesReferenced.length} files`);
    }

    return parts.length > 0 ? parts.join(' ‚Ä¢ ') : undefined;
  }

  private formatMetadata(metadata: any): Record<string, string> {
    const formatted: Record<string, string> = {};

    // Always format basic fields
    if (metadata.created) {
      formatted['Created'] = this.formatTimestamp(metadata.created);
    }
    if (metadata.updated) {
      formatted['Updated'] = this.formatTimestamp(metadata.updated);
    }
    if (metadata.sessionId) {
      formatted['Session'] = metadata.sessionId;
    }
    if (metadata.workspaceId) {
      formatted['Workspace'] = metadata.workspaceId;
    }

    // Format type-specific fields
    if (metadata.agent && metadata.mode) {
      formatted['Tool'] = `${metadata.agent}.${metadata.mode}`;
    }
    if (metadata.executionTime) {
      formatted['Execution Time'] = `${metadata.executionTime}ms`;
    }
    if (metadata.success !== undefined) {
      formatted['Status'] = metadata.success ? 'Success' : 'Failed';
    }
    if (metadata.filesReferenced && metadata.filesReferenced.length > 0) {
      formatted['Files'] = metadata.filesReferenced.join(', ');
    }

    return formatted;
  }

  private enhanceToolCallContent(content: string, result: MemorySearchResult): string {
    const metadata = result.metadata;
    const prefix = `[${metadata.agent || 'Unknown'}.${metadata.mode || 'Unknown'}]`;
    const status = metadata.success ? 'SUCCESS' : 'FAILED';
    const timing = metadata.executionTime ? ` (${metadata.executionTime}ms)` : '';
    
    return `${prefix} ${content} [${status}${timing}]`;
  }

  private getGroupKey(result: MemorySearchResult, groupBy: string): string {
    switch (groupBy) {
      case 'type':
        return result.type;
      
      case 'session':
        return result.metadata.sessionId || 'No Session';
      
      case 'workspace':
        return result.metadata.workspaceId || 'No Workspace';
      
      case 'date':
        try {
          const date = new Date(result.metadata.created);
          return date.toISOString().split('T')[0]; // YYYY-MM-DD
        } catch {
          return 'Unknown Date';
        }
      
      case 'agent':
        return result.metadata.agent || 'No Agent';
      
      case 'mode':
        return result.metadata.mode || 'No Mode';
      
      case 'success':
        if (result.type === MemoryType.TOOL_CALL && result.metadata.success !== undefined) {
          return result.metadata.success ? 'Success' : 'Failed';
        }
        return 'N/A';
      
      default:
        return 'Other';
    }
  }

  private getDisplayName(key: string, groupBy: MemoryGroupOption): string {
    // Handle sub-grouped keys
    if (key.includes(':')) {
      const [primary, secondary] = key.split(':');
      return `${primary} ‚Üí ${secondary}`;
    }
    
    return key;
  }

  private buildGroupMetadata(results: MemorySearchResult[], key: string): Record<string, any> {
    const metadata: Record<string, any> = {};
    
    // Calculate group-specific statistics
    const scores = results.map(r => r.score);
    metadata.minScore = Math.min(...scores);
    metadata.maxScore = Math.max(...scores);
    metadata.scoreStdDev = this.calculateStandardDeviation(scores);
    
    // Type distribution within group
    const typeDistribution: Record<string, number> = {};
    for (const result of results) {
      typeDistribution[result.type] = (typeDistribution[result.type] || 0) + 1;
    }
    metadata.typeDistribution = typeDistribution;
    
    // Date range within group
    const timestamps = results.map(r => new Date(r.metadata.created).getTime()).filter(t => !isNaN(t));
    if (timestamps.length > 0) {
      metadata.dateRange = {
        start: new Date(Math.min(...timestamps)).toISOString(),
        end: new Date(Math.max(...timestamps)).toISOString()
      };
    }
    
    return metadata;
  }

  private calculateGroupStatistics(groups: MemoryResultGroup[]): GroupStatistics {
    if (groups.length === 0) {
      return {
        averageGroupSize: 0,
        largestGroupSize: 0,
        smallestGroupSize: 0,
        scoreDistribution: {}
      };
    }

    const groupSizes = groups.map(g => g.count);
    const averageGroupSize = groupSizes.reduce((sum, size) => sum + size, 0) / groups.length;
    const largestGroupSize = Math.max(...groupSizes);
    const smallestGroupSize = Math.min(...groupSizes);

    // Score distribution across all groups
    const scoreDistribution: Record<string, number> = {};
    for (const group of groups) {
      const scoreRange = this.getScoreRange(group.averageScore);
      scoreDistribution[scoreRange] = (scoreDistribution[scoreRange] || 0) + 1;
    }

    return {
      averageGroupSize: Math.round(averageGroupSize * 100) / 100,
      largestGroupSize,
      smallestGroupSize,
      scoreDistribution
    };
  }

  private compareRelevance(a: MemorySearchResult, b: MemorySearchResult): number {
    // Custom relevance comparison - could be enhanced with more sophisticated logic
    let aRelevance = a.score;
    let bRelevance = b.score;

    // Boost tool call results
    if (a.type === MemoryType.TOOL_CALL) aRelevance += 0.1;
    if (b.type === MemoryType.TOOL_CALL) bRelevance += 0.1;

    // Boost recent results
    const aTime = new Date(a.metadata.created).getTime();
    const bTime = new Date(b.metadata.created).getTime();
    const timeDiff = Math.abs(aTime - bTime);
    const daysDiff = timeDiff / (1000 * 60 * 60 * 24);
    
    if (daysDiff < 1) {
      if (aTime > bTime) aRelevance += 0.05;
      else bRelevance += 0.05;
    }

    return bRelevance - aRelevance;
  }

  private generateHighlights(
    result: MemorySearchResult, 
    query: string, 
    options: { maxHighlights: number; highlightLength: number; caseSensitive: boolean; wholeWord: boolean }
  ): SearchHighlight[] {
    const highlights: SearchHighlight[] = [];
    const searchQuery = options.caseSensitive ? query : query.toLowerCase();
    
    // Search in different fields
    const searchFields = [
      { field: 'highlight', content: result.highlight },
      { field: 'context.match', content: result.context.match },
      { field: 'context.before', content: result.context.before },
      { field: 'context.after', content: result.context.after }
    ];

    for (const { field, content } of searchFields) {
      if (highlights.length >= options.maxHighlights) break;
      
      const searchContent = options.caseSensitive ? content : content.toLowerCase();
      let index = searchContent.indexOf(searchQuery);
      
      while (index !== -1 && highlights.length < options.maxHighlights) {
        const start = Math.max(0, index - 20);
        const end = Math.min(content.length, index + searchQuery.length + 20);
        
        highlights.push({
          field,
          start: index,
          end: index + searchQuery.length,
          text: content.substring(index, index + searchQuery.length),
          context: content.substring(start, end)
        });
        
        index = searchContent.indexOf(searchQuery, index + 1);
      }
    }

    return highlights.slice(0, options.maxHighlights);
  }

  private getScoreRange(score: number): string {
    if (score >= 0.9) return '0.9-1.0';
    if (score >= 0.8) return '0.8-0.9';
    if (score >= 0.7) return '0.7-0.8';
    if (score >= 0.6) return '0.6-0.7';
    if (score >= 0.5) return '0.5-0.6';
    return '0.0-0.5';
  }

  private calculateStandardDeviation(values: number[]): number {
    if (values.length === 0) return 0;
    
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
    const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
    
    return Math.sqrt(avgSquaredDiff);
  }
}
```

## agents/vaultLibrarian/services/index.ts

```typescript
/**
 * Vault Librarian Services Barrel Export
 * 
 * Location: src/agents/vaultLibrarian/services/index.ts  
 * Purpose: Centralizes all vault librarian service exports
 */

export { MemorySearchProcessor } from './MemorySearchProcessor';
export type { MemorySearchProcessorInterface } from './MemorySearchProcessor';
export { MemorySearchFilters } from './MemorySearchFilters';
export type { MemorySearchFiltersInterface } from './MemorySearchFilters';
export { ResultFormatter } from './ResultFormatter';
export type { ResultFormatterInterface } from './ResultFormatter';
```

## agents/vaultLibrarian/types.ts

```typescript
import { CommonParameters, CommonResult } from '../../types';





/**
 * Graph boost options for enhancing search results using graph connections
 * Note: Graph boost is now hardcoded into the RRF calculation with sensible defaults
 * These options are maintained for internal use but no longer exposed to users
 */
export interface GraphBoostOptions {
  // Internal parameters - no longer user-facing since graph boost is hardcoded
}


/**
 * Universal search category types
 */
export type CategoryType = 
  | 'files'
  | 'folders' 
  | 'content'
  | 'workspaces'
  | 'sessions'
  | 'snapshots'
  | 'memory_traces'
  | 'tags'
  | 'properties';

/**
 * Universal search parameters
 */
export interface UniversalSearchParams extends CommonParameters, GraphBoostOptions {
  /**
   * Search query across all content types
   * Supports metadata filtering syntax: "tag:javascript priority:high content query"
   */
  query: string;

  /**
   * Search strategy type - controls weighting of semantic/keyword/fuzzy search methods
   * - 'exact': 70% keyword, 20% semantic, 10% fuzzy (for specific terms)
   * - 'conceptual': 60% semantic, 30% keyword, 10% fuzzy (for topics)
   * - 'exploratory': 80% semantic, 15% fuzzy, 5% keyword (for questions)
   * - 'mixed': 40% semantic, 40% keyword, 20% fuzzy (balanced)
   */
  queryType?: 'exact' | 'conceptual' | 'exploratory' | 'mixed';
  
  /**
   * Maximum number of results per category (default: 10)
   */
  limit?: number;
  
  /**
   * Categories to exclude from search
   */
  excludeCategories?: CategoryType[];
  
  /**
   * Categories to prioritize (return more results)
   */
  prioritizeCategories?: CategoryType[];
  
  /**
   * Paths to restrict search to
   */
  paths?: string[];
  
  /**
   * Whether to include content snippets in results (default: true)
   */
  includeContent?: boolean;
  
  /**
   * Length of context window around search matches (in characters)
   * Creates snippets with this many characters before and after the match
   * Required parameter for all searches
   */
  snippetLength: number;
  
  /**
   * Force semantic search even if traditional might be better (default: auto-detect)
   */
  forceSemanticSearch?: boolean;
  
  /**
   * Additional metadata filters (alternative to query syntax)
   */
  metadataFilters?: {
    /**
     * Tags to filter by (AND logic if multiple)
     */
    tags?: string[];
    
    /**
     * Properties to filter by (field: value pairs)
     */
    properties?: Record<string, any>;
    
    /**
     * Logic operator for combining filters ('AND' | 'OR')
     */
    operator?: 'AND' | 'OR';
  };
}

/**
 * Search result item for any category
 */
export interface UniversalSearchResultItem {
  /**
   * Item identifier (file path, workspace id, etc.)
   */
  id: string;
  
  /**
   * Display title/name
   */
  title: string;
  
  /**
   * Content snippet or description
   */
  snippet?: string;
  
  /**
   * Search relevance score (0-1)
   */
  score: number;
  
  /**
   * Search method used for this result
   */
  searchMethod: 'semantic' | 'fuzzy' | 'exact' | 'hybrid';
  
  /**
   * Category-specific metadata
   */
  metadata?: Record<string, any>;
  
  /**
   * File metadata (tags, properties) if applicable
   */
  fileMetadata?: {
    tags?: string[];
    properties?: Record<string, any>;
    aliases?: string[];
  };
  
  /**
   * Full content (if includeContent is true)
   */
  content?: string;
}

/**
 * Search results for a specific category
 */
export interface SearchResultCategory {
  /**
   * Total number of results found in this category
   */
  count: number;
  
  /**
   * Top results (up to limit)
   */
  results: UniversalSearchResultItem[];
  
  /**
   * Whether more results are available beyond the limit
   */
  hasMore: boolean;
  
  /**
   * Primary search method used for this category
   */
  searchMethod: 'semantic' | 'fuzzy' | 'exact' | 'hybrid';
  
  /**
   * Whether semantic search was available for this category
   */
  semanticAvailable: boolean;
}

/**
 * Universal search results organized by category
 */
export interface UniversalSearchResult extends CommonResult {
  /**
   * Original search query
   */
  query: string;
  
  /**
   * Total number of results across all categories
   */
  totalResults: number;
  
  /**
   * Search execution time in milliseconds
   */
  executionTime: number;
  
  /**
   * Results organized by category
   */
  categories: {
    files?: SearchResultCategory;
    folders?: SearchResultCategory;
    content?: SearchResultCategory;
    workspaces?: SearchResultCategory;
    sessions?: SearchResultCategory;
    snapshots?: SearchResultCategory;
    memory_traces?: SearchResultCategory;
    tags?: SearchResultCategory;
    properties?: SearchResultCategory;
  };
  
  /**
   * Overall search strategy information
   */
  searchStrategy: {
    semanticAvailable: boolean;
    categoriesSearched: CategoryType[];
    categoriesExcluded: CategoryType[];
    fallbacksUsed: CategoryType[];
    metadataFiltersApplied?: {
      tags?: string[];
      properties?: Record<string, any>;
      operator?: 'AND' | 'OR';
      filesFilteredByMetadata?: number;
    };
  };
  
  /**
   * Suggested prompt for using ContentManager's batchContent mode to read the most relevant files
   * This encourages deeper exploration of search results by reading full file contents
   */
  contextPrompt?: string;
}

/**
 * Batch universal search parameters
 */
export interface BatchUniversalSearchParams extends CommonParameters {
  /**
   * Array of universal search queries to execute
   */
  searches: UniversalSearchParams[];
  
  /**
   * Whether to merge all results into a single response
   */
  mergeResults?: boolean;
  
  /**
   * Maximum concurrent searches to execute (default: 5)
   */
  maxConcurrency?: number;
}

/**
 * Batch universal search results
 */
export interface BatchUniversalSearchResult extends CommonResult {
  /**
   * Individual search results (if mergeResults is false)
   */
  searches?: UniversalSearchResult[];
  
  /**
   * Merged search results (if mergeResults is true)
   */
  merged?: {
    totalQueries: number;
    totalResults: number;
    combinedCategories: {
      files?: SearchResultCategory;
      folders?: SearchResultCategory;
      content?: SearchResultCategory;
      workspaces?: SearchResultCategory;
      sessions?: SearchResultCategory;
      snapshots?: SearchResultCategory;
      memory_traces?: SearchResultCategory;
      tags?: SearchResultCategory;
      properties?: SearchResultCategory;
    };
  };
  
  /**
   * Execution statistics
   */
  stats: {
    totalExecutionTimeMS: number;
    queriesExecuted: number;
    queriesFailed: number;
    avgExecutionTimeMS: number;
  };
}


```

## agents/vaultLibrarian/vaultLibrarian.ts

```typescript
import { App } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import { VaultLibrarianConfig } from '../../config/agents';
import {
  SearchContentMode,
  SearchDirectoryMode,
  SearchMemoryMode,
  BatchMode
} from './modes';
import { MemorySettings, DEFAULT_MEMORY_SETTINGS } from '../../types';
import { MemoryService } from "../memoryManager/services/MemoryService";
import { WorkspaceService } from "../memoryManager/services/WorkspaceService";
import { getErrorMessage } from '../../utils/errorUtils';

/**
 * Agent for searching and navigating the vault
 * Provides comprehensive search capabilities across vault content
 */
export class VaultLibrarianAgent extends BaseAgent {
  public app: App;
  private memoryService: MemoryService | null = null;
  private workspaceService: WorkspaceService | null = null;
  private settings: MemorySettings;
  
  /**
   * Create a new VaultLibrarianAgent
   * @param app Obsidian app instance
   * @param enableVectorModes Whether to enable vector-based modes (legacy parameter)
   */
  constructor(app: App, enableVectorModes = false) {
    super(
      VaultLibrarianConfig.name,
      VaultLibrarianConfig.description,
      VaultLibrarianConfig.version
    );
    
    this.app = app;
    
    // Initialize with default settings
    this.settings = { ...DEFAULT_MEMORY_SETTINGS };
    
    
    // Define plugin using safe type check
    let plugin: any = null;
    try {
      if (app.plugins) {
        plugin = app.plugins.getPlugin('claudesidian-mcp');
        if (plugin) {
          // Plugin instance found
          // Safely access settings
          const pluginAny = plugin as any;
          const memorySettings = pluginAny.settings?.settings?.memory;
          if (memorySettings) {
            this.settings = memorySettings;
          }
          
          // Access services from ServiceContainer (new pattern)
          try {
            // Use ServiceContainer getIfReady to avoid waiting for initialization
            if (pluginAny.serviceContainer) {
              this.memoryService = pluginAny.serviceContainer.getIfReady('memoryService');
              this.workspaceService = pluginAny.serviceContainer.getIfReady('workspaceService');
                        }
          } catch (error) {
            console.warn('[VaultLibrarian] Failed to access services:', error);
          }
        }
      }
    } catch (error) {
      console.warn('[VaultLibrarian] Failed to access plugin services:', error);
    }
    
    // Register ContentSearchMode (fuzzy + keyword search using native Obsidian APIs)
    this.registerMode(new SearchContentMode(
      plugin || ({ app } as any) // Fallback to minimal plugin interface if not found
    ));
    
    // Register focused search modes with enhanced validation and service integration
    this.registerMode(new SearchDirectoryMode(
      plugin || ({ app } as any),
      this.workspaceService || undefined
    ));
    
    
    this.registerMode(new SearchMemoryMode(
      plugin || ({ app } as any),
      this.memoryService || undefined,
      this.workspaceService || undefined
    ));
    
    // Always register BatchMode (supports both semantic and non-semantic users)
    this.registerMode(new BatchMode(
      plugin || ({ app } as any), // Fallback to minimal plugin interface if not found
      this.memoryService || undefined,
      this.workspaceService || undefined
    ));
    
    
  }
  
  
  /**
   * Update the agent settings
   * @param settings New memory settings
   */
  async updateSettings(settings: MemorySettings): Promise<void> {
    this.settings = settings;
  }
  
  /**
   * Initialize the VaultLibrarianAgent
   * This is called after the agent is registered with the agent manager
   */
  async initialize(): Promise<void> {
    await super.initialize();
    
    // Initialize search service in background - non-blocking
    this.initializeSearchService().catch(error => {
    });
  }
  
  /**
   * Initialize the search service
   */
  async initializeSearchService(): Promise<void> {
    // Search service initialization for JSON-based storage
  }

  
  /**
   * Clean up resources when the agent is unloaded
   */
  onunload(): void {
    try {
      // Call parent class onunload if it exists
      super.onunload?.();
    } catch (error) {
    }
  }
}
```

## agents/vaultManager/modes/baseDirectoryMode.ts

```typescript
import { App, TFolder } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { CommonParameters, CommonResult } from '../../../types';

/**
 * Base class for directory listing operations
 * Provides common functionality for modes that work with directories
 */
export abstract class BaseDirectoryMode<T extends CommonParameters, R extends CommonResult> extends BaseMode<T, R> {
  protected app: App;
  
  constructor(slug: string, name: string, description: string, version: string, app: App) {
    super(slug, name, description, version);
    this.app = app;
  }
  
  /**
   * Normalize directory path by removing leading slash and handling special cases for root
   * @param path Path to normalize
   * @returns Normalized path (empty string for root)
   */
  protected normalizeDirectoryPath(path: string): string {
    // Handle special cases for root directory
    if (!path || path === '/' || path === '.') {
      return '';
    }
    // Remove leading slash if present
    return path.startsWith('/') ? path.slice(1) : path;
  }
  
  /**
   * Get a folder from the vault by path
   * @param path Directory path (normalized or not)
   * @returns TFolder instance
   * @throws Error if folder not found
   */
  protected async getFolder(path: string): Promise<TFolder> {
    const normalizedPath = this.normalizeDirectoryPath(path);
    
    // Handle root directory case
    if (normalizedPath === '') {
      return this.app.vault.getRoot();
    }
    
    // Get folder by path - use getAbstractFileByPath for folders
    const folder = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder || !(folder instanceof TFolder)) {
      // Double check by looking at the exact path without any modifications
      throw new Error(`Folder not found at path: ${normalizedPath}`);
    }
    
    return folder;
  }
  
  /**
   * Get standardized directory path schema for JSON schema
   * @returns Schema object for directory path parameter
   */
  protected getDirectoryPathSchema(): any {
    return {
      type: 'string',
      description: 'Directory path (required). Use empty string (""), "/" or "." for root directory',
      default: ''
    };
  }
  
  /**
   * Generate helpful message for root directory operations
   * @param normalizedPath The normalized path (empty string indicates root)
   * @param operationType Type of operation being performed
   * @returns Helpful message or undefined
   */
  protected getRootDirectoryMessage(normalizedPath: string, operationType: string): string | undefined {
    if (normalizedPath === '') {
      return `${operationType} in root directory only. This may not include all items in the vault - many may be organized in subfolders. Use listFolders mode to explore the full vault structure.`;
    }
    return undefined;
  }
}

```

## agents/vaultManager/modes/createFolderMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { CommonParameters, CommonResult } from '../../../types';
import { FileOperations } from '../utils/FileOperations';
import { MemoryService } from "../../memoryManager/services/MemoryService";
import {parseWorkspaceContext} from '../../../utils/contextUtils';
import { createErrorMessage } from '../../../utils/errorUtils';

/**
 * Parameters for create folder mode
 */
interface CreateFolderParameters extends CommonParameters {
  /**
   * Path of the folder to create
   */
  path: string;
}

/**
 * Result for create folder mode
 */
interface CreateFolderResult extends CommonResult {
  data?: {
    path: string;
    existed?: boolean;
  };
}

/**
 * Mode to create a new folder
 */
export class CreateFolderMode extends BaseMode<CreateFolderParameters, CreateFolderResult> {
  private app: App;
  private memoryService: MemoryService | null = null;
  
  /**
   * Create a new CreateFolderMode
   * @param app Obsidian app instance
   * @param memoryService Optional memory service for activity recording
   */
  constructor(app: App, memoryService?: MemoryService | null) {
    super(
      'createFolder',
      'Create Folder',
      'Create a new folder in the vault',
      '1.0.0'
    );
    this.app = app;
    this.memoryService = memoryService || null;
    
    // Try to get memory service from plugin if not provided
    if (!this.memoryService) {
      try {
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
        }
      } catch (error) {
        console.error('Failed to get memory service:', error);
      }
    }
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise resolving to the result
   */
  async execute(params: CreateFolderParameters): Promise<CreateFolderResult> {
    try {
      // Validate parameters
      if (!params.path) {
        return this.prepareResult(false, undefined, 'Path is required');
      }
      
      // Create the folder using existing utility if available
      let result: { path: string; existed: boolean };
      
      if (typeof FileOperations?.createFolder === 'function') {
        const existed = await FileOperations.createFolder(this.app, params.path);
        result = { path: params.path, existed };
      } 
      // Otherwise use default implementation
      else {
        // Check if folder already exists
        const existingFolder = this.app.vault.getAbstractFileByPath(params.path);
        if (existingFolder) {
          result = { path: params.path, existed: true };
        } else {
          // Create the folder
          await this.app.vault.createFolder(params.path);
          result = { path: params.path, existed: false };
        }
      }
      
      // Record this activity in workspace memory if applicable
      const parsedContext = parseWorkspaceContext(params.workspaceContext) || undefined;
  if (parsedContext?.workspaceId) {
        await this.recordActivity(params, result);
      }
      
      return this.prepareResult(true, result, undefined, params.context, parseWorkspaceContext(params.workspaceContext) || undefined);
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Failed to create folder: ', error));
    }
  }
  
  /**
   * Get the parameter schema
   */
  getParameterSchema(): Record<string, any> {
    // Create the mode-specific schema
    const modeSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path of the folder to create (REQUIRED)'
        }
      },
      required: ['path']
    };
    
    // Merge with common schema (workspace context)
    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Record folder creation activity in workspace memory
   * @param params Parameters used for folder creation
   * @param result Result of folder creation operation
   */
  private async recordActivity(
    params: CreateFolderParameters, 
    result: { path: string; existed: boolean }
  ): Promise<void> {
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(params.workspaceContext) || undefined;
    
    if (!parsedContext?.workspaceId || !this.memoryService) {
      return; // Skip if no workspace context or memory service
    }
    
    try {
      // Create a descriptive content about this operation
      const content = `${result.existed ? 'Found existing' : 'Created new'} folder: ${params.path}`;
      
      // Record the activity using memory service
      await this.memoryService.recordActivityTrace({
        workspaceId: parsedContext.workspaceId,
        type: 'research', // Using supported activity type
        content,
        timestamp: Date.now(),
          metadata: {
            tool: 'CreateFolderMode',
            params: {
              path: params.path
            },
            result: {
              existed: result.existed
            },
            relatedFiles: []
          },
          sessionId: params.context.sessionId
        }
      );
    } catch (error) {
      // Log but don't fail the main operation
      console.error('Failed to record folder creation activity:', createErrorMessage('', error));
      
      // Try to get memory service from plugin if not available
      if (!this.memoryService) {
        try {
          const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
          if (plugin?.services?.memoryService) {
            this.memoryService = plugin.services.memoryService;
            // Try again with the newly found service
            await this.recordActivity(params, result);
          }
        } catch (retryError) {
          console.error('Error accessing memory service for retry:', createErrorMessage('', retryError));
        }
      }
    }
  }

  /**
   * Get the result schema
   */
  getResultSchema(): Record<string, any> {
    const baseSchema = super.getResultSchema();
    
    // Extend the base schema to include our specific data
    baseSchema.properties.data = {
      type: 'object',
      properties: {
        path: { 
          type: 'string',
          description: 'Path of the created folder'
        },
        existed: {
          type: 'boolean',
          description: 'Whether the folder already existed'
        }
      }
    };
    
    return baseSchema;
  }
}

```

## agents/vaultManager/modes/deleteFolderMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { DeleteFolderArgs, DeleteFolderResult } from '../types';
import { FileOperations } from '../utils/FileOperations';
import { createErrorMessage } from '../../../utils/errorUtils';

/**
 * Mode for deleting a folder
 */
export class DeleteFolderMode extends BaseMode<DeleteFolderArgs, DeleteFolderResult> {
  private app: App;
  
  /**
   * Create a new DeleteFolderMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'deleteFolder',
      'Delete Folder',
      'Delete a folder',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the result of deleting the folder
   */
  async execute(params: DeleteFolderArgs): Promise<DeleteFolderResult> {
    const { path, recursive } = params;
    
    try {
      await FileOperations.deleteFolder(this.app, path, recursive);
      
      return {
        path,
        success: true
      };
    } catch (error) {
      return {
        path,
        success: false,
        error: createErrorMessage('Failed to delete folder: ', error)
      };
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the folder'
        },
        recursive: {
          type: 'boolean',
          description: 'Whether to delete recursively'
        }
      },
      required: ['path'],
      description: 'Delete a folder'
    };
    
    // Merge with common schema (sessionId and context)
    return this.getMergedSchema(modeSchema);
  }
}

```

## agents/vaultManager/modes/deleteNoteMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { DeleteNoteArgs, DeleteNoteResult } from '../types';
import { FileOperations } from '../utils/FileOperations';
import { createErrorMessage } from '../../../utils/errorUtils';

/**
 * Mode for deleting a note
 */
export class DeleteNoteMode extends BaseMode<DeleteNoteArgs, DeleteNoteResult> {
  private app: App;
  
  /**
   * Create a new DeleteNoteMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'deleteNote',
      'Delete Note',
      'Delete a note from the vault',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the result of deleting the note
   */
  async execute(params: DeleteNoteArgs): Promise<DeleteNoteResult> {
    const { path } = params;
    
    try {
      await FileOperations.deleteNote(this.app, path);
      
      return {
        path,
        success: true
      };
    } catch (error) {
      return {
        path,
        success: false,
        error: createErrorMessage('Failed to delete note: ', error)
      };
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the note to delete'
        }
      },
      required: ['path'],
      description: 'Delete a note from the vault'
    };
    
    // Merge with common schema (sessionId and context)
    return this.getMergedSchema(modeSchema);
  }
}
```

## agents/vaultManager/modes/duplicateNoteMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { DuplicateNoteArgs, DuplicateNoteResult } from '../types';
import { FileOperations } from '../utils/FileOperations';
import { MemoryService } from "../../memoryManager/services/MemoryService";
import { parseWorkspaceContext } from '../../../utils/contextUtils';
import { createErrorMessage } from '../../../utils/errorUtils';
import { addRecommendations, Recommendation } from '../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../utils/nudgeHelpers';

/**
 * Mode for duplicating a note
 */
export class DuplicateNoteMode extends BaseMode<DuplicateNoteArgs, DuplicateNoteResult> {
  private app: App;
  private memoryService: MemoryService | null = null;
  
  /**
   * Create a new DuplicateNoteMode
   * @param app Obsidian app instance
   * @param memoryService Optional memory service for activity recording
   */
  constructor(app: App, memoryService?: MemoryService | null) {
    super(
      'duplicateNote',
      'Duplicate Note',
      'Create a duplicate of an existing note',
      '1.0.0'
    );
    
    this.app = app;
    this.memoryService = memoryService || null;
    
    // Try to get memory service from plugin if not provided
    if (!this.memoryService) {
      try {
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
        }
      } catch (error) {
        console.error('Failed to get memory service:', error);
      }
    }
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the result of duplicating the note
   */
  async execute(params: DuplicateNoteArgs): Promise<DuplicateNoteResult> {
    try {
      // Validate parameters
      if (!params.sourcePath) {
        return {
          sourcePath: '',
          targetPath: '',
          success: false,
          error: 'Source path is required'
        };
      }
      
      if (!params.targetPath) {
        return {
          sourcePath: params.sourcePath,
          targetPath: '',
          success: false,
          error: 'Target path is required'
        };
      }
      
      // Perform the duplication
      const result = await FileOperations.duplicateNote(
        this.app,
        params.sourcePath,
        params.targetPath,
        params.overwrite || false,
        params.autoIncrement || false
      );
      
      // Record activity in workspace memory if applicable
      await this.recordActivity(params, result);
      
      const response = {
        sourcePath: result.sourcePath,
        targetPath: result.targetPath,
        success: true,
        wasAutoIncremented: result.wasAutoIncremented,
        wasOverwritten: result.wasOverwritten
      };

      // Generate nudges for duplicate operations
      const nudges = this.generateDuplicateNudges();
      
      return addRecommendations(response, nudges);
    } catch (error) {
      return {
        sourcePath: params.sourcePath || '',
        targetPath: params.targetPath || '',
        success: false,
        error: createErrorMessage('Failed to duplicate note: ', error)
      };
    }
  }
  
  /**
   * Record note duplication activity in workspace memory
   * @param params Parameters used for note duplication
   * @param result Result of duplication operation
   */
  private async recordActivity(
    params: DuplicateNoteArgs,
    result: {
      sourcePath: string;
      targetPath: string;
      wasAutoIncremented: boolean;
      wasOverwritten: boolean;
    }
  ): Promise<void> {
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(params.workspaceContext);
    
    if (!parsedContext?.workspaceId || !this.memoryService) {
      return; // Skip if no workspace context or memory service
    }
    
    try {
      // Create a descriptive content about this operation
      let action = 'Duplicated';
      if (result.wasOverwritten) {
        action += ' (overwritten target)';
      } else if (result.wasAutoIncremented) {
        action += ' (auto-incremented name)';
      }
      
      const content = `${action} note from ${result.sourcePath} to ${result.targetPath}`;
      
      // Record the activity using memory service
      await this.memoryService.recordActivityTrace({
        workspaceId: parsedContext.workspaceId,
        type: 'research', // Using supported activity type
        content,
        timestamp: Date.now(),
          metadata: {
            tool: 'DuplicateNoteMode',
            params: {
              sourcePath: params.sourcePath,
              targetPath: params.targetPath,
              overwrite: params.overwrite,
              autoIncrement: params.autoIncrement
            },
            result: {
              finalTargetPath: result.targetPath,
              wasAutoIncremented: result.wasAutoIncremented,
              wasOverwritten: result.wasOverwritten
            },
            relatedFiles: [result.sourcePath, result.targetPath]
          },
          sessionId: params.context.sessionId
        }
      );
    } catch (error) {
      // Log but don't fail the main operation
      console.error('Failed to record note duplication activity:', createErrorMessage('', error));
      
      // Try to get memory service from plugin if not available
      if (!this.memoryService) {
        try {
          const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
          if (plugin?.services?.memoryService) {
            this.memoryService = plugin.services.memoryService;
            // Try again with the newly found service
            await this.recordActivity(params, result);
          }
        } catch (retryError) {
          console.error('Error accessing memory service for retry:', createErrorMessage('', retryError));
        }
      }
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    // Create the mode-specific schema
    const modeSchema = {
      type: 'object',
      properties: {
        sourcePath: {
          type: 'string',
          description: 'Path to the source note to duplicate (REQUIRED)'
        },
        targetPath: {
          type: 'string',
          description: 'Path for the duplicate note (REQUIRED)'
        },
        overwrite: {
          type: 'boolean',
          description: 'Whether to overwrite if target already exists',
          default: false
        },
        autoIncrement: {
          type: 'boolean',
          description: 'Whether to auto-increment filename if target exists (takes precedence over overwrite)',
          default: false
        }
      },
      required: ['sourcePath', 'targetPath']
    };
    
    // Merge with common schema (workspace context)
    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the result schema
   */
  getResultSchema(): Record<string, any> {
    const baseSchema = super.getResultSchema();
    
    // Extend the base schema to include our specific data
    baseSchema.properties.data = {
      type: 'object',
      properties: {
        sourcePath: { 
          type: 'string',
          description: 'Path of the source note'
        },
        targetPath: {
          type: 'string',
          description: 'Final path of the duplicated note'
        },
        wasAutoIncremented: {
          type: 'boolean',
          description: 'Whether the filename was auto-incremented due to conflicts'
        },
        wasOverwritten: {
          type: 'boolean',
          description: 'Whether an existing file was overwritten'
        }
      }
    };
    
    return baseSchema;
  }

  /**
   * Generate nudges for duplicate operations
   */
  private generateDuplicateNudges(): Recommendation[] {
    const nudges: Recommendation[] = [];

    // Always suggest customization after duplicating files
    nudges.push(NudgeHelpers.suggestCustomization());

    return nudges;
  }
}

```

## agents/vaultManager/modes/editFolderMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { CommonParameters, CommonResult } from '../../../types';
import { createErrorMessage } from '../../../utils/errorUtils';

/**
 * Arguments for editing a folder
 */
export interface EditFolderArgs extends CommonParameters {
  /**
   * Path to the folder to edit
   */
  path: string;
  
  /**
   * New path for the folder
   */
  newPath: string;
}

/**
 * Result of editing a folder
 */
export interface EditFolderResult extends CommonResult {
  /**
   * Path to the folder
   */
  path?: string;
  
  /**
   * New path for the folder
   */
  newPath?: string;
}

/**
 * Mode for editing a folder
 */
export class EditFolderMode extends BaseMode<EditFolderArgs, EditFolderResult> {
  private app: App;
  
  /**
   * Create a new EditFolderMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'editFolder',
      'Edit Folder',
      'Edit a folder in the vault',
      '1.0.0'
    );
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise resolving to the result
   */
  async execute(params: EditFolderArgs): Promise<EditFolderResult> {
    try {
      if (!params.path) {
        return {
          success: false,
          error: 'Path is required'
        };
      }
      
      if (!params.newPath) {
        return {
          success: false,
          error: 'New path is required'
        };
      }
      
      // Rename the folder using the Obsidian Vault API
      try {
        await this.app.vault.adapter.rename(params.path, params.newPath);
      } catch (renameError) {
        return {
          success: false,
          error: createErrorMessage('Failed to rename folder: ', renameError)
        };
      }
      
      return {
        success: true,
        path: params.path,
        newPath: params.newPath
      };
    } catch (error) {
      return {
        success: false,
        error: createErrorMessage('Failed to edit folder: ', error)
      };
    }
  }
  
  /**
   * Get the parameter schema
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the folder to edit'
        },
        newPath: {
          type: 'string',
          description: 'New path for the folder'
        }
      },
      required: ['path', 'newPath']
    };
    
    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the result schema
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation was successful'
        },
        error: {
          type: 'string',
          description: 'Error message if operation failed'
        },
        path: {
          type: 'string',
          description: 'Path to the folder'
        },
        newPath: {
          type: 'string',
          description: 'New path for the folder'
        }
      },
      required: ['success']
    };
  }
}
```

## agents/vaultManager/modes/index.ts

```typescript
export * from './listDirectoryMode';
export * from './createFolderMode';
export * from './editFolderMode';
export * from './deleteFolderMode';
export * from './deleteNoteMode';
export * from './moveNoteMode';
export * from './moveFolderMode';
export * from './duplicateNoteMode';
export * from './openNoteMode';

```

## agents/vaultManager/modes/listDirectoryMode.ts

```typescript
import { App, TFile, TFolder } from 'obsidian';
import { BaseDirectoryMode } from './baseDirectoryMode';
import { CommonParameters, CommonResult } from '../../../types';
import { createErrorMessage } from '../../../utils/errorUtils';
import { filterByName, FILTER_DESCRIPTION } from '../../../utils/filterUtils';
import { parseWorkspaceContext } from '../../../utils/contextUtils';

/**
 * Parameters for list directory mode
 */
interface ListDirectoryParameters extends CommonParameters {
  /**
   * Directory path to list contents from (required)
   * Use empty string (""), "/" or "." for root directory
   */
  path: string;
  
  /**
   * Optional filter pattern for files and folders
   */
  filter?: string;
  
  /**
   * Recursive depth for directory traversal (optional)
   * 0 = only current directory (default)
   * 1 = current directory + immediate subdirectories
   * 2 = current directory + subdirectories + their subdirectories
   * etc.
   */
  depth?: number;
  
  /**
   * Whether to include files in the results (default: true)
   */
  includeFiles?: boolean;
  
  /**
   * Whether to include folders in the results (default: true)
   */
  includeFolders?: boolean;
  
  /**
   * Shortcut to only return files (sets includeFiles=true, includeFolders=false)
   */
  filesOnly?: boolean;
  
  /**
   * Shortcut to only return folders (sets includeFiles=false, includeFolders=true)
   */
  foldersOnly?: boolean;
}

/**
 * Result for list directory mode
 */
interface ListDirectoryResult extends CommonResult {
  data?: {
    files?: Array<{
      name: string;
      path: string;
      size: number;
      created: number;
      modified: number;
    }>;
    folders?: Array<{
      name: string;
      path: string;
    }>;
    summary?: {
      fileCount: number;
      folderCount: number;
      totalItems: number;
    };
  };
}

/**
 * Mode to list files and/or folders in a directory
 */
export class ListDirectoryMode extends BaseDirectoryMode<ListDirectoryParameters, ListDirectoryResult> {
  
  /**
   * Create a new ListDirectoryMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'listDirectory',
      'List Directory',
      'List files and/or folders in a directory with optional recursive depth',
      '1.0.0',
      app
    );
  }

  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise resolving to the result
   */
  async execute(params: ListDirectoryParameters): Promise<ListDirectoryResult> {
    try {
      // Get the folder using base class method
      const parentFolder = await this.getFolder(params.path);
      const normalizedPath = this.normalizeDirectoryPath(params.path);
      
      // Resolve what to include based on parameters
      const { includeFiles, includeFolders } = this.resolveIncludeOptions(params);
      
      // Get contents recursively based on depth
      const depth = params.depth ?? 0;
      const allFiles = includeFiles ? this.getFilesRecursively(parentFolder, depth) : [];
      const allFolders = includeFolders ? this.getFoldersRecursively(parentFolder, depth) : [];
      
      // Apply filter if provided
      let filteredFiles = allFiles;
      let filteredFolders = allFolders;
      
      if (params.filter) {
        filteredFiles = filterByName(allFiles, params.filter);
        filteredFolders = filterByName(allFolders, params.filter);
      }
      
      // Prepare result data
      const result: any = {};
      
      if (includeFiles) {
        // Map files to required format
        const fileData = filteredFiles.map(file => ({
          name: file.name,
          path: file.path,
          size: file.stat.size,
          created: file.stat.ctime,
          modified: file.stat.mtime
        }));
        
        // Sort files by modified date (newest first)
        fileData.sort((a, b) => b.modified - a.modified);
        result.files = fileData;
      }
      
      if (includeFolders) {
        // Map folders to required format
        const folderData = filteredFolders.map(folder => ({
          name: folder.name,
          path: folder.path
        }));
        
        // Sort folders alphabetically
        folderData.sort((a, b) => a.name.localeCompare(b.name));
        result.folders = folderData;
      }
      
      // Add summary
      result.summary = {
        fileCount: filteredFiles.length,
        folderCount: filteredFolders.length,
        totalItems: filteredFiles.length + filteredFolders.length
      };
      
      // Generate helpful message
      const depthMessage = depth > 0 ? ` (depth: ${depth})` : '';
      const typeMessage = this.getTypeMessage(includeFiles, includeFolders);
      const message = this.getRootDirectoryMessage(normalizedPath, `Listing ${typeMessage}${depthMessage}`);
      
      return this.prepareResult(
        true, 
        result, 
        message, 
        params.context, 
        parseWorkspaceContext(params.workspaceContext, 'default-workspace', params.context) || undefined
      );
      
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Failed to list directory contents: ', error));
    }
  }
  
  /**
   * Resolve include options based on parameters
   */
  private resolveIncludeOptions(params: ListDirectoryParameters): { includeFiles: boolean; includeFolders: boolean } {
    // Handle shortcut parameters first
    if (params.filesOnly) {
      return { includeFiles: true, includeFolders: false };
    }
    
    if (params.foldersOnly) {
      return { includeFiles: false, includeFolders: true };
    }
    
    // Use explicit parameters or defaults
    return {
      includeFiles: params.includeFiles ?? true,
      includeFolders: params.includeFolders ?? true
    };
  }
  
  /**
   * Get type message for the result
   */
  private getTypeMessage(includeFiles: boolean, includeFolders: boolean): string {
    if (includeFiles && includeFolders) {
      return 'directory contents';
    } else if (includeFiles) {
      return 'files';
    } else if (includeFolders) {
      return 'folders';
    } else {
      return 'nothing (no files or folders selected)';
    }
  }
  
  /**
   * Recursively get files up to specified depth
   * @param folder The folder to start from
   * @param depth The maximum depth to traverse (0 = current folder only)
   * @returns Array of files
   */
  private getFilesRecursively(folder: TFolder, depth: number): TFile[] {
    const result: TFile[] = [];
    
    // Get direct children that are files
    const childFiles = (folder.children || []).filter(child => child instanceof TFile) as TFile[];
    result.push(...childFiles);
    
    // If depth > 0, recursively get files from subfolders
    if (depth > 0) {
      const childFolders = (folder.children || []).filter(child => child instanceof TFolder) as TFolder[];
      for (const childFolder of childFolders) {
        const subFiles = this.getFilesRecursively(childFolder, depth - 1);
        result.push(...subFiles);
      }
    }
    
    return result;
  }
  
  /**
   * Recursively get folders up to specified depth
   * @param folder The folder to start from
   * @param depth The maximum depth to traverse (0 = current folder only)
   * @returns Array of folders
   */
  private getFoldersRecursively(folder: TFolder, depth: number): TFolder[] {
    const result: TFolder[] = [];
    
    // Get direct children that are folders
    const childFolders = (folder.children || []).filter(child => child instanceof TFolder) as TFolder[];
    result.push(...childFolders);
    
    // If depth > 0, recursively get subfolders
    if (depth > 0) {
      for (const childFolder of childFolders) {
        const subfolders = this.getFoldersRecursively(childFolder, depth - 1);
        result.push(...subfolders);
      }
    }
    
    return result;
  }
  
  /**
   * Get the parameter schema
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        path: this.getDirectoryPathSchema(),
        filter: {
          type: 'string',
          description: FILTER_DESCRIPTION
        },
        depth: {
          type: 'number',
          description: 'Recursive depth for directory traversal (0 = current directory only, 1 = include immediate subdirectories, 2 = include subdirectories of subdirectories, etc.)',
          minimum: 0,
          default: 0
        },
        includeFiles: {
          type: 'boolean',
          description: 'Whether to include files in the results',
          default: true
        },
        includeFolders: {
          type: 'boolean',
          description: 'Whether to include folders in the results',
          default: true
        },
        filesOnly: {
          type: 'boolean',
          description: 'Shortcut to only return files (overrides includeFiles/includeFolders)',
          default: false
        },
        foldersOnly: {
          type: 'boolean',
          description: 'Shortcut to only return folders (overrides includeFiles/includeFolders)',
          default: false
        }
      },
      required: ['path']
    };
    
    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the result schema
   */
  getResultSchema(): any {
    const baseSchema = super.getResultSchema();
    
    // Extend the base schema to include our specific data
    baseSchema.properties.data = {
      type: 'object',
      properties: {
        files: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              path: { type: 'string' },
              size: { type: 'number' },
              created: { type: 'number' },
              modified: { type: 'number' }
            }
          }
        },
        folders: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              path: { type: 'string' }
            }
          }
        },
        summary: {
          type: 'object',
          properties: {
            fileCount: { type: 'number' },
            folderCount: { type: 'number' },
            totalItems: { type: 'number' }
          }
        }
      }
    };
    
    return baseSchema;
  }
}
```

## agents/vaultManager/modes/moveFolderMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { MoveFolderArgs, MoveFolderResult } from '../types';
import { FileOperations } from '../utils/FileOperations';
import { createErrorMessage } from '../../../utils/errorUtils';

/**
 * Mode for moving a folder
 */
export class MoveFolderMode extends BaseMode<MoveFolderArgs, MoveFolderResult> {
  private app: App;
  
  /**
   * Create a new MoveFolderMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'moveFolder',
      'Move Folder',
      'Move a folder to a new location',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the result of moving the folder
   */
  async execute(params: MoveFolderArgs): Promise<MoveFolderResult> {
    const { path, newPath, overwrite } = params;
    
    try {
      await FileOperations.moveFolder(this.app, path, newPath, overwrite);
      
      return {
        path,
        newPath,
        success: true
      };
    } catch (error) {
      return {
        path,
        newPath,
        success: false,
        error: createErrorMessage('Failed to move folder: ', error)
      };
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the folder'
        },
        newPath: {
          type: 'string',
          description: 'New path for the folder'
        },
        overwrite: {
          type: 'boolean',
          description: 'Whether to overwrite if a folder already exists at the new path'
        }
      },
      required: ['path', 'newPath'],
      description: 'Move a folder to a new location'
    };
    
    // Merge with common schema (sessionId and context)
    return this.getMergedSchema(modeSchema);
  }
}

```

## agents/vaultManager/modes/moveNoteMode.ts

```typescript
import { App } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { MoveNoteArgs, MoveNoteResult } from '../types';
import { FileOperations } from '../utils/FileOperations';
import { createErrorMessage } from '../../../utils/errorUtils';
import { addRecommendations, Recommendation } from '../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../utils/nudgeHelpers';

/**
 * Mode for moving a note
 */
export class MoveNoteMode extends BaseMode<MoveNoteArgs, MoveNoteResult> {
  private app: App;
  
  /**
   * Create a new MoveNoteMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'moveNote',
      'Move Note',
      'Move a note to a new location',
      '1.0.0'
    );
    
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with the result of moving the note
   */
  async execute(params: MoveNoteArgs): Promise<MoveNoteResult> {
    const { path, newPath, overwrite } = params;
    
    try {
      await FileOperations.moveNote(this.app, path, newPath, overwrite);
      
      const result = {
        path,
        newPath,
        success: true
      };

      // Generate nudges for move operations
      const nudges = this.generateMoveNudges();
      
      return addRecommendations(result, nudges);
    } catch (error) {
      return {
        path,
        newPath,
        success: false,
        error: createErrorMessage('Failed to move note: ', error)
      };
    }
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the note'
        },
        newPath: {
          type: 'string',
          description: 'New path for the note'
        },
        overwrite: {
          type: 'boolean',
          description: 'Whether to overwrite if a note already exists at the new path'
        }
      },
      required: ['path', 'newPath'],
      description: 'Move a note to a new location'
    };
    
    // Merge with common schema (sessionId and context)
    return this.getMergedSchema(modeSchema);
  }

  /**
   * Generate nudges for move operations
   */
  private generateMoveNudges(): Recommendation[] {
    const nudges: Recommendation[] = [];

    // Always suggest link checking after moving files
    nudges.push(NudgeHelpers.suggestLinkChecking());

    return nudges;
  }
}

```

## agents/vaultManager/modes/openNoteMode.ts

```typescript
import { App, TFile, WorkspaceLeaf } from 'obsidian';
import { BaseMode } from '../../baseMode';
import { CommonParameters, CommonResult } from '../../../types';
import { createErrorMessage } from '../../../utils/errorUtils';
import { smartNormalizePath } from '../../../utils/pathUtils';
import { parseWorkspaceContext } from '../../../utils/contextUtils';
/**
 * Parameters for open note mode
 */
interface OpenNoteParameters extends CommonParameters {
  /**
   * Path to the note to open
   */
  path: string;
  
  /**
   * Where to open the note
   * - 'tab': Open in new tab
   * - 'split': Open in horizontal split
   * - 'window': Open in new window
   * - 'current': Open in current tab (default)
   */
  mode?: 'tab' | 'split' | 'window' | 'current';
  
  /**
   * Whether to focus the opened note
   */
  focus?: boolean;
}

/**
 * Result for open note mode
 */
interface OpenNoteResult extends CommonResult {
  data?: {
    path: string;
    opened: boolean;
    mode: string;
  };
}

/**
 * Mode to open a note in the vault
 */
export class OpenNoteMode extends BaseMode<OpenNoteParameters, OpenNoteResult> {
  private app: App;
  
  /**
   * Create a new OpenNoteMode
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'openNote',
      'Open Note',
      'Open a note in the vault',
      '1.0.0'
    );
    this.app = app;
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise resolving to the result
   */
  async execute(params: OpenNoteParameters): Promise<OpenNoteResult> {
    try {
      // Validate parameters
      if (!params.path) {
        return this.prepareResult(false, undefined, 'Path is required');
      }
      
      // Apply smart normalization for note operations (includes .md extension handling)
      const normalizedPath = smartNormalizePath(params.path, false, 'NOTE');
      
      // Get the file
      const file = this.app.vault.getAbstractFileByPath(normalizedPath);
      if (!file || !(file instanceof TFile)) {
        return this.prepareResult(false, undefined, `Note not found at path: ${normalizedPath}`);
      }
      
      // Determine how to open the file
      const mode = params.mode || 'current';
      let leaf: WorkspaceLeaf;
      
      switch (mode) {
        case 'tab':
          leaf = this.app.workspace.getLeaf('tab');
          break;
        case 'split':
          leaf = this.app.workspace.getLeaf('split');
          break;
        case 'window':
          leaf = this.app.workspace.getLeaf('window');
          break;
        case 'current':
        default:
          leaf = this.app.workspace.getLeaf(false);
          break;
      }
      
      // Open the file
      await leaf.openFile(file);
      
      // Focus if requested
      if (params.focus !== false) {
        this.app.workspace.setActiveLeaf(leaf, { focus: true });
      }
      
      return this.prepareResult(true, { 
          path: file.path,
          opened: true,
          mode: mode
        }, undefined, params.context, parseWorkspaceContext(params.workspaceContext) || undefined);
      
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Failed to open note: ', error));
    }
  }
  
  /**
   * Get the parameter schema
   */
  getParameterSchema(): any {
    const modeSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the note to open'
        },
        mode: {
          type: 'string',
          enum: ['tab', 'split', 'window', 'current'],
          description: 'Where to open the note (tab, split, window, or current)',
          default: 'current'
        },
        focus: {
          type: 'boolean',
          description: 'Whether to focus the opened note',
          default: true
        }
      },
      required: ['path']
    };
    
    return this.getMergedSchema(modeSchema);
  }
  
  /**
   * Get the result schema
   */
  getResultSchema(): any {
    const baseSchema = super.getResultSchema();
    
    // Extend the base schema to include our specific data
    baseSchema.properties.data = {
      type: 'object',
      properties: {
        path: { type: 'string' },
        opened: { type: 'boolean' },
        mode: { type: 'string' }
      }
    };
    
    return baseSchema;
  }
}

```

## agents/vaultManager/types.ts

```typescript
import { CommonParameters } from '../../types';

/**
 * Arguments for creating a note
 */
export interface CreateNoteArgs extends CommonParameters {
  /**
   * Path to the note
   */
  path: string;
  
  /**
   * Content of the note
   */
  content: string;
  
  /**
   * Whether to overwrite if the note already exists
   */
  overwrite?: boolean;
}

/**
 * Result of creating a note
 */
export interface CreateNoteResult {
  /**
   * Path to the note
   */
  path: string;
  
  /**
   * Whether the note was created successfully
   */
  success: boolean;
  
  /**
   * Error message if creation failed
   */
  error?: string;
  
  /**
   * Whether the note already existed
   */
  existed?: boolean;
}

/**
 * Arguments for creating a folder
 */
export interface CreateFolderArgs extends CommonParameters {
  /**
   * Path to the folder
   */
  path: string;
}

/**
 * Result of creating a folder
 */
export interface CreateFolderResult {
  /**
   * Path to the folder
   */
  path: string;
  
  /**
   * Whether the folder was created successfully
   */
  success: boolean;
  
  /**
   * Error message if creation failed
   */
  error?: string;
  
  /**
   * Whether the folder already existed
   */
  existed?: boolean;
}

/**
 * Arguments for deleting a note
 */
export interface DeleteNoteArgs extends CommonParameters {
  /**
   * Path to the note
   */
  path: string;
}

/**
 * Result of deleting a note
 */
export interface DeleteNoteResult {
  /**
   * Path to the note
   */
  path: string;
  
  /**
   * Whether the note was deleted successfully
   */
  success: boolean;
  
  /**
   * Error message if deletion failed
   */
  error?: string;
}

/**
 * Arguments for deleting a folder
 */
export interface DeleteFolderArgs extends CommonParameters {
  /**
   * Path to the folder
   */
  path: string;
  
  /**
   * Whether to delete recursively
   */
  recursive?: boolean;
}

/**
 * Result of deleting a folder
 */
export interface DeleteFolderResult {
  /**
   * Path to the folder
   */
  path: string;
  
  /**
   * Whether the folder was deleted successfully
   */
  success: boolean;
  
  /**
   * Error message if deletion failed
   */
  error?: string;
}

/**
 * Arguments for moving a note
 */
export interface MoveNoteArgs extends CommonParameters {
  /**
   * Path to the note
   */
  path: string;
  
  /**
   * New path for the note
   */
  newPath: string;
  
  /**
   * Whether to overwrite if a note already exists at the new path
   */
  overwrite?: boolean;
}

/**
 * Result of moving a note
 */
export interface MoveNoteResult {
  /**
   * Original path of the note
   */
  path: string;
  
  /**
   * New path of the note
   */
  newPath: string;
  
  /**
   * Whether the note was moved successfully
   */
  success: boolean;
  
  /**
   * Error message if move failed
   */
  error?: string;
}

/**
 * Arguments for moving a folder
 */
export interface MoveFolderArgs extends CommonParameters {
  /**
   * Path to the folder
   */
  path: string;
  
  /**
   * New path for the folder
   */
  newPath: string;
  
  /**
   * Whether to overwrite if a folder already exists at the new path
   */
  overwrite?: boolean;
}

/**
 * Result of moving a folder
 */
export interface MoveFolderResult {
  /**
   * Original path of the folder
   */
  path: string;
  
  /**
   * New path of the folder
   */
  newPath: string;
  
  /**
   * Whether the folder was moved successfully
   */
  success: boolean;
  
  /**
   * Error message if move failed
   */
  error?: string;
}

/**
 * Arguments for duplicating a note
 */
export interface DuplicateNoteArgs extends CommonParameters {
  /**
   * Path to the source note to duplicate
   */
  sourcePath: string;
  
  /**
   * Path for the duplicate note
   */
  targetPath: string;
  
  /**
   * Whether to overwrite if a note already exists at the target path
   */
  overwrite?: boolean;
  
  /**
   * Whether to auto-increment the filename if target exists (e.g., "note copy.md", "note copy 2.md")
   * This takes precedence over overwrite when both are true
   */
  autoIncrement?: boolean;
}

/**
 * Result of duplicating a note
 */
export interface DuplicateNoteResult {
  /**
   * Original path of the source note
   */
  sourcePath: string;
  
  /**
   * Final path of the duplicated note
   */
  targetPath: string;
  
  /**
   * Whether the note was duplicated successfully
   */
  success: boolean;
  
  /**
   * Error message if duplication failed
   */
  error?: string;
  
  /**
   * Whether the target path was auto-incremented due to conflicts
   */
  wasAutoIncremented?: boolean;
  
  /**
   * Whether an existing file was overwritten
   */
  wasOverwritten?: boolean;
}
```

## agents/vaultManager/utils/FileOperations.ts

```typescript
import { App, TFile, TFolder } from 'obsidian';
import { smartNormalizePath, normalizePath } from '../../../utils/pathUtils';

/**
 * Utility class for file operations
 */
export class FileOperations {
  /**
   * Create a note
   * @param app Obsidian app instance
   * @param path Path to the note
   * @param content Content of the note
   * @param overwrite Whether to overwrite if the note already exists
   * @returns Promise that resolves with the created file and whether it already existed
   * @throws Error if creation fails
   */
  static async createNote(
    app: App,
    path: string,
    content: string,
    overwrite = false
  ): Promise<{ file: TFile; existed: boolean }> {
    // Apply smart normalization for note operations (includes .md extension handling)
    const normalizedPath = smartNormalizePath(path, false, 'NOTE');
    
    // Check if the file already exists
    const existingFile = app.vault.getAbstractFileByPath(normalizedPath);
    if (existingFile) {
      if (existingFile instanceof TFile) {
        if (overwrite) {
          // Overwrite the existing file
          await app.vault.modify(existingFile, content);
          return { file: existingFile, existed: true };
        } else {
          throw new Error(`File already exists: ${path}`);
        }
      } else {
        throw new Error(`Path exists but is not a file: ${path}`);
      }
    }
    
    // Ensure the parent folder exists
    const folderPath = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));
    if (folderPath) {
      await FileOperations.ensureFolder(app, folderPath);
    }
    
    // Create the file
    const file = await app.vault.create(normalizedPath, content);
    return { file, existed: false };
  }
  
  /**
   * Create a folder
   * @param app Obsidian app instance
   * @param path Path to the folder
   * @returns Promise that resolves with whether the folder already existed
   * @throws Error if creation fails
   */
  static async createFolder(app: App, path: string): Promise<boolean> {
    // Normalize path to remove any leading slash
    const normalizedPath = normalizePath(path);
    
    // Check if the folder already exists
    const existingFolder = app.vault.getAbstractFileByPath(normalizedPath);
    if (existingFolder) {
      if (existingFolder instanceof TFolder) {
        return true;
      } else {
        throw new Error(`Path exists but is not a folder: ${path}`);
      }
    }
    
    // Create the folder
    await app.vault.createFolder(normalizedPath);
    return false;
  }
  
  /**
   * Ensure a folder exists
   * @param app Obsidian app instance
   * @param path Path to the folder
   * @returns Promise that resolves when the folder exists
   */
  static async ensureFolder(app: App, path: string): Promise<void> {
    // Normalize path to remove any leading slash
    const normalizedPath = normalizePath(path);
    
    const folders = normalizedPath.split('/').filter((p: string) => p.length > 0);
    let currentPath = '';
    
    for (const folder of folders) {
      currentPath += folder;
      
      try {
        await FileOperations.createFolder(app, currentPath);
      } catch (error) {
        // Ignore errors if the folder already exists
      }
      
      currentPath += '/';
    }
  }
  
  /**
   * Delete a note
   * @param app Obsidian app instance
   * @param path Path to the note
   * @returns Promise that resolves when the note is deleted
   * @throws Error if deletion fails
   */
  static async deleteNote(app: App, path: string): Promise<void> {
    // Normalize path to remove any leading slash
    const normalizedPath = normalizePath(path);
    
    const file = app.vault.getAbstractFileByPath(normalizedPath);
    if (!file) {
      throw new Error(`File not found: ${path}`);
    }
    
    if (!(file instanceof TFile)) {
      throw new Error(`Path is not a file: ${path}`);
    }
    
    await app.vault.delete(file);
  }
  
  /**
   * Delete a folder
   * @param app Obsidian app instance
   * @param path Path to the folder
   * @param recursive Whether to delete recursively
   * @returns Promise that resolves when the folder is deleted
   * @throws Error if deletion fails
   */
  static async deleteFolder(app: App, path: string, recursive = false): Promise<void> {
    // Normalize path to remove any leading slash
    const normalizedPath = normalizePath(path);
    
    const folder = app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder) {
      throw new Error(`Folder not found: ${path}`);
    }
    
    if (!(folder instanceof TFolder)) {
      throw new Error(`Path is not a folder: ${path}`);
    }
    
    if (!recursive && folder.children.length > 0) {
      throw new Error(`Folder is not empty: ${path}`);
    }
    
    await app.vault.delete(folder, true);
  }
  
  /**
   * Move a note
   * @param app Obsidian app instance
   * @param path Path to the note
   * @param newPath New path for the note
   * @param overwrite Whether to overwrite if a note already exists at the new path
   * @returns Promise that resolves when the note is moved
   * @throws Error if move fails
   */
  static async moveNote(
    app: App,
    path: string,
    newPath: string,
    overwrite = false
  ): Promise<void> {
    // Normalize paths to remove any leading slashes
    const normalizedPath = normalizePath(path);
    const normalizedNewPath = normalizePath(newPath);
    
    const file = app.vault.getAbstractFileByPath(normalizedPath);
    if (!file) {
      throw new Error(`File not found: ${path}`);
    }
    
    if (!(file instanceof TFile)) {
      throw new Error(`Path is not a file: ${path}`);
    }
    
    // Check if the destination already exists
    const existingFile = app.vault.getAbstractFileByPath(normalizedNewPath);
    if (existingFile) {
      if (overwrite) {
        await app.vault.delete(existingFile);
      } else {
        throw new Error(`Destination already exists: ${newPath}`);
      }
    }
    
    // Ensure the parent folder exists
    const folderPath = normalizedNewPath.substring(0, normalizedNewPath.lastIndexOf('/'));
    if (folderPath) {
      await FileOperations.ensureFolder(app, folderPath);
    }
    
    await app.vault.rename(file, normalizedNewPath);
  }
  
  /**
   * Move a folder
   * @param app Obsidian app instance
   * @param path Path to the folder
   * @param newPath New path for the folder
   * @param overwrite Whether to overwrite if a folder already exists at the new path
   * @returns Promise that resolves when the folder is moved
   * @throws Error if move fails
   */
  static async moveFolder(
    app: App,
    path: string,
    newPath: string,
    overwrite = false
  ): Promise<void> {
    // Normalize paths to remove any leading slashes
    const normalizedPath = normalizePath(path);
    const normalizedNewPath = normalizePath(newPath);
    
    const folder = app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder) {
      throw new Error(`Folder not found: ${path}`);
    }
    
    if (!(folder instanceof TFolder)) {
      throw new Error(`Path is not a folder: ${path}`);
    }
    
    // Check if the destination already exists
    const existingFolder = app.vault.getAbstractFileByPath(normalizedNewPath);
    if (existingFolder) {
      if (overwrite) {
        await app.vault.delete(existingFolder, true);
      } else {
        throw new Error(`Destination already exists: ${newPath}`);
      }
    }
    
    // Ensure the parent folder exists
    const parentPath = normalizedNewPath.substring(0, normalizedNewPath.lastIndexOf('/'));
    if (parentPath) {
      await FileOperations.ensureFolder(app, parentPath);
    }
    
    await app.vault.rename(folder, normalizedNewPath);
  }
  
  /**
   * Duplicate a note
   * @param app Obsidian app instance
   * @param sourcePath Path to the source note
   * @param targetPath Path for the duplicate note
   * @param overwrite Whether to overwrite if target exists
   * @param autoIncrement Whether to auto-increment filename if target exists
   * @returns Promise that resolves with duplication details
   * @throws Error if duplication fails
   */
  static async duplicateNote(
    app: App,
    sourcePath: string,
    targetPath: string,
    overwrite = false,
    autoIncrement = false
  ): Promise<{
    sourcePath: string;
    targetPath: string;
    wasAutoIncremented: boolean;
    wasOverwritten: boolean;
  }> {
    // Normalize paths to remove any leading slashes
    const normalizedSourcePath = normalizePath(sourcePath);
    const normalizedTargetPath = normalizePath(targetPath);

    // Check if source file exists
    const sourceFile = app.vault.getAbstractFileByPath(normalizedSourcePath);
    if (!sourceFile) {
      throw new Error(`Source file not found: ${sourcePath}`);
    }

    if (!(sourceFile instanceof TFile)) {
      throw new Error(`Source path is not a file: ${sourcePath}`);
    }

    // Read source content
    const sourceContent = await app.vault.read(sourceFile);
    
    let finalTargetPath = normalizedTargetPath;
    let wasAutoIncremented = false;
    let wasOverwritten = false;

    // Handle existing target file
    let existingTarget = app.vault.getAbstractFileByPath(finalTargetPath);
    
    if (existingTarget) {
      if (autoIncrement) {
        // Auto-increment filename until we find an available one
        let counter = 1;
        const pathParts = finalTargetPath.split('.');
        const extension = pathParts.length > 1 ? `.${pathParts.pop()}` : '';
        const basePath = pathParts.join('.');
        
        do {
          const suffix = counter === 1 ? ' copy' : ` copy ${counter}`;
          finalTargetPath = `${basePath}${suffix}${extension}`;
          existingTarget = app.vault.getAbstractFileByPath(finalTargetPath);
          counter++;
        } while (existingTarget && counter < 1000); // Safety limit
        
        if (counter >= 1000) {
          throw new Error('Too many duplicates - unable to find available filename');
        }
        
        wasAutoIncremented = counter > 1;
      } else if (overwrite) {
        // Delete existing file
        await app.vault.delete(existingTarget);
        wasOverwritten = true;
      } else {
        throw new Error(`Target file already exists: ${targetPath}`);
      }
    }

    // Ensure target directory exists
    const targetFolderPath = finalTargetPath.substring(0, finalTargetPath.lastIndexOf('/'));
    if (targetFolderPath) {
      await FileOperations.ensureFolder(app, targetFolderPath);
    }

    // Create the duplicate
    await app.vault.create(finalTargetPath, sourceContent);

    return {
      sourcePath: normalizedSourcePath,
      targetPath: finalTargetPath,
      wasAutoIncremented,
      wasOverwritten
    };
  }
}

```

## agents/vaultManager/vaultManager.ts

```typescript
import { App, TFile, TFolder } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import { VaultManagerConfig } from '../../config/agents';
import { 
  ListDirectoryMode, 
  CreateFolderMode, 
  EditFolderMode,
  DeleteFolderMode,
  DeleteNoteMode,
  MoveFolderMode,
  DuplicateNoteMode,
  OpenNoteMode
} from './modes';
import { MoveNoteMode } from './modes/moveNoteMode';
import { sanitizeVaultName } from '../../utils/vaultUtils';

/**
 * Agent for file system operations in the Obsidian vault
 */
export class VaultManagerAgent extends BaseAgent {
  private app: App;
  private vaultName: string;
  private isGettingDescription = false;

  /**
   * Create a new VaultManagerAgent
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      VaultManagerConfig.name,
      VaultManagerConfig.description,
      VaultManagerConfig.version
    );
    
    this.app = app;
    this.vaultName = sanitizeVaultName(app.vault.getName());
    
    // Register modes
    this.registerMode(new ListDirectoryMode(app));
    this.registerMode(new CreateFolderMode(app));
    this.registerMode(new EditFolderMode(app));
    this.registerMode(new DeleteFolderMode(app));
    this.registerMode(new DeleteNoteMode(app));
    this.registerMode(new MoveNoteMode(app));
    this.registerMode(new MoveFolderMode(app));
    this.registerMode(new DuplicateNoteMode(app));
    this.registerMode(new OpenNoteMode(app));
  }

  /**
   * Dynamic description that includes current vault structure
   */
  get description(): string {
    const baseDescription = VaultManagerConfig.description;
    
    // Prevent infinite recursion
    if (this.isGettingDescription) {
      return `[${this.vaultName}] ${baseDescription}`;
    }
    
    this.isGettingDescription = true;
    try {
      const vaultContext = this.getVaultStructureSummary();
      return `[${this.vaultName}] ${baseDescription}\n\n${vaultContext}`;
    } finally {
      this.isGettingDescription = false;
    }
  }

  /**
   * Get a summary of the vault structure
   * @returns Formatted string with vault structure information
   * @private
   */
  private getVaultStructureSummary(): string {
    try {
      const markdownFiles = this.app.vault.getMarkdownFiles();
      const rootFolder = this.app.vault.getRoot();
      
      // Get root folders (folders directly in vault root)
      const rootFolders = rootFolder.children
        .filter(child => child instanceof TFolder)
        .map(folder => folder.name)
        .sort(); // Sort alphabetically for consistent display

      // Count files in each root folder
      const folderStructure: string[] = [];

      for (const folderName of rootFolders) {
        const filesInFolder = markdownFiles.filter(file => 
          file.path.startsWith(folderName + '/')
        ).length;
        folderStructure.push(`   ‚îî‚îÄ‚îÄ ${folderName}/ (${filesInFolder} files)`);
      }

      // Count files in root
      const rootFiles = markdownFiles.filter(file => 
        !file.path.includes('/')
      ).length;

      const summary = [
        `üìÅ Vault Structure: ${markdownFiles.length} files, ${rootFolders.length} root folders`
      ];

      if (rootFiles > 0) {
        summary.push(`   ‚îî‚îÄ‚îÄ / (${rootFiles} files in root)`);
      }

      summary.push(...folderStructure);

      return summary.join('\n');
    } catch (error) {
      return `üìÅ Vault Structure: Unable to load vault information (${error})`;
    }
  }
}

```

## components/Accordion.ts

```typescript
import { Component } from 'obsidian';

/**
 * A collapsible accordion component for Obsidian plugin settings
 * Provides smooth animations and mobile-friendly interaction
 */
export class Accordion extends Component {
    containerEl: HTMLElement;
    contentEl: HTMLElement;
    isOpen: boolean;

    /**
     * Create a new accordion
     * @param containerEl Parent container element
     * @param title Accordion header title
     * @param defaultOpen Whether accordion is open by default
     */
    constructor(containerEl: HTMLElement, title: string, defaultOpen = false) {
        super();
        
        this.containerEl = containerEl;
        this.isOpen = defaultOpen;
        
        // Create main accordion container
        const accordionEl = this.containerEl.createEl('div', {
            cls: 'mcp-accordion'
        });

        // Create container to scope selectors
        const accordionContainer = accordionEl.createEl('div', {
            cls: 'mcp-accordion-container'
        });

        // Create header with toggle button
        const headerEl = accordionContainer.createEl('div', {
            cls: 'mcp-accordion-header'
        });

        const toggleButton = headerEl.createEl('button', {
            cls: 'mcp-accordion-toggle'
        });

        // Add title
        toggleButton.createEl('span', {
            text: title,
            cls: 'mcp-accordion-title'
        });

        // Add expand/collapse icon
        toggleButton.createEl('span', {
            cls: `mcp-accordion-icon ${this.isOpen ? 'is-open' : ''}`
        });

        // Create content container
        this.contentEl = accordionContainer.createEl('div', {
            cls: `mcp-accordion-content ${this.isOpen ? 'is-open' : ''}`
        });

        // Toggle on click
        toggleButton.addEventListener('click', () => {
            this.toggle(accordionContainer);
        });
    }

    /**
     * Toggle accordion open/closed state
     * @param container The accordion container element to toggle
     */
    toggle(container: HTMLElement): void {
        this.isOpen = !this.isOpen;
        
        // Update icon - scoped to this container
        const iconEl = container.querySelector('.mcp-accordion-icon');
        if (iconEl) {
            iconEl.classList.toggle('is-open');
        }
        
        // Update content - scoped to this container
        const contentEl = container.querySelector('.mcp-accordion-content');
        if (contentEl) {
            contentEl.classList.toggle('is-open');
        }
    }

    /**
     * Get the content element to add children to
     */
    getContentEl(): HTMLElement {
        const innerContent = this.contentEl.createEl('div');
        return innerContent;
    }
}

```

## components/Card.ts

```typescript
/**
 * Reusable Card Component
 * Matches the existing Custom Agent card styling and behavior
 */

import { ToggleComponent } from 'obsidian';

export interface CardAction {
  icon: string; // SVG icon as string
  label: string; // aria-label for accessibility
  onClick: () => void;
}

export interface CardConfig {
  title: string;
  description: string;
  isEnabled?: boolean;
  showToggle?: boolean; // Whether to show the toggle switch
  onToggle?: (enabled: boolean) => void;
  onEdit?: () => void;
  onDelete?: () => void;
  additionalActions?: CardAction[];
}

export class Card {
  private containerEl: HTMLElement;
  private cardEl: HTMLElement;
  private config: CardConfig;

  constructor(containerEl: HTMLElement, config: CardConfig) {
    this.containerEl = containerEl;
    this.config = config;
    this.cardEl = this.createCard();
  }

  /**
   * Create the card element with standard styling
   */
  private createCard(): HTMLElement {
    const cardEl = this.containerEl.createDiv('agent-management-card');
    
    // Header with name and toggle
    const headerEl = cardEl.createDiv('agent-management-card-header');
    const titleEl = headerEl.createDiv('agent-management-card-title');
    titleEl.setText(this.config.title);
    
    const actionsEl = headerEl.createDiv('agent-management-card-actions');
    
    // Toggle switch using Obsidian's ToggleComponent (only if showToggle is true)
    if (this.config.showToggle && this.config.onToggle) {
      const toggleContainer = actionsEl.createDiv('agent-management-toggle');
      new ToggleComponent(toggleContainer)
        .setValue(this.config.isEnabled || false)
        .onChange(async (value) => {
          this.config.isEnabled = value;
          this.config.onToggle!(value);
        });
    }
    
    // Edit button (if provided)
    if (this.config.onEdit) {
      const editBtn = actionsEl.createEl('button', { 
        cls: 'clickable-icon agent-management-edit-btn',
        attr: { 'aria-label': 'Edit' }
      });
      editBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-edit"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`;
      editBtn.addEventListener('click', () => this.config.onEdit!());
    }
    
    // Delete button (if provided)
    if (this.config.onDelete) {
      const deleteBtn = actionsEl.createEl('button', { 
        cls: 'clickable-icon agent-management-delete-btn',
        attr: { 'aria-label': 'Delete' }
      });
      deleteBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash"><polyline points="3,6 5,6 21,6"></polyline><path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path></svg>`;
      deleteBtn.addEventListener('click', () => this.config.onDelete!());
    }
    
    // Additional actions (if provided)
    if (this.config.additionalActions) {
      this.config.additionalActions.forEach(action => {
        const actionBtn = actionsEl.createEl('button', { 
          cls: 'clickable-icon agent-management-action-btn',
          attr: { 'aria-label': action.label }
        });
        actionBtn.innerHTML = action.icon;
        actionBtn.addEventListener('click', action.onClick);
      });
    }
    
    // Description (only show if not empty)
    if (this.config.description && this.config.description.trim()) {
      const descEl = cardEl.createDiv('agent-management-card-description');
      descEl.setText(this.config.description);
    }
    
    return cardEl;
  }

  /**
   * Update the card's configuration and refresh display
   */
  updateConfig(config: Partial<CardConfig>): void {
    this.config = { ...this.config, ...config };
    this.refresh();
  }

  /**
   * Update the card's enabled state
   */
  setEnabled(enabled: boolean): void {
    this.config.isEnabled = enabled;
    // Just update the internal state - don't create new toggle components
    // The toggle state will be reflected when the card is refreshed
  }

  /**
   * Update the card's title
   */
  setTitle(title: string): void {
    this.config.title = title;
    const titleEl = this.cardEl.querySelector('.agent-management-card-title');
    if (titleEl) {
      titleEl.textContent = title;
    }
  }

  /**
   * Update the card's description
   */
  setDescription(description: string): void {
    this.config.description = description;
    
    // Remove existing description element
    const existingDescEl = this.cardEl.querySelector('.agent-management-card-description');
    if (existingDescEl) {
      existingDescEl.remove();
    }
    
    // Add new description element only if not empty
    if (description && description.trim()) {
      const descEl = this.cardEl.createDiv('agent-management-card-description');
      descEl.setText(description);
    }
  }

  /**
   * Refresh the entire card display
   */
  private refresh(): void {
    this.cardEl.remove();
    this.cardEl = this.createCard();
  }

  /**
   * Remove the card from the DOM
   */
  remove(): void {
    this.cardEl.remove();
  }

  /**
   * Get the card's DOM element
   */
  getElement(): HTMLElement {
    return this.cardEl;
  }

  /**
   * Check if the card is enabled
   */
  isEnabled(): boolean {
    return this.config.isEnabled || false;
  }
}
```

## components/CardManager.ts

```typescript
/**
 * Unified Card Manager Component
 * Generic card management system for agents, providers, and other card-based UIs
 */

import { ButtonComponent } from 'obsidian';
import { Card, CardConfig } from './Card';

export interface CardItem {
    id: string;
    name: string;
    description?: string;
    isEnabled: boolean;
}

export interface CardManagerConfig<T extends CardItem> {
    containerEl: HTMLElement;
    title: string;
    addButtonText: string;
    emptyStateText: string;
    items: T[];
    onAdd: () => void;
    onToggle: (item: T, enabled: boolean) => Promise<void>;
    onEdit: (item: T) => void;
    onDelete?: (item: T) => void;
    showToggle?: boolean;
    showAddButton?: boolean;
}

export class CardManager<T extends CardItem> {
    private config: CardManagerConfig<T>;
    private cardsContainer!: HTMLElement;
    private cards: Map<string, Card> = new Map();

    constructor(config: CardManagerConfig<T>) {
        this.config = config;
        this.buildContent();
    }

    /**
     * Build the card manager content
     */
    private buildContent(): void {
        this.config.containerEl.empty();

        // Add button section (optional)
        if (this.config.showAddButton !== false) {
            this.createAddButton();
        }

        // Cards container
        this.cardsContainer = this.config.containerEl.createDiv('card-manager-grid');
        this.refreshCards();
    }

    /**
     * Create the add button
     */
    private createAddButton(): void {
        const addButtonContainer = this.config.containerEl.createDiv('card-manager-add-button');
        new ButtonComponent(addButtonContainer)
            .setButtonText(this.config.addButtonText)
            .setCta()
            .onClick(() => this.config.onAdd());
    }

    /**
     * Refresh the cards display
     */
    public refreshCards(): void {
        this.cardsContainer.empty();
        this.cards.clear();

        if (this.config.items.length === 0) {
            this.cardsContainer.createDiv('card-manager-empty')
                .setText(this.config.emptyStateText);
            return;
        }

        this.config.items.forEach(item => this.createCard(item));
    }

    /**
     * Create a card for a single item
     */
    private createCard(item: T): void {
        const cardConfig: CardConfig = {
            title: item.name,
            description: item.description || '',
            isEnabled: item.isEnabled,
            showToggle: this.config.showToggle !== false,
            onToggle: async (enabled: boolean) => {
                await this.config.onToggle(item, enabled);
                this.refreshCards();
            },
            onEdit: () => this.config.onEdit(item),
            onDelete: this.config.onDelete ? () => this.config.onDelete!(item) : undefined
        };

        const card = new Card(this.cardsContainer, cardConfig);
        this.cards.set(item.id, card);
    }

    /**
     * Update the items and refresh display
     */
    public updateItems(items: T[]): void {
        this.config.items = items;
        this.refreshCards();
    }

    /**
     * Get a card by item ID
     */
    public getCard(itemId: string): Card | undefined {
        return this.cards.get(itemId);
    }
}
```

## components/ConfigModal.ts

```typescript
import { App, Modal, Platform, Setting } from 'obsidian';
import * as path from 'path';
import { sanitizeVaultName } from '../utils/vaultUtils';

/**
 * Configuration modal for the plugin
 * Provides setup instructions for different operating systems
 */
export class ConfigModal extends Modal {
    private activeTab = 'windows';
    private tabButtons: Record<string, HTMLElement> = {};
    private tabContents: Record<string, HTMLElement> = {};
    private isFirstTimeSetup = true;
    
    /**
     * Create a new configuration modal
     * @param app Obsidian app instance
     * @param settings Settings instance (optional)
     */
    constructor(app: App) {
        super(app);
    }
    
    /**
     * Called when the modal is opened
     */
    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        
        contentEl.createEl('h2', { text: 'MCP Configuration' });

        // Add configuration type toggle
        const toggleContainer = contentEl.createDiv({ cls: 'mcp-config-toggle' });
        toggleContainer.createEl('span', { text: 'Configuration Type:', cls: 'mcp-config-label' });
        new Setting(toggleContainer)
            .setName('First Time Setup')
            .setDesc('Toggle between first-time setup and adding to existing configuration')
            .addToggle(toggle => toggle
                .setValue(this.isFirstTimeSetup)
                .onChange(value => {
                    this.isFirstTimeSetup = value;
                    this.updateConfigDisplay();
                }));

        // Create tab container
        const tabContainer = contentEl.createDiv({ cls: 'mcp-config-tabs' });
        
        // Add tab buttons
        this.createTabButtons(tabContainer);
        
        // Create content container
        const contentContainer = contentEl.createDiv({ cls: 'mcp-config-content' });
        
        // Create tab contents
        this.createWindowsTab(contentContainer);
        this.createMacTab(contentContainer);
        this.createLinuxTab(contentContainer);
        
        // Show default tab
        this.showTab(this.activeTab);
        
        // Add CSS
        this.addStyles();
        
        // Close button
        new Setting(contentEl)
            .addButton(button => button
                .setButtonText('Close')
                .onClick(() => {
                    this.close();
                }));
    }
    
    /**
     * Create tab buttons
     * @param container Container element
     */
    private createTabButtons(container: HTMLElement) {
        const tabButtonContainer = container.createDiv({ cls: 'mcp-tab-buttons' });
        
        // Windows tab button
        const windowsButton = tabButtonContainer.createEl('button', {
            text: 'Windows',
            cls: 'mcp-tab-button'
        });
        windowsButton.addEventListener('click', () => this.showTab('windows'));
        this.tabButtons['windows'] = windowsButton;
        
        // Mac tab button
        const macButton = tabButtonContainer.createEl('button', {
            text: 'Mac',
            cls: 'mcp-tab-button'
        });
        macButton.addEventListener('click', () => this.showTab('mac'));
        this.tabButtons['mac'] = macButton;
        
        // Linux tab button
        const linuxButton = tabButtonContainer.createEl('button', {
            text: 'Linux',
            cls: 'mcp-tab-button'
        });
        linuxButton.addEventListener('click', () => this.showTab('linux'));
        this.tabButtons['linux'] = linuxButton;
        
        // Auto-select current platform
        if (Platform.isMacOS) {
            this.activeTab = 'mac';
        } else if (Platform.isLinux) {
            this.activeTab = 'linux';
        }
    }
    
    /**
     * Create Windows tab content
     * @param container Container element
     */
    private createWindowsTab(container: HTMLElement) {
        const windowsContent = container.createDiv({ cls: 'mcp-tab-content hidden' });
        this.tabContents['windows'] = windowsContent;
        
        const instructions = windowsContent.createEl('div');
        instructions.createEl('p', { text: 'To configure Claude Desktop to work with Claudesidian MCP on Windows:' });
        
        const steps = instructions.createEl('ol');
        
        // Step 1: Open config file
        steps.createEl('li', { text: 'Open your Claude Desktop config file:' });
        
        const configPath = '%AppData%\\Claude\\claude_desktop_config.json';
        const configLink = steps.createEl('a', {
            text: configPath,
            href: '#'
        });
        
        configLink.addEventListener('click', async (e) => {
            e.preventDefault();
            // Try to open the file with system's default program
            const actualPath = this.getWindowsConfigPath();
            window.open('file:///' + actualPath.replace(/\\/g, '/'), '_blank');
        });
        
        // Step 2: Copy configuration
        steps.createEl('li', { text: 'Copy the following JSON configuration:' });
        
        const config = this.getConfiguration('windows');
        
        const codeBlock = windowsContent.createEl('pre');
        codeBlock.createEl('code', {
            text: JSON.stringify(config, null, 2)
        });
        
        // Copy button
        const copyButton = windowsContent.createEl('button', {
            text: 'Copy Configuration',
            cls: 'mod-cta'
        });
        
        copyButton.onclick = () => {
            navigator.clipboard.writeText(JSON.stringify(config, null, 2));
            copyButton.setText('Copied!');
            setTimeout(() => copyButton.setText('Copy Configuration'), 2000);
        };
        
        // Remaining steps
        steps.createEl('li', { text: this.isFirstTimeSetup
            ? 'Paste this into your config file, replacing any existing content'
            : 'Add this to the mcpServers section of your existing config file'
        });
        steps.createEl('li', { text: 'Save the file and restart Claude Desktop' });
    }
    
    /**
     * Create Mac tab content
     * @param container Container element
     */
    private createMacTab(container: HTMLElement) {
        const macContent = container.createDiv({ cls: 'mcp-tab-content hidden' });
        this.tabContents['mac'] = macContent;
        
        const instructions = macContent.createEl('div');
        instructions.createEl('p', { text: 'To configure Claude Desktop to work with Claudesidian MCP on Mac:' });
        
        const steps = instructions.createEl('ol');
        
        // Step 1: Open config file
        steps.createEl('li', { text: 'Open your Claude Desktop config file:' });
        
        const configPath = '~/Library/Application Support/Claude/claude_desktop_config.json';
        const configLink = steps.createEl('a', {
            text: configPath,
            href: '#'
        });
        
        configLink.addEventListener('click', async (e) => {
            e.preventDefault();
            // Try to open the file with system's default program
            const actualPath = this.getMacConfigPath();
            window.open('file:///' + actualPath, '_blank');
        });
        
        // Step 2: Copy configuration
        steps.createEl('li', { text: 'Copy the following JSON configuration:' });
        
        const config = this.getConfiguration('mac');
        
        const codeBlock = macContent.createEl('pre');
        codeBlock.createEl('code', {
            text: JSON.stringify(config, null, 2)
        });
        
        // Copy button
        const copyButton = macContent.createEl('button', {
            text: 'Copy Configuration',
            cls: 'mod-cta'
        });
        
        copyButton.onclick = () => {
            navigator.clipboard.writeText(JSON.stringify(config, null, 2));
            copyButton.setText('Copied!');
            setTimeout(() => copyButton.setText('Copy Configuration'), 2000);
        };
        
        // Remaining steps
        steps.createEl('li', { text: this.isFirstTimeSetup
            ? 'Paste this into your config file, replacing any existing content'
            : 'Add this to the mcpServers section of your existing config file'
        });
        steps.createEl('li', { text: 'Save the file and restart Claude Desktop' });
    }
    
    /**
     * Create Linux tab content
     * @param container Container element
     */
    private createLinuxTab(container: HTMLElement) {
        const linuxContent = container.createDiv({ cls: 'mcp-tab-content hidden' });
        this.tabContents['linux'] = linuxContent;
        
        const instructions = linuxContent.createEl('div');
        instructions.createEl('p', { text: 'To configure Claude Desktop to work with Claudesidian MCP on Linux:' });
        
        const steps = instructions.createEl('ol');
        
        // Step 1: Open config file
        steps.createEl('li', { text: 'Open your Claude Desktop config file:' });
        
        const configPath = '~/.config/Claude/claude_desktop_config.json';
        const configLink = steps.createEl('a', {
            text: configPath,
            href: '#'
        });
        
        configLink.addEventListener('click', async (e) => {
            e.preventDefault();
            // Try to open the file with system's default program
            const actualPath = this.getLinuxConfigPath();
            window.open('file:///' + actualPath, '_blank');
        });
        
        // Step 2: Copy configuration
        steps.createEl('li', { text: 'Copy the following JSON configuration:' });
        
        const config = this.getConfiguration('linux');
        
        const codeBlock = linuxContent.createEl('pre');
        codeBlock.createEl('code', {
            text: JSON.stringify(config, null, 2)
        });
        
        // Copy button
        const copyButton = linuxContent.createEl('button', {
            text: 'Copy Configuration',
            cls: 'mod-cta'
        });
        
        copyButton.onclick = () => {
            navigator.clipboard.writeText(JSON.stringify(config, null, 2));
            copyButton.setText('Copied!');
            setTimeout(() => copyButton.setText('Copy Configuration'), 2000);
        };
        
        // Remaining steps
        steps.createEl('li', { text: this.isFirstTimeSetup
            ? 'Paste this into your config file, replacing any existing content'
            : 'Add this to the mcpServers section of your existing config file'
        });
        steps.createEl('li', { text: 'Save the file and restart Claude Desktop' });
    }
    
    /**
     * Show a specific tab
     * @param tabId Tab ID to show
     */
    private showTab(tabId: string) {
        // Update active tab
        this.activeTab = tabId;
        
        // Update button styles
        for (const [id, button] of Object.entries(this.tabButtons)) {
            if (id === tabId) {
                button.addClass('mcp-tab-active');
            } else {
                button.removeClass('mcp-tab-active');
            }
        }
        
        // Show/hide content
        for (const [id, content] of Object.entries(this.tabContents)) {
            if (id === tabId) {
                content.removeClass('hidden');
                content.addClass('active');
            } else {
                content.addClass('hidden');
                content.removeClass('active');
            }
        }
    }
    
    /**
     * Add CSS styles for the modal (now implemented in styles.css)
     */
    private addStyles() {
        // All styles are now in the global styles.css file
    }
    
    /**
     * Get the configuration object for a specific OS
     * @param os Operating system (windows, mac, linux)
     * @returns Configuration object
     */
    /**
     * Update the configuration display based on selected mode
     */
    private updateConfigDisplay() {
        // Update all tab contents with new configuration
        Object.keys(this.tabContents).forEach(tabId => {
            const content = this.tabContents[tabId];
            const codeBlock = content.querySelector('pre code');
            if (codeBlock) {
                const config = this.getConfiguration(tabId);
                codeBlock.textContent = JSON.stringify(config, null, 2);
            }
        });
    }

    /**
     * Get the configuration object for a specific OS
     * @param os Operating system (windows, mac, linux)
     * @returns Configuration object
     */
    /**
     * Gets a sanitized version of the vault name suitable for use in a configuration key
     * Uses the centralized sanitizeVaultName utility function
     * @returns Sanitized vault name
     */
    private getSanitizedVaultName(): string {
        // Get the vault name from the app
        const vaultName = this.app.vault.getName();
        
        // Use the centralized utility function to sanitize the vault name
        return sanitizeVaultName(vaultName);
    }
    
    /**
     * Get the configuration object for a specific OS
     * @param os Operating system (windows, mac, linux)
     * @returns Configuration object
     */
    private getConfiguration(os: string) {
        const connectorPath = this.getConnectorPath(os);
        
        // Get the sanitized vault name for the server key
        const sanitizedVaultName = this.getSanitizedVaultName();
        
        // Create the server key with vault name
        const serverKey = `claudesidian-mcp-${sanitizedVaultName}`;
        
        // Create server configuration
        const serverConfig = {
            command: "node",
            args: [connectorPath]
        };
        
        // Return different configurations based on setup type
        if (this.isFirstTimeSetup) {
            return {
                mcpServers: {
                    [serverKey]: serverConfig
                }
            };
        } else {
            return {
                [serverKey]: serverConfig
            };
        }
    }
    
    /**
     * Get the connector path for a specific OS
     * @param os Operating system (windows, mac, linux)
     * @returns Connector path
     */
    private getConnectorPath(os: string): string {
        // Get the vault's root path
        const vaultRoot = (this.app.vault.adapter as any).basePath;
        
        // Build the path based on the OS
        if (os === 'windows') {
            return path.join(vaultRoot, '.obsidian', 'plugins', 'claudesidian-mcp', 'connector.js');
        } else if (os === 'mac') {
            return path.join(vaultRoot, '.obsidian', 'plugins', 'claudesidian-mcp', 'connector.js');
        } else if (os === 'linux') {
            return path.join(vaultRoot, '.obsidian', 'plugins', 'claudesidian-mcp', 'connector.js');
        }
        
        // Default to a generic path
        return path.join(vaultRoot, '.obsidian', 'plugins', 'claudesidian-mcp', 'connector.js');
    }
    
    /**
     * Get the Windows config path
     * @returns Windows config path
     */
    private getWindowsConfigPath(): string {
        return path.join(process.env.APPDATA || '', 'Claude', 'claude_desktop_config.json');
    }
    
    /**
     * Get the Mac config path
     * @returns Mac config path
     */
    private getMacConfigPath(): string {
        return path.join(process.env.HOME || '', 'Library', 'Application Support', 'Claude', 'claude_desktop_config.json');
    }
    
    /**
     * Get the Linux config path
     * @returns Linux config path
     */
    private getLinuxConfigPath(): string {
        return path.join(process.env.HOME || '', '.config', 'Claude', 'claude_desktop_config.json');
    }
    
    /**
     * Called when the modal is closed
     */
    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

```

## components/LLMProviderModal.ts

```typescript
/**
 * LLM Provider Configuration Modal
 * Modal-based editing for LLM provider settings and model descriptions
 */

import { Modal, App, Setting, ButtonComponent, Notice } from 'obsidian';
import { LLMProviderConfig, ModelConfig } from '../types';
import { LLMProviderManager } from '../services/llm/providers/ProviderManager';
import { StaticModelsService, ModelWithProvider } from '../services/StaticModelsService';
import { LLMValidationService } from '../services/llm/validation/ValidationService';

export interface LLMProviderModalConfig {
  providerId: string;
  providerName: string;
  keyFormat: string;
  signupUrl: string;
  config: LLMProviderConfig;
  onSave: (config: LLMProviderConfig) => void;
}

export class LLMProviderModal extends Modal {
  private config: LLMProviderModalConfig;
  private providerManager: LLMProviderManager;
  private staticModelsService: StaticModelsService;
  
  private apiKeyInput!: HTMLInputElement;
  private modelsContainer!: HTMLElement;
  private models: ModelWithProvider[] = [];
  private isValidated = false;
  private validationTimeout: NodeJS.Timeout | null = null;
  private ollamaModel: string = ''; // Temporary storage for Ollama model
  private testButton?: HTMLButtonElement; // Reference to test button
  private autoSaveTimeout: NodeJS.Timeout | null = null;
  private saveStatusEl?: HTMLElement;

  constructor(app: App, config: LLMProviderModalConfig, providerManager: LLMProviderManager) {
    super(app);
    this.config = config;
    this.providerManager = providerManager;
    this.staticModelsService = StaticModelsService.getInstance();
    
    // Initialize Ollama model if editing existing config
    if (this.config.providerId === 'ollama') {
      // Try to get the current model from settings if Ollama is default
      const settings = this.providerManager.getSettings();
      if (settings.defaultModel.provider === 'ollama') {
        this.ollamaModel = settings.defaultModel.model || '';
      }
    }
  }

  // Constructor moved above

  onOpen(): void {
    const { contentEl } = this;
    contentEl.empty();

    // Modal title
    contentEl.createEl('h1', { text: `Configure ${this.config.providerName}` });

    // API Key section
    this.createApiKeySection(contentEl);

    // Models section
    this.createModelsSection(contentEl);

    // Buttons
    this.createButtons(contentEl);

    // Load models immediately (no API key needed for static models)
    this.loadModels();
  }

  onClose(): void {
    const { contentEl } = this;
    contentEl.empty();
    
    // Clean up validation timeout
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }

    // Clean up auto-save timeout
    if (this.autoSaveTimeout) {
      clearTimeout(this.autoSaveTimeout);
      this.autoSaveTimeout = null;
    }
  }

  /**
   * Create API key input section
   */
  private createApiKeySection(contentEl: HTMLElement): void {
    const section = contentEl.createDiv('provider-modal-section');
    
    // Special handling for Ollama - URL instead of API key
    if (this.config.providerId === 'ollama') {
      section.createEl('h2', { text: 'Ollama Server URL' });
      
      new Setting(section)
        .setDesc('Enter your Ollama server URL (default: http://127.0.0.1:11434)')
        .addText(text => {
          this.apiKeyInput = text.inputEl;
          this.apiKeyInput.addClass('llm-provider-input');
          text
            .setPlaceholder('http://127.0.0.1:11434')
            .setValue(this.config.config.apiKey || 'http://127.0.0.1:11434')
            .onChange((value) => {
              // Reset validation when URL changes
              this.isValidated = false;
              this.apiKeyInput.removeClass('success');
              this.apiKeyInput.removeClass('error');
              
              // Clear existing timeout
              if (this.validationTimeout) {
                clearTimeout(this.validationTimeout);
                this.validationTimeout = null;
              }
              
              // Show yellow outline immediately when typing
              if (value.trim()) {
                this.apiKeyInput.addClass('validating');
                // Auto-validate after 2 second delay
                this.validationTimeout = setTimeout(() => {
                  this.validateApiKey();
                }, 2000);
                
                // Auto-enable when URL is added
                if (!this.config.config.enabled) {
                  this.config.config.enabled = true;
                  this.autoSave();
                }
              } else {
                this.apiKeyInput.removeClass('validating');
              }
            });
        })
        .addButton(button => {
          this.testButton = button.buttonEl;
          button
            .setButtonText('Test Connection')
            .setTooltip('Test connection to Ollama server with the configured model')
            .onClick(() => {
              this.testOllamaConnection();
            });
        });
    } else {
      // Standard API key handling for other providers
      section.createEl('h2', { text: 'API Key' });

      new Setting(section)
        .setDesc(`Enter your ${this.config.providerName} API key (format: ${this.config.keyFormat})`)
        .addText(text => {
          this.apiKeyInput = text.inputEl;
          this.apiKeyInput.type = 'password'; // Make it a password field
          this.apiKeyInput.addClass('llm-provider-input');
          text
            .setPlaceholder(`Enter your ${this.config.providerName} API key`)
            .setValue(this.config.config.apiKey || '')
            .onChange((value) => {
              // Reset validation when key changes
              this.isValidated = false;
              this.apiKeyInput.removeClass('success');
              this.apiKeyInput.removeClass('error');
              
              // Clear existing timeout
              if (this.validationTimeout) {
                clearTimeout(this.validationTimeout);
                this.validationTimeout = null;
              }
              
              // Show yellow outline immediately when typing
              if (value.trim()) {
                this.apiKeyInput.addClass('validating');
                // Auto-validate after 2 second delay
                this.validationTimeout = setTimeout(() => {
                  this.validateApiKey();
                }, 2000);
                
                // Auto-enable when API key is added
                if (!this.config.config.enabled) {
                  this.config.config.enabled = true;
                  this.autoSave();
                }
              } else {
                this.apiKeyInput.removeClass('validating');
              }
            });
        })
        .addButton(button => {
          button
            .setButtonText('Get Key')
            .setTooltip(`Open ${this.config.providerName} API key page`)
            .onClick(() => {
              window.open(this.config.signupUrl, '_blank');
            });
        });
    }
  }


  /**
   * Create models section
   */
  private createModelsSection(contentEl: HTMLElement): void {
    const section = contentEl.createDiv('provider-modal-section');
    const header = section.createDiv('models-header llm-provider-header');
    
    header.createEl('h2', { text: 'Available Models' });

    this.modelsContainer = section.createDiv('models-container');
    
    // Special handling for Ollama - single model configuration
    if (this.config.providerId === 'ollama') {
      // Add model input field for Ollama
      new Setting(section)
        .setName('Default Model')
        .setDesc('Enter the name of the Ollama model to use (this will be the only available model)')
        .addText(text => text
          .setPlaceholder('e.g., llama3.1, mistral, phi3')
          .setValue(this.ollamaModel || '')
          .onChange(value => {
            // Store the model selection and auto-save
            this.ollamaModel = value;
            if (value.trim()) {
              this.autoSave();
            }
          })
        );
      
      // Add helpful information
      this.modelsContainer.createDiv('models-info').innerHTML = `
        <p><strong>‚ÑπÔ∏è Ollama Model Configuration:</strong></p>
        <p>Configure the single model that will be available:</p>
        <ol>
          <li>Install the model using: <code>ollama pull [model-name]</code></li>
          <li>Common models: llama3.1, mistral, codellama, phi3, gemma</li>
          <li>View installed models: <code>ollama list</code></li>
          <li>Enter the exact model name above - this will be your only available model</li>
        </ol>
      `;
    } else {
      // For other providers, load and display static models
      this.loadModels();
    }
  }

  /**
   * Load models from static service (no API calls needed)
   */
  private loadModels(): void {
    try {
      this.models = this.staticModelsService.getModelsForProvider(this.config.providerId);
      this.displayModels();
    } catch (error) {
      console.error('Error loading static models:', error);
      this.modelsContainer.empty();
      const errorEl = this.modelsContainer.createDiv('models-error');
      errorEl.innerHTML = `
        <p><strong>‚ö†Ô∏è Error loading models:</strong></p>
        <p>${error instanceof Error ? error.message : 'Unknown error'}</p>
      `;
    }
  }

  /**
   * Display the loaded models
   */
  private displayModels(): void {
    this.modelsContainer.empty();

    if (this.models.length === 0) {
      this.modelsContainer.createDiv('models-empty')
        .textContent = 'No models available. Check your API key and try again.';
      return;
    }

    const modelsList = this.modelsContainer.createDiv('models-list');
    
    this.models.forEach(model => {
      const modelEl = modelsList.createDiv('model-item');
      
      // Simple layout: | Model Name | Toggle (right-aligned) |
      const modelRow = modelEl.createDiv('model-row llm-provider-model-row');
      modelRow.style.display = 'flex';
      modelRow.style.justifyContent = 'space-between';
      modelRow.style.alignItems = 'center';

      // Model name (left side)
      const modelNameEl = modelRow.createDiv('model-name llm-provider-model-name');
      modelNameEl.textContent = model.name;

      // Model toggle (right side)
      const currentEnabled = this.config.config.models?.[model.id]?.enabled ?? true;
      const toggleContainer = modelRow.createDiv('model-toggle-container');
      toggleContainer.style.marginLeft = 'auto';

      new Setting(toggleContainer)
        .addToggle(toggle => toggle
          .setValue(currentEnabled)
          .onChange(async (enabled) => {
            // Initialize models object if needed
            if (!this.config.config.models) {
              this.config.config.models = {};
            }
            if (!this.config.config.models[model.id]) {
              this.config.config.models[model.id] = { enabled: true };
            }

            // Update enabled status
            this.config.config.models[model.id].enabled = enabled;
            this.autoSave();
          })
        );
    });
  }

  /**
   * Create status display (no action buttons - auto-save only)
   */
  private createButtons(contentEl: HTMLElement): void {
    const statusContainer = contentEl.createDiv('modal-status-container llm-provider-status-container');

    // Save status indicator
    this.saveStatusEl = statusContainer.createDiv('save-status');
    this.showSaveStatus('Ready');

    // Only close button
    const buttonContainer = statusContainer.createDiv('modal-button-container');
    const closeBtn = buttonContainer.createEl('button', { text: 'Close', cls: 'mod-cta' });
    closeBtn.addEventListener('click', () => this.close());
  }

  /**
   * Validate the API key by making a real test request
   */
  private async validateApiKey(): Promise<void> {
    const apiKey = this.apiKeyInput.value.trim();
    
    if (!apiKey) {
      new Notice('Please enter an API key first');
      return;
    }

    // Show visual feedback that validation is in progress
    this.apiKeyInput.removeClass('success');
    this.apiKeyInput.removeClass('error');
    this.apiKeyInput.addClass('validating');

    try {
      // Use the dedicated validation service for real API testing
      const result = await LLMValidationService.validateApiKey(this.config.providerId, apiKey);
      
      if (result.success) {
        // Mark as validated and auto-save
        this.isValidated = true;
        this.apiKeyInput.removeClass('validating');
        this.apiKeyInput.removeClass('error');
        this.apiKeyInput.addClass('success');

        // Auto-save the validated configuration
        this.config.config.apiKey = apiKey;
        this.config.config.enabled = true;
        this.autoSave();

        new Notice(`‚úÖ ${this.config.providerName} API key validated successfully!`);
      } else {
        throw new Error(result.error || 'API key validation failed');
      }
      
    } catch (error) {
      console.error('API key validation failed:', error);
      
      this.isValidated = false;
      this.apiKeyInput.removeClass('validating');
      this.apiKeyInput.removeClass('success');
      this.apiKeyInput.addClass('error');
      
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      new Notice(`‚ùå ${this.config.providerName} API key validation failed: ${errorMessage}`);
    } finally {
      // Validation feedback is already shown via border colors
    }
  }

  /**
   * Test Ollama connection with the configured server URL and model
   */
  private async testOllamaConnection(): Promise<void> {
    const serverUrl = this.apiKeyInput.value.trim();
    const modelName = this.ollamaModel.trim();

    if (!serverUrl) {
      new Notice('Please enter a server URL first');
      return;
    }

    if (!modelName) {
      new Notice('Please enter a model name first');
      return;
    }

    // Validate URL format
    try {
      new URL(serverUrl);
    } catch (e) {
      new Notice('Please enter a valid URL (e.g., http://127.0.0.1:11434)');
      return;
    }

    // Show testing state
    if (this.testButton) {
      this.testButton.textContent = 'Testing...';
      this.testButton.disabled = true;
    }

    try {
      // First, test if the server is running
      const serverResponse = await fetch(`${serverUrl}/api/tags`);
      if (!serverResponse.ok) {
        throw new Error(`Server not responding: ${serverResponse.status} ${serverResponse.statusText}`);
      }

      // Check if the model is available
      const serverData = await serverResponse.json();
      const availableModels = serverData.models || [];
      const modelExists = availableModels.some((model: any) => model.name === modelName);

      if (!modelExists) {
        new Notice(`‚ö†Ô∏è Model '${modelName}' not found on server. Available models: ${availableModels.map((m: any) => m.name).join(', ') || 'none'}`);
        return;
      }

      // Test a simple generation request with the model
      const testResponse = await fetch(`${serverUrl}/api/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: modelName,
          prompt: 'Hello',
          stream: false,
          options: {
            num_predict: 5 // Just a few tokens for testing
          }
        })
      });

      if (!testResponse.ok) {
        const errorText = await testResponse.text();
        throw new Error(`Model test failed: ${testResponse.status} ${testResponse.statusText} - ${errorText}`);
      }

      const testData = await testResponse.json();
      if (testData.response) {
        new Notice(`‚úÖ Ollama connection successful! Model '${modelName}' is working.`);

        // Mark as validated and auto-save
        this.isValidated = true;
        this.apiKeyInput.removeClass('validating');
        this.apiKeyInput.removeClass('error');
        this.apiKeyInput.addClass('success');

        // Auto-save the validated Ollama configuration
        this.config.config.apiKey = serverUrl;
        this.config.config.enabled = true;
        if (this.ollamaModel) {
          (this.config.config as any).__ollamaModel = this.ollamaModel;
        }
        this.autoSave();
      } else {
        throw new Error('Model test returned invalid response');
      }

    } catch (error) {
      console.error('Ollama connection test failed:', error);
      
      this.isValidated = false;
      this.apiKeyInput.removeClass('validating');
      this.apiKeyInput.removeClass('success');
      this.apiKeyInput.addClass('error');
      
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      new Notice(`‚ùå Ollama test failed: ${errorMessage}`);
    } finally {
      // Restore button state
      if (this.testButton) {
        this.testButton.textContent = 'Test Connection';
        this.testButton.disabled = false;
      }
    }
  }

  /**
   * Auto-save with debouncing and visual feedback
   */
  private autoSave(): void {
    if (this.autoSaveTimeout) {
      clearTimeout(this.autoSaveTimeout);
    }

    this.showSaveStatus('Saving...');

    this.autoSaveTimeout = setTimeout(() => {
      // Update API key from current input
      const apiKey = this.apiKeyInput?.value?.trim();
      if (apiKey) {
        this.config.config.apiKey = apiKey;
      }

      // For Ollama, include model if available
      if (this.config.providerId === 'ollama' && this.ollamaModel) {
        (this.config.config as any).__ollamaModel = this.ollamaModel;
      }

      // Call the save callback
      this.config.onSave(this.config.config);
      this.showSaveStatus('Saved');

      // Reset status after 2 seconds
      setTimeout(() => {
        this.showSaveStatus('Ready');
      }, 2000);
    }, 500);
  }

  /**
   * Show save status with visual feedback
   */
  private showSaveStatus(status: string): void {
    if (this.saveStatusEl) {
      this.saveStatusEl.textContent = status;
      this.saveStatusEl.className = `save-status save-status-${status.toLowerCase()}`;
    }
  }
}
```

## components/LLMProviderTab.ts

```typescript
/**
 * LLM Provider Tab Component
 * Card-based interface for managing LLM providers and their models
 */

import { Setting, ButtonComponent, Modal, App } from 'obsidian';
import { LLMProviderSettings, LLMProviderConfig, ModelConfig } from '../types';
import { LLMProviderManager } from '../services/llm/providers/ProviderManager';
import { CardManager, CardManagerConfig, CardItem } from './CardManager';
import { LLMProviderModal, LLMProviderModalConfig } from './LLMProviderModal';
import { StaticModelsService } from '../services/StaticModelsService';

export interface LLMProviderTabOptions {
  containerEl: HTMLElement;
  settings: LLMProviderSettings;
  onSettingsChange: (settings: LLMProviderSettings) => void;
}

interface ProviderCardItem extends CardItem {
  providerId: string;
  config: LLMProviderConfig;
  displayConfig: ProviderDisplayConfig;
}

export class LLMProviderTab {
  private containerEl: HTMLElement;
  private settings: LLMProviderSettings;
  private onSettingsChange: (settings: LLMProviderSettings) => void;
  private providerCardManager: CardManager<ProviderCardItem> | null = null;
  private providerManager: LLMProviderManager;
  private app: App;
  private staticModelsService: StaticModelsService;
  private modelDropdownSetting: Setting | null = null;
  private providerDropdownSetting: Setting | null = null;

  constructor(options: LLMProviderTabOptions & { app?: App }) {
    this.containerEl = options.containerEl;
    this.settings = options.settings;
    this.onSettingsChange = options.onSettingsChange;
    this.providerManager = new LLMProviderManager(this.settings);
    this.app = options.app || (window as any).app;
    this.staticModelsService = StaticModelsService.getInstance();

    this.buildContent();
  }

  /**
   * Build the LLM provider tab content
   */
  private buildContent(): void {
    this.containerEl.empty();

    // Header section with default model settings
    this.createDefaultModelSection();

    // Provider cards section
    this.createProviderCardsSection();
  }

  /**
   * Create the default model selection section
   */
  private createDefaultModelSection(): void {
    const sectionEl = this.containerEl.createDiv('llm-default-section');
    sectionEl.createEl('h3', { text: 'üéØ Default Model Settings' });

    // Create provider dropdown setting and store reference
    this.providerDropdownSetting = new Setting(sectionEl)
      .setName('Default Provider')
      .setDesc('The LLM provider to use when none is specified');
    
    // Initial population of provider dropdown
    this.updateProviderDropdown();

    // Create model dropdown setting and store reference
    this.modelDropdownSetting = new Setting(sectionEl)
      .setName('Default Model')
      .setDesc('The specific model to use by default');
    
    // Initial population of model dropdown
    this.updateModelDropdown(this.settings.defaultModel.provider).catch(console.error);
  }

  /**
   * Update the provider dropdown with enabled providers
   */
  private updateProviderDropdown(): void {
    if (!this.providerDropdownSetting) return;

    // Clear existing dropdown
    this.providerDropdownSetting.clear();
    
    this.providerDropdownSetting
      .setName('Default Provider')
      .setDesc('The LLM provider to use when none is specified')
      .addDropdown(dropdown => {
        const enabledProviders = Object.keys(this.settings.providers)
          .filter(id => this.settings.providers[id]?.enabled && this.settings.providers[id]?.apiKey);
        
        if (enabledProviders.length === 0) {
          dropdown.addOption('', 'No providers enabled');
        } else {
          enabledProviders.forEach(providerId => {
            dropdown.addOption(providerId, this.getProviderDisplayName(providerId));
          });
        }
        
        dropdown
          .setValue(this.settings.defaultModel.provider)
          .onChange(async (value) => {
            this.settings.defaultModel.provider = value;
            // Reset model when provider changes
            this.settings.defaultModel.model = '';
            await this.updateModelDropdown(value);
            this.onSettingsChange(this.settings);
          });
      });
  }

  /**
   * Update the model dropdown based on selected provider
   */
  private async updateModelDropdown(providerId: string): Promise<void> {
    if (!this.modelDropdownSetting) return;

    // Clear existing dropdown
    this.modelDropdownSetting.clear();
    
    // Special handling for Ollama - use text input instead of dropdown
    if (providerId === 'ollama') {
      this.modelDropdownSetting
        .setName('Default Model')
        .setDesc('The configured Ollama model (set in the Ollama provider card)')
        .addText(text => text
          .setPlaceholder('Configure in Ollama provider card')
          .setValue(this.settings.defaultModel.model || '')
          .setDisabled(true) // Read-only, configured in modal
        );
      return;
    }
    
    // Standard dropdown for other providers
    this.modelDropdownSetting
      .setName('Default Model')
      .setDesc('The specific model to use by default')
      .addDropdown(dropdown => {
        if (!providerId) {
          dropdown.addOption('', 'Select a provider first');
          dropdown.setValue('');
          return;
        }

        // Load models asynchronously
        this.loadModelsForDropdown(dropdown, providerId);
      });
  }

  /**
   * Load models for dropdown asynchronously
   */
  private async loadModelsForDropdown(dropdown: any, providerId: string): Promise<void> {
    try {
      // Use ProviderManager to get filtered models (respects enabled status)
      const models = await this.providerManager.getModelsForProvider(providerId);

      if (models.length === 0) {
        dropdown.addOption('', 'No models available');
        dropdown.setValue('');
        return;
      }

      // Add models to dropdown
      models.forEach(model => {
        dropdown.addOption(model.id, model.name);
      });

      // Set current value or first model if current is invalid
      const currentModel = this.settings.defaultModel.model;
      const modelExists = models.some(m => m.id === currentModel);

      if (modelExists) {
        dropdown.setValue(currentModel);
      } else if (models.length > 0) {
        // Set to first model if current model is invalid
        dropdown.setValue(models[0].id);
        this.settings.defaultModel.model = models[0].id;
      }

      dropdown.onChange(async (value: string) => {
        this.settings.defaultModel.model = value;
        this.onSettingsChange(this.settings);
      });

    } catch (error) {
      console.error('Error loading models for provider:', providerId, error);
      dropdown.addOption('', 'Error loading models');
      dropdown.setValue('');
    }
  }

  /**
   * Create the provider cards section
   */
  private createProviderCardsSection(): void {
    const sectionEl = this.containerEl.createDiv('llm-providers-section');
    sectionEl.createEl('h3', { text: 'ü§ñ LLM Providers' });

    const cardManagerConfig: CardManagerConfig<ProviderCardItem> = {
      containerEl: sectionEl,
      title: 'LLM Providers',
      addButtonText: 'Add Provider',
      emptyStateText: 'No providers configured yet.',
      items: this.getProviderCardItems(),
      onAdd: () => {}, // No add functionality for providers
      onToggle: async (item: ProviderCardItem, enabled: boolean) => {
        if (!item.config.apiKey && enabled) {
          // If trying to enable without API key, open modal instead
          this.openProviderModal(item.providerId, item.displayConfig, item.config);
          return;
        }
        
        this.settings.providers[item.providerId] = {
          ...item.config,
          enabled: enabled
        };
        this.onSettingsChange(this.settings);
        
        // Refresh both provider and model dropdowns when toggling providers
        this.updateProviderDropdown();
        this.updateModelDropdown(this.settings.defaultModel.provider).catch(console.error);
        this.refreshProviderCards();
      },
      onEdit: (item: ProviderCardItem) => this.openProviderModal(item.providerId, item.displayConfig, item.config),
      showToggle: true,
      showAddButton: false // Don't show add button for providers
    };

    this.providerCardManager = new CardManager(cardManagerConfig);
  }

  /**
   * Get provider card items for CardManager
   */
  private getProviderCardItems(): ProviderCardItem[] {
    const providerConfigs = this.getProviderConfigs();
    
    return Object.keys(providerConfigs).map(providerId => {
      const providerConfig = this.settings.providers[providerId] || {
        apiKey: '',
        enabled: false,
        userDescription: '',
        models: {}
      };
      
      const hasValidatedApiKey = !!(providerConfig.apiKey && providerConfig.apiKey.length > 0);
      
      return {
        id: providerId,
        name: providerConfigs[providerId].name,
        description: '', // No description for providers
        isEnabled: hasValidatedApiKey && providerConfig.enabled,
        providerId,
        config: providerConfig,
        displayConfig: providerConfigs[providerId]
      };
    });
  }

  /**
   * Refresh the provider cards display
   */
  private refreshProviderCards(): void {
    if (this.providerCardManager) {
      const items = this.getProviderCardItems();
      this.providerCardManager.updateItems(items);
    }

    // Refresh the provider dropdown to show newly enabled providers
    this.updateProviderDropdown();
    
    // Also refresh the default model dropdown in case provider states changed
    this.updateModelDropdown(this.settings.defaultModel.provider).catch(console.error);
  }


  /**
   * Open the provider configuration modal
   */
  private openProviderModal(
    providerId: string, 
    config: ProviderDisplayConfig, 
    providerConfig: LLMProviderConfig
  ): void {
    const modalConfig: LLMProviderModalConfig = {
      providerId,
      providerName: config.name,
      keyFormat: config.keyFormat,
      signupUrl: config.signupUrl,
      config: providerConfig,
      onSave: (updatedConfig: LLMProviderConfig) => {
        this.settings.providers[providerId] = updatedConfig;
        
        // For Ollama, extract and handle the model from the special field
        if (providerId === 'ollama') {
          const ollamaModel = (updatedConfig as any).__ollamaModel;
          if (ollamaModel) {
            // Clean up the temporary field
            delete (updatedConfig as any).__ollamaModel;
            
            // Update the default model if Ollama is the current default provider
            if (this.settings.defaultModel.provider === 'ollama') {
              this.settings.defaultModel.model = ollamaModel;
            }
            
            // Force provider manager to reinitialize with new model
            this.providerManager.updateSettings(this.settings);
          }
        }
        
        this.onSettingsChange(this.settings);
        this.refreshProviderCards();
      }
    };

    new LLMProviderModal(this.app, modalConfig, this.providerManager).open();
  }


  /**
   * Get provider display configurations
   */
  private getProviderConfigs(): { [key: string]: ProviderDisplayConfig } {
    return {
      openai: {
        name: 'OpenAI',
        description: '',
        keyFormat: 'sk-proj-...',
        signupUrl: 'https://platform.openai.com/api-keys',
        docsUrl: 'https://platform.openai.com/docs'
      },
      anthropic: {
        name: 'Anthropic',
        description: '',
        keyFormat: 'sk-ant-...',
        signupUrl: 'https://console.anthropic.com/login',
        docsUrl: 'https://docs.anthropic.com'
      },
      google: {
        name: 'Google AI',
        description: '',
        keyFormat: 'AIza...',
        signupUrl: 'https://aistudio.google.com/app/apikey',
        docsUrl: 'https://ai.google.dev'
      },
      mistral: {
        name: 'Mistral AI',
        description: '',
        keyFormat: 'msak_...',
        signupUrl: 'https://console.mistral.ai/api-keys',
        docsUrl: 'https://docs.mistral.ai'
      },
      groq: {
        name: 'Groq',
        description: '',
        keyFormat: 'gsk_...',
        signupUrl: 'https://console.groq.com/keys',
        docsUrl: 'https://console.groq.com/docs'
      },
      openrouter: {
        name: 'OpenRouter',
        description: '',
        keyFormat: 'sk-or-...',
        signupUrl: 'https://openrouter.ai/keys',
        docsUrl: 'https://openrouter.ai/docs'
      },
      requesty: {
        name: 'Requesty',
        description: '',
        keyFormat: 'req_...',
        signupUrl: 'https://requesty.com/api-keys',
        docsUrl: 'https://docs.requesty.com'
      },
      perplexity: {
        name: 'Perplexity',
        description: '',
        keyFormat: 'pplx-...',
        signupUrl: 'https://www.perplexity.ai/settings/api',
        docsUrl: 'https://docs.perplexity.ai'
      },
      ollama: {
        name: 'Ollama (Local)',
        description: '',
        keyFormat: 'http://127.0.0.1:11434',
        signupUrl: 'https://ollama.com/download',
        docsUrl: 'https://github.com/ollama/ollama'
      }
    };
  }

  /**
   * Get provider display name
   */
  private getProviderDisplayName(providerId: string): string {
    const configs = this.getProviderConfigs();
    return configs[providerId]?.name || providerId;
  }


  /**
   * Refresh the tab content
   */
  refresh(): void {
    this.buildContent();
  }
}

interface ProviderDisplayConfig {
  name: string;
  description: string;
  keyFormat: string;
  signupUrl: string;
  docsUrl: string;
}
```

## components/LLMUsageTab.ts

```typescript
/**
 * LLM Usage Tab Component
 * Displays LLM usage statistics and budget management for Agent Manager
 */

import { App } from 'obsidian';
import { UsageTracker, UsageData, BudgetStatus } from '../services/UsageTracker';
import { UsageChart } from './shared/UsageChart';

export interface LLMUsageTabOptions {
    containerEl: HTMLElement;
    app: App;
}

export class LLMUsageTab {
    private containerEl: HTMLElement;
    private app: App;
    private usageTracker: UsageTracker;
    private usageChart: UsageChart | null = null;
    private refreshInterval: NodeJS.Timeout | null = null;

    constructor(options: LLMUsageTabOptions) {
        this.containerEl = options.containerEl;
        this.app = options.app;
        
        // Get settings from plugin
        const plugin = (this.app as any).plugins.plugins['claudesidian-mcp'];
        const settings = plugin?.settings || {};
        
        // Initialize usage tracker for LLM usage
        this.usageTracker = new UsageTracker('llm', settings);
        
        this.buildContent();
        this.startAutoRefresh();
    }

    /**
     * Build the LLM usage tab content
     */
    private async buildContent(): Promise<void> {
        this.containerEl.empty();
        
        // Create main container
        const mainContainer = this.containerEl.createDiv('llm-usage-tab llm-usage-main-container');

        // Header
        const headerEl = mainContainer.createEl('h3', { text: 'LLM Usage & Budget' });
        headerEl.style.marginBottom = '20px';

        // Description
        const descEl = mainContainer.createDiv();
        descEl.style.marginBottom = '20px';
        descEl.style.color = 'var(--text-muted)';
        descEl.style.fontSize = '0.9em';
        descEl.textContent = 'Track your LLM API costs and manage monthly budgets. Costs are calculated based on token usage from Agent Manager operations.';

        // Usage chart container
        const chartContainer = mainContainer.createDiv('llm-usage-chart');
        
        // Load and display usage data
        await this.refreshUsageData(chartContainer);
    }

    /**
     * Refresh usage data and update chart
     */
    private async refreshUsageData(chartContainer?: HTMLElement): Promise<void> {
        try {
            const container = chartContainer || this.containerEl.querySelector('.llm-usage-chart') as HTMLElement;
            if (!container) return;

            const usageData = await this.usageTracker.getUsageData();
            const budgetStatus = await this.usageTracker.getBudgetStatusAsync();

            // Create or update chart
            if (!this.usageChart) {
                this.usageChart = new UsageChart({
                    containerEl: container,
                    title: 'üí∞ LLM Costs',
                    usageData,
                    budgetStatus,
                    onResetMonthly: () => this.handleResetMonthly(),
                    onBudgetChange: (budget: number) => this.handleBudgetChange(budget)
                });
            } else {
                this.usageChart.update(usageData, budgetStatus);
            }

        } catch (error) {
            console.error('Error refreshing LLM usage data:', error);
            this.showError(chartContainer || this.containerEl);
        }
    }

    /**
     * Handle monthly usage reset
     */
    private async handleResetMonthly(): Promise<void> {
        try {
            await this.usageTracker.resetMonthlyUsage();
            await this.refreshUsageData();
            
            // Show success message
            const plugin = (this.app as any).plugins.plugins['claudesidian-mcp'];
            if (plugin?.showNotice) {
                plugin.showNotice('Monthly LLM usage reset successfully');
            }
        } catch (error) {
            console.error('Error resetting monthly LLM usage:', error);
            
            // Show error message
            const plugin = (this.app as any).plugins.plugins['claudesidian-mcp'];
            if (plugin?.showNotice) {
                plugin.showNotice('Failed to reset monthly usage', 'error');
            }
        }
    }

    /**
     * Handle budget change
     */
    private handleBudgetChange(budget: number): void {
        try {
            this.usageTracker.setMonthlyBudget(budget);
            
            // Refresh to show updated budget status
            setTimeout(() => {
                this.refreshUsageData();
            }, 100);
            
            // Show success message
            const plugin = (this.app as any).plugins.plugins['claudesidian-mcp'];
            if (plugin?.showNotice) {
                if (budget > 0) {
                    plugin.showNotice(`Monthly LLM budget set to $${budget.toFixed(2)}`);
                } else {
                    plugin.showNotice('Monthly LLM budget disabled');
                }
            }
        } catch (error) {
            console.error('Error setting LLM budget:', error);
            
            // Show error message
            const plugin = (this.app as any).plugins.plugins['claudesidian-mcp'];
            if (plugin?.showNotice) {
                plugin.showNotice('Failed to set budget', 'error');
            }
        }
    }

    /**
     * Show error message
     */
    private showError(container: HTMLElement): void {
        container.empty();
        
        const errorEl = container.createDiv('llm-usage-error');
        
        errorEl.createEl('h4', { text: '‚ö†Ô∏è Error Loading Usage Data' });
        errorEl.createEl('p', { text: 'Unable to load LLM usage statistics. Please try refreshing the tab.' });
        
        const retryButton = errorEl.createEl('button', { text: 'Retry', cls: 'llm-usage-error-button' });
        
        retryButton.addEventListener('click', () => {
            this.refreshUsageData();
        });
    }

    /**
     * Start auto-refresh interval
     */
    private startAutoRefresh(): void {
        // Refresh every 30 seconds
        this.refreshInterval = setInterval(() => {
            this.refreshUsageData();
        }, 30000);
    }

    /**
     * Stop auto-refresh interval
     */
    private stopAutoRefresh(): void {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
        }
    }

    /**
     * Cleanup when tab is destroyed
     */
    destroy(): void {
        this.stopAutoRefresh();
        this.usageChart = null;
    }

    /**
     * Get current budget status for external use
     */
    async getBudgetStatus(): Promise<BudgetStatus> {
        return await this.usageTracker.getBudgetStatusAsync();
    }

    /**
     * Check if a cost can be afforded within budget
     */
    async canAfford(cost: number): Promise<boolean> {
        return await this.usageTracker.canAfford(cost);
    }
}
```

## components/MemorySettingsTab.ts

```typescript
import { App } from 'obsidian';
import { WorkspaceService } from '../agents/memoryManager/services/WorkspaceService';
import { MemoryService } from '../agents/memoryManager/services/MemoryService';
import { WorkspaceCardManager } from './workspace/WorkspaceCardManager';
import { Settings } from '../settings';

/**
 * Memory Manager settings tab component
 * Card-based workspace management interface
 */
export class MemorySettingsTab {
    private app: App;
    private workspaceService: WorkspaceService;
    private memoryService: MemoryService;
    private settings: Settings;
    private workspaceCardManager: WorkspaceCardManager;

    constructor(
        private containerEl: HTMLElement,
        app: App,
        workspaceService: WorkspaceService,
        memoryService: MemoryService,
        settings: Settings
    ) {
        this.app = app;
        this.workspaceService = workspaceService;
        this.memoryService = memoryService;
        this.settings = settings;

        this.workspaceCardManager = new WorkspaceCardManager(
            this.containerEl,
            this.workspaceService,
            this.settings
        );
    }

    async display(): Promise<void> {
        this.containerEl.empty();

        const memorySection = this.containerEl.createEl('div', { cls: 'memory-settings-container' });
        memorySection.createEl('h2', { text: 'Workspace Management' });

        // Create a new WorkspaceCardManager with the correct container
        this.workspaceCardManager = new WorkspaceCardManager(
            memorySection,
            this.workspaceService,
            this.settings
        );

        await this.workspaceCardManager.display();
    }
}
```

## components/ProgressBar.ts

```typescript
import { type App } from 'obsidian';

/**
 * Interface for progress update data
 */
export interface ProgressUpdateData {
    total: number;
    processed: number;
    remaining: number;
    operationId?: string;
}

/**
 * Interface for progress completion data
 */
export interface ProgressCompleteData {
    success: boolean;
    processed: number;
    failed: number;
    error?: string;
    operationId: string;
}

/**
 * Interface for progress cancellation data
 */
export interface ProgressCancelData {
    operationId: string;
}

/**
 * ProgressBar component for displaying progress
 * Uses custom event handling to show progress of operations like indexing
 */
export class ProgressBar {
    private container: HTMLElement;
    private progressBar: HTMLElement;
    private progressText: HTMLElement;
    private cancelButton: HTMLElement;
    // app instance not used but kept for future use
    
    private progress = 0;
    private total = 0;
    private operationId = '';
    
    // Custom event handlers
    private onProgressHandler!: (data: ProgressUpdateData) => void;
    private onCompleteHandler!: (data: ProgressCompleteData) => void;
    
    /**
     * Create a new progress bar component
     * 
     * @param containerEl Container element to append to
     * @param app Obsidian app instance for event handling
     */
    constructor(containerEl: HTMLElement, _app: App) {
        // App parameter marked with underscore as it's not currently used
        
        // Create the container
        this.container = containerEl.createDiv({ cls: 'mcp-progress-container' });
        this.container.style.display = 'none';
        
        // Progress info
        const infoContainer = this.container.createDiv({ cls: 'mcp-progress-info' });
        this.progressText = infoContainer.createSpan({ cls: 'mcp-progress-text' });
        
        // Progress bar
        const barContainer = this.container.createDiv({ cls: 'mcp-progress-bar-container' });
        this.progressBar = barContainer.createDiv({ cls: 'mcp-progress-bar' });
        
        // Cancel button
        this.cancelButton = this.container.createDiv({
            cls: 'mcp-progress-cancel',
            text: 'Cancel'
        });
        
        this.cancelButton.addEventListener('click', () => {
            this.triggerCancel();
        });
        
        // Create event handlers
        this.setupEventHandlers();
        
        // Initialize with hidden state
        this.hide();
    }
    
    /**
     * Set up event handlers using a custom approach
     */
    private setupEventHandlers(): void {
        // Create progress update handler
        this.onProgressHandler = (data: ProgressUpdateData) => {
            // Progress update received
            
            // Update progress
            this.total = data.total;
            this.progress = data.processed;
            
            // Store operation ID for resume functionality
            if (data.operationId) {
                this.operationId = data.operationId;
            }
            
            // Update UI
            this.updateProgressBar();
            
            // Show the progress bar if not already visible
            this.show();
        };
        
        // Create completion handler
        this.onCompleteHandler = (data: ProgressCompleteData) => {
            // Progress completion received
            
            // Update the progress bar one last time to show completion
            if (data.processed > 0 && this.total > 0) {
                this.progress = data.processed;
                this.updateProgressBar();
            }
            
            // Hide the progress bar
            setTimeout(() => {
                this.hide();
            }, 2000); // Give user time to see completion
        };
        
        // Create cancellation handler
        const onCancelHandler = (data: ProgressCancelData) => {
            // Progress cancellation received
            
            // Only process if this is for our current operation
            if (data.operationId === this.operationId) {
                // Update text to show cancellation
                this.progressText.setText(`Indexing cancelled: ${this.progress} / ${this.total}`);
                
                // Hide the progress bar after a delay
                setTimeout(() => {
                    this.hide();
                }, 1000);
            }
        };
        
        // Expose handlers as global methods to be called from other components
        // @ts-ignore - Adding methods to window for inter-component communication
        window.mcpProgressHandlers = {
            updateProgress: this.onProgressHandler,
            completeProgress: this.onCompleteHandler,
            cancelProgress: onCancelHandler
        };
    }
    
    /**
     * Show the progress bar
     */
    show(): void {
        this.container.style.display = 'flex';
    }
    
    /**
     * Hide the progress bar
     */
    hide(): void {
        this.container.style.display = 'none';
    }
    
    /**
     * Update the progress bar UI
     */
    private updateProgressBar(): void {
        // Calculate percentage
        const percent = this.total > 0 ? Math.floor((this.progress / this.total) * 100) : 0;
        
        // Update bar width
        this.progressBar.style.width = `${percent}%`;
        
        // Update text
        this.progressText.setText(`Indexing: ${this.progress} / ${this.total} (${percent}%)`);
    }
    
    /**
     * Trigger cancel operation event
     */
    private triggerCancel(): void {
        // Call global cancel handler if available
        // @ts-ignore - Using global methods for inter-component communication
        if (window.mcpProgressHandlers && window.mcpProgressHandlers.cancelProgress) {
            // @ts-ignore
            window.mcpProgressHandlers.cancelProgress({
                operationId: this.operationId
            });
        }
        
        // Hide progress bar
        this.hide();
    }
}
```

## components/SettingsTab.ts

```typescript
import { App, Plugin, PluginSettingTab, Setting, Notice, ButtonComponent } from 'obsidian';
import { Settings } from '../settings';
// import { ConfigModal } from './ConfigModal';
import { 
    WhatIsClaudesidianAccordion, 
    SetupInstructionsAccordion,
    MemoryManagementAccordion,
    AgentManagementAccordion
} from './accordions';
import { UpdateManager } from '../utils/UpdateManager';
import { VaultLibrarianAgent } from '../agents/vaultLibrarian/vaultLibrarian';
import { MemoryManagerAgent } from '../agents/memoryManager/memoryManager';

// Import services
import { WorkspaceService } from '../agents/memoryManager/services/WorkspaceService';
import { MemoryService } from "../agents/memoryManager/services/MemoryService";
import { CustomPromptStorageService } from "../agents/agentManager/services/CustomPromptStorageService";
import type { ServiceManager } from '../core/ServiceManager';

/**
 * Settings tab for the Claudesidian MCP plugin
 * Provides configuration options and agent explanations
 */
export class SettingsTab extends PluginSettingTab {
    private settings: Settings;
    private plugin: Plugin;

    // Simplified Services
    private memoryService: MemoryService | undefined;
    private workspaceService: WorkspaceService | undefined;
    
    // Agent references
    private vaultLibrarian: VaultLibrarianAgent | undefined;
    private memoryManager: MemoryManagerAgent | undefined;
    
    // Service manager
    private serviceManager: ServiceManager | undefined;
    
    // Plugin lifecycle manager
    private pluginLifecycleManager: any;
    
    // Accordion references for updating
    private memoryManagementAccordion: MemoryManagementAccordion | undefined;
    
    /**
     * Create a new settings tab
     * @param app Obsidian app instance
     * @param plugin Plugin instance
     * @param settings Settings manager
     * @param services Service references
     * @param vaultLibrarian VaultLibrarian agent instance
     * @param memoryManager Memory Manager agent instance
     * @param serviceManager ServiceManager instance
     * @param pluginLifecycleManager Plugin lifecycle manager instance
     */
    constructor(
        app: App, 
        plugin: Plugin, 
        private settingsManager: Settings,
        services?: {
            workspaceService?: WorkspaceService,
            memoryService?: MemoryService,
        },
        vaultLibrarian?: VaultLibrarianAgent,
        memoryManager?: MemoryManagerAgent,
        serviceManager?: ServiceManager,
        pluginLifecycleManager?: any
    ) {
        super(app, plugin);
        this.settings = settingsManager;
        this.plugin = plugin;
        
        // Setup services
        if (services) {
            this.memoryService = services.memoryService;
            this.workspaceService = services.workspaceService;
        }
        
        // Store agent references
        this.vaultLibrarian = vaultLibrarian;
        this.memoryManager = memoryManager;
        
        // Store service manager reference
        this.serviceManager = serviceManager;
        
        // Store plugin lifecycle manager reference
        this.pluginLifecycleManager = pluginLifecycleManager;
    }

    /**
     * Update services when they become available and refresh the UI
     * @param services Updated service references
     */
    updateServices(services: {
        workspaceService?: WorkspaceService,
        memoryService?: MemoryService,
    }): void {
        // Update service references
        this.memoryService = services.memoryService;
        this.workspaceService = services.workspaceService;

        // Update the memory management accordion if it exists
        if (this.memoryManagementAccordion) {
            this.memoryManagementAccordion.updateServices(
                this.memoryService,
                this.vaultLibrarian
            );
        }
        
        // Refresh the UI to show updated status
        this.display();
    }

    /**
     * Cleanup method to clear any intervals or resources
     */
    cleanup(): void {
        if (this.memoryManagementAccordion) {
            this.memoryManagementAccordion.cleanup();
        }
    }

    /**
     * Creates the update section in settings
     * Displays current version, last update info, and update button
     */
    private async createUpdateSection(containerEl: HTMLElement): Promise<void> {
        const updateSection = containerEl.createEl('div', { cls: 'mcp-section' });
        updateSection.createEl('h3', { text: 'Plugin Updates' });
        
        // Display current version
        updateSection.createEl('p', { 
            text: `Current version: ${this.plugin.manifest.version}` 
        });
        
        // Display available update notification if there's an update
        if (this.settings.settings.availableUpdateVersion) {
            const updateAlert = updateSection.createEl('div', { 
                cls: 'mcp-update-alert',
                attr: { style: 'background-color: var(--interactive-accent); color: var(--text-on-accent); padding: 10px; border-radius: 5px; margin: 10px 0;' }
            });
            updateAlert.createEl('strong', { text: 'üéâ Update Available!' });
            updateAlert.createEl('br');
            updateAlert.createEl('span', { 
                text: `Version ${this.settings.settings.availableUpdateVersion} is ready to install.` 
            });
        }
        
        // Display last update info if available
        if (this.settings.settings.lastUpdateVersion && this.settings.settings.lastUpdateDate) {
            const lastUpdateDate = new Date(this.settings.settings.lastUpdateDate);
            const formattedDate = lastUpdateDate.toLocaleDateString() + ' ' + 
                                  lastUpdateDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            updateSection.createEl('p', {
                text: `Last updated: ${this.settings.settings.lastUpdateVersion} (${formattedDate})`
            });
        }
        
        // Display last check date if available
        if (this.settings.settings.lastUpdateCheckDate) {
            const lastCheckDate = new Date(this.settings.settings.lastUpdateCheckDate);
            const formattedCheckDate = lastCheckDate.toLocaleDateString() + ' ' + 
                                     lastCheckDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            updateSection.createEl('p', {
                text: `Last checked: ${formattedCheckDate}`,
                attr: { style: 'color: var(--text-muted); font-size: 0.9em;' }
            });
        }
        
        // Add update button
        new Setting(updateSection)
            .setName('Manual Update Check')
            .setDesc('Check for and install the latest version')
            .addButton((button: ButtonComponent) => {
                // Change button text based on whether an update is available
                const buttonText = this.settings.settings.availableUpdateVersion 
                    ? `Install v${this.settings.settings.availableUpdateVersion}` 
                    : 'Check for Updates';
                
                button.setButtonText(buttonText)
                    .onClick(async () => {
                        button.setDisabled(true);
                        try {
                            const updateManager = new UpdateManager(this.plugin);
                            const hasUpdate = await updateManager.checkForUpdate();
                            
                            // Update the check date and available version
                            this.settings.settings.lastUpdateCheckDate = new Date().toISOString();
                            
                            if (hasUpdate) {
                                // Get the latest version info
                                const release = await (updateManager as any).fetchLatestRelease();
                                const availableVersion = release.tag_name.replace('v', '');
                                this.settings.settings.availableUpdateVersion = availableVersion;
                                
                                await updateManager.updatePlugin();
                                
                                // Clear the available update after successful installation
                                this.settings.settings.availableUpdateVersion = undefined;
                                
                                // Refresh the settings display to show the updated version
                                this.display();
                            } else {
                                // Clear any stored available update version
                                this.settings.settings.availableUpdateVersion = undefined;
                                new Notice('You are already on the latest version!');
                            }
                            
                            await this.settings.saveSettings();
                            
                            // Refresh display to update UI
                            this.display();
                            
                        } catch (error) {
                            new Notice(`Update failed: ${(error as Error).message}`);
                        } finally {
                            button.setDisabled(false);
                        }
                    });
            });
    }


    /**
     * Add CSS styles for the settings tab (now implemented in styles.css)
     * @param containerEl Container element
     */
    private addStyles(): void {
        // Styles are now in the global styles.css file
    }
    
    /**
     * Display the settings tab
     */
    display(): void {
        const { containerEl } = this;
        containerEl.empty();

        // Update section first
        this.createUpdateSection(containerEl);

        // Memory Management accordion with simplified services
        this.memoryManagementAccordion = new MemoryManagementAccordion(
            containerEl,
            this.settingsManager,
            this.memoryService,
            this.workspaceService,
            this.vaultLibrarian,
            this.serviceManager
        );

        // Agent Management accordion
        const customPromptStorage = new CustomPromptStorageService(this.settingsManager);
        new AgentManagementAccordion(
            containerEl,
            this.settingsManager,
            customPromptStorage,
            this.app,
            this.pluginLifecycleManager
        );

        // Setup Instructions accordion
        new SetupInstructionsAccordion(containerEl);

        // What is Claudesidian? accordion
        new WhatIsClaudesidianAccordion(containerEl);

        // Add CSS styles
        this.addStyles();
    }

}

```

## components/TabContainer.ts

```typescript
/**
 * Reusable Tab Container Component
 * Matches the existing Memory Manager tab styling and behavior
 */

export interface TabConfig {
  key: string;
  label: string;
}

export class TabContainer {
  private containerEl: HTMLElement;
  private tabContainer!: HTMLElement;
  private contentContainer!: HTMLElement;
  private tabs: Record<string, HTMLElement> = {};
  private contents: Record<string, HTMLElement> = {};
  private activeTabKey: string;
  private onTabChange?: (tabKey: string) => void;

  constructor(
    containerEl: HTMLElement,
    tabConfigs: TabConfig[],
    defaultTab: string = tabConfigs[0]?.key,
    onTabChange?: (tabKey: string) => void
  ) {
    this.containerEl = containerEl;
    this.activeTabKey = defaultTab;
    this.onTabChange = onTabChange;

    this.createTabStructure(tabConfigs);
  }

  /**
   * Create the tab structure using Memory Manager styling
   */
  private createTabStructure(tabConfigs: TabConfig[]): void {
    // Create tabs container (same as memory-settings-tabs)
    this.tabContainer = this.containerEl.createDiv({ cls: 'memory-settings-tabs' });
    
    // Create tab buttons
    tabConfigs.forEach(config => {
      const tabEl = this.tabContainer.createDiv({ 
        cls: 'memory-tab', 
        text: config.label 
      });
      
      tabEl.addEventListener('click', () => this.switchToTab(config.key));
      this.tabs[config.key] = tabEl;
    });

    // Content container (same as memory-tab-content)
    this.contentContainer = this.containerEl.createDiv({ cls: 'memory-tab-content' });
    
    // Create content panes
    tabConfigs.forEach(config => {
      const contentEl = this.contentContainer.createDiv({ cls: 'memory-tab-pane' });
      this.contents[config.key] = contentEl;
    });

    // Set initial active tab
    this.switchToTab(this.activeTabKey);
  }

  /**
   * Switch to a specific tab (same logic as Memory Manager)
   */
  private switchToTab(tabKey: string): void {
    this.activeTabKey = tabKey;
    
    // Remove active class from all tabs and contents
    Object.values(this.tabs).forEach(t => t.removeClass('active'));
    Object.values(this.contents).forEach(c => c.removeClass('active'));
    
    // Add active class to clicked tab and corresponding content
    this.tabs[tabKey]?.addClass('active');
    this.contents[tabKey]?.addClass('active');
    
    // Call callback if provided
    this.onTabChange?.(tabKey);
  }

  /**
   * Get content container for a specific tab
   */
  getTabContent(tabKey: string): HTMLElement | undefined {
    return this.contents[tabKey];
  }

  /**
   * Get the currently active tab key
   */
  getActiveTab(): string {
    return this.activeTabKey;
  }

  /**
   * Programmatically switch to a tab
   */
  activateTab(tabKey: string): void {
    if (this.contents[tabKey]) {
      this.switchToTab(tabKey);
    }
  }
}
```

## components/UnifiedTabs.ts

```typescript
/**
 * Unified Tabs Component
 * Exact replication of Memory Manager tab pattern for consistent UI across the plugin
 */

export interface UnifiedTabConfig {
  key: string;
  label: string;
}

export interface UnifiedTabsOptions {
  containerEl: HTMLElement;
  tabs: UnifiedTabConfig[];
  defaultTab?: string;
  onTabChange?: (tabKey: string) => void;
}

export class UnifiedTabs {
  private containerEl: HTMLElement;
  private tabContainer!: HTMLElement;
  private contentContainer!: HTMLElement;
  private tabs: Record<string, HTMLElement> = {};
  private contents: Record<string, HTMLElement> = {};
  private activeTabKey: string;
  private onTabChange?: (tabKey: string) => void;

  constructor(options: UnifiedTabsOptions) {
    this.containerEl = options.containerEl;
    this.activeTabKey = options.defaultTab || options.tabs[0]?.key || '';
    this.onTabChange = options.onTabChange;

    this.createTabStructure(options.tabs);
    this.activateDefaultTab();
  }

  /**
   * Create the tab structure exactly like MemorySettingsTab
   */
  private createTabStructure(tabConfigs: UnifiedTabConfig[]): void {
    // Create tabs container with exact same class as Memory Manager
    this.tabContainer = this.containerEl.createDiv({ cls: 'memory-settings-tabs' });
    
    // Create individual tab elements exactly like Memory Manager
    tabConfigs.forEach(config => {
      this.tabs[config.key] = this.tabContainer.createDiv({ 
        cls: 'memory-tab', 
        text: config.label 
      });
    });

    // Content container with exact same class as Memory Manager
    this.contentContainer = this.containerEl.createDiv({ cls: 'memory-tab-content' });
    
    // Create content panes exactly like Memory Manager
    tabConfigs.forEach(config => {
      this.contents[config.key] = this.contentContainer.createDiv({ 
        cls: 'memory-tab-pane' 
      });
    });

    // Setup tab switching logic exactly like Memory Manager
    Object.entries(this.tabs).forEach(([key, tab]) => {
      tab.addEventListener('click', () => {
        this.switchToTab(key);
      });
    });
  }

  /**
   * Switch to a specific tab using exact Memory Manager logic
   */
  private switchToTab(tabKey: string): void {
    this.activeTabKey = tabKey;
    
    // Remove active class from all tabs and contents (exact Memory Manager pattern)
    Object.values(this.tabs).forEach(t => t.removeClass('active'));
    Object.values(this.contents).forEach(c => c.removeClass('active'));
    
    // Add active class to clicked tab and corresponding content (exact Memory Manager pattern)
    this.tabs[tabKey]?.addClass('active');
    this.contents[tabKey]?.addClass('active');
    
    // Call callback if provided
    this.onTabChange?.(tabKey);
  }

  /**
   * Activate the default tab
   */
  private activateDefaultTab(): void {
    if (this.activeTabKey && this.tabs[this.activeTabKey]) {
      this.switchToTab(this.activeTabKey);
    } else if (Object.keys(this.tabs).length > 0) {
      // Fallback to first tab
      const firstTabKey = Object.keys(this.tabs)[0];
      this.activeTabKey = firstTabKey;
      this.switchToTab(firstTabKey);
    }
  }

  /**
   * Get content container for a specific tab
   */
  getTabContent(tabKey: string): HTMLElement | undefined {
    return this.contents[tabKey];
  }

  /**
   * Get the currently active tab key
   */
  getActiveTab(): string {
    return this.activeTabKey;
  }

  /**
   * Programmatically switch to a tab
   */
  activateTab(tabKey: string): void {
    if (this.contents[tabKey]) {
      this.switchToTab(tabKey);
    }
  }

  /**
   * Get all tab keys
   */
  getTabKeys(): string[] {
    return Object.keys(this.tabs);
  }

  /**
   * Update a tab's label
   */
  updateTabLabel(tabKey: string, newLabel: string): void {
    if (this.tabs[tabKey]) {
      this.tabs[tabKey].textContent = newLabel;
    }
  }

  /**
   * Check if a tab exists
   */
  hasTab(tabKey: string): boolean {
    return !!this.tabs[tabKey];
  }

  /**
   * Destroy the tabs component
   */
  destroy(): void {
    this.containerEl.empty();
    this.tabs = {};
    this.contents = {};
  }
}
```

## components/accordions/AgentManagement.ts

```typescript
import { Accordion } from '../Accordion';
import { Settings } from '../../settings';
import { CustomPromptStorageService } from "../../agents/agentManager/services/CustomPromptStorageService";
import { CustomPrompt, LLMProviderSettings, DEFAULT_LLM_PROVIDER_SETTINGS, ChatViewSettings } from '../../types';
import { Setting, Modal, App, ButtonComponent, ToggleComponent } from 'obsidian';
import { LLMProviderTab } from '../LLMProviderTab';
import { LLMUsageTab } from '../LLMUsageTab';
import { ChatViewTab } from './ChatViewTab';
import { UnifiedTabs, UnifiedTabConfig } from '../UnifiedTabs';
import { CardManager, CardManagerConfig } from '../CardManager';

/**
 * Agent Management accordion component
 * Controls custom prompt agents and LLM providers with tab interface
 */
export class AgentManagementAccordion extends Accordion {
    private settings: Settings;
    private customPromptStorage: CustomPromptStorageService;
    private app: App;
    private pluginLifecycleManager?: any;
    
    // Tab system
    private unifiedTabs: UnifiedTabs | null = null;
    
    // Agent tab content
    private agentCardManager: CardManager<CustomPrompt> | null = null;
    
    // LLM Provider tab
    private llmProviderTab: LLMProviderTab | null = null;
    
    // LLM Usage tab
    private llmUsageTab: LLMUsageTab | null = null;
    
    // ChatView tab
    private chatViewTab: ChatViewTab | null = null;
    
    /**
     * Create a new Agent Management accordion
     * @param containerEl Parent container element
     * @param settings Plugin settings
     * @param customPromptStorage Custom prompt storage service
     * @param app Obsidian app instance
     * @param pluginLifecycleManager Optional lifecycle manager for ChatView activation
     */
    constructor(
        containerEl: HTMLElement, 
        settings: Settings,
        customPromptStorage: CustomPromptStorageService,
        app: App,
        pluginLifecycleManager?: any
    ) {
        super(containerEl, 'Agent Management', false);
        
        this.settings = settings;
        this.customPromptStorage = customPromptStorage;
        this.app = app;
        this.pluginLifecycleManager = pluginLifecycleManager;
        
        this.initializeContent();
    }
    
    /**
     * Initialize the accordion content with tabs
     */
    private initializeContent(): void {
        this.contentEl.empty();
        
        // Ensure LLM provider settings exist, but preserve existing values
        if (!this.settings.settings.llmProviders) {
            this.settings.settings.llmProviders = DEFAULT_LLM_PROVIDER_SETTINGS;
        } else {
            // Merge with defaults to ensure all provider entries exist, but keep existing API keys
            const currentSettings = this.settings.settings.llmProviders;
            const mergedProviders = { ...DEFAULT_LLM_PROVIDER_SETTINGS.providers };
            
            // Preserve existing provider settings (especially API keys)
            Object.keys(currentSettings.providers || {}).forEach(providerId => {
                if (mergedProviders[providerId]) {
                    mergedProviders[providerId] = {
                        ...mergedProviders[providerId],
                        ...currentSettings.providers[providerId]
                    };
                }
            });
            
            this.settings.settings.llmProviders = {
                ...DEFAULT_LLM_PROVIDER_SETTINGS,
                ...currentSettings,
                providers: mergedProviders
            };
        }
        
        // Ensure ChatView settings exist with defaults
        if (!this.settings.settings.chatView) {
            this.settings.settings.chatView = {
                enabled: false,
                acknowledgedExperimental: false
            };
        }
        
        // Save settings after ensuring they're properly initialized
        this.settings.saveSettings();
        
        this.createTabStructure();
    }

    /**
     * Create the tab structure using the unified tabs component
     */
    private createTabStructure(): void {
        const tabConfigs: UnifiedTabConfig[] = [
            { key: 'agents', label: 'ü§ñ Custom Agents' },
            { key: 'llm-providers', label: 'üîë LLM Providers' },
            { key: 'llm-usage', label: 'üìä LLM Usage' },
            { key: 'chatview', label: 'üí¨ AI Chat (Experimental)' }
        ];
        
        this.unifiedTabs = new UnifiedTabs({
            containerEl: this.contentEl,
            tabs: tabConfigs,
            defaultTab: 'agents',
            onTabChange: (tabKey: string) => this.onTabChange(tabKey)
        });
        
        // Initialize tab content
        this.createAgentsTab();
        this.createLLMProvidersTab();
        this.createLLMUsageTab();
        this.createChatViewTab();
    }

    /**
     * Handle tab change events
     */
    private onTabChange(tabKey: string): void {
        // Any additional logic when tabs change can go here
        // For now, the TabContainer handles all the display logic
    }


    /**
     * Create the Custom Agents tab content
     */
    private createAgentsTab(): void {
        const contentEl = this.unifiedTabs?.getTabContent('agents');
        if (!contentEl) return;
        
        const cardManagerConfig: CardManagerConfig<CustomPrompt> = {
            containerEl: contentEl,
            title: 'Custom Agents',
            addButtonText: 'Add Agent',
            emptyStateText: 'No custom agents created yet. Click "Add Agent" to create your first one.',
            items: this.customPromptStorage.getAllPrompts(),
            onAdd: () => this.openPromptModal(),
            onToggle: async (prompt: CustomPrompt, enabled: boolean) => {
                await this.customPromptStorage.togglePrompt(prompt.id);
            },
            onEdit: (prompt: CustomPrompt) => this.openPromptModal(prompt),
            onDelete: (prompt: CustomPrompt) => this.deletePrompt(prompt),
            showToggle: true
        };
        
        this.agentCardManager = new CardManager(cardManagerConfig);
    }

    /**
     * Create the LLM Providers tab content
     */
    private createLLMProvidersTab(): void {
        const contentEl = this.unifiedTabs?.getTabContent('llm-providers');
        if (!contentEl) return;
        
        this.llmProviderTab = new LLMProviderTab({
            containerEl: contentEl,
            settings: this.settings.settings.llmProviders!,
            app: this.app,
            onSettingsChange: async (llmProviderSettings: LLMProviderSettings) => {
                this.settings.settings.llmProviders = llmProviderSettings;
                await this.settings.saveSettings();
            }
        });
    }
    
    /**
     * Create the LLM Usage tab content
     */
    private createLLMUsageTab(): void {
        const contentEl = this.unifiedTabs?.getTabContent('llm-usage');
        if (!contentEl) return;
        
        this.llmUsageTab = new LLMUsageTab({
            containerEl: contentEl,
            app: this.app
        });
    }
    
    /**
     * Create the ChatView tab content
     */
    private createChatViewTab(): void {
        const contentEl = this.unifiedTabs?.getTabContent('chatview');
        if (!contentEl) return;
        
        this.chatViewTab = new ChatViewTab({
            containerEl: contentEl,
            settings: this.settings.settings.chatView!,
            app: this.app,
            onSettingsChange: async (chatViewSettings: ChatViewSettings) => {
                this.settings.settings.chatView = chatViewSettings;
                await this.settings.saveSettings();
            },
            onChatViewEnabled: async () => {
                // Register ChatView UI and auto-open on first enable
                if (this.pluginLifecycleManager) {
                    await this.pluginLifecycleManager.enableChatViewUI();
                }
            }
        });
    }
    
    /**
     * Refresh the agent cards display
     */
    private refreshAgentCards(): void {
        if (this.agentCardManager) {
            const prompts = this.customPromptStorage.getAllPrompts();
            this.agentCardManager.updateItems(prompts);
        }
    }
    
    /**
     * Open the prompt modal for creating or editing
     * @param prompt Existing prompt to edit, or undefined for new prompt
     */
    private openPromptModal(prompt?: CustomPrompt): void {
        new PromptModal(this.app, prompt, async (result) => {
            if (prompt) {
                // Edit existing prompt
                await this.customPromptStorage.updatePrompt(prompt.id, result);
            } else {
                // Create new prompt - default to enabled
                await this.customPromptStorage.createPrompt({
                    ...result,
                    isEnabled: true
                });
            }
            this.refreshAgentCards();
        }).open();
    }
    
    /**
     * Delete a prompt with confirmation
     * @param prompt Prompt to delete
     */
    private async deletePrompt(prompt: CustomPrompt): Promise<void> {
        const confirmed = confirm(`Are you sure you want to delete the agent "${prompt.name}"? This action cannot be undone.`);
        if (confirmed) {
            await this.customPromptStorage.deletePrompt(prompt.id);
            this.refreshAgentCards();
        }
    }
    
    /**
     * Cleanup when accordion is unloaded
     */
    onunload(): void {
        if (this.llmUsageTab) {
            this.llmUsageTab.destroy();
            this.llmUsageTab = null;
        }
        if (this.chatViewTab) {
            this.chatViewTab.destroy();
            this.chatViewTab = null;
        }
        super.onunload();
    }
}

/**
 * Modal for creating/editing custom prompts
 */
class PromptModal extends Modal {
    private prompt?: CustomPrompt;
    private onSave: (result: Omit<CustomPrompt, 'id' | 'isEnabled'>) => void;
    
    private nameInput!: HTMLInputElement;
    private descriptionInput!: HTMLInputElement;
    private promptTextarea!: HTMLTextAreaElement;
    
    constructor(app: App, prompt: CustomPrompt | undefined, onSave: (result: Omit<CustomPrompt, 'id' | 'isEnabled'>) => void) {
        super(app);
        this.prompt = prompt;
        this.onSave = onSave;
    }
    
    onOpen(): void {
        const { contentEl } = this;
        contentEl.empty();
        
        contentEl.createEl('h1', { text: this.prompt ? 'Edit Agent' : 'Create New Agent' });
        
        // Name field
        contentEl.createEl('h2', { text: 'Name' });
        this.nameInput = contentEl.createEl('input', { 
            type: 'text',
            cls: 'agent-modal-input'
        });
        this.nameInput.value = this.prompt?.name || '';
        this.nameInput.placeholder = 'e.g., Writing Assistant, Code Reviewer, Research Helper';
        
        // Description field
        contentEl.createEl('h2', { text: 'Description' });
        this.descriptionInput = contentEl.createEl('input', { 
            type: 'text',
            cls: 'agent-modal-input'
        });
        this.descriptionInput.value = this.prompt?.description || '';
        this.descriptionInput.placeholder = 'e.g., Expert at creative writing and editing';
        
        // Instructions field
        contentEl.createEl('h2', { text: 'Instructions' });
        this.promptTextarea = contentEl.createEl('textarea', {
            cls: 'agent-modal-textarea'
        });
        this.promptTextarea.value = this.prompt?.prompt || '';
        this.promptTextarea.placeholder = 'You are a professional writing assistant with expertise in creative writing, grammar, and style. Always provide constructive, actionable feedback to help improve the user\'s writing. Focus on clarity, flow, and engagement while maintaining the author\'s unique voice.';
        this.promptTextarea.rows = 6;
        
        // Buttons
        const buttonContainer = contentEl.createDiv('modal-button-container agent-management-button-container');
        
        const cancelBtn = buttonContainer.createEl('button', { text: 'Cancel' });
        cancelBtn.addEventListener('click', () => this.close());
        
        const saveBtn = buttonContainer.createEl('button', { text: this.prompt ? 'Save' : 'Create', cls: 'mod-cta' });
        saveBtn.addEventListener('click', () => this.savePrompt());
        
        // Focus name input
        this.nameInput.focus();
    }
    
    onClose(): void {
        const { contentEl } = this;
        contentEl.empty();
    }
    
    private savePrompt(): void {
        const name = this.nameInput.value.trim();
        const description = this.descriptionInput.value.trim();
        const prompt = this.promptTextarea.value.trim();
        
        // Validation
        if (!name) {
            this.nameInput.focus();
            return;
        }
        
        if (!description) {
            this.descriptionInput.focus();
            return;
        }
        
        if (!prompt) {
            this.promptTextarea.focus();
            return;
        }
        
        this.onSave({
            name,
            description,
            prompt
        });
        
        this.close();
    }
}
```

## components/accordions/ChatViewTab.ts

```typescript
import { Setting, App, ToggleComponent } from 'obsidian';
import { Settings } from '../../settings';
import { ChatViewSettings } from '../../types';

export interface ChatViewTabConfig {
    containerEl: HTMLElement;
    settings: ChatViewSettings;
    app: App;
    onSettingsChange: (settings: ChatViewSettings) => Promise<void>;
    onChatViewEnabled?: () => Promise<void>;
}

/**
 * ChatView Tab - Experimental AI Chat controls and warnings
 * Provides settings for the experimental ChatView feature with appropriate warnings
 */
export class ChatViewTab {
    private config: ChatViewTabConfig;
    
    constructor(config: ChatViewTabConfig) {
        this.config = config;
        this.createContent();
    }
    
    /**
     * Create the tab content with experimental warnings and controls
     */
    private createContent(): void {
        const { containerEl } = this.config;
        containerEl.empty();
        
        // Experimental warning banner
        this.createExperimentalWarning();
        
        // ChatView enable/disable controls
        this.createChatViewControls();
        
        // Additional information
        this.createAdditionalInfo();
    }
    
    /**
     * Create the experimental warning banner
     */
    private createExperimentalWarning(): void {
        const warningContainer = this.config.containerEl.createDiv('experimental-warning-container');
        
        // Warning icon and header
        const warningHeader = warningContainer.createDiv('experimental-warning-header');
        warningHeader.createSpan({ text: '‚ö†Ô∏è', cls: 'experimental-warning-icon' });
        warningHeader.createEl('h3', { text: 'Experimental Feature', cls: 'experimental-warning-title' });
        
        // Warning message
        const warningMessage = warningContainer.createDiv('experimental-warning-message');
        warningMessage.createEl('p', {
            text: 'The AI Chat feature is experimental and may contain bugs or unexpected behavior. Use at your own risk.'
        });
        
        // Feedback link
        const feedbackParagraph = warningMessage.createEl('p');
        feedbackParagraph.createSpan({ text: 'Found an issue? ' });
        const feedbackLink = feedbackParagraph.createEl('a', {
            text: 'Report it on GitHub',
            href: 'https://github.com/ProfSynapse/claudesidian-mcp/issues'
        });
        feedbackLink.setAttribute('target', '_blank');
        feedbackLink.setAttribute('rel', 'noopener noreferrer');
    }
    
    /**
     * Create ChatView enable/disable controls
     */
    private createChatViewControls(): void {
        const controlsSection = this.config.containerEl.createDiv('chatview-controls-section');
        controlsSection.createEl('h4', { text: 'AI Chat Settings' });
        
        // Enable ChatView toggle
        new Setting(controlsSection)
            .setName('Enable AI Chat')
            .setDesc('Enable the experimental AI chat interface. Requires acknowledgment of experimental nature.')
            .addToggle((toggle: ToggleComponent) => {
                toggle
                    .setValue(this.config.settings.enabled)
                    .onChange(async (value: boolean) => {
                        if (value && !this.config.settings.acknowledgedExperimental) {
                            // If enabling but not acknowledged, show acknowledgment first
                            toggle.setValue(false);
                            this.showAcknowledgmentDialog(async () => {
                                // After acknowledgment, enable the toggle
                                this.config.settings.acknowledgedExperimental = true;
                                this.config.settings.enabled = true;
                                toggle.setValue(true);
                                await this.saveSettings();
                                this.refreshAcknowledgmentDisplay();
                                
                                // Trigger ChatView activation (register UI and auto-open)
                                if (this.config.onChatViewEnabled) {
                                    await this.config.onChatViewEnabled();
                                }
                            });
                        } else {
                            this.config.settings.enabled = value;
                            await this.saveSettings();
                            
                            // If enabling (and already acknowledged), trigger ChatView activation
                            if (value && this.config.onChatViewEnabled) {
                                await this.config.onChatViewEnabled();
                            }
                        }
                    });
            });
        
        // Acknowledgment status
        this.createAcknowledgmentDisplay();
    }
    
    /**
     * Create acknowledgment status display
     */
    private createAcknowledgmentDisplay(): void {
        const ackContainer = this.config.containerEl.createDiv('acknowledgment-display');
        this.refreshAcknowledgmentDisplay();
    }
    
    /**
     * Refresh the acknowledgment display
     */
    private refreshAcknowledgmentDisplay(): void {
        const ackContainer = this.config.containerEl.querySelector('.acknowledgment-display') as HTMLElement;
        if (!ackContainer) return;
        
        ackContainer.empty();
        
        if (this.config.settings.acknowledgedExperimental) {
            const ackStatus = ackContainer.createDiv('acknowledgment-status acknowledged');
            ackStatus.createSpan({ text: '‚úì', cls: 'acknowledgment-check' });
            ackStatus.createSpan({ text: 'Experimental nature acknowledged' });
        } else {
            const ackStatus = ackContainer.createDiv('acknowledgment-status not-acknowledged');
            ackStatus.createSpan({ text: '‚óã', cls: 'acknowledgment-pending' });
            ackStatus.createSpan({ text: 'Experimental acknowledgment required to enable' });
        }
    }
    
    /**
     * Show acknowledgment dialog
     */
    private showAcknowledgmentDialog(onAcknowledge: () => Promise<void>): void {
        const modal = document.createElement('div');
        modal.className = 'modal-container mod-dim';
        
        const modalBg = modal.createDiv('modal-bg');
        const modalContent = modal.createDiv('modal');
        
        // Modal header
        const modalHeader = modalContent.createDiv('modal-header');
        modalHeader.createEl('h2', { text: 'Acknowledge Experimental Feature' });
        
        // Modal body
        const modalBody = modalContent.createDiv('modal-body');
        modalBody.createEl('p', {
            text: 'The AI Chat feature is experimental and may:'
        });
        
        const riskList = modalBody.createEl('ul');
        riskList.createEl('li', { text: 'Contain bugs or unexpected behavior' });
        riskList.createEl('li', { text: 'Change significantly in future updates' });
        riskList.createEl('li', { text: 'Consume API tokens from your LLM providers' });
        riskList.createEl('li', { text: 'Not work reliably in all scenarios' });
        
        modalBody.createEl('p', {
            text: 'By proceeding, you acknowledge these risks and agree to use the feature at your own discretion.'
        });
        
        // Modal buttons
        const modalButtons = modalContent.createDiv('modal-button-container');
        
        const cancelBtn = modalButtons.createEl('button', { text: 'Cancel' });
        cancelBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        const acknowledgeBtn = modalButtons.createEl('button', { 
            text: 'I Understand - Enable Chat', 
            cls: 'mod-cta' 
        });
        acknowledgeBtn.addEventListener('click', async () => {
            await onAcknowledge();
            document.body.removeChild(modal);
        });
        
        // Close on background click
        modalBg.addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        document.body.appendChild(modal);
    }
    
    /**
     * Create additional information section
     */
    private createAdditionalInfo(): void {
        const infoSection = this.config.containerEl.createDiv('chatview-info-section');
        infoSection.createEl('h4', { text: 'About AI Chat' });
        
        const infoParagraph = infoSection.createEl('p');
        infoParagraph.createSpan({ 
            text: 'The AI Chat feature provides a conversational interface for interacting with AI models. '
        });
        infoParagraph.createSpan({
            text: 'It integrates with your configured LLM providers and can execute vault operations through MCP tools.'
        });
        
        // Usage notes
        const usageSection = infoSection.createDiv('chatview-usage-notes');
        usageSection.createEl('h5', { text: 'Usage Notes:' });
        
        const notesList = usageSection.createEl('ul');
        notesList.createEl('li', { text: 'Ensure you have LLM providers configured in the "üîë LLM Providers" tab' });
        notesList.createEl('li', { text: 'Chat conversations will consume API tokens from your providers' });
        notesList.createEl('li', { text: 'The chat can access and modify your vault through available agents' });
        notesList.createEl('li', { text: 'Report any issues or unexpected behavior on GitHub' });
    }
    
    /**
     * Save settings changes
     */
    private async saveSettings(): Promise<void> {
        await this.config.onSettingsChange(this.config.settings);
    }
    
    /**
     * Update settings and refresh display
     */
    updateSettings(settings: ChatViewSettings): void {
        this.config.settings = settings;
        this.refreshAcknowledgmentDisplay();
    }
    
    /**
     * Cleanup when tab is destroyed
     */
    destroy(): void {
        // No cleanup needed for this component
    }
}
```

## components/accordions/MemoryManagement.ts

```typescript
import { Accordion } from '../Accordion';
import { Settings } from '../../settings';
import { VaultLibrarianAgent } from '../../agents/vaultLibrarian/vaultLibrarian';
import { MemorySettingsTab } from '../MemorySettingsTab';
import { MemoryService } from "../../agents/memoryManager/services/MemoryService";
import { WorkspaceService } from "../../agents/memoryManager/services/WorkspaceService";
import type { ServiceManager } from '../../core/ServiceManager';

/**
 * Memory Management accordion component
 * Controls enabling/disabling the memory manager and displays settings
 */
export class MemoryManagementAccordion extends Accordion {
    private settings: Settings;
    private memorySettingsContainer: HTMLElement;

    // Simplified Services
    private memoryService: MemoryService | undefined;
    private workspaceService: WorkspaceService | undefined;
    
    // Agent (for backward compatibility)
    private vaultLibrarian: VaultLibrarianAgent | undefined;
    
    private memorySettingsTab: MemorySettingsTab | null = null;
    private serviceManager: ServiceManager | undefined;
    private readinessCheckInterval: NodeJS.Timeout | null = null;
    private statusElement: HTMLElement | null = null;
    
    /**
     * Create a new Memory Management accordion
     * @param containerEl Parent container element
     * @param settings Plugin settings
     * @param memoryService MemoryService for memory traces and sessions
     * @param workspaceService WorkspaceService for workspace management
     * @param vaultLibrarian VaultLibrarian agent instance (optional, for backward compatibility)
     * @param serviceManager ServiceManager instance for checking service readiness (optional)
     */
    constructor(
        containerEl: HTMLElement,
        settings: Settings,
        memoryService?: MemoryService,
        workspaceService?: WorkspaceService,
        vaultLibrarian?: VaultLibrarianAgent,
        serviceManager?: ServiceManager
    ) {
        super(containerEl, 'Memory Management', false);
        this.settings = settings;
        this.memoryService = memoryService;
        this.workspaceService = workspaceService;
        this.vaultLibrarian = vaultLibrarian;
        this.serviceManager = serviceManager;
        
        const contentEl = this.getContentEl();
        
        // Add simple description
        contentEl.createEl('p', {
            text: 'Manage workspaces: view, create, edit, and delete workspace configurations.'
        });
        
        // Container for memory settings
        this.memorySettingsContainer = contentEl.createEl('div', {
            cls: 'memory-settings-container'
        });
        
        // Memory settings are now visible by default via CSS
        
        // Initialize UI based on current service state
        this.initializeUI();

        // Start monitoring service readiness
        this.startServiceReadinessMonitoring();
    }
    
    /**
     * Initialize UI based on current service state
     */
    private initializeUI(): void {
        if (this.areServicesReady()) {
            this.initializeMemorySettingsTab();
        } else {
            this.showServiceLoadingStatus();
        }
    }
    
    /**
     * Check if all required services are ready
     */
    private areServicesReady(): boolean {
        // If we have a service manager, use it to check readiness
        if (this.serviceManager) {
            const memoryReady = this.serviceManager.isServiceReady('memoryService');
            return memoryReady;
        }
        
        // Fallback to direct service checks
        const hasServices = this.memoryService;
        const hasAgent = this.vaultLibrarian;
        
        return !!(hasServices || hasAgent);
    }
    
    /**
     * Show service loading status with periodic updates
     */
    private showServiceLoadingStatus(): void {
        // Clear existing content
        this.memorySettingsContainer.empty();
        
        this.statusElement = this.memorySettingsContainer.createEl('div', {
            cls: 'memory-notice'
        });
        
        this.statusElement.createEl('p', {
            text: 'Memory Manager is enabled and services are initializing...'
        });
        
        this.updateServiceStatus();
        
        this.statusElement.createEl('p', {
            text: 'Settings will appear automatically when all services are ready.',
            cls: 'memory-notice-small'
        });
    }
    
    /**
     * Update service status display
     */
    private updateServiceStatus(): void {
        if (!this.statusElement) return;
        
        // Remove existing service status
        const existingStatus = this.statusElement.querySelector('.service-status');
        if (existingStatus) {
            existingStatus.remove();
        }
        
        const serviceStatus = this.statusElement.createEl('div', {
            cls: 'service-status'
        });
        
        serviceStatus.createEl('p', {
            text: 'Service Status:'
        });
        
        // Create service status list
        const serviceList = serviceStatus.createEl('ul');
        
        const services = [
            { name: 'Memory Service', key: 'memoryService', instance: this.memoryService }
        ];
        
        services.forEach(service => {
            const isReady = this.serviceManager ? 
                this.serviceManager.isServiceReady(service.key) : 
                !!service.instance;
            
            const listItem = serviceList.createEl('li');
            
            // Simple service status display
            listItem.innerHTML = `${service.name}: ${isReady ? '‚úÖ Ready' : '‚è≥ Loading...'}`;
        });
    }
    
    /**
     * Show message when memory manager is disabled
     */
    private showMemoryDisabledMessage(): void {
        this.memorySettingsContainer.empty();
        this.memorySettingsContainer.createEl('div', {
            cls: 'memory-notice',
            text: 'Memory Manager configuration options will appear here once enabled. Use the toggle in the Memory Manager Settings above to enable this feature.'
        });
    }
    
    /**
     * Start monitoring service readiness (services should already be initializing in background)
     */
    private startServiceReadinessMonitoring(): void {
        // Services should already be initializing in background
        if (this.areServicesReady()) {
            this.initializeMemorySettingsTab();
            return;
        }
        
        // Display current status
        this.updateServiceStatus();
        
        // Check once more after background initialization should complete
        setTimeout(() => {
            if (this.areServicesReady()) {
                this.initializeMemorySettingsTab();
            } else {
                // If still not ready, show current status and allow timeout handling
                this.updateServiceStatus();
                this.startFallbackMonitoring();
            }
        }, 3000); // Single check after background init
    }
    
    /**
     * Fallback monitoring for cases where background init is slow
     */
    private startFallbackMonitoring(): void {
        if (this.readinessCheckInterval) {
            clearInterval(this.readinessCheckInterval);
        }
        
        this.readinessCheckInterval = setInterval(() => {
            if (this.areServicesReady()) {
                this.stopServiceReadinessMonitoring();
                this.initializeMemorySettingsTab();
            } else {
                this.updateServiceStatus();
            }
        }, 2000); // Check every 2 seconds as fallback
        
        // Set a timeout to stop monitoring after 15 seconds
        setTimeout(() => {
            if (this.readinessCheckInterval) {
                this.stopServiceReadinessMonitoring();
                // Show the settings tab with whatever services are available
                this.initializeMemorySettingsTab();
                
                if (this.statusElement && !this.areServicesReady()) {
                    const warningEl = this.statusElement.createEl('p', {
                        text: 'Some services are still initializing. Settings may be limited until complete.',
                        cls: 'memory-notice-warning'
                    });
                    warningEl.style.color = 'var(--text-warning)';
                }
            }
        }, 15000); // Reduced timeout
    }
    
    /**
     * Stop monitoring service readiness
     */
    private stopServiceReadinessMonitoring(): void {
        if (this.readinessCheckInterval) {
            clearInterval(this.readinessCheckInterval);
            this.readinessCheckInterval = null;
        }
    }
    
    /**
     * Update services (called externally when services become available)
     */
    public updateServices(
        memoryService?: MemoryService,
        vaultLibrarian?: VaultLibrarianAgent
    ): void {
        this.memoryService = memoryService;
        this.vaultLibrarian = vaultLibrarian;
        
        // Refresh UI
        this.initializeUI();
    }
    
    /**
     * Cleanup method to clear intervals
     */
    public cleanup(): void {
        this.stopServiceReadinessMonitoring();
    }
    
    /**
     * Initialize the memory settings tab
     */
    private initializeMemorySettingsTab(): void {
        // Clear existing content
        this.memorySettingsContainer.empty();
        
        // Check if we have services available (preferred) or need to fall back to agents
        const hasServices = this.areServicesReady();
        const hasAgent = this.vaultLibrarian;
        
        if (!hasServices && !hasAgent) {
            // Show error message if neither services nor agents are available
            const errorEl = this.memorySettingsContainer.createEl('div', {
                cls: 'memory-notice error'
            });
            errorEl.createEl('p', {
                text: 'Memory Manager services are not available.'
            });
            
            // Show detailed service status for debugging
            if (this.serviceManager) {
                const statusEl = errorEl.createEl('div', {
                    cls: 'service-status-debug'
                });
                statusEl.createEl('p', {
                    text: 'Service Status:'
                });
                
                const services = ['memoryService'];
                const statusList = statusEl.createEl('ul');
                
                services.forEach(serviceName => {
                    const isReady = this.serviceManager!.isServiceReady(serviceName);
                    const listItem = statusList.createEl('li');
                    listItem.innerHTML = `${serviceName}: ${isReady ? '‚úÖ Ready' : '‚ùå Not Ready'}`;
                });
            }
            
            errorEl.createEl('p', {
                text: 'Please restart Obsidian or check console for errors.'
            });
            return;
        }
        
        // Initialize the MemorySettingsTab with simplified services
        if (this.memoryService) {
            this.memorySettingsTab = new MemorySettingsTab(
                this.memorySettingsContainer,
                (window as any).app,
                this.workspaceService!,
                this.memoryService,
                this.settings
            );
        }
        
        // Display settings
        if (this.memorySettingsTab) {
            this.memorySettingsTab.display();
        }
    }
}
```

## components/accordions/SetupInstructions.ts

```typescript
import { Accordion } from '../Accordion';
import { Setting } from 'obsidian';
import { ConfigModal } from '../ConfigModal';

export class SetupInstructionsAccordion {
    constructor(container: HTMLElement) {
        const accordion = new Accordion(container, 'Setup Instructions', false);
        const content = accordion.getContentEl();
        this.createContent(content);
    }

    private createContent(content: HTMLElement): void {
        // Prerequisites
        const prerequisites = content.createEl('div', { cls: 'mcp-section' });
        prerequisites.createEl('h4', { text: 'Prerequisites' });
        const prereqList = prerequisites.createEl('ul');
        
        const nodejsItem = prereqList.createEl('li');
        const nodejsLink = nodejsItem.createEl('a', {
            text: 'Node.js',
            href: 'https://nodejs.org/en/download'
        });
        nodejsLink.setAttr('target', '_blank');
        nodejsItem.appendChild(document.createTextNode(' installed on your system'));

        const claudeItem = prereqList.createEl('li');
        const claudeLink = claudeItem.createEl('a', {
            text: 'Claude Desktop App',
            href: 'https://claude.ai/download'
        });
        claudeLink.setAttr('target', '_blank');
        claudeItem.appendChild(document.createTextNode(' installed'));

        // Setup steps
        content.createEl('h4', { text: 'Installation Steps' });
        const setupSteps = content.createEl('ol');
        setupSteps.createEl('li', {
            text: 'Close Claude completely (ensure it\'s not running in background)'
        });
        setupSteps.createEl('li', {
            text: 'Click the "Open Configuration" button below'
        });
        setupSteps.createEl('li', {
            text: 'Copy the appropriate configuration based on your setup'
        });
        setupSteps.createEl('li', {
            text: 'Open the configuration file using the provided link'
        });
        setupSteps.createEl('li', {
            text: 'Paste the copied text (replacing everything if no existing MCPs, or adding to the servers array if you have them)'
        });
        setupSteps.createEl('li', {
            text: 'Open Claude Desktop App'
        });
        setupSteps.createEl('li', {
            text: 'Look for the hammer icon with a number at the bottom of the chatbox'
        });
        
        // Memory Manager Setup
        content.createEl('h4', { text: 'Memory Manager Setup (Optional)' });
        const memorySteps = content.createEl('ol');
        memorySteps.createEl('li', {
            text: 'Go to the Memory Management accordion in Settings'
        });
        memorySteps.createEl('li', {
            text: 'Enable Memory Manager using the toggle switch if it does not automatically enable'
        });
        
        // Add a note about what the Memory Manager does
        const memoryNote = content.createEl('div', { cls: 'mcp-setup-instructions' });
        memoryNote.createEl('p', { text: 'The Memory Manager enables workspace and session management across your vault, allowing Claude to organize content and maintain context. Once configured, Claude can use memory management modes to work with your content organization.' });

        // Configuration button
        new Setting(content)
            .setName('MCP Configuration')
            .setDesc('Configure MCP agents and tools')
            .addButton(button => button
                .setButtonText('Open Configuration')
                .onClick(() => {
                    // @ts-ignore - App is available in Obsidian context
                    const app = window.app;
                    new ConfigModal(app).open();
                }));
    }
}

```

## components/accordions/WhatIsClaudesidian.ts

```typescript
import { Accordion } from '../Accordion';

export class WhatIsClaudesidianAccordion {
    constructor(container: HTMLElement) {
        const accordion = new Accordion(container, 'What is Claudesidian?', false);
        const content = accordion.getContentEl();
        this.createContent(content);
    }

    private createAgentDescription(container: HTMLElement, name: string, description: string): void {
        const agentEl = container.createEl('div', { cls: 'mcp-agent' });
        agentEl.createEl('h4', { text: name, cls: 'mcp-agent-name' });
        agentEl.createEl('p', { text: description, cls: 'mcp-agent-description' });
    }

    private createContent(content: HTMLElement): void {
        content.createEl('p', {
            text: 'Claudesidian MCP transforms your Obsidian vault into a natural language programming environment that enables powerful AI-assisted note-taking and knowledge management by connecting the Claude Desktop App to your vault, and giving it tools to take actions.'
        });

        // Natural Language Programming explanation
        const nlpInfo = content.createEl('div', { cls: 'mcp-section' });
        nlpInfo.createEl('h4', { text: 'Natural Language Programming' });
        nlpInfo.createEl('p', {
            text: 'Work with your notes using natural language commands and structured templates. Claudesidian understands your vault organization and can help you:'
        });
        
        const nlpList = nlpInfo.createEl('ul');
        nlpList.createEl('li', {
            text: 'Create and organize notes using consistent patterns'
        });
        nlpList.createEl('li', {
            text: 'Search and retrieve information from your vault using natural language queries'
        });
        nlpList.createEl('li', {
            text: 'Track projects and research progress'
        });
        nlpList.createEl('li', {
            text: 'Build connections between your notes'
        });
        nlpList.createEl('li', {
            text: 'And anything else you can dream up by leveraging the below agents!'
        });

        // Agents section within intro
        const agentsSection = content.createEl('div', { cls: 'mcp-section' });
        agentsSection.createEl('h4', { text: 'Available Agents' });
        const agentsContainer = agentsSection.createEl('div', { cls: 'mcp-agents-container' });

        // Add all agents
        this.createAgentDescription(
            agentsContainer,
            'Content Manager',
            'Manages note content with read, create, append, prepend, replace, delete, find-replace, and batch operations. Combines functionality of the previous Note Reader and Note Editor agents into a single unified interface for all content operations.'
        );
        
        this.createAgentDescription(
            agentsContainer,
            'Command Manager',
            'Executes Obsidian commands on your behalf using the command palette (Control+P/Cmd+P). Can list available commands and execute them, enabling access to any functionality in the command palette, automating tasks, and triggering plugin features.'
        );
        
        
        this.createAgentDescription(
            agentsContainer,
            'Vault Manager',
            'Manages vault organization with operations for listing files/folders, creating/editing/deleting folders, moving notes, and duplicating notes. Provides comprehensive file system management for your vault structure.'
        );
        
        this.createAgentDescription(
            agentsContainer,
            'Vault Librarian',
            'Searches and navigates your vault with advanced content, tag, property, and text search capabilities. Includes batch operations for complex search patterns and content matching.'
        );
        
        this.createAgentDescription(
            agentsContainer,
            'Memory Manager',
            'Manages workspace sessions, state snapshots, and persistent memory across conversations. Provides operations for creating, listing, editing, and deleting sessions and snapshot states.'
        );
        
        this.createAgentDescription(
            agentsContainer,
            'Agent Manager',
            'Manages agent configurations, custom prompts, and agent-specific settings. Provides operations for creating, editing, and managing custom agent prompts and behaviors.'
        );
        

        // Example Interactions section within intro
        const examplesSection = content.createEl('div', { cls: 'mcp-section' });
        examplesSection.createEl('h4', { text: 'Example Interactions' });
        
        const examplesList = examplesSection.createEl('ul');
        examplesList.createEl('li', { 
            text: '"Create a literature note for this paper using our template" - Claude follows template structure and updates MOCs'
        });
        examplesList.createEl('li', { 
            text: '"Analyze these research notes and update our map of contents" - Claude identifies connections and updates maps'
        });
        examplesList.createEl('li', { 
            text: '"Start new project: Research Database" - Claude sets up project structure and tracking'
        });
    }
}

```

## components/accordions/index.ts

```typescript
export { WhatIsClaudesidianAccordion } from './WhatIsClaudesidian';
export { SetupInstructionsAccordion } from './SetupInstructions';
export { MemoryManagementAccordion } from './MemoryManagement';
export { AgentManagementAccordion } from './AgentManagement';

```

## components/shared/UsageChart.ts

```typescript
/**
 * Shared Usage Chart Component
 * Displays provider-based cost breakdown with Obsidian-style design
 */

import { ProviderUsage, BudgetStatus, UsageData } from '../../services/UsageTracker';

export interface UsageChartOptions {
    containerEl: HTMLElement;
    title: string;
    usageData: UsageData;
    budgetStatus?: BudgetStatus;
    onResetMonthly?: () => void;
    onBudgetChange?: (budget: number) => void;
}

export class UsageChart {
    private containerEl: HTMLElement;
    private options: UsageChartOptions;

    constructor(options: UsageChartOptions) {
        this.containerEl = options.containerEl;
        this.options = options;
        this.render();
    }

    /**
     * Update the chart with new data
     */
    update(usageData: UsageData, budgetStatus?: BudgetStatus): void {
        this.options.usageData = usageData;
        this.options.budgetStatus = budgetStatus;
        this.render();
    }

    /**
     * Render the usage chart
     */
    private render(): void {
        this.containerEl.empty();
        
        // Create main container
        const chartContainer = this.containerEl.createDiv('usage-chart-container');
        
        // Title
        const titleEl = chartContainer.createEl('h4', { text: this.options.title, cls: 'usage-chart-title' });

        // Budget section (if provided)
        if (this.options.budgetStatus) {
            this.renderBudgetSection(chartContainer);
        }

        // Monthly costs section
        this.renderCostsSection(chartContainer, 'This Month', this.options.usageData.monthly, this.options.usageData.monthlyTotal);
        
        // All-time costs section
        this.renderCostsSection(chartContainer, 'All Time', this.options.usageData.allTime, this.options.usageData.allTimeTotal);

        // Action buttons
        this.renderActionButtons(chartContainer);
    }

    /**
     * Render budget status section
     */
    private renderBudgetSection(container: HTMLElement): void {
        if (!this.options.budgetStatus) return;

        const budgetSection = container.createDiv('usage-budget-section');

        // Budget header
        const budgetHeader = budgetSection.createEl('h5', { text: 'Monthly Budget', cls: 'usage-budget-header' });

        // Budget info
        const budgetInfo = budgetSection.createDiv();
        
        if (this.options.budgetStatus.monthlyBudget > 0) {
            // Progress bar
            const progressContainer = budgetInfo.createDiv('usage-progress-container');
            
            const progressBar = progressContainer.createDiv('usage-progress-bar');
            
            const progressFill = progressBar.createDiv('usage-progress-fill');
            const percentage = Math.min(100, this.options.budgetStatus.percentageUsed);
            progressFill.style.width = `${percentage}%`;
            
            // Add appropriate status class
            if (percentage >= 100) {
                progressFill.addClass('error');
            } else if (percentage >= 80) {
                progressFill.addClass('warning');
            } else {
                progressFill.addClass('success');
            }

            // Budget text
            const budgetText = budgetInfo.createDiv('usage-budget-text');
            
            const currentSpending = this.formatCurrency(this.options.budgetStatus.currentSpending);
            const totalBudget = this.formatCurrency(this.options.budgetStatus.monthlyBudget);
            const percentText = `${this.options.budgetStatus.percentageUsed}%`;
            
            budgetText.textContent = `${currentSpending} of ${totalBudget} used (${percentText})`;
            
            // Budget exceeded warning
            if (this.options.budgetStatus.budgetExceeded) {
                const warningEl = budgetInfo.createDiv('usage-budget-warning');
                warningEl.textContent = '‚ö†Ô∏è Budget exceeded - API calls will be blocked';
            }
        } else {
            budgetInfo.textContent = 'No budget set';
            budgetInfo.addClass('usage-budget-text');
        }

        // Budget setting input
        if (this.options.onBudgetChange) {
            const budgetInput = budgetSection.createEl('input', { cls: 'usage-budget-input' });
            budgetInput.type = 'number';
            budgetInput.step = '0.01';
            budgetInput.min = '0';
            budgetInput.placeholder = 'Set monthly budget ($)';
            budgetInput.value = this.options.budgetStatus.monthlyBudget > 0 ? 
                              this.options.budgetStatus.monthlyBudget.toString() : '';

            budgetInput.addEventListener('change', () => {
                const budget = parseFloat(budgetInput.value) || 0;
                this.options.onBudgetChange!(budget);
            });
        }
    }

    /**
     * Render costs section (monthly or all-time)
     */
    private renderCostsSection(container: HTMLElement, title: string, usage: ProviderUsage, total: number): void {
        const section = container.createDiv('usage-costs-section');

        // Section title
        const sectionTitle = section.createEl('h5', { text: title, cls: 'usage-section-title' });

        // Total cost
        const totalEl = section.createDiv('usage-total-cost');
        totalEl.textContent = `Total: ${this.formatCurrency(total)}`;

        // Provider breakdown with stacked progress bar
        const providers = Object.entries(usage);
        if (providers.length > 0) {
            // Create stacked progress bar
            this.renderStackedProgressBar(section, providers, total);
            
            // Create provider list below the progress bar
            const providerList = section.createDiv('usage-provider-list');
            
            providers
                .sort(([, a], [, b]) => b - a) // Sort by cost descending
                .forEach(([provider, cost]) => {
                    this.renderProviderListItem(providerList, provider, cost, total);
                });
        } else {
            // Show empty progress bar even when no usage
            const progressContainer = section.createDiv('usage-stacked-progress-container');
            
            const noDataEl = section.createDiv('usage-no-data');
            noDataEl.textContent = 'No usage yet';
        }
    }

    /**
     * Render stacked progress bar showing all providers
     */
    private renderStackedProgressBar(container: HTMLElement, providers: [string, number][], totalCost: number): void {
        const progressContainer = container.createDiv('usage-stacked-progress-container');
        
        // Sort providers by cost descending for consistent stacking
        const sortedProviders = providers.sort(([, a], [, b]) => b - a);
        
        sortedProviders.forEach(([provider, cost]) => {
            const percentage = totalCost > 0 ? (cost / totalCost) * 100 : 0;
            
            if (percentage > 0) {
                const segment = progressContainer.createDiv('usage-progress-segment');
                segment.style.width = `${percentage}%`;
                segment.style.backgroundColor = this.getProviderColor(provider);
                
                // Add tooltip on hover
                segment.title = `${this.formatProviderName(provider)}: ${this.formatCurrency(cost)} (${percentage.toFixed(1)}%)`;
            }
        });
    }

    /**
     * Render provider list item with color indicator
     */
    private renderProviderListItem(container: HTMLElement, provider: string, cost: number, totalCost: number): void {
        const providerEl = container.createDiv('usage-provider-item');
        
        // Left side: color indicator + name
        const leftEl = providerEl.createDiv('usage-provider-left');
        
        // Color indicator
        const colorDot = leftEl.createDiv('usage-provider-color-dot');
        colorDot.style.backgroundColor = this.getProviderColor(provider);
        
        // Provider name
        const nameEl = leftEl.createSpan({ cls: 'usage-provider-name' });
        nameEl.textContent = this.formatProviderName(provider);
        
        // Right side: cost and percentage
        const rightEl = providerEl.createDiv('usage-provider-right');
        
        const costEl = rightEl.createSpan({ cls: 'usage-provider-cost' });
        costEl.textContent = this.formatCurrency(cost);
        
        const percentageEl = rightEl.createSpan({ cls: 'usage-provider-percentage' });
        const percentage = totalCost > 0 ? (cost / totalCost) * 100 : 0;
        percentageEl.textContent = `(${percentage.toFixed(1)}%)`;
    }

    /**
     * Get color for provider
     */
    private getProviderColor(provider: string): string {
        const colors: { [key: string]: string } = {
            'openai': '#10a37f',        // OpenAI green
            'anthropic': '#d4715a',     // Anthropic orange/brown
            'google': '#4285f4',        // Google blue
            'groq': '#f55036',          // Groq red/orange
            'ollama': '#8b5cf6',        // Purple for local
            'perplexity': '#20a4f7',    // Perplexity blue
            'xai': '#000000',           // xAI black
            'mistral': '#ff6b35',       // Mistral orange
            'cohere': '#39b5f1',        // Cohere blue
            'openrouter': '#6366f1'     // Indigo for OpenRouter
        };
        
        return colors[provider.toLowerCase()] || '#6b7280'; // Default gray
    }

    /**
     * Render action buttons
     */
    private renderActionButtons(container: HTMLElement): void {
        if (!this.options.onResetMonthly) return;

        const actionsSection = container.createDiv('usage-actions');

        const resetButton = actionsSection.createEl('button', { text: 'Reset Monthly Usage', cls: 'usage-reset-button' });

        resetButton.addEventListener('click', () => {
            this.options.onResetMonthly!();
        });

        // Hover effects are now handled by CSS
    }

    /**
     * Format currency value with better precision for small amounts
     */
    private formatCurrency(amount: number): string {
        if (amount === 0) return '$0.00';
        
        // For amounts >= 1 cent, use standard 2 decimal places
        if (amount >= 0.01) return `$${amount.toFixed(2)}`;
        
        // For smaller amounts, always show significant digits
        if (amount >= 0.000001) {
            // Find the number of decimal places needed to show at least 3 significant digits
            const str = amount.toFixed(8); // Start with 8 decimal places
            const match = str.match(/^\d*\.(\d*?[1-9]\d*?[1-9]\d*?)/); // Find first 3 significant digits
            if (match) {
                const decimalPlaces = match[1].length;
                return `$${amount.toFixed(Math.max(3, decimalPlaces))}`;
            }
            return `$${amount.toFixed(6)}`;
        }
        
        // For extremely small amounts, use scientific notation
        return `$${amount.toExponential(2)}`;
    }

    /**
     * Format provider name for display
     */
    private formatProviderName(provider: string): string {
        return provider.charAt(0).toUpperCase() + provider.slice(1);
    }
}
```

## components/workspace/WorkspaceCardManager.ts

```typescript
import { CardManager, CardItem } from '../CardManager';
import { WorkspaceService } from '../../agents/memoryManager/services/WorkspaceService';
import { ProjectWorkspace } from '../../database/workspace-types';
import { WorkspaceEditModal } from './WorkspaceEditModal';
import { Settings } from '../../settings';

/**
 * Workspace-specific card item interface
 * Extends CardItem to work with CardManager pattern
 */
export interface WorkspaceCardItem extends CardItem {
  id: string;
  name: string;
  description: string;
  isEnabled: boolean;

  // Core workspace fields
  rootFolder: string;
  created: number;
  lastAccessed: number;

  // Rich context fields
  purpose?: string;
  currentGoal?: string;
  status?: string;

  // Full workspace reference for editing
  workspace: ProjectWorkspace;
}

/**
 * Workspace card manager using DRY pattern from existing Card/CardManager
 */
export class WorkspaceCardManager {
  private cardManager: CardManager<WorkspaceCardItem>;
  private workspaceService: WorkspaceService;
  private settings: Settings;
  private containerEl: HTMLElement;

  constructor(
    containerEl: HTMLElement,
    workspaceService: WorkspaceService,
    settings: Settings
  ) {
    this.containerEl = containerEl;
    this.workspaceService = workspaceService;
    this.settings = settings;

    this.cardManager = new CardManager<WorkspaceCardItem>({
      containerEl: containerEl,
      title: 'Workspace Management',
      addButtonText: 'Add Workspace',
      emptyStateText: 'No workspaces found. Create your first workspace to get started.',
      items: [],
      onAdd: () => this.handleAddWorkspace(),
      onToggle: (item, enabled) => this.handleToggleWorkspace(item, enabled),
      onEdit: (item) => this.handleEditWorkspace(item),
      onDelete: (item) => this.handleDeleteWorkspace(item),
      showToggle: true,
      showAddButton: true
    });
  }

  /**
   * Load and display workspaces
   */
  async refreshWorkspaces(): Promise<void> {
    try {
      let workspaces = await this.workspaceService.getAllWorkspaces();

      // Consolidate multiple root workspaces into one
      workspaces = this.consolidateRootWorkspaces(workspaces);

      const cardItems = workspaces.map(workspace => this.workspaceToCardItem(workspace));
      this.cardManager.updateItems(cardItems);
    } catch (error) {
      console.error('Error loading workspaces:', error);
    }
  }

  /**
   * Consolidate multiple root workspaces into a single default workspace
   */
  private consolidateRootWorkspaces(workspaces: ProjectWorkspace[]): ProjectWorkspace[] {
    const rootWorkspaces = workspaces.filter(w =>
      !w.rootFolder || w.rootFolder === '/' || w.rootFolder === ''
    );
    const nonRootWorkspaces = workspaces.filter(w =>
      w.rootFolder && w.rootFolder !== '/' && w.rootFolder !== ''
    );

    if (rootWorkspaces.length <= 1) {
      return workspaces; // No consolidation needed
    }

    // Find the most recent or preferred root workspace
    let primaryRoot = rootWorkspaces.find(w =>
      w.name === 'Plugin Testing Workspace' ||
      w.name === 'Comprehensive Tool Testing Workspace' ||
      !w.name.startsWith('Workspace ')
    );

    if (!primaryRoot) {
      // Use the most recently accessed one
      primaryRoot = rootWorkspaces.reduce((latest, current) =>
        current.lastAccessed > latest.lastAccessed ? current : latest
      );
    }

    // Mark the primary root as the default
    const consolidatedRoot: ProjectWorkspace = {
      ...primaryRoot,
      name: primaryRoot.name.startsWith('Workspace ') ? 'Default Workspace' : primaryRoot.name,
      description: primaryRoot.description || 'Default workspace for vault root',
      rootFolder: '/'
    };

    return [consolidatedRoot, ...nonRootWorkspaces];
  }

  /**
   * Convert ProjectWorkspace to WorkspaceCardItem
   */
  private workspaceToCardItem(workspace: ProjectWorkspace): WorkspaceCardItem {
    return {
      id: workspace.id,
      name: this.generateWorkspaceName(workspace),
      description: this.generateCardDescription(workspace),
      isEnabled: workspace.isActive ?? true,
      rootFolder: workspace.rootFolder,
      created: workspace.created,
      lastAccessed: workspace.lastAccessed,
      purpose: workspace.context?.purpose,
      currentGoal: workspace.context?.currentGoal,
      status: (workspace.context as any)?.status, // Legacy field for backward compatibility
      workspace: workspace
    };
  }

  /**
   * Generate a user-friendly workspace name based on folder
   */
  private generateWorkspaceName(workspace: ProjectWorkspace): string {
    // If there's a custom name that's not the generic pattern, use it
    if (workspace.name &&
        !workspace.name.startsWith('Workspace ') &&
        workspace.name !== 'workspace' &&
        workspace.name !== 'default-workspace') {
      return workspace.name;
    }

    // Use folder-based naming
    if (!workspace.rootFolder || workspace.rootFolder === '/' || workspace.rootFolder === '') {
      return 'Default (Root)';
    }

    // Extract the folder name from the path
    const folderName = workspace.rootFolder.split('/').filter(part => part).pop() || 'Root';
    return folderName;
  }

  /**
   * Generate a meaningful description for the card
   */
  private generateCardDescription(workspace: ProjectWorkspace): string {
    if (workspace.description) {
      return workspace.description;
    }

    if (workspace.context?.purpose) {
      const parts = [workspace.context.purpose];
      if (workspace.context.currentGoal) {
        parts.push(`Goal: ${workspace.context.currentGoal}`);
      }
      if ((workspace.context as any).status) {
        parts.push(`Status: ${(workspace.context as any).status}`);
      }
      return parts.join(' ‚Ä¢ ');
    }

    return `Workspace in ${workspace.rootFolder}`;
  }

  /**
   * Handle add workspace button click
   */
  private async handleAddWorkspace(): Promise<void> {
    const modal = new WorkspaceEditModal(
      this.containerEl.ownerDocument.defaultView!.app,
      this.workspaceService,
      this.settings,
      'create',
      undefined,
      () => this.refreshWorkspaces()
    );
    modal.open();
  }

  /**
   * Handle workspace enable/disable toggle
   */
  private async handleToggleWorkspace(item: WorkspaceCardItem, enabled: boolean): Promise<void> {
    try {
      await this.workspaceService.updateWorkspace(item.id, { isActive: enabled });
      await this.refreshWorkspaces();
    } catch (error) {
      console.error('Error toggling workspace:', error);
    }
  }

  /**
   * Handle edit workspace button click
   */
  private async handleEditWorkspace(item: WorkspaceCardItem): Promise<void> {
    const modal = new WorkspaceEditModal(
      this.containerEl.ownerDocument.defaultView!.app,
      this.workspaceService,
      this.settings,
      'edit',
      item.workspace,
      () => this.refreshWorkspaces()
    );
    modal.open();
  }

  /**
   * Handle delete workspace button click
   */
  private async handleDeleteWorkspace(item: WorkspaceCardItem): Promise<void> {
    const confirmed = confirm(`Are you sure you want to delete workspace "${item.name}"? This action cannot be undone.`);

    if (confirmed) {
      try {
        await this.workspaceService.deleteWorkspace(item.id);
        await this.refreshWorkspaces();
      } catch (error) {
        console.error('Error deleting workspace:', error);
      }
    }
  }

  /**
   * Initial display
   */
  async display(): Promise<void> {
    await this.refreshWorkspaces();
  }
}
```

## components/workspace/WorkspaceEditModal.ts

```typescript
import { App, Modal, Setting, TFile } from 'obsidian';
import { WorkspaceService } from '../../agents/memoryManager/services/WorkspaceService';
import { ProjectWorkspace } from '../../database/workspace-types';
import { WorkspaceContext } from '../../database/types/workspace/WorkspaceTypes';
import { UnifiedTabs, UnifiedTabConfig } from '../UnifiedTabs';
import { CustomPromptStorageService } from '../../agents/agentManager/services/CustomPromptStorageService';
import { CustomPrompt } from '../../types/mcp/CustomPromptTypes';
import { Settings } from '../../settings';

/**
 * Modal view types for different editing interfaces
 */
enum ModalView {
  MAIN_TABS = 'main',        // The current 3-tab interface
  WORKFLOW_EDIT = 'workflow' // Full workflow editor view
}

/**
 * Modal for creating and editing workspaces
 * Supports the rich workspace data structure with tabbed interface
 */
export class WorkspaceEditModal extends Modal {
  private workspaceService: WorkspaceService;
  private customPromptStorage: CustomPromptStorageService;
  private mode: 'create' | 'edit';
  private workspace?: ProjectWorkspace;
  private onSave: () => void;

  // Form data
  private formData: Partial<ProjectWorkspace> = {};

  // UI components
  private tabs?: UnifiedTabs;
  private availableAgents: CustomPrompt[] = [];

  // View management
  private currentView: ModalView = ModalView.MAIN_TABS;
  private editingWorkflowIndex?: number;

  constructor(
    app: App,
    workspaceService: WorkspaceService,
    settings: Settings,
    mode: 'create' | 'edit',
    workspace?: ProjectWorkspace,
    onSave?: () => void
  ) {
    super(app);
    this.workspaceService = workspaceService;
    this.customPromptStorage = new CustomPromptStorageService(settings);
    this.mode = mode;
    this.workspace = workspace;
    this.onSave = onSave || (() => {});

    // Initialize form data
    if (this.mode === 'edit' && this.workspace) {
      this.formData = { ...this.workspace };
    } else {
      this.formData = this.getDefaultWorkspaceData();
    }
  }

  async onOpen() {
    // Load available agents
    this.availableAgents = this.customPromptStorage.getAllPrompts();

    // Render current view
    this.renderCurrentView();
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.tabs?.destroy();
  }

  /**
   * Render the current view based on currentView state
   */
  private renderCurrentView(): void {
    const { contentEl } = this;
    contentEl.empty();

    if (this.currentView === ModalView.MAIN_TABS) {
      this.renderMainTabsView();
    } else if (this.currentView === ModalView.WORKFLOW_EDIT) {
      this.renderWorkflowEditView();
    }
  }

  /**
   * Render the main tabs view (current interface)
   */
  private renderMainTabsView(): void {
    const { contentEl } = this;

    contentEl.createEl('h2', {
      text: this.mode === 'create' ? 'Create Workspace' : 'Edit Workspace'
    });

    // Create tabbed interface
    this.createTabbedInterface(contentEl);

    // Render action buttons (always visible)
    this.renderActionButtons(contentEl);
  }

  /**
   * Render the workflow edit view with full editor
   */
  private renderWorkflowEditView(): void {
    const { contentEl } = this;

    // Ensure we have a workflow to edit
    if (!this.formData.context?.workflows) {
      this.formData.context = this.formData.context || {
        purpose: '', currentGoal: '', workflows: [], keyFiles: [], preferences: ''
      };
      this.formData.context.workflows = [];
    }

    // Get the workflow being edited (or create new one)
    let workflow: { name: string; when: string; steps: string[] };
    const isNewWorkflow = this.editingWorkflowIndex === undefined ||
                         this.editingWorkflowIndex >= this.formData.context.workflows.length;

    if (isNewWorkflow) {
      workflow = { name: '', when: '', steps: [''] };
    } else {
      workflow = { ...this.formData.context.workflows[this.editingWorkflowIndex!] };
      // Ensure workflow has at least one step for editing
      if (workflow.steps.length === 0) {
        workflow.steps = [''];
      }
    }

    // Header with back button
    const header = contentEl.createDiv('workflow-edit-header');
    header.style.display = 'flex';
    header.style.alignItems = 'center';
    header.style.marginBottom = '20px';

    const backButton = header.createEl('button', {
      text: '‚Üê Back to Workspace',
      cls: 'workflow-back-button'
    });
    backButton.addEventListener('click', () => this.backToMainTabs());

    header.createEl('h2', {
      text: isNewWorkflow ? 'Create Workflow' : 'Edit Workflow',
      cls: 'workflow-edit-title'
    });

    // Workflow form
    const form = contentEl.createDiv('workflow-edit-form');
    form.style.maxWidth = '600px';
    form.style.margin = '0 auto';

    // Workflow Name
    new Setting(form)
      .setName('Workflow Name')
      .setDesc('What do you call this workflow?')
      .addText(text => text
        .setPlaceholder('e.g., New Application, Follow-up, Interview Prep')
        .setValue(workflow.name)
        .onChange(value => {
          workflow.name = value;
        }));

    // When to Use
    new Setting(form)
      .setName('When to Use')
      .setDesc('When should this workflow be used?')
      .addText(text => text
        .setPlaceholder('e.g., When applying to new position, When following up after interview')
        .setValue(workflow.when)
        .onChange(value => {
          workflow.when = value;
        }));

    // Steps Section
    const stepsSection = form.createDiv('workflow-steps-section');
    stepsSection.style.marginTop = '20px';

    stepsSection.createEl('h3', { text: 'Steps' });
    stepsSection.createEl('p', {
      text: 'Define the step-by-step process for this workflow',
      cls: 'setting-item-description'
    });

    const stepsContainer = stepsSection.createDiv('workflow-steps-container');

    const renderSteps = () => {
      stepsContainer.empty();

      workflow.steps.forEach((step, stepIndex) => {
        const stepSetting = new Setting(stepsContainer)
          .setName(`Step ${stepIndex + 1}`)
          .addText(text => text
            .setPlaceholder('e.g., Research company, Customize cover letter')
            .setValue(step)
            .onChange(value => {
              workflow.steps[stepIndex] = value;
            }))
          .addButton(button => button
            .setButtonText('Remove')
            .setClass('mod-warning')
            .onClick(() => {
              workflow.steps.splice(stepIndex, 1);
              // Ensure at least one step remains
              if (workflow.steps.length === 0) {
                workflow.steps.push('');
              }
              renderSteps();
            }));

        // Hide remove button if it's the only step
        if (workflow.steps.length === 1) {
          const removeButton = stepSetting.controlEl.querySelector('.mod-warning') as HTMLElement;
          if (removeButton) {
            removeButton.style.display = 'none';
          }
        }
      });

      // Add Step button
      new Setting(stepsContainer)
        .addButton(button => button
          .setButtonText('+ Add Step')
          .setClass('mod-cta')
          .onClick(() => {
            workflow.steps.push('');
            renderSteps();
          }));
    };

    renderSteps();

    // Action buttons
    const actionsContainer = contentEl.createDiv('workflow-edit-actions');
    actionsContainer.style.display = 'flex';
    actionsContainer.style.justifyContent = 'center';
    actionsContainer.style.gap = '12px';
    actionsContainer.style.marginTop = '30px';

    const saveButton = actionsContainer.createEl('button', {
      text: 'Save Workflow',
      cls: 'mod-cta'
    });
    saveButton.addEventListener('click', () => this.saveWorkflow(workflow, isNewWorkflow));

    const cancelButton = actionsContainer.createEl('button', {
      text: 'Cancel'
    });
    cancelButton.addEventListener('click', () => this.backToMainTabs());
  }

  /**
   * Switch to workflow editor view
   */
  private switchToWorkflowEditor(workflowIndex?: number): void {
    this.currentView = ModalView.WORKFLOW_EDIT;
    this.editingWorkflowIndex = workflowIndex;
    this.renderCurrentView();
  }

  /**
   * Switch back to main tabs view
   */
  private backToMainTabs(): void {
    this.currentView = ModalView.MAIN_TABS;
    this.editingWorkflowIndex = undefined;
    this.renderCurrentView();
  }

  /**
   * Save the workflow and return to main tabs
   */
  private saveWorkflow(workflow: { name: string; when: string; steps: string[] }, isNewWorkflow: boolean): void {
    // Validate workflow data
    if (!workflow.name.trim()) {
      alert('Workflow name is required');
      return;
    }

    if (!workflow.when.trim()) {
      alert('Please specify when this workflow should be used');
      return;
    }

    // Filter out empty steps
    workflow.steps = workflow.steps.filter(step => step.trim());
    if (workflow.steps.length === 0) {
      alert('At least one step is required');
      return;
    }

    // Ensure context exists
    if (!this.formData.context?.workflows) {
      this.formData.context = this.formData.context || {
        purpose: '', currentGoal: '', workflows: [], keyFiles: [], preferences: ''
      };
      this.formData.context.workflows = [];
    }

    // Save workflow
    if (isNewWorkflow) {
      this.formData.context.workflows.push(workflow);
    } else {
      this.formData.context.workflows[this.editingWorkflowIndex!] = workflow;
    }

    // Return to main tabs
    this.backToMainTabs();
  }

  /**
   * Create the tabbed interface
   */
  private createTabbedInterface(container: HTMLElement): void {
    const tabsContainer = container.createDiv('workspace-edit-tabs-container');

    const tabConfigs: UnifiedTabConfig[] = [
      { key: 'basic', label: 'üìù Basic Info' },
      { key: 'context', label: '‚öôÔ∏è Context' },
      { key: 'agent-files', label: 'ü§ñ Agent & Files' }
    ];

    this.tabs = new UnifiedTabs({
      containerEl: tabsContainer,
      tabs: tabConfigs,
      defaultTab: 'basic'
    });

    // Render content for each tab
    this.renderBasicInfoTab();
    this.renderContextTab();
    this.renderAgentFilesTab();
  }

  /**
   * Render Tab 1: Basic Info
   */
  private renderBasicInfoTab(): void {
    const tabContent = this.tabs?.getTabContent('basic');
    if (!tabContent) return;

    new Setting(tabContent)
      .setName('Name')
      .setDesc('Workspace name')
      .addText(text => text
        .setPlaceholder('My Workspace')
        .setValue(this.formData.name || '')
        .onChange(value => {
          this.formData.name = value;
        }));

    new Setting(tabContent)
      .setName('Description')
      .setDesc('Brief description of this workspace')
      .addTextArea(text => text
        .setPlaceholder('Description of what this workspace is for...')
        .setValue(this.formData.description || '')
        .onChange(value => {
          this.formData.description = value;
        }));

    new Setting(tabContent)
      .setName('Root Folder')
      .setDesc('Base folder for this workspace')
      .addText(text => text
        .setPlaceholder('/')
        .setValue(this.formData.rootFolder || '/')
        .onChange(value => {
          this.formData.rootFolder = value;
        }));

    new Setting(tabContent)
      .setName('Active')
      .setDesc('Enable this workspace')
      .addToggle(toggle => toggle
        .setValue(this.formData.isActive ?? true)
        .onChange(value => {
          this.formData.isActive = value;
        }));
  }

  /**
   * Render Tab 2: Context
   */
  private renderContextTab(): void {
    const tabContent = this.tabs?.getTabContent('context');
    if (!tabContent) return;

    // Ensure context exists (using new simplified structure)
    if (!this.formData.context) {
      this.formData.context = {
        purpose: '',
        currentGoal: '',
        workflows: [],
        keyFiles: [],
        preferences: ''
      };
    }

    new Setting(tabContent)
      .setName('Purpose')
      .setDesc('What is this workspace for?')
      .addText(text => text
        .setPlaceholder('e.g., Apply for marketing manager positions')
        .setValue(this.formData.context?.purpose || '')
        .onChange(value => {
          if (this.formData.context) {
            this.formData.context.purpose = value;
          }
        }));

    new Setting(tabContent)
      .setName('Current Goal')
      .setDesc('What are you trying to accomplish right now?')
      .addText(text => text
        .setPlaceholder('e.g., Submit 10 applications this week')
        .setValue(this.formData.context?.currentGoal || '')
        .onChange(value => {
          if (this.formData.context) {
            this.formData.context.currentGoal = value;
          }
        }));

    // Preferences section
    this.renderPreferencesSection(tabContent);

    // Workflows section
    this.renderWorkflowsSection(tabContent);
  }

  /**
   * Render Tab 3: Agent & Files
   */
  private renderAgentFilesTab(): void {
    const tabContent = this.tabs?.getTabContent('agent-files');
    if (!tabContent) return;

    // Ensure context exists
    if (!this.formData.context) {
      this.formData.context = {
        purpose: '',
        currentGoal: '',
        workflows: [],
        keyFiles: [],
        preferences: ''
      };
    }

    // Dedicated Agent section
    this.renderAgentSection(tabContent);

    // Key Files section
    this.renderKeyFilesSection(tabContent);
  }

  /**
   * Render Preferences section with simple textarea
   */
  private renderPreferencesSection(container: HTMLElement): void {
    new Setting(container)
      .setName('Preferences')
      .setDesc('Actionable guidelines for this workspace')
      .addTextArea(text => text
        .setPlaceholder('Use professional tone. Focus on tech companies. Be concise and clear.')
        .setValue(this.formData.context?.preferences || '')
        .onChange(value => {
          if (this.formData.context) {
            this.formData.context.preferences = value;
          }
        }));
  }

  /**
   * Render Workflows section with simple summary list
   */
  private renderWorkflowsSection(container: HTMLElement): void {
    const workflowsContainer = container.createDiv('workflows-section');
    workflowsContainer.createEl('h4', { text: 'Workflows' });
    workflowsContainer.createEl('p', {
      text: 'Step-by-step workflows for different situations',
      cls: 'setting-item-description'
    });

    // Ensure workflows array exists
    if (!this.formData.context?.workflows) {
      this.formData.context = this.formData.context || {
        purpose: '', currentGoal: '', workflows: [], keyFiles: [], preferences: ''
      };
      this.formData.context.workflows = [];
    }

    // Show workflow summaries
    if (this.formData.context.workflows.length === 0) {
      const emptyState = workflowsContainer.createDiv('workflows-empty');
      emptyState.createEl('p', {
        text: 'No workflows defined yet',
        cls: 'setting-item-description'
      });
    } else {
      this.formData.context.workflows.forEach((workflow, index) => {
        const workflowSummary = workflowsContainer.createDiv('workflow-summary');
        workflowSummary.style.display = 'flex';
        workflowSummary.style.alignItems = 'center';
        workflowSummary.style.marginBottom = '8px';
        workflowSummary.style.padding = '8px';
        workflowSummary.style.border = '1px solid var(--background-modifier-border)';
        workflowSummary.style.borderRadius = '4px';

        // Workflow name and description
        const workflowInfo = workflowSummary.createDiv('workflow-info');
        workflowInfo.style.flex = '1';
        const workflowName = workflow.name || `Workflow ${index + 1}`;
        const stepCount = workflow.steps?.length || 0;
        workflowInfo.innerHTML = `<strong>${workflowName}</strong><br><small>${stepCount} steps</small>`;

        // Action buttons
        const workflowActions = workflowSummary.createDiv('workflow-actions');
        workflowActions.style.display = 'flex';
        workflowActions.style.gap = '8px';

        const editButton = workflowActions.createEl('button', {
          text: 'Edit',
          cls: 'mod-cta'
        });
        editButton.style.padding = '4px 12px';
        editButton.addEventListener('click', () => {
          this.switchToWorkflowEditor(index);
        });

        const deleteButton = workflowActions.createEl('button', {
          text: 'Delete',
          cls: 'mod-warning'
        });
        deleteButton.style.padding = '4px 12px';
        deleteButton.addEventListener('click', () => {
          if (confirm(`Delete workflow "${workflowName}"?`)) {
            this.formData.context!.workflows.splice(index, 1);
            this.renderCurrentView(); // Refresh the view
          }
        });
      });
    }

    // Add new workflow button
    const addWorkflowContainer = workflowsContainer.createDiv('add-workflow-container');
    addWorkflowContainer.style.marginTop = '12px';

    new Setting(addWorkflowContainer)
      .addButton(button => button
        .setButtonText('Add Workflow')
        .setClass('mod-cta')
        .onClick(() => {
          // Create new workflow and switch to editor
          const newWorkflow = {
            name: '',
            when: '',
            steps: []
          };
          this.formData.context!.workflows.push(newWorkflow);
          this.switchToWorkflowEditor(this.formData.context!.workflows.length - 1);
        }));
  }

  /**
   * Render Agent selection section
   */
  private renderAgentSection(container: HTMLElement): void {
    const agentContainer = container.createDiv('agent-section');
    agentContainer.createEl('h4', { text: 'Dedicated Agent' });
    agentContainer.createEl('p', {
      text: 'Choose a custom agent for this workspace (optional)',
      cls: 'setting-item-description'
    });

    new Setting(agentContainer)
      .setName('Agent')
      .setDesc('Select an agent to provide specialized assistance for this workspace')
      .addDropdown(dropdown => {
        // Add default option
        dropdown.addOption('', 'No agent selected');

        // Add available agents
        this.availableAgents.forEach(agent => {
          dropdown.addOption(agent.id, agent.name);
        });

        // Set current value
        const currentAgentId = this.formData.context?.dedicatedAgent?.agentId || '';
        dropdown.setValue(currentAgentId);

        dropdown.onChange(value => {
          if (!this.formData.context) {
            this.formData.context = {
              purpose: '', currentGoal: '', workflows: [], keyFiles: [], preferences: ''
            };
          }

          if (value) {
            const selectedAgent = this.availableAgents.find(agent => agent.id === value);
            if (selectedAgent) {
              this.formData.context.dedicatedAgent = {
                agentId: selectedAgent.id,
                agentName: selectedAgent.name
              };
            }
          } else {
            delete this.formData.context.dedicatedAgent;
          }
        });
      });
  }

  /**
   * Render Key Files section
   */
  private renderKeyFilesSection(container: HTMLElement): void {
    const keyFilesContainer = container.createDiv('key-files-section');
    keyFilesContainer.createEl('h4', { text: 'Key Files' });
    keyFilesContainer.createEl('p', {
      text: 'Select important files for quick reference in this workspace',
      cls: 'setting-item-description'
    });

    const keyFilesListEl = keyFilesContainer.createDiv('key-files-list');

    const updateKeyFilesList = () => {
      keyFilesListEl.empty();

      if (!this.formData.context?.keyFiles) {
        this.formData.context = this.formData.context || {
          purpose: '', currentGoal: '', workflows: [], keyFiles: [], preferences: ''
        };
        this.formData.context.keyFiles = [];
      }

      this.formData.context.keyFiles.forEach((filePath, index) => {
        new Setting(keyFilesListEl)
          .addText(text => text
            .setPlaceholder('path/to/file.md')
            .setValue(filePath)
            .onChange(value => {
              if (this.formData.context?.keyFiles) {
                this.formData.context.keyFiles[index] = value;
              }
            }))
          .addButton(button => button
            .setButtonText('Browse')
            .onClick(async () => {
              const files = this.app.vault.getFiles();
              const fileOptions = files.map(file => ({
                value: file.path,
                text: file.path
              }));

              // Simple file selection using a dropdown in a mini modal
              const fileSelectorModal = new Modal(this.app);
              fileSelectorModal.titleEl.setText('Select File');

              let selectedFile = '';
              new Setting(fileSelectorModal.contentEl)
                .setName('File')
                .addDropdown(dropdown => {
                  dropdown.addOption('', 'Select a file...');
                  fileOptions.forEach(option => {
                    dropdown.addOption(option.value, option.text);
                  });
                  dropdown.onChange(value => {
                    selectedFile = value;
                  });
                });

              new Setting(fileSelectorModal.contentEl)
                .addButton(button => button
                  .setButtonText('Select')
                  .setClass('mod-cta')
                  .onClick(() => {
                    if (selectedFile && this.formData.context?.keyFiles) {
                      this.formData.context.keyFiles[index] = selectedFile;
                      updateKeyFilesList();
                    }
                    fileSelectorModal.close();
                  }))
                .addButton(button => button
                  .setButtonText('Cancel')
                  .onClick(() => {
                    fileSelectorModal.close();
                  }));

              fileSelectorModal.open();
            }))
          .addButton(button => button
            .setButtonText('Remove')
            .setClass('mod-warning')
            .onClick(() => {
              if (this.formData.context?.keyFiles) {
                this.formData.context.keyFiles.splice(index, 1);
                updateKeyFilesList();
              }
            }));
      });

      // Add new key file button
      const addKeyFileContainer = keyFilesListEl.createDiv('add-key-file-container');
      new Setting(addKeyFileContainer)
        .addButton(button => button
          .setButtonText('Add Key File')
          .setClass('mod-cta')
          .onClick(() => {
            if (!this.formData.context?.keyFiles) {
              this.formData.context = this.formData.context || {
                purpose: '', currentGoal: '', workflows: [], keyFiles: [], preferences: ''
              };
              this.formData.context.keyFiles = [];
            }
            this.formData.context.keyFiles.push('');
            updateKeyFilesList();
          }));
    };

    updateKeyFilesList();
  }

  /**
   * Render action buttons
   */
  private renderActionButtons(container: HTMLElement): void {
    const buttonContainer = container.createDiv('workspace-edit-actions');

    const saveButton = buttonContainer.createEl('button', {
      text: this.mode === 'create' ? 'Create Workspace' : 'Save Changes',
      cls: 'mod-cta'
    });
    saveButton.addEventListener('click', () => this.handleSave());

    const cancelButton = buttonContainer.createEl('button', {
      text: 'Cancel'
    });
    cancelButton.addEventListener('click', () => this.close());
  }

  /**
   * Validate form data across all tabs
   */
  private validateFormData(): string[] {
    const errors: string[] = [];

    if (!this.formData.name?.trim()) {
      errors.push('Workspace name is required');
    }

    // Validate workflows - ensure they have names and steps if they exist
    if (this.formData.context?.workflows) {
      this.formData.context.workflows.forEach((workflow, index) => {
        if (workflow.name?.trim() && !workflow.when?.trim()) {
          errors.push(`Workflow ${index + 1}: "When to use" is required`);
        }
        if (workflow.name?.trim() && workflow.steps.length === 0) {
          errors.push(`Workflow ${index + 1}: At least one step is required`);
        }
        workflow.steps.forEach((step, stepIndex) => {
          if (!step?.trim()) {
            errors.push(`Workflow ${index + 1}, Step ${stepIndex + 1}: Step description is required`);
          }
        });
      });
    }

    // Validate preferences - no validation needed for string format

    // Validate key files - ensure they're not empty
    if (this.formData.context?.keyFiles) {
      this.formData.context.keyFiles.forEach((filePath, index) => {
        if (!filePath?.trim()) {
          errors.push(`Key file ${index + 1}: File path is required`);
        }
      });
    }

    return errors;
  }

  /**
   * Handle save button click
   */
  private async handleSave(): Promise<void> {
    try {
      // Validate form data
      const errors = this.validateFormData();
      if (errors.length > 0) {
        alert('Please fix the following errors:\n\n' + errors.join('\n'));
        return;
      }

      if (this.mode === 'create') {
        await this.workspaceService.createWorkspace(this.formData as Omit<ProjectWorkspace, 'id'>);
      } else if (this.workspace) {
        await this.workspaceService.updateWorkspace(this.workspace.id, this.formData);
      }

      this.onSave();
      this.close();
    } catch (error) {
      console.error('Error saving workspace:', error);
      alert('Error saving workspace: ' + (error as Error).message);
    }
  }

  /**
   * Get default workspace data for creation
   */
  private getDefaultWorkspaceData(): Partial<ProjectWorkspace> {
    return {
      name: '',
      description: '',
      rootFolder: '/',
      isActive: true,
      context: {
        purpose: '',
        currentGoal: '',
        workflows: [],
        keyFiles: [],
        preferences: ''
      }
    };
  }
}
```

## config.ts

```typescript
/**
 * Plugin configuration
 */
export const CONFIG = {
    /**
     * Plugin name
     */
    PLUGIN_NAME: 'Claudesidian MCP',
    
    /**
     * Plugin version
     */
    VERSION: '2.6.3',
    
    /**
     * Default port for the MCP server
     */
    DEFAULT_PORT: 3001,
    
    /**
     * Default host for the MCP server
     */
    DEFAULT_HOST: 'localhost',
    
    /**
     * Default timeout for requests (in milliseconds)
     */
    DEFAULT_TIMEOUT: 1200000,
    
    /**
     * Maximum number of concurrent requests
     */
    MAX_CONCURRENT_REQUESTS: 100
};
```

## config/agents.ts

```typescript
/**
 * Location: /src/config/agents.ts
 * 
 * Unified configuration registry for all MCP agents. This file consolidates individual 
 * agent configs into a single source of truth with type safety and centralized management.
 * 
 * Used by: All agent implementations, MCP connector, agent registration, and agent discovery
 */

/**
 * Agent categories for logical grouping
 */
export const AGENT_CATEGORIES = {
  CONTENT_OPERATIONS: 'content-operations',
  FILE_SYSTEM: 'file-system', 
  SEARCH_RETRIEVAL: 'search-retrieval',
  MEMORY_MANAGEMENT: 'memory-management',
  LLM_INTEGRATION: 'llm-integration',
  SYSTEM_COMMANDS: 'system-commands'
} as const;

/**
 * Comprehensive agent registry with metadata, modes, and categorization
 */
export const AGENT_REGISTRY = {
  /**
   * Content Manager - CRUD operations on note content
   */
  contentManager: {
    name: 'contentManager',
    displayName: 'Content Manager', 
    description: 'Content operations for Obsidian notes',
    version: '1.0.0',
    category: AGENT_CATEGORIES.CONTENT_OPERATIONS,
    modes: [
      'readContent',
      'createContent', 
      'appendContent',
      'prependContent',
      'replaceContent',
      'replaceByLine',
      'deleteContent',
      'findReplaceContent',
      'batchContent'
    ] as const,
    capabilities: ['create', 'read', 'update', 'delete', 'batch'] as string[],
    requiresVault: true,
  },

  /**
   * Vault Manager - File system operations for Obsidian vault
   */
  vaultManager: {
    name: 'vaultManager',
    displayName: 'Vault Manager',
    description: 'File system operations for Obsidian vault', 
    version: '1.0.0',
    category: AGENT_CATEGORIES.FILE_SYSTEM,
    modes: [
      'listDirectory',
      'createFolder',
      'editFolder', 
      'deleteFolder',
      'deleteNote',
      'moveNote',
      'moveFolder',
      'duplicateNote',
      'openNote'
    ] as const,
    capabilities: ['create', 'read', 'update', 'delete', 'move', 'duplicate'] as string[],
    requiresVault: true,
  },

  /**
   * Vault Librarian - Search operations for Obsidian vault
   */
  vaultLibrarian: {
    name: 'vaultLibrarian',
    displayName: 'Vault Librarian',
    description: 'Search operations for Obsidian vault',
    version: '1.0.0', 
    category: AGENT_CATEGORIES.SEARCH_RETRIEVAL,
    modes: [
      'search',
      'searchDirectory',
      'searchWorkspace',
      'searchMemory',
      'batch'
    ] as const,
    capabilities: ['search', 'text-search', 'batch'] as string[],
    requiresVault: true,
  },

  /**
   * Memory Manager - Manages workspaces, memory sessions, and state snapshots
   */
  memoryManager: {
    name: 'memoryManager', 
    displayName: 'Memory Manager',
    description: 'Manages workspaces, memory sessions, and state snapshots for contextual recall',
    version: '1.2.0',
    category: AGENT_CATEGORIES.MEMORY_MANAGEMENT,
    modes: [
      // Session modes
      'createSession',
      'listSessions',
      'editSession',
      'deleteSession', 
      'loadSession',
      // State modes
      'createState',
      'listStates',
      'loadState',
      'editState',
      'deleteState',
      // Workspace modes
      'addFilesToWorkspace',
      'createWorkspace',
      'deleteWorkspace',
      'editWorkspace',
      'listWorkspaces',
      'loadWorkspace',
      'manageAssociatedNotes'
    ] as const,
    capabilities: ['session-management', 'state-management', 'workspace-management', 'contextual-recall'] as string[],
    requiresVault: true,
  },

  /**
   * Agent Manager - LLM integration and custom AI agent execution
   */
  agentManager: {
    name: 'agentManager',
    displayName: 'Agent Manager', 
    description: 'Manage custom prompt agents for personalized AI interactions',
    version: '1.0.0',
    category: AGENT_CATEGORIES.LLM_INTEGRATION,
    modes: [
      // Prompt management
      'listPrompts',
      'getPrompt',
      'createPrompt',
      'updatePrompt',
      'deletePrompt',
      'togglePrompt',
      // LLM execution
      'listModels',
      'executePrompt',
      'batchExecutePrompt'
    ] as const,
    capabilities: ['prompt-management', 'llm-execution', 'model-selection', 'batch-execution'] as string[],
    requiresVault: false,
  },

  /**
   * Command Manager - Command palette operations for Obsidian
   */
  commandManager: {
    name: 'commandManager',
    displayName: 'Command Manager',
    description: 'Command palette operations for Obsidian',
    version: '1.0.0',
    category: AGENT_CATEGORIES.SYSTEM_COMMANDS,
    modes: [
      'listCommands',
      'executeCommand'
    ] as const,
    capabilities: ['command-execution', 'system-integration'] as string[],
    requiresVault: true,
  }
} as const;

/**
 * Type definitions for type-safe agent references
 */
export type AgentCategory = typeof AGENT_CATEGORIES[keyof typeof AGENT_CATEGORIES];
export type AgentName = keyof typeof AGENT_REGISTRY;
export type AgentConfig = typeof AGENT_REGISTRY[AgentName];

/**
 * Type for agent mode references 
 */
export type AgentModes<T extends AgentName> = typeof AGENT_REGISTRY[T]['modes'][number];

/**
 * Utility functions for agent registry operations
 */
export class AgentRegistryUtils {
  /**
   * Get agent configuration by name
   */
  static getAgent(name: AgentName): AgentConfig {
    return AGENT_REGISTRY[name];
  }

  /**
   * Get all agents in a specific category
   */
  static getAgentsByCategory(category: AgentCategory): AgentConfig[] {
    return Object.values(AGENT_REGISTRY).filter(agent => agent.category === category);
  }

  /**
   * Get all agent names
   */
  static getAllAgentNames(): AgentName[] {
    return Object.keys(AGENT_REGISTRY) as AgentName[];
  }

  /**
   * Check if an agent supports a specific mode
   */
  static hasMode(agentName: AgentName, mode: string): boolean {
    return (AGENT_REGISTRY[agentName].modes as readonly string[]).includes(mode);
  }

  /**
   * Get agents that support a specific capability
   */
  static getAgentsByCapability(capability: string): AgentConfig[] {
    return Object.values(AGENT_REGISTRY).filter(agent => 
      agent.capabilities.includes(capability)
    );
  }


  /**
   * Validate agent and mode combination
   */
  static validateAgentMode(agentName: string, mode: string): boolean {
    if (!(agentName in AGENT_REGISTRY)) {
      return false;
    }
    return this.hasMode(agentName as AgentName, mode);
  }

  /**
   * Get formatted agent information for display
   */
  static getAgentInfo(name: AgentName): {
    name: string;
    displayName: string;
    description: string;
    version: string;
    category: string;
    modeCount: number;
    capabilities: string[];
  } {
    const agent = AGENT_REGISTRY[name];
    return {
      name: agent.name,
      displayName: agent.displayName,
      description: agent.description,
      version: agent.version,
      category: agent.category,
      modeCount: agent.modes.length,
      capabilities: agent.capabilities
    };
  }
}

/**
 * Legacy compatibility - export individual configs for backward compatibility
 * during transition period. These should be removed after all consumers are updated.
 * 
 * @deprecated Use AGENT_REGISTRY instead
 */
export const AgentManagerConfig = {
  name: AGENT_REGISTRY.agentManager.name,
  description: AGENT_REGISTRY.agentManager.description,
  version: AGENT_REGISTRY.agentManager.version
};

export const ContentManagerConfig = {
  name: AGENT_REGISTRY.contentManager.name,
  description: AGENT_REGISTRY.contentManager.description,
  version: AGENT_REGISTRY.contentManager.version
};

export const VaultLibrarianConfig = {
  name: AGENT_REGISTRY.vaultLibrarian.name,
  description: AGENT_REGISTRY.vaultLibrarian.description,
  version: AGENT_REGISTRY.vaultLibrarian.version
};

export const VaultManagerConfig = {
  name: AGENT_REGISTRY.vaultManager.name,
  description: AGENT_REGISTRY.vaultManager.description,
  version: AGENT_REGISTRY.vaultManager.version
};

export const MemoryManagerConfig = {
  name: AGENT_REGISTRY.memoryManager.name,
  description: AGENT_REGISTRY.memoryManager.description,
  version: AGENT_REGISTRY.memoryManager.version
};

export const CommandManagerConfig = {
  name: AGENT_REGISTRY.commandManager.name,
  description: AGENT_REGISTRY.commandManager.description,
  version: AGENT_REGISTRY.commandManager.version
};
```

## connector.ts

```typescript
import { App, Plugin } from 'obsidian';
import ClaudesidianPlugin from './main';
import { EventManager } from './services/EventManager';
import { SessionContextManager, WorkspaceContext } from './services/SessionContextManager';
import type { ServiceManager } from './core/ServiceManager';
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import { logger } from './utils/logger';
import { CustomPromptStorageService } from "./agents/agentManager/services/CustomPromptStorageService";
// ToolCallCaptureService removed in simplified architecture

// Extracted services
import { MCPConnectionManager, MCPConnectionManagerInterface } from './services/mcp/MCPConnectionManager';
import { ToolCallRouter, ToolCallRouterInterface } from './services/mcp/ToolCallRouter';
import { AgentRegistrationService, AgentRegistrationServiceInterface } from './services/agent/AgentRegistrationService';

// Type definitions
import { AgentModeParams } from './types/agent/AgentTypes';
import { VaultLibrarianAgent } from './agents';
import { MemoryManagerAgent } from './agents';


/**
 * MCP Connector
 * Orchestrates MCP server operations through extracted services:
 * - MCPConnectionManager: Handles server lifecycle
 * - ToolCallRouter: Routes tool calls to agents/modes  
 * - AgentRegistrationService: Manages agent initialization and registration
 */
export class MCPConnector {
    private connectionManager: MCPConnectionManagerInterface;
    private toolRouter: ToolCallRouterInterface;
    private agentRegistry: AgentRegistrationServiceInterface;
    private eventManager: EventManager;
    private sessionContextManager: SessionContextManager;
    private customPromptStorage?: CustomPromptStorageService;
    private serviceManager?: ServiceManager;
    private toolCallCaptureService: any = null;
    private pendingToolCalls = new Map<string, any>();
    
    constructor(
        private app: App,
        private plugin: Plugin | ClaudesidianPlugin
    ) {
        // Initialize core components
        this.eventManager = new EventManager();
        this.sessionContextManager = new SessionContextManager();
        
        // Get service manager reference
        if (this.plugin && (this.plugin as any).getServiceContainer) {
            this.serviceManager = (this.plugin as any).getServiceContainer();
        }
        
        // Initialize custom prompt storage if possible
        // Note: Settings might not be fully loaded yet, so we'll check again during initialization
        const pluginSettings = this.plugin && (this.plugin as any).settings;
        if (pluginSettings) {
            try {
                this.customPromptStorage = new CustomPromptStorageService(pluginSettings);
                logger.systemLog('CustomPromptStorageService initialized successfully');
            } catch (error) {
                logger.systemError(error as Error, 'CustomPromptStorageService Initialization');
                this.customPromptStorage = undefined;
            }
        } else {
            logger.systemWarn('Plugin settings not available during MCPConnector construction - will retry during initialization');
        }
        
        // Initialize extracted services
        this.connectionManager = new MCPConnectionManager(
            this.app,
            this.plugin,
            this.eventManager,
            this.sessionContextManager,
            this.customPromptStorage,
            (toolName: string, params: any) => this.onToolCall(toolName, params),
            (toolName: string, params: any, response: any, success: boolean, executionTime: number) => this.onToolResponse(toolName, params, response, success, executionTime)
        );
        
        this.toolRouter = new ToolCallRouter();
        
        this.agentRegistry = new AgentRegistrationService(
            this.app,
            this.plugin,
            this.eventManager,
            this.serviceManager,
            this.customPromptStorage
        );
    }
    
    /**
     * Handle tool call responses - capture completed tool calls
     */
    private async onToolResponse(toolName: string, params: any, response: any, success: boolean, executionTime: number): Promise<void> {
        
        try {
            // Find the matching pending tool call
            const pendingEntries = Array.from(this.pendingToolCalls.entries());
            const matchingEntry = pendingEntries.find(([toolCallId, capture]) => {
                return capture.agent === toolName.split('_')[0] && capture.mode === toolName.split('_')[1];
            });
            
            if (matchingEntry) {
                const [toolCallId, captureInfo] = matchingEntry;
                
                // Initialize tool call capture service if not already done
                await this.initializeToolCallCaptureService();
                
                if (this.toolCallCaptureService) {
                    // Create response object
                    const toolResponse: any = {
                        result: response,
                        success: success,
                        executionTime: executionTime,
                        timestamp: Date.now(),
                        resultType: this.inferResultType(response),
                        resultSummary: this.generateResultSummary(response),
                        affectedResources: this.extractAffectedResources(response, params)
                    };
                    
                    // Add error information if unsuccessful
                    if (!success && response?.error) {
                        toolResponse.error = {
                            type: 'ExecutionError',
                            message: response.error,
                            code: 'TOOL_EXECUTION_FAILED'
                        };
                    }
                    
                    await this.toolCallCaptureService.captureResponse(toolCallId, toolResponse);
                    
                    // Remove from pending
                    this.pendingToolCalls.delete(toolCallId);
                } else {
                    console.warn('[MCPConnector] üö® ToolCallCaptureService not available for response capture:', toolName);
                }
            } else {
                console.warn('[MCPConnector] üö® No matching pending tool call found for response:', toolName);
            }
        } catch (error) {
            console.error('[MCPConnector] Error in onToolResponse capture:', error);
        }
    }
    
    /**
     * Handle tool calls - services now load on demand automatically
     */
    private async onToolCall(toolName: string, params: any): Promise<void> {
        
        try {
            // Initialize tool call capture service if not already done
            await this.initializeToolCallCaptureService();
            
            if (this.toolCallCaptureService) {
                // Parse tool name to get agent and mode
                const [agent, mode] = toolName.split('_');
                
                // Generate unique tool call ID
                const toolCallId = this.generateToolCallId();
                
                // Create tool call request
                const request = {
                    toolCallId,
                    agent,
                    mode,
                    params,
                    timestamp: Date.now(),
                    source: 'mcp-client' as const,
                    workspaceContext: this.extractWorkspaceContext(params)
                };
                
                await this.toolCallCaptureService.captureRequest(request);
                
                // Store for response capture later
                this.pendingToolCalls.set(toolCallId, { agent, mode, params, captureStartTime: Date.now() });
                
            } else {
                console.warn('[MCPConnector] üö® ToolCallCaptureService not available for tool call:', toolName);
            }
        } catch (error) {
            console.error('[MCPConnector] Error in onToolCall capture:', error);
        }
    }
    
    /**
     * Check if this tool call is workspace-related
     */
    private isWorkspaceOperation(toolName: string, params: any): boolean {
        const workspaceTools = [
            'memoryManager.switchWorkspace',
            'memoryManager.createWorkspace',
            'memoryManager.getWorkspace',
            'vaultLibrarian.search'
        ];
        
        return workspaceTools.some(tool => toolName.includes(tool)) || 
               (params && (params.workspaceId || params.workspace));
    }
    
    /**
     * Extract workspace ID from tool parameters
     */
    private extractWorkspaceId(params: any): string | null {
        if (params?.workspaceId) return params.workspaceId;
        if (params?.workspace) return params.workspace;
        if (params?.params?.workspaceId) return params.params.workspaceId;
        return null;
    }
    
    /**
     * Initialize all agents - delegates to AgentRegistrationService
     */
    public async initializeAgents(): Promise<void> {
        try {
            // Ensure customPromptStorage is available if settings are now loaded
            if (!this.customPromptStorage) {
                const pluginSettings = this.plugin && (this.plugin as any).settings;
                if (pluginSettings) {
                    try {
                        this.customPromptStorage = new CustomPromptStorageService(pluginSettings);
                        
                        // Update the agent registry with the new storage service
                        this.agentRegistry = new AgentRegistrationService(
                            this.app,
                            this.plugin,
                            this.eventManager,
                            this.serviceManager,
                            this.customPromptStorage
                        );
                        
                        logger.systemLog('CustomPromptStorageService initialized during agent initialization');
                    } catch (error) {
                        logger.systemError(error as Error, 'Late CustomPromptStorageService Initialization');
                    }
                }
            }
            
            // Initialize connection manager first
            await this.connectionManager.initialize();
            
            // Set up tool router with server reference
            const server = this.connectionManager.getServer();
            if (server) {
                this.toolRouter.setServer(server);
            }
            
            // Initialize all agents through the registration service
            await this.agentRegistry.initializeAllAgents();
            
            // Register agents with server through the registration service
            this.agentRegistry.registerAgentsWithServer((agent: any) => {
                if (server) {
                    server.registerAgent(agent);
                }
            });
            
            // Reinitialize request router with registered agents
            this.connectionManager.reinitializeRequestRouter();
            
            // Inject session service into SessionContextManager for database validation
            if (this.serviceManager) {
                try {
                    const sessionService = await this.serviceManager.getService<any>('sessionService');
                    if (sessionService) {
                        this.sessionContextManager.setSessionService(sessionService);
                    } else {
                        logger.systemWarn('SessionService not found in service manager');
                    }
                } catch (error) {
                    logger.systemWarn(`Failed to inject SessionService: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            
            logger.systemLog('Agent initialization completed successfully');
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'Agent Initialization');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to initialize agents',
                error
            );
        }
    }
    
    /**
     * Call a tool using the new agent-mode architecture with integrated tool call capture
     * Now delegates to ToolCallRouter service for validation and execution
     */
    /**
     * Get available tools for ChatService
     */
    getAvailableTools(): any[] {
        const tools: any[] = [];
        
        if (!this.agentRegistry) {
            console.warn('[MCPConnector] No agent registration service available for tool manifest');
            return [];
        }

        const registeredAgents = this.agentRegistry.getAllAgents();
        
        for (const [agentName, agent] of registeredAgents) {
            const modes = (agent as any).getModes?.() || [];
            
            // getModes returns an array, so iterate directly over modes
            for (const mode of modes) {
                const modeInstance = mode as any;
                if (modeInstance && typeof modeInstance.getParameterSchema === 'function') {
                    try {
                        const paramSchema = modeInstance.getParameterSchema();
                        const modeName = modeInstance.slug || modeInstance.name || 'unknown';
                        tools.push({
                            name: `${agentName}.${modeName}`,
                            description: modeInstance.description || `Execute ${modeName} on ${agentName}`,
                            inputSchema: paramSchema
                        });
                    } catch (error) {
                        const modeName = modeInstance.slug || modeInstance.name || 'unknown';
                        console.warn(`[MCPConnector] Failed to get schema for ${agentName}.${modeName}:`, error);
                    }
                }
            }
        }
        
        console.log(`[MCPConnector] Generated ${tools.length} tools for ChatService`);
        return tools;
    }

    async callTool(params: AgentModeParams): Promise<any> {
        const captureStartTime = Date.now();
        let toolCallId: string | undefined;
        
        try {
            const { agent, mode, params: modeParams } = params;
            
            // Initialize tool call capture service if not already done
            await this.initializeToolCallCaptureService();
            
            // Generate unique tool call ID for capture
            toolCallId = this.generateToolCallId();
            
            // CAPTURE REQUEST (Non-blocking)
            if (this.toolCallCaptureService) {
                try {
                    await this.toolCallCaptureService.captureRequest({
                        toolCallId,
                        agent,
                        mode,
                        params: modeParams,
                        timestamp: captureStartTime,
                        source: 'mcp-client',
                        workspaceContext: this.extractWorkspaceContext(modeParams)
                    });
                } catch (captureError) {
                    console.warn('[MCPConnector] Tool call request capture failed:', captureError);
                }
            }
            
            // Delegate validation and execution to ToolCallRouter
            this.toolRouter.validateBatchOperations(modeParams);
            const result = await this.toolRouter.executeAgentMode(agent, mode, modeParams);
            
            // CAPTURE SUCCESSFUL RESPONSE (Non-blocking)
            if (this.toolCallCaptureService && toolCallId) {
                try {
                    await this.toolCallCaptureService.captureResponse(toolCallId, {
                        result: result,
                        success: true,
                        executionTime: Date.now() - captureStartTime,
                        timestamp: Date.now(),
                        resultType: this.inferResultType(result),
                        resultSummary: this.generateResultSummary(result),
                        affectedResources: this.extractAffectedResources(result, modeParams)
                    });
                } catch (captureError) {
                    console.warn('[MCPConnector] Tool call response capture failed:', captureError);
                }
            }
            
            return result;
            
        } catch (error) {
            // CAPTURE ERROR RESPONSE (Non-blocking) 
            if (this.toolCallCaptureService && toolCallId) {
                try {
                    await this.toolCallCaptureService.captureResponse(toolCallId, {
                        result: null,
                        success: false,
                        error: {
                            type: (error as Error).constructor.name,
                            message: (error as Error).message,
                            code: (error as any).code,
                            stack: (error as Error).stack
                        },
                        executionTime: Date.now() - captureStartTime,
                        timestamp: Date.now()
                    });
                } catch (captureError) {
                    console.warn('[MCPConnector] Tool call error capture failed:', captureError);
                }
            }
            
            if (error instanceof McpError) {
                throw error;
            }
            throw new McpError(
                ErrorCode.InvalidParams,
                (error as Error).message || 'Failed to call tool',
                error
            );
        }
    }
    
    
    /**
     * Initialize the tool call capture service using Direct Property Access pattern
     * @private
     */
    private async initializeToolCallCaptureService(): Promise<void> {
        if (this.toolCallCaptureService) {
            return; // Already initialized
        }

        try {
            if (this.serviceManager) {
                this.toolCallCaptureService = await this.serviceManager.getService('toolCallCaptureService');
                if (this.toolCallCaptureService) {
                    console.debug('[MCPConnector] Tool call capture service initialized');
                } else {
                    console.debug('[MCPConnector] Tool call capture service not available');
                }
            }
        } catch (error) {
            console.warn('[MCPConnector] Failed to initialize tool call capture service:', error);
            this.toolCallCaptureService = null;
        }
    }
    
    /**
     * Generate a unique tool call ID
     * @private
     */
    private generateToolCallId(): string {
        return `tool_call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    /**
     * Extract workspace context from parameters
     * @private
     */
    private extractWorkspaceContext(params: any): any {
        // Direct workspace context
        if (params?.workspaceContext) {
            return params.workspaceContext;
        }
        
        // Try to extract from session context
        if (params?.sessionId) {
            return {
                sessionId: params.sessionId,
                workspaceId: 'unknown'
            };
        }
        
        // Extract from file paths
        if (params?.filePath) {
            return {
                workspaceId: this.detectWorkspaceFromPath(params.filePath),
                workspacePath: [params.filePath.split('/')[0]]
            };
        }
        
        // Extract from batch operations
        if (params?.operations && Array.isArray(params.operations)) {
            const firstOperation = params.operations[0];
            if (firstOperation?.params?.filePath) {
                return {
                    workspaceId: this.detectWorkspaceFromPath(firstOperation.params.filePath),
                    workspacePath: [firstOperation.params.filePath.split('/')[0]]
                };
            }
        }
        
        return null;
    }
    
    /**
     * Detect workspace from file path (simple implementation)
     * @private
     */
    private detectWorkspaceFromPath(filePath: string): string {
        // Simple workspace detection - could be enhanced
        return 'default-workspace';
    }
    
    /**
     * Infer the result type from the result object
     * @private
     */
    private inferResultType(result: any): string {
        if (result === null || result === undefined) return 'null';
        if (Array.isArray(result)) return 'array';
        return typeof result;
    }
    
    /**
     * Generate a summary of the result
     * @private
     */
    private generateResultSummary(result: any): string {
        if (!result) return 'no result';
        if (typeof result === 'string') {
            return result.length > 100 ? `${result.substring(0, 100)}...` : result;
        }
        if (typeof result === 'object') {
            if (Array.isArray(result)) {
                return `array with ${result.length} items`;
            }
            const keys = Object.keys(result);
            return `object with ${keys.length} properties (${keys.slice(0, 3).join(', ')})${keys.length > 3 ? '...' : ''}`;
        }
        return String(result);
    }
    
    /**
     * Extract affected resources from result and parameters
     * @private
     */
    private extractAffectedResources(result: any, params: any): string[] {
        const resources: string[] = [];
        
        // From parameters
        if (params?.filePath) resources.push(params.filePath);
        if (params?.paths && Array.isArray(params.paths)) {
            resources.push(...params.paths);
        }
        if (params?.operations && Array.isArray(params.operations)) {
            for (const op of params.operations) {
                if (op.params?.filePath) resources.push(op.params.filePath);
                if (op.path) resources.push(op.path);
            }
        }
        
        // From result
        if (result?.affectedFiles && Array.isArray(result.affectedFiles)) {
            resources.push(...result.affectedFiles);
        }
        if (result?.createdFiles && Array.isArray(result.createdFiles)) {
            resources.push(...result.createdFiles);
        }
        if (result?.modifiedFiles && Array.isArray(result.modifiedFiles)) {
            resources.push(...result.modifiedFiles);
        }
        
        // Remove duplicates
        return Array.from(new Set(resources));
    }
    
    /**
     * Start the MCP server - delegates to MCPConnectionManager
     */
    async start(): Promise<void> {
        try {
            // Initialize agents and connection manager first
            await this.initializeAgents();

            // Then start the server
            await this.connectionManager.start();
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'Server Start');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to start MCP server',
                error
            );
        }
    }
    
    /**
     * Stop the MCP server - delegates to MCPConnectionManager
     */
    async stop(): Promise<void> {
        try {
            await this.connectionManager.stop();
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'Server Stop');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to stop MCP server',
                error
            );
        }
    }
    
    /**
     * Get the MCP server instance - delegates to MCPConnectionManager
     */
    getServer(): any {
        return this.connectionManager.getServer();
    }
    
    /**
     * Get the connection manager instance
     */
    getConnectionManager(): MCPConnectionManagerInterface {
        return this.connectionManager;
    }
    
    /**
     * Get the tool router instance
     */
    getToolRouter(): ToolCallRouterInterface {
        return this.toolRouter;
    }
    
    /**
     * Get the agent registry instance
     */
    getAgentRegistry(): AgentRegistrationServiceInterface {
        return this.agentRegistry;
    }
    
    /**
     * Get the event manager instance
     */
    getEventManager(): EventManager {
        return this.eventManager;
    }
    
    /**
     * Get the vault librarian instance - delegates to AgentRegistrationService
     */
    getVaultLibrarian(): VaultLibrarianAgent | null {
        return this.agentRegistry.getAgent('vaultLibrarian') as VaultLibrarianAgent | null;
    }
    
    /**
     * Get the memory manager instance - delegates to AgentRegistrationService
     */
    getMemoryManager(): MemoryManagerAgent | null {
        return this.agentRegistry.getAgent('memoryManager') as MemoryManagerAgent | null;
    }
    
    
    /**
     * Get the session context manager instance
     */
    getSessionContextManager(): SessionContextManager {
        return this.sessionContextManager;
    }
    
    /**
     * Set default workspace context for all new sessions
     * The default context will be used when a session doesn't have an explicit workspace context
     * 
     * @param workspaceId Workspace ID 
     * @param workspacePath Optional hierarchical path within the workspace
     * @returns True if successful
     */
    setDefaultWorkspaceContext(workspaceId: string, workspacePath?: string[]): boolean {
        if (!workspaceId) {
            logger.systemWarn('Cannot set default workspace context with empty workspaceId');
            return false;
        }
        
        const context: WorkspaceContext = {
            workspaceId,
            workspacePath,
            activeWorkspace: true
        };
        
        this.sessionContextManager.setDefaultWorkspaceContext(context);
        return true;
    }
    
    /**
     * Clear the default workspace context
     */
    clearDefaultWorkspaceContext(): void {
        this.sessionContextManager.setDefaultWorkspaceContext(null);
    }
    
    /**
     * Set workspace context for a specific session
     * 
     * @param sessionId Session ID
     * @param workspaceId Workspace ID
     * @param workspacePath Optional hierarchical path within the workspace
     * @returns True if successful
     */
    setSessionWorkspaceContext(sessionId: string, workspaceId: string, workspacePath?: string[]): boolean {
        if (!sessionId || !workspaceId) {
            logger.systemWarn('Cannot set session workspace context with empty sessionId or workspaceId');
            return false;
        }
        
        const context: WorkspaceContext = {
            workspaceId,
            workspacePath,
            activeWorkspace: true
        };
        
        this.sessionContextManager.setWorkspaceContext(sessionId, context);
        return true;
    }
}

```

## core/ObsidianPathManager.ts

```typescript
/**
 * ObsidianPathManager - Path management using Obsidian's normalizePath and proper validation
 * Location: src/core/ObsidianPathManager.ts
 * 
 * This class replaces all manual path construction with Obsidian API-first patterns,
 * ensuring cross-platform compatibility and security through proper validation.
 * 
 * Key improvements over PathManager:
 * - Uses Obsidian's normalizePath function exclusively
 * - Security validation prevents path traversal
 * - Cross-platform path handling (mobile + desktop)
 * - Integration with Vault API for directory operations
 * 
 * Used by:
 * - VaultOperations for all path operations
 * - Plugin data directory management
 * - Configuration file path handling
 */

import { Vault, normalizePath, FileSystemAdapter, App } from 'obsidian';

export interface PathValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  normalizedPath: string;
}

/**
 * Path management using Obsidian's normalizePath and proper validation
 * Replaces all manual path construction
 */
export class ObsidianPathManager {
  private manifest: any;

  constructor(private vault: Vault, manifest?: any) {
    this.manifest = manifest;
  }

  /**
   * Core path operations using Obsidian API
   */
  normalizePath(path: string): string {
    // Use Obsidian's official normalizePath function
    return normalizePath(path);
  }

  /**
   * Validate path for security and compatibility
   */
  validatePath(path: string): PathValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Security validation - prevent path traversal
    if (path.includes('..') || path.includes('~')) {
      errors.push('Path traversal sequences are not allowed for security');
    }

    // Platform compatibility checks
    const invalidChars = /[<>:"|?*]/;
    if (invalidChars.test(path)) {
      errors.push('Path contains invalid characters for cross-platform compatibility');
    }

    // Ensure vault-relative (not absolute)
    if (path.startsWith('/') || /^[A-Za-z]:/.test(path)) {
      errors.push('Path should be relative to vault root, not absolute');
    }

    // Check for dangerous patterns
    if (path.includes('\\')) {
      warnings.push('Path contains backslashes, will be normalized to forward slashes');
    }

    // Path length limits for cross-platform compatibility
    if (path.length > 260) {
      warnings.push('Path length exceeds recommended limits for cross-platform compatibility');
    }

    const normalizedPath = this.normalizePath(path);

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      normalizedPath
    };
  }

  /**
   * Sanitize path component for filesystem safety
   */
  sanitizePath(path: string): string {
    return path
      .replace(/[<>:"|?*]/g, '_')  // Replace invalid filesystem chars
      .replace(/\\/g, '/')         // Normalize separators
      .replace(/\/+/g, '/')        // Remove duplicate separators
      .replace(/^\/|\/$/g, '')     // Remove leading/trailing separators
      .replace(/\.{2,}/g, '_')     // Replace path traversal sequences
      .substring(0, 255);          // Limit length for filesystem compatibility
  }

  /**
   * Plugin-specific path construction
   */
  getPluginDataPath(): string {
    if (!this.manifest?.id) {
      throw new Error('Plugin manifest ID not available for path construction');
    }
    return this.normalizePath(`${this.manifest.id}/data`);
  }

  /**
   * Get storage path for data files
   */
  getStoragePath(fileName: string): string {
    const safeName = this.sanitizePath(fileName);
    return this.normalizePath(`.obsidian/plugins/${this.manifest.id}/data/storage/${safeName}`);
  }

  /**
   * Get cache directory path
   */
  getCachePath(): string {
    return this.normalizePath(`${this.getPluginDataPath()}/cache`);
  }

  /**
   * Get logs directory path
   */
  getLogsPath(): string {
    return this.normalizePath(`${this.getPluginDataPath()}/logs`);
  }

  /**
   * Get backup directory path
   */
  getBackupPath(): string {
    return this.normalizePath(`${this.getPluginDataPath()}/backups`);
  }

  /**
   * Get JSON storage path
   */
  getDataStoragePath(): string {
    return this.normalizePath(`${this.getPluginDataPath()}/storage`);
  }

  /**
   * Safe path operations with validation
   */
  async ensureParentExists(filePath: string): Promise<void> {
    const parentPath = this.getParentPath(filePath);
    if (parentPath && !this.vault.getFolderByPath(parentPath)) {
      await this.vault.createFolder(parentPath);
    }
  }

  /**
   * Generate unique path to avoid conflicts
   */
  async generateUniquePath(basePath: string): Promise<string> {
    let uniquePath = basePath;
    let counter = 1;

    while (this.vault.getAbstractFileByPath(uniquePath)) {
      const extension = this.getExtension(basePath);
      const basename = this.getBasename(basePath);
      const parentPath = this.getParentPath(basePath);
      
      const newFileName = extension 
        ? `${basename} ${counter}.${extension}`
        : `${basename} ${counter}`;
      
      uniquePath = parentPath 
        ? this.joinPath(parentPath, newFileName)
        : newFileName;
      
      counter++;
    }

    return uniquePath;
  }

  /**
   * Join path segments safely
   */
  joinPath(...segments: string[]): string {
    return this.normalizePath(
      segments
        .filter(segment => segment && segment.length > 0)
        .join('/')
    );
  }

  /**
   * Get parent directory path
   */
  getParentPath(path: string): string {
    const normalized = this.normalizePath(path);
    const lastSlash = normalized.lastIndexOf('/');
    return lastSlash > 0 ? normalized.substring(0, lastSlash) : '';
  }

  /**
   * Get filename without directory
   */
  getFileName(path: string): string {
    const normalized = this.normalizePath(path);
    const lastSlash = normalized.lastIndexOf('/');
    return lastSlash >= 0 ? normalized.substring(lastSlash + 1) : normalized;
  }

  /**
   * Get basename (filename without extension)
   */
  getBasename(path: string): string {
    const fileName = this.getFileName(path);
    const lastDot = fileName.lastIndexOf('.');
    return lastDot > 0 ? fileName.substring(0, lastDot) : fileName;
  }

  /**
   * Get file extension
   */
  getExtension(path: string): string {
    const fileName = this.getFileName(path);
    const lastDot = fileName.lastIndexOf('.');
    return lastDot > 0 ? fileName.substring(lastDot + 1) : '';
  }

  /**
   * Check if path is absolute
   */
  isAbsolutePath(path: string): boolean {
    return /^[A-Za-z]:|^\//.test(path);
  }

  /**
   * Convert absolute path to vault-relative (cross-platform safe)
   */
  makeVaultRelative(absolutePath: string): string {
    // Try to get vault base path safely
    const vaultBasePath = this.getVaultBasePath();
    
    if (!vaultBasePath) {
      // Mobile or base path not available - extract plugin path pattern
      return this.extractPluginPathPattern(absolutePath);
    }

    try {
      const normalizedAbsolute = this.normalizePath(absolutePath);
      const normalizedBase = this.normalizePath(vaultBasePath);

      if (normalizedAbsolute.startsWith(normalizedBase)) {
        let relativePath = normalizedAbsolute.substring(normalizedBase.length);
        
        // Remove leading separator
        if (relativePath.startsWith('/')) {
          relativePath = relativePath.substring(1);
        }
        
        return relativePath || this.getPluginDataPath();
      }
      
      // Fallback to pattern extraction
      return this.extractPluginPathPattern(absolutePath);
    } catch (error) {
      // Ultimate fallback
      return this.getPluginDataPath();
    }
  }

  /**
   * Extract plugin path pattern from absolute path
   */
  private extractPluginPathPattern(path: string): string {
    const normalized = this.normalizePath(path);
    
    // Look for plugin directory pattern
    if (this.manifest?.id) {
      const pluginPattern = `/${this.manifest.id}/`;
      const pluginIndex = normalized.indexOf(pluginPattern);
      
      if (pluginIndex >= 0) {
        // Extract from plugin directory onwards
        const pluginStart = normalized.substring(0, pluginIndex + pluginPattern.length - 1);
        const remaining = normalized.substring(pluginIndex + pluginPattern.length);
        return this.normalizePath(`${this.manifest.id}/${remaining}`);
      }
    }
    
    // Look for .obsidian/plugins pattern
    const obsidianIndex = normalized.indexOf('.obsidian/plugins/');
    if (obsidianIndex >= 0) {
      return normalized.substring(obsidianIndex);
    }

    // Ultimate fallback
    return this.getPluginDataPath();
  }

  /**
   * Get vault base path safely (returns null on mobile)
   */
  private getVaultBasePath(): string | null {
    try {
      const adapter = this.vault.adapter;
      if (adapter instanceof FileSystemAdapter) {
        return adapter.getBasePath();
      }
      return null;
    } catch (error) {
      return null;
    }
  }

  /**
   * Safe path operation wrapper with validation
   */
  async safePathOperation<T>(
    path: string,
    operation: (validPath: string) => Promise<T>,
    operationName: string = 'unknown'
  ): Promise<T> {
    try {
      // Convert to relative if absolute
      const relativePath = this.isAbsolutePath(path) 
        ? this.makeVaultRelative(path) 
        : path;

      // Validate the path
      const validation = this.validatePath(relativePath);
      if (!validation.isValid) {
        throw new Error(`Path validation failed: ${validation.errors.join(', ')}`);
      }

      // Log warnings if any
      if (validation.warnings.length > 0) {
        console.warn(`[ObsidianPathManager] Path warnings for ${operationName}:`, validation.warnings);
      }

      // Execute operation with normalized path
      return await operation(validation.normalizedPath);

    } catch (error) {
      console.error(`[ObsidianPathManager] Safe operation '${operationName}' failed for path: ${path}`, error);
      throw error;
    }
  }

  /**
   * Batch validate paths
   */
  validatePaths(paths: string[]): Map<string, PathValidationResult> {
    const results = new Map<string, PathValidationResult>();
    
    for (const path of paths) {
      results.set(path, this.validatePath(path));
    }
    
    return results;
  }

  /**
   * Get path type (file or folder)
   */
  async getPathType(path: string): Promise<'file' | 'folder' | null> {
    try {
      const normalizedPath = this.normalizePath(path);
      const stat = await this.vault.adapter.stat(normalizedPath);
      return stat?.type as 'file' | 'folder' || null;
    } catch (error) {
      return null;
    }
  }

  /**
   * Check if path exists
   */
  async pathExists(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.normalizePath(path);
      return await this.vault.adapter.exists(normalizedPath);
    } catch (error) {
      return false;
    }
  }
}
```

## core/PluginDataManager.ts

```typescript
/**
 * Plugin Data Manager
 * Handles simple plugin data storage operations using Obsidian's native data.json
 */

import { Plugin } from 'obsidian';

export class PluginDataManager {
  constructor(private plugin: Plugin) {}

  /**
   * Save data to plugin storage
   */
  async saveData(data: any): Promise<void> {
    await this.plugin.saveData(data);
  }

  /**
   * Load data from plugin storage
   */
  async loadData(): Promise<any> {
    return await this.plugin.loadData();
  }

  /**
   * Load data with defaults and migration support
   */
  async load(defaults: any = {}, migrateFn?: (data: any) => any): Promise<any> {
    try {
      let data = await this.plugin.loadData();
      if (!data) {
        data = defaults;
      }
      if (migrateFn) {
        data = migrateFn(data);
      }
      return data;
    } catch {
      return defaults;
    }
  }

  /**
   * Check if data exists
   */
  async hasData(): Promise<boolean> {
    try {
      const data = await this.plugin.loadData();
      return data !== null && data !== undefined;
    } catch {
      return false;
    }
  }
}

// Legacy compatibility exports
export class SettingsMigrationManager {
  static migrate(data: any): any {
    return data;
  }
}

export interface SettingsSchema {
  [key: string]: any;
}

export interface SettingsMigration {
  version: number;
  migrate: (data: any) => any;
}

export interface BackupData {
  version: string;
  timestamp: number;
  data: any;
}
```

## core/PluginLifecycleManager.ts

```typescript
/**
 * Location: /src/core/PluginLifecycleManager.ts
 * 
 * Plugin Lifecycle Manager - Handles plugin initialization, startup, and shutdown logic
 * 
 * This service extracts complex lifecycle management from the main plugin class,
 * coordinating service initialization, background tasks, and cleanup procedures.
 * Used by main.ts to manage the plugin's lifecycle phases in a structured way.
 */

import { Plugin, Notice } from 'obsidian';
import { ServiceManager } from './ServiceManager';
import { Settings } from '../settings';
import { SettingsTab } from '../components/SettingsTab';
import { MCPConnector } from '../connector';
import { UpdateManager } from '../utils/UpdateManager';
import { ServiceRegistrar } from './services/ServiceRegistrar';
import { MaintenanceCommandManager } from './commands/MaintenanceCommandManager';
import { ChatUIManager } from './ui/ChatUIManager';
import { BackgroundProcessor } from './background/BackgroundProcessor';
import { SettingsTabManager } from './settings/SettingsTabManager';
import type { ServiceCreationContext } from './services/ServiceDefinitions';

export interface PluginLifecycleConfig {
    plugin: Plugin;
    app: any;
    serviceManager: ServiceManager;
    settings: Settings;
    connector: MCPConnector;
    manifest: any;
}

/**
 * Plugin Lifecycle Manager - coordinates plugin initialization and shutdown
 */
export class PluginLifecycleManager {
    private config: PluginLifecycleConfig;
    private isInitialized: boolean = false;
    private startTime: number = Date.now();
    private serviceRegistrar: ServiceRegistrar;
    private commandManager: MaintenanceCommandManager;
    private chatUIManager: ChatUIManager;
    private backgroundProcessor: BackgroundProcessor;
    private settingsTabManager: SettingsTabManager;

    constructor(config: PluginLifecycleConfig) {
        this.config = config;
        
        // Create service registrar with proper context
        const serviceContext: ServiceCreationContext = {
            plugin: config.plugin,
            app: config.app,
            serviceManager: config.serviceManager,
            settings: config.settings,
            connector: config.connector,
            manifest: config.manifest
        };
        this.serviceRegistrar = new ServiceRegistrar(serviceContext);
        
        // Create command manager
        this.commandManager = new MaintenanceCommandManager({
            plugin: config.plugin,
            serviceManager: config.serviceManager,
            getService: (name, timeoutMs) => this.serviceRegistrar.getService(name, timeoutMs),
            isInitialized: () => this.isInitialized
        });
        
        // Create chat UI manager
        this.chatUIManager = new ChatUIManager({
            plugin: config.plugin,
            app: config.app,
            settings: config.settings,
            getService: (name, timeoutMs) => this.serviceRegistrar.getService(name, timeoutMs)
        });
        
        // Create background processor
        this.backgroundProcessor = new BackgroundProcessor({
            plugin: config.plugin,
            settings: config.settings,
            serviceManager: config.serviceManager,
            getService: (name, timeoutMs) => this.serviceRegistrar.getService(name, timeoutMs),
            waitForService: (name, timeoutMs) => this.serviceRegistrar.waitForService(name, timeoutMs),
            isInitialized: () => this.isInitialized
        });
        
        // Create settings tab manager
        this.settingsTabManager = new SettingsTabManager({
            plugin: config.plugin,
            app: config.app,
            settings: config.settings,
            serviceManager: config.serviceManager,
            connector: config.connector,
            lifecycleManager: this,
            backgroundProcessor: this.backgroundProcessor
        });
    }

    /**
     * Initialize plugin - called from onload()
     */
    async initialize(): Promise<void> {
        const startTime = Date.now();
        
        try {
            // PHASE 1: Foundation - Service container and settings already created by main.ts
            
            // PHASE 2: Register core services (no initialization yet)
            await this.serviceRegistrar.registerCoreServices();
            
            // PHASE 3: Initialize essential services only
            await this.serviceRegistrar.initializeEssentialServices();
            
            // Plugin is now "loaded" - defer full initialization to background
            const loadTime = Date.now() - startTime;
            
            // PHASE 4: Start background initialization after onload completes
            setTimeout(() => {
                this.startBackgroundInitialization().catch(error => {
                    console.error('[PluginLifecycleManager] Background initialization failed:', error);
                });
            }, 0);
            
        } catch (error) {
            console.error('[PluginLifecycleManager] Critical initialization failure:', error);
            this.enableFallbackMode();
        }
    }

    /**
     * Background initialization - runs after onload() completes
     */
    private async startBackgroundInitialization(): Promise<void> {
        const bgStartTime = Date.now();
        
        try {
            // Load settings first
            await this.config.settings.loadSettings();
            
            // Log data.json for debugging StateManager
            try {
                const data = await this.config.plugin.loadData();
                // Plugin data.json loaded successfully
            } catch (error) {
                console.warn('Failed to debug data.json:', error);
            }
            
            // Initialize data directories
            await this.serviceRegistrar.initializeDataDirectories();
            
            // PRIORITY: Initialize MCP server FIRST to prevent timeout
            // This allows Claude Desktop to connect while heavy services initialize in background
            try {
                await this.config.connector.initializeAgents();
                await this.config.connector.start();
                console.log('[PluginLifecycleManager] MCP server started - connection available');
            } catch (error) {
                console.warn('[PluginLifecycleManager] MCP initialization failed:', error);
            }
            
            // Now initialize heavy services in background (non-blocking)
            setTimeout(async () => {
                try {
                    // Initialize core services in proper dependency order
                    await this.serviceRegistrar.initializeBusinessServices();
                    
                    // Pre-initialize UI-critical services to avoid long loading times
                    await this.serviceRegistrar.preInitializeUICriticalServices();
                    
                    // Validate search functionality
                    await this.backgroundProcessor.validateSearchFunctionality();
                    
                    console.log('[PluginLifecycleManager] Heavy services initialization complete');
                } catch (error) {
                    console.error('[PluginLifecycleManager] Background service initialization failed:', error);
                }
            }, 100); // Small delay to ensure MCP connection is fully established
            
            // Register chat UI components
            await this.chatUIManager.registerChatUI();
            
            // Create settings tab
            await this.settingsTabManager.initializeSettingsTab();
            
            // Register all maintenance commands
            this.commandManager.registerMaintenanceCommands();
            
            // Check for updates
            this.backgroundProcessor.checkForUpdatesOnStartup();
            
            // Update settings tab with loaded services
            this.backgroundProcessor.updateSettingsTabServices();
            
            // Mark as fully initialized
            this.isInitialized = true;
            
            // Start background startup processing after everything is ready
            this.backgroundProcessor.startBackgroundStartupProcessing();
            
            const bgLoadTime = Date.now() - bgStartTime;
            
        } catch (error) {
            console.error('[PluginLifecycleManager] Background initialization failed:', error);
        }
    }









    /**
     * Enable ChatView UI when user toggles it on in settings
     * This registers the UI components and auto-opens the ChatView
     */
    async enableChatViewUI(): Promise<void> {
        try {
            return await this.chatUIManager.enableChatViewUI();
        } catch (error) {
            console.error('[PluginLifecycleManager] Failed to enable ChatView UI:', error);
        }
    }



    /**
     * Enable fallback mode with minimal functionality
     */
    private enableFallbackMode(): void {
        try {
            this.commandManager.registerTroubleshootCommand();
        } catch (error) {
            console.error('[PluginLifecycleManager] Fallback mode setup failed:', error);
        }
    }

    /**
     * Get service helper method
     */
    private async getService<T>(name: string, timeoutMs: number = 10000): Promise<T | null> {
        if (!this.config.serviceManager) {
            return null;
        }
        
        // Try to get service (will initialize if needed)
        try {
            return await this.config.serviceManager.getService<T>(name);
        } catch (error) {
            console.warn(`[PluginLifecycleManager] Failed to get service '${name}':`, error);
            return null;
        }
    }

    /**
     * Reload configuration for all services after settings change
     */
    reloadConfiguration(): void {
        try {
            const fileEventManager = this.config.serviceManager?.getServiceIfReady('fileEventManager');
            if (fileEventManager && typeof (fileEventManager as any).reloadConfiguration === 'function') {
                (fileEventManager as any).reloadConfiguration();
            }
        } catch (error) {
            console.warn('Error reloading file event manager configuration:', error);
        }
    }

    /**
     * Get initialization status
     */
    getInitializationStatus(): { isInitialized: boolean; startTime: number } {
        return {
            isInitialized: this.isInitialized,
            startTime: this.startTime
        };
    }

    /**
     * Shutdown and cleanup
     */
    async shutdown(): Promise<void> {
        try {
            // Save processed files state before cleanup
            const stateManager = this.config.serviceManager?.getServiceIfReady('stateManager');
            if (stateManager && typeof (stateManager as any).saveState === 'function') {
                await (stateManager as any).saveState();
            }
            
            // Cleanup settings tab accordions
            this.settingsTabManager.cleanup();
            
            // Cleanup service manager (handles all service cleanup)
            if (this.config.serviceManager) {
                await this.config.serviceManager.stop();
            }
            
            // Stop the MCP connector
            if (this.config.connector) {
                await this.config.connector.stop();
            }
            
        } catch (error) {
            console.error('[PluginLifecycleManager] Error during cleanup:', error);
        }
    }
}
```

## core/ServiceContainer.ts

```typescript
/**
 * ServiceContainer - Enhanced dependency injection container with lazy loading and factory support
 * Location: src/core/ServiceContainer.ts
 * 
 * This service replaces the complex service registries and initialization coordination
 * with a unified, predictable dependency injection pattern. It provides clean service
 * lifecycle management and proper dependency resolution with multiple registration patterns.
 * 
 * Key features:
 * - Simple factory-based service registration
 * - Lazy loading capabilities with deferred initialization
 * - IServiceFactory pattern support for advanced factories
 * - Singleton and transient service support
 * - Dependency injection with type safety
 * - Circular dependency detection
 * - Promise-based duplicate initialization prevention
 * - Clean cleanup and lifecycle management
 * 
 * Registration Types:
 * - register(): Traditional factory with dependency injection
 * - registerLazy(): Lazy-loaded services with deferred creation
 * - registerFactory(): IServiceFactory pattern with advanced dependency management
 * 
 * Used by:
 * - Enhanced Plugin main class for service coordination
 * - Service initialization and dependency resolution
 * - Lazy loading patterns from LazyServiceManager
 * - Factory patterns from ServiceDescriptors
 * - Clean service lifecycle management
 * - Service cleanup during plugin unload
 */

export type ServiceFactory<T> = (dependencies: Record<string, any>) => T | Promise<T>;
export type LazyFactory<T> = () => Promise<T>;

export interface ServiceRegistration<T> {
  factory: ServiceFactory<T>;
  singleton: boolean;
  dependencies?: string[];
}

export interface IServiceFactory<T> {
  create(dependencies: Map<string, any>): Promise<T>;
  getRequiredDependencies(): string[];
}

export interface IServiceContainer {
  register<T>(name: string, factory: ServiceFactory<T>, options?: { singleton?: boolean; dependencies?: string[] }): void;
  registerLazy<T>(name: string, factory: LazyFactory<T>): void;
  registerFactory<T>(name: string, factory: IServiceFactory<T>): void;
  get<T>(name: string): Promise<T>;
  getLazy<T>(name: string): Promise<T>;
  getIfReady<T>(name: string): T | null;
  has(name: string): boolean;
  isReady(name: string): boolean;
  resolveDependencies(name: string): Promise<void>;
  
  // Additional methods required by ServiceManager
  getServiceMetadata(name: string): ServiceMetadata | null;
  getRegisteredServices(): string[];
  clear(): void;
  getReadyServices(): string[];
  getStats(): { registered: number; ready: number; failed: number };
  validateDependencies(): { isValid: boolean; errors: string[] };
  preInitializeMany(names: string[]): Promise<void>;
  initializeInOrder(names: string[]): Promise<void>;
  exportDependencyGraph(): { nodes: string[], edges: Array<{from: string, to: string}> };
}

export interface ServiceMetadata {
  name: string;
  singleton: boolean;
  initialized: boolean;
  dependencies: string[];
  dependents: string[];
}

/**
 * Enhanced dependency injection container with lazy loading and factory support
 * Replaces complex service registries with unified service management
 */
export class ServiceContainer implements IServiceContainer {
  private services = new Map<string, any>();
  private factories = new Map<string, ServiceRegistration<any>>();
  private lazyFactories = new Map<string, LazyFactory<any>>();
  private serviceFactories = new Map<string, IServiceFactory<any>>();
  private initializationStack: string[] = [];
  private dependencyGraph = new Map<string, Set<string>>();
  private pendingPromises = new Map<string, Promise<any>>();

  /**
   * Register service factory with optional dependencies
   */
  register<T>(
    name: string, 
    factory: ServiceFactory<T>, 
    options: {
      singleton?: boolean;
      dependencies?: string[];
    } = {}
  ): void {
    const singleton = options.singleton !== false; // Default to singleton
    const dependencies = options.dependencies || [];

    this.factories.set(name, {
      factory,
      singleton,
      dependencies
    });

    // Build dependency graph
    this.dependencyGraph.set(name, new Set(dependencies));
  }

  /**
   * Register lazy-loaded service factory
   * Services registered with this method are created on-demand without explicit dependencies
   */
  registerLazy<T>(name: string, factory: LazyFactory<T>): void {
    this.lazyFactories.set(name, factory);
    // Lazy services have no explicit dependencies - they manage their own resolution
    this.dependencyGraph.set(name, new Set());
  }

  /**
   * Register service using IServiceFactory interface
   * Supports the factory pattern with explicit dependency management
   */
  registerFactory<T>(name: string, factory: IServiceFactory<T>): void {
    const dependencies = factory.getRequiredDependencies();
    this.serviceFactories.set(name, factory);
    // Build dependency graph from factory
    this.dependencyGraph.set(name, new Set(dependencies));
  }

  /**
   * Get service instance with dependency resolution
   * Supports regular factories, lazy factories, and IServiceFactory pattern
   */
  async get<T>(name: string): Promise<T> {
    // Check if already instantiated (for singletons)
    if (this.services.has(name)) {
      return this.services.get(name);
    }

    // Check if there's a pending promise to avoid duplicate initialization
    if (this.pendingPromises.has(name)) {
      return this.pendingPromises.get(name);
    }

    // Try different registration types in order of preference
    const registration = this.factories.get(name);
    const lazyFactory = this.lazyFactories.get(name);
    const serviceFactory = this.serviceFactories.get(name);

    if (!registration && !lazyFactory && !serviceFactory) {
      const availableServices = [
        ...Array.from(this.factories.keys()),
        ...Array.from(this.lazyFactories.keys()),
        ...Array.from(this.serviceFactories.keys())
      ];
      throw new Error(`Service '${name}' not found. Available services: ${availableServices.join(', ')}`);
    }

    // Check for circular dependencies
    if (this.initializationStack.includes(name)) {
      const cycle = [...this.initializationStack, name].join(' -> ');
      throw new Error(`Circular dependency detected: ${cycle}`);
    }

    // Create and store promise to avoid duplicate initialization
    const promise = this.createServiceInstance<T>(name, registration, lazyFactory, serviceFactory);
    this.pendingPromises.set(name, promise);

    try {
      const instance = await promise;
      this.pendingPromises.delete(name);
      return instance;
    } catch (error) {
      this.pendingPromises.delete(name);
      throw error;
    }
  }

  /**
   * Get service using lazy loading pattern
   * Equivalent to get() but explicitly for lazy-registered services
   */
  async getLazy<T>(name: string): Promise<T> {
    return this.get<T>(name);
  }

  /**
   * Internal method to create service instance based on registration type
   */
  private async createServiceInstance<T>(
    name: string,
    registration: ServiceRegistration<any> | undefined,
    lazyFactory: LazyFactory<any> | undefined,
    serviceFactory: IServiceFactory<any> | undefined
  ): Promise<T> {
    // Add to initialization stack
    this.initializationStack.push(name);

    try {
      let instance: T;

      if (lazyFactory) {
        // Handle lazy factory (no dependency injection)
        instance = await lazyFactory();
        // Lazy factories are always treated as singletons
        this.services.set(name, instance);
      } else if (serviceFactory) {
        // Handle IServiceFactory pattern
        const dependencies = serviceFactory.getRequiredDependencies();
        const resolvedDependencies = new Map<string, any>();
        
        // Resolve dependencies
        for (const depName of dependencies) {
          const dependency = await this.get(depName);
          resolvedDependencies.set(depName, dependency);
        }

        instance = await serviceFactory.create(resolvedDependencies);
        // ServiceFactory instances are always treated as singletons
        this.services.set(name, instance);
      } else if (registration) {
        // Handle regular factory pattern
        const resolvedDependencies: Record<string, any> = {};
        const dependencies = registration.dependencies || [];
        
        // Resolve dependencies
        for (const depName of dependencies) {
          const dependency = await this.get(depName);
          resolvedDependencies[depName] = dependency;
        }

        instance = await registration.factory(resolvedDependencies);

        // Store if singleton
        if (registration.singleton) {
          this.services.set(name, instance);
        }
      } else {
        throw new Error(`No valid factory found for service '${name}'`);
      }

      return instance;

    } catch (error) {
      console.error(`[ServiceContainer] ‚ùå Failed to create service '${name}':`, error);
      throw error;
    } finally {
      // Remove from initialization stack
      this.initializationStack.pop();
    }
  }

  /**
   * Get service if already instantiated (non-blocking)
   */
  getIfReady<T>(name: string): T | null {
    return this.services.get(name) || null;
  }

  /**
   * Check if service is registered (any type)
   */
  has(name: string): boolean {
    return this.factories.has(name) || this.lazyFactories.has(name) || this.serviceFactories.has(name);
  }

  /**
   * Resolve all dependencies for a service without instantiating the service itself
   * Useful for preparation phase of service initialization
   */
  async resolveDependencies(name: string): Promise<void> {
    const dependencies = this.dependencyGraph.get(name);
    if (!dependencies || dependencies.size === 0) {
      return; // No dependencies to resolve
    }

    // Pre-resolve all dependencies in parallel
    const dependencyPromises = Array.from(dependencies).map(depName => this.get(depName));
    await Promise.all(dependencyPromises);
  }

  /**
   * Check if service is instantiated
   */
  isReady(name: string): boolean {
    return this.services.has(name);
  }

  /**
   * Get all registered service names (all types)
   */
  getRegisteredServices(): string[] {
    return [
      ...Array.from(this.factories.keys()),
      ...Array.from(this.lazyFactories.keys()),
      ...Array.from(this.serviceFactories.keys())
    ];
  }

  /**
   * Get all instantiated service names
   */
  getReadyServices(): string[] {
    return Array.from(this.services.keys());
  }

  /**
   * Get service metadata (supports all service types)
   */
  getServiceMetadata(name: string): ServiceMetadata | null {
    const registration = this.factories.get(name);
    const lazyFactory = this.lazyFactories.get(name);
    const serviceFactory = this.serviceFactories.get(name);

    if (!registration && !lazyFactory && !serviceFactory) {
      return null;
    }

    // Find dependents (services that depend on this one)
    const dependents: string[] = [];
    for (const [serviceName, deps] of Array.from(this.dependencyGraph.entries())) {
      if (deps.has(name)) {
        dependents.push(serviceName);
      }
    }

    let singleton = true; // Default for lazy and service factory
    let dependencies: string[] = [];

    if (registration) {
      singleton = registration.singleton;
      dependencies = registration.dependencies || [];
    } else if (serviceFactory) {
      dependencies = serviceFactory.getRequiredDependencies();
    }
    // Lazy services have no explicit dependencies

    return {
      name,
      singleton,
      initialized: this.services.has(name),
      dependencies,
      dependents
    };
  }

  /**
   * Get all service metadata
   */
  getAllServiceMetadata(): Record<string, ServiceMetadata> {
    const metadata: Record<string, ServiceMetadata> = {};
    
    // Get metadata for all registered services (all types)
    for (const serviceName of this.getRegisteredServices()) {
      const meta = this.getServiceMetadata(serviceName);
      if (meta) {
        metadata[serviceName] = meta;
      }
    }

    return metadata;
  }

  /**
   * Pre-initialize a service without waiting
   */
  async preInitialize(name: string): Promise<void> {
    try {
      await this.get(name);
    } catch (error) {
      console.warn(`[ServiceContainer] Failed to pre-initialize service '${name}':`, error);
    }
  }

  /**
   * Pre-initialize multiple services in parallel
   */
  async preInitializeMany(names: string[]): Promise<void> {
    const promises = names.map(name => this.preInitialize(name));
    await Promise.allSettled(promises);
  }

  /**
   * Initialize services in dependency order
   */
  async initializeInOrder(names: string[]): Promise<void> {
    const sorted = this.topologicalSort(names);
    
    for (const name of sorted) {
      await this.get(name);
    }
  }

  /**
   * Validate dependency graph for cycles
   */
  validateDependencies(): { isValid: boolean; errors: string[] } {
    const cycles: string[] = [];
    const visited = new Set<string>();
    const recursionStack = new Set<string>();

    const detectCycle = (node: string, path: string[]): boolean => {
      if (recursionStack.has(node)) {
        const cycleStart = path.indexOf(node);
        const cycle = path.slice(cycleStart).join(' -> ') + ' -> ' + node;
        cycles.push(cycle);
        return true;
      }

      if (visited.has(node)) {
        return false;
      }

      visited.add(node);
      recursionStack.add(node);

      const dependencies = this.dependencyGraph.get(node) || new Set();
      for (const dep of Array.from(dependencies)) {
        if (detectCycle(dep, [...path, node])) {
          return true;
        }
      }

      recursionStack.delete(node);
      return false;
    };

    for (const service of Array.from(this.factories.keys())) {
      if (!visited.has(service)) {
        detectCycle(service, []);
      }
    }

    return {
      isValid: cycles.length === 0,
      errors: cycles
    };
  }

  /**
   * Topological sort for dependency order
   */
  private topologicalSort(services: string[]): string[] {
    const visited = new Set<string>();
    const result: string[] = [];

    const visit = (node: string) => {
      if (visited.has(node)) return;
      visited.add(node);

      const dependencies = this.dependencyGraph.get(node) || new Set();
      for (const dep of Array.from(dependencies)) {
        if (services.includes(dep)) {
          visit(dep);
        }
      }

      result.push(node);
    };

    for (const service of services) {
      visit(service);
    }

    return result;
  }

  /**
   * Replace a service instance (for testing or hot-swapping)
   */
  replace<T>(name: string, instance: T): void {
    if (!this.factories.has(name)) {
      throw new Error(`Cannot replace unregistered service '${name}'`);
    }

    this.services.set(name, instance);
  }

  /**
   * Remove a service (cleanup)
   */
  remove(name: string): void {
    const instance = this.services.get(name);
    
    // Call cleanup if available
    if (instance && typeof instance.cleanup === 'function') {
      try {
        instance.cleanup();
      } catch (error) {
        console.error(`[ServiceContainer] Service '${name}' cleanup failed:`, error);
      }
    }

    // Remove from all maps
    this.services.delete(name);
    this.factories.delete(name);
    this.lazyFactories.delete(name);
    this.serviceFactories.delete(name);
    this.dependencyGraph.delete(name);
    this.pendingPromises.delete(name);
  }

  /**
   * Clear all services with proper cleanup
   */
  clear(): void {
    // Get services in reverse dependency order for cleanup
    const allServices = Array.from(this.services.keys());
    const cleanupOrder = this.topologicalSort(allServices).reverse();

    // Cleanup services in dependency order
    for (const serviceName of cleanupOrder) {
      const service = this.services.get(serviceName);
      
      if (service && typeof service.cleanup === 'function') {
        try {
          service.cleanup();
        } catch (error) {
          console.error(`[ServiceContainer] ‚ùå Cleanup failed for service '${serviceName}':`, error);
        }
      }
    }
    
    // Clear all maps
    this.services.clear();
    this.factories.clear();
    this.lazyFactories.clear();
    this.serviceFactories.clear();
    this.dependencyGraph.clear();
    this.pendingPromises.clear();
    this.initializationStack = [];
  }

  /**
   * Get container statistics
   */
  getStats(): { registered: number; ready: number; failed: number } {
    let singletons = 0;
    let transients = 0;
    let totalDependencies = 0;

    // Count regular factory services
    for (const registration of Array.from(this.factories.values())) {
      if (registration.singleton) {
        singletons++;
      } else {
        transients++;
      }
      totalDependencies += (registration.dependencies || []).length;
    }

    // Lazy services and factory services are always singletons
    singletons += this.lazyFactories.size + this.serviceFactories.size;

    // Count dependencies from service factories
    for (const factory of Array.from(this.serviceFactories.values())) {
      totalDependencies += factory.getRequiredDependencies().length;
    }

    return {
      registered: this.factories.size + this.lazyFactories.size + this.serviceFactories.size,
      ready: this.services.size,
      failed: 0 // TODO: Track failed services if needed
    };
  }

  /**
   * Export dependency graph for visualization
   */
  exportDependencyGraph(): { nodes: string[]; edges: Array<{ from: string; to: string }> } {
    const nodes = this.getRegisteredServices();
    const edges: Array<{ from: string; to: string }> = [];

    for (const [service, dependencies] of Array.from(this.dependencyGraph.entries())) {
      for (const dep of Array.from(dependencies)) {
        edges.push({ from: service, to: dep });
      }
    }

    return { nodes, edges };
  }
}
```

## core/ServiceManager.ts

```typescript
/**
 * Location: src/core/ServiceManager.ts
 * 
 * ServiceManager - Unified service management facade that consolidates all service management capabilities
 * 
 * This facade unifies 4 competing service management systems into a single, clean interface:
 * - ServiceContainer (enhanced DI container with lifecycle management)
 * - LazyServiceManager (stage-based loading with coordination)
 * - SimpleServiceManager (3-tier architecture with immediate/fast/background)
 * - Lazy-initialization system (descriptor-based configuration)
 * 
 * Key features:
 * - Unified registration interface supporting all existing patterns
 * - Stage-based initialization (immediate, fast, background, on-demand)
 * - Dependency injection with circular dependency detection
 * - Lifecycle management with proper cleanup
 * - Service descriptors for configuration-driven service definitions
 * - Backward compatibility with all existing systems
 * - Type-safe generics throughout
 * 
 * Used by:
 * - Main plugin class for unified service coordination
 * - All service consumers through single interface
 * - Settings components for service management UI
 * - Agents and modes for service dependencies
 */

import { App, Plugin } from 'obsidian';
import { ServiceContainer, IServiceContainer, ServiceFactory, LazyFactory, IServiceFactory } from './ServiceContainer';
// All service management now handled through ServiceContainer - no external dependencies needed

// Core interfaces for unified service management
export interface IServiceDescriptor<T = any> {
    name: string;
    dependencies?: string[];
    stage?: ServiceStage;
    singleton?: boolean;
    create(): Promise<T> | T;
}

export interface IServiceManager {
    // Registration methods - unified interface
    registerService<T>(descriptor: IServiceDescriptor<T>): Promise<void>;
    registerFactory<T>(name: string, factory: ServiceFactory<T>, options?: ServiceRegistrationOptions): void;
    registerLazy<T>(name: string, factory: LazyFactory<T>): void;
    registerServiceFactory<T>(name: string, factory: IServiceFactory<T>): void;
    
    // Service retrieval - unified interface
    getService<T>(name: string): Promise<T>;
    getServiceIfReady<T>(name: string): T | null;
    getServiceSync<T>(name: string): T | null; // For immediate services only
    
    // Lifecycle management
    initializeServices(): Promise<void>;
    initializeStage(stage: ServiceStage): Promise<void>;
    
    // Service status and introspection
    isServiceReady(name: string): boolean;
    isStageReady(stage: ServiceStage): boolean;
    getServiceStatus(name: string): ServiceStatus;
    getAllServiceStatus(): Record<string, ServiceStatus>;
    
    // Lifecycle operations
    start(): Promise<void>;
    stop(): Promise<void>;
    cleanup(): Promise<void>;
}

export interface ServiceRegistrationOptions {
    singleton?: boolean;
    dependencies?: string[];
    stage?: ServiceStage;
    timeout?: number;
}

export enum ServiceStage {
    IMMEDIATE = 'immediate',       // < 100ms - essential for plugin loading
    FAST = 'fast',                // ~300ms - important for UX
    BACKGROUND = 'background',    // ~2-5s - full functionality  
    ON_DEMAND = 'on_demand'       // Only when needed
}

export interface ServiceStatus {
    name: string;
    stage: ServiceStage;
    ready: boolean;
    initialized: boolean;
    loading: boolean;
    error?: Error;
    dependencies: string[];
    dependents: string[];
    registrationTime?: number;
    initializationTime?: number;
}

/**
 * ServiceManager - Unified facade for all service management operations
 * 
 * Architecture:
 * - Uses ServiceContainer as the core DI engine
 * - Integrates ServiceLifecycleManager for advanced lifecycle coordination
 * - Supports all existing registration patterns
 * - Provides unified interface for service consumers
 * - Maintains backward compatibility with all existing systems
 */
export class ServiceManager implements IServiceManager {
    private container: IServiceContainer;
    private serviceStages = new Map<string, ServiceStage>();
    private isStarted = false;
    private isInitializing = false;
    private initializationPromise: Promise<void> | null = null;
    
    constructor(
        private app: App,
        private plugin: Plugin
    ) {
        // Initialize core components
        this.container = new ServiceContainer();
    }

    /**
     * Register service using unified descriptor interface
     * Supports all existing registration patterns through a single interface
     */
    async registerService<T>(descriptor: IServiceDescriptor<T>): Promise<void> {
        const stage = descriptor.stage || ServiceStage.BACKGROUND;
        const singleton = descriptor.singleton !== false; // Default to singleton
        
        // Store stage information
        this.serviceStages.set(descriptor.name, stage);
        
        // Register with ServiceContainer using factory pattern
        this.container.register<T>(
            descriptor.name,
            async (dependencies: Record<string, any>) => {
                // Resolve dependencies if needed
                if (descriptor.dependencies && descriptor.dependencies.length > 0) {
                    const resolvedDeps: Record<string, any> = {};
                    for (const depName of descriptor.dependencies) {
                        resolvedDeps[depName] = await this.getService(depName);
                    }
                    
                    // Create service instance
                    const result = descriptor.create();
                    return result instanceof Promise ? await result : result;
                }
                
                const result = descriptor.create();
                return result instanceof Promise ? await result : result;
            },
            {
                singleton,
                dependencies: descriptor.dependencies || []
            }
        );
        
        // Service registered with ServiceContainer - no legacy compatibility needed
    }

    /**
     * Register service using traditional factory pattern
     */
    registerFactory<T>(name: string, factory: ServiceFactory<T>, options?: ServiceRegistrationOptions): void {
        const stage = options?.stage || ServiceStage.BACKGROUND;
        this.serviceStages.set(name, stage);
        
        this.container.register<T>(name, factory, {
            singleton: options?.singleton,
            dependencies: options?.dependencies
        });
    }

    /**
     * Register lazy-loaded service
     */
    registerLazy<T>(name: string, factory: LazyFactory<T>): void {
        this.serviceStages.set(name, ServiceStage.ON_DEMAND);
        this.container.registerLazy<T>(name, factory);
    }

    /**
     * Register service using IServiceFactory interface
     */
    registerServiceFactory<T>(name: string, factory: IServiceFactory<T>): void {
        this.serviceStages.set(name, ServiceStage.BACKGROUND);
        this.container.registerFactory<T>(name, factory);
    }

    /**
     * Get service instance - unified retrieval method
     */
    async getService<T>(name: string): Promise<T> {
        try {
            return await this.container.get<T>(name);
        } catch (error) {
            console.error(`[ServiceManager] Failed to get service '${name}':`, error);
            throw error;
        }
    }

    /**
     * Get service if already initialized (non-blocking)
     */
    getServiceIfReady<T>(name: string): T | null {
        return this.container.getIfReady<T>(name);
    }

    /**
     * Get service synchronously - only works for immediate services
     */
    getServiceSync<T>(name: string): T | null {
        const stage = this.serviceStages.get(name);
        if (stage !== ServiceStage.IMMEDIATE) {
            console.warn(`[ServiceManager] getServiceSync called on non-immediate service '${name}' (stage: ${stage})`);
            return null;
        }
        
        return this.container.getIfReady<T>(name);
    }

    /**
     * Initialize all services in dependency order
     */
    async initializeServices(): Promise<void> {
        if (this.initializationPromise) {
            return this.initializationPromise;
        }
        
        if (this.isInitializing) {
            console.warn('[ServiceManager] Services are already initializing');
            return;
        }
        
        this.isInitializing = true;
        
        this.initializationPromise = this.performInitialization();
        
        try {
            await this.initializationPromise;
        } finally {
            this.isInitializing = false;
            this.initializationPromise = null;
        }
    }

    /**
     * Internal initialization logic
     */
    private async performInitialization(): Promise<void> {
        const startTime = Date.now();
        
        try {
            // Initialize in stage order for optimal startup performance
            await this.initializeStage(ServiceStage.IMMEDIATE);
            await this.initializeStage(ServiceStage.FAST);
            
            // Background services can be initialized in parallel
            setTimeout(() => {
                this.initializeStage(ServiceStage.BACKGROUND).catch(error => {
                    console.error('[ServiceManager] Background service initialization failed:', error);
                });
            }, 0);
            
            const duration = Date.now() - startTime;
            // Critical services initialized
            
        } catch (error) {
            console.error('[ServiceManager] Service initialization failed:', error);
            throw error;
        }
    }

    /**
     * Initialize all services in a specific stage
     */
    async initializeStage(stage: ServiceStage): Promise<void> {
        const serviceNames = this.getServicesByStage(stage);
        if (serviceNames.length === 0) {
            return;
        }

        const stageStartTime = Date.now();
        // Initializing services for stage
        
        // Initialize services in parallel within stage, but respect dependencies
        const initPromises = serviceNames.map(async (serviceName) => {
            try {
                await this.getService(serviceName);
                // Service initialized successfully
            } catch (error) {
                console.error(`[ServiceManager] ‚úó Failed to initialize ${serviceName}:`, error);
                throw error;
            }
        });
        
        await Promise.all(initPromises);
        
        const stageDuration = Date.now() - stageStartTime;
        // Stage initialization completed
    }

    /**
     * Check if service is ready
     */
    isServiceReady(name: string): boolean {
        return this.container.isReady(name);
    }

    /**
     * Check if all services in a stage are ready
     */
    isStageReady(stage: ServiceStage): boolean {
        const serviceNames = this.getServicesByStage(stage);
        return serviceNames.every(name => this.container.isReady(name));
    }

    /**
     * Get detailed service status
     */
    getServiceStatus(name: string): ServiceStatus {
        const containerMeta = this.container.getServiceMetadata(name);
        const stage = this.serviceStages.get(name) || ServiceStage.BACKGROUND;
        
        return {
            name,
            stage,
            ready: this.container.isReady(name),
            initialized: containerMeta?.initialized || false,
            loading: false, // TODO: Track loading state
            dependencies: containerMeta?.dependencies || [],
            dependents: containerMeta?.dependents || []
        };
    }

    /**
     * Get status of all services
     */
    getAllServiceStatus(): Record<string, ServiceStatus> {
        const status: Record<string, ServiceStatus> = {};
        
        for (const serviceName of this.container.getRegisteredServices()) {
            status[serviceName] = this.getServiceStatus(serviceName);
        }
        
        return status;
    }

    /**
     * Start the service manager
     */
    async start(): Promise<void> {
        if (this.isStarted) {
            return;
        }
        
        this.isStarted = true;
        // Service manager starting
        
        // Initialize services
        await this.initializeServices();
    }

    /**
     * Stop the service manager
     */
    async stop(): Promise<void> {
        if (!this.isStarted) {
            return;
        }
        
        // Service manager stopping
        
        // Stop services in reverse dependency order
        await this.cleanup();
        
        this.isStarted = false;
    }

    /**
     * Cleanup all services
     */
    async cleanup(): Promise<void> {
        try {
            // Container handles cleanup in proper dependency order
            this.container.clear();
            
            // Clear stage mappings
            this.serviceStages.clear();
            
            // Service cleanup completed
            
        } catch (error) {
            console.error('[ServiceManager] Cleanup error:', error);
            throw error;
        }
    }

    // Helper methods

    /**
     * Get services by stage
     */
    private getServicesByStage(stage: ServiceStage): string[] {
        const services: string[] = [];
        
        this.serviceStages.forEach((serviceStage, serviceName) => {
            if (serviceStage === stage) {
                services.push(serviceName);
            }
        });
        
        return services;
    }

    // Legacy stage mapping removed - all stage management now through ServiceStage enum

    // Compatibility methods for existing consumers

    /**
     * Compatibility method for LazyServiceManager interface
     */
    async get<T>(name: string): Promise<T> {
        return this.getService<T>(name);
    }

    /**
     * Compatibility method for SimpleServiceManager interface
     */
    getIfReady<T>(name: string): T | null {
        return this.getServiceIfReady<T>(name);
    }

    /**
     * Compatibility method for getting all initialized services
     */
    getAllInitialized(): Record<string, any> {
        const services: Record<string, any> = {};
        
        for (const serviceName of this.container.getReadyServices()) {
            const service = this.container.getIfReady(serviceName);
            if (service) {
                services[serviceName] = service;
            }
        }
        
        return services;
    }

    /**
     * Get container statistics
     */
    getStats() {
        return this.container.getStats();
    }

    /**
     * Get ready service names
     */
    getReadyServices(): string[] {
        return this.container.getReadyServices();
    }

    /**
     * Get registered service names
     */
    getRegisteredServices(): string[] {
        return this.container.getRegisteredServices();
    }

    /**
     * Validate dependency graph
     */
    validateDependencies(): { valid: boolean; cycles: string[] } {
        const result = this.container.validateDependencies();
        return {
            valid: result.isValid,
            cycles: result.errors
        };
    }

    /**
     * Pre-initialize services for better performance
     */
    async preInitializeServices(serviceNames: string[]): Promise<void> {
        await this.container.preInitializeMany(serviceNames);
    }

    /**
     * Initialize services in dependency order
     */
    async initializeInOrder(serviceNames: string[]): Promise<void> {
        await this.container.initializeInOrder(serviceNames);
    }

    /**
     * Export dependency graph for visualization
     */
    exportDependencyGraph(): { nodes: string[]; edges: Array<{ from: string; to: string }> } {
        return this.container.exportDependencyGraph();
    }
}
```

## core/StructuredLogger.ts

```typescript
/**
 * StructuredLogger - Structured logging system replacing console.log proliferation
 * Location: src/core/StructuredLogger.ts
 * 
 * This service replaces the 1,286+ console.log statements throughout the codebase
 * with a proper logging system that respects debug modes, provides structured output,
 * and includes log management features.
 * 
 * Key features:
 * - Configurable log levels and debug mode
 * - Structured log entries with metadata
 * - Context-specific loggers for modules
 * - Log buffering and export functionality
 * - Performance timing utilities
 * - Cross-platform compatibility
 * 
 * Used by:
 * - All services to replace console.log statements
 * - Debug and troubleshooting operations
 * - Performance monitoring
 * - Error tracking and reporting
 */

import { Plugin } from 'obsidian';

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  data?: any;
  context?: string;
  plugin: string;
  performance?: {
    duration?: number;
    memory?: number;
  };
}

export interface LoggerConfig {
  debugMode: boolean;
  level: LogLevel;
  maxBufferSize: number;
  enablePerformanceLogging: boolean;
  enableExport: boolean;
}

/**
 * Context-specific logger for modules/services
 */
export class ContextLogger {
  constructor(
    private logger: StructuredLogger,
    private context: string
  ) {}

  debug(message: string, data?: any): void {
    this.logger.debug(message, data, this.context);
  }

  info(message: string, data?: any): void {
    this.logger.info(message, data, this.context);
  }

  warn(message: string, data?: any): void {
    this.logger.warn(message, data, this.context);
  }

  error(message: string, error?: Error): void {
    this.logger.error(message, error, this.context);
  }

  time(label: string): void {
    this.logger.time(`${this.context}:${label}`);
  }

  timeEnd(label: string): void {
    this.logger.timeEnd(`${this.context}:${label}`);
  }
}

/**
 * Structured logging system replacing console.log proliferation
 * Configurable levels and proper error handling
 */
export class StructuredLogger {
  private config: LoggerConfig;
  private logBuffer: LogEntry[] = [];
  private timers = new Map<string, number>();
  private contextLoggers = new Map<string, ContextLogger>();

  constructor(private plugin: Plugin) {
    this.config = {
      debugMode: false,
      level: LogLevel.INFO,
      maxBufferSize: 1000,
      enablePerformanceLogging: false,
      enableExport: true
    };
    
    this.loadLogSettings();
  }

  /**
   * Load logging configuration from plugin settings
   */
  private async loadLogSettings(): Promise<void> {
    try {
      const settings = await this.plugin.loadData();
      const loggingSettings = settings?.logging;
      
      if (loggingSettings) {
        this.config = {
          debugMode: loggingSettings.debugMode || false,
          level: loggingSettings.level || LogLevel.INFO,
          maxBufferSize: loggingSettings.maxBufferSize || 1000,
          enablePerformanceLogging: loggingSettings.enablePerformanceLogging || false,
          enableExport: loggingSettings.enableExport !== false
        };
      }
    } catch (error) {
      // Fallback to defaults if settings can't be loaded
      console.warn('[StructuredLogger] Failed to load log settings, using defaults:', error);
    }
  }

  /**
   * Update logging configuration
   */
  async updateConfig(newConfig: Partial<LoggerConfig>): Promise<void> {
    this.config = { ...this.config, ...newConfig };
    
    try {
      const settings = await this.plugin.loadData() || {};
      settings.logging = this.config;
      await this.plugin.saveData(settings);
    } catch (error) {
      console.error('[StructuredLogger] Failed to save log configuration:', error);
    }
  }

  /**
   * Debug level logging
   */
  debug(message: string, data?: any, context?: string): void {
    if (this.config.debugMode && this.shouldLog(LogLevel.DEBUG)) {
      this.log(LogLevel.DEBUG, message, data, context);
    }
  }

  /**
   * Info level logging
   */
  info(message: string, data?: any, context?: string): void {
    if (this.shouldLog(LogLevel.INFO)) {
      this.log(LogLevel.INFO, message, data, context);
    }
  }

  /**
   * Warning level logging
   */
  warn(message: string, data?: any, context?: string): void {
    if (this.shouldLog(LogLevel.WARN)) {
      this.log(LogLevel.WARN, message, data, context);
    }
  }

  /**
   * Error level logging
   */
  error(message: string, error?: Error, context?: string): void {
    if (this.shouldLog(LogLevel.ERROR)) {
      // Extract error information
      const errorData = error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined;
      
      this.log(LogLevel.ERROR, message, errorData, context);
    }
  }

  /**
   * Performance timing start
   */
  time(label: string): void {
    if (this.config.enablePerformanceLogging || this.config.debugMode) {
      this.timers.set(label, performance.now());
      console.time(`[${this.plugin.manifest.id}] ${label}`);
    }
  }

  /**
   * Performance timing end
   */
  timeEnd(label: string): void {
    if (this.config.enablePerformanceLogging || this.config.debugMode) {
      const startTime = this.timers.get(label);
      if (startTime !== undefined) {
        const duration = performance.now() - startTime;
        this.timers.delete(label);
        
        this.debug(`Performance: ${label} completed`, {
          duration: `${duration.toFixed(2)}ms`,
          label
        }, 'Performance');
        
        console.timeEnd(`[${this.plugin.manifest.id}] ${label}`);
      }
    }
  }

  /**
   * Create context-specific logger
   */
  createContextLogger(context: string): ContextLogger {
    if (!this.contextLoggers.has(context)) {
      this.contextLoggers.set(context, new ContextLogger(this, context));
    }
    return this.contextLoggers.get(context)!;
  }

  /**
   * Log performance metrics
   */
  logPerformance(operation: string, duration: number, context?: string): void {
    if (this.config.enablePerformanceLogging) {
      this.info(`Performance: ${operation}`, {
        duration: `${duration.toFixed(2)}ms`,
        operation
      }, context || 'Performance');
    }
  }

  /**
   * Log memory usage
   */
  logMemoryUsage(context?: string): void {
    if (this.config.enablePerformanceLogging && 'memory' in performance) {
      const memInfo = (performance as any).memory;
      this.debug('Memory usage', {
        used: `${(memInfo.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
        total: `${(memInfo.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
        limit: `${(memInfo.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`
      }, context || 'Memory');
    }
  }

  /**
   * Core logging method
   */
  private log(level: LogLevel, message: string, data?: any, context?: string): void {
    const timestamp = new Date().toISOString();
    const logEntry: LogEntry = {
      timestamp,
      level,
      message,
      data,
      context,
      plugin: this.plugin.manifest.id
    };

    // Add performance data if available
    if (this.config.enablePerformanceLogging && 'memory' in performance) {
      const memInfo = (performance as any).memory;
      logEntry.performance = {
        memory: memInfo.usedJSHeapSize
      };
    }

    // Add to buffer
    this.addToBuffer(logEntry);

    // Output to console with proper formatting
    const formattedMessage = this.formatMessage(logEntry);
    
    switch (level) {
      case LogLevel.DEBUG:
        if (this.config.debugMode) {
          console.log(formattedMessage, data);
        }
        break;
      case LogLevel.INFO:
        console.log(formattedMessage, data || '');
        break;
      case LogLevel.WARN:
        console.warn(formattedMessage, data || '');
        break;
      case LogLevel.ERROR:
        console.error(formattedMessage, data || '');
        break;
    }
  }

  /**
   * Check if should log at level
   */
  private shouldLog(level: LogLevel): boolean {
    return level >= this.config.level;
  }

  /**
   * Format log message for console output
   */
  private formatMessage(entry: LogEntry): string {
    const levelStr = LogLevel[entry.level];
    const contextStr = entry.context ? ` [${entry.context}]` : '';
    const timestamp = new Date(entry.timestamp).toLocaleTimeString();
    
    return `[${entry.plugin}]${contextStr} ${levelStr}: ${entry.message} (${timestamp})`;
  }

  /**
   * Add entry to buffer with size management
   */
  private addToBuffer(entry: LogEntry): void {
    this.logBuffer.push(entry);
    
    if (this.logBuffer.length > this.config.maxBufferSize) {
      // Remove oldest entries
      const excess = this.logBuffer.length - this.config.maxBufferSize;
      this.logBuffer.splice(0, excess);
    }
  }

  /**
   * Export logs for debugging
   */
  async exportLogs(): Promise<string> {
    if (!this.config.enableExport) {
      throw new Error('Log export is disabled');
    }

    const exportData = {
      plugin: this.plugin.manifest.id,
      version: this.plugin.manifest.version,
      exported: new Date().toISOString(),
      config: this.config,
      platform: (this.plugin.app as any).isMobile ? 'mobile' : 'desktop',
      logCount: this.logBuffer.length,
      logs: this.logBuffer
    };
    
    return JSON.stringify(exportData, null, 2);
  }

  /**
   * Get log statistics
   */
  getLogStats(): {
    totalEntries: number;
    byLevel: Record<string, number>;
    byContext: Record<string, number>;
    bufferSize: number;
    oldestEntry?: string;
    newestEntry?: string;
  } {
    const byLevel: Record<string, number> = {};
    const byContext: Record<string, number> = {};

    for (const entry of this.logBuffer) {
      const levelStr = LogLevel[entry.level];
      byLevel[levelStr] = (byLevel[levelStr] || 0) + 1;
      
      const context = entry.context || 'Unknown';
      byContext[context] = (byContext[context] || 0) + 1;
    }

    return {
      totalEntries: this.logBuffer.length,
      byLevel,
      byContext,
      bufferSize: this.config.maxBufferSize,
      oldestEntry: this.logBuffer[0]?.timestamp,
      newestEntry: this.logBuffer[this.logBuffer.length - 1]?.timestamp
    };
  }

  /**
   * Clear log buffer
   */
  clearBuffer(): void {
    const clearedCount = this.logBuffer.length;
    this.logBuffer = [];
    this.info(`Log buffer cleared (${clearedCount} entries removed)`, undefined, 'Logger');
  }

  /**
   * Search logs by criteria
   */
  searchLogs(criteria: {
    level?: LogLevel;
    context?: string;
    message?: string;
    since?: Date;
    until?: Date;
  }): LogEntry[] {
    return this.logBuffer.filter(entry => {
      if (criteria.level !== undefined && entry.level !== criteria.level) {
        return false;
      }
      
      if (criteria.context && entry.context !== criteria.context) {
        return false;
      }
      
      if (criteria.message && !entry.message.toLowerCase().includes(criteria.message.toLowerCase())) {
        return false;
      }
      
      const entryTime = new Date(entry.timestamp);
      if (criteria.since && entryTime < criteria.since) {
        return false;
      }
      
      if (criteria.until && entryTime > criteria.until) {
        return false;
      }
      
      return true;
    });
  }

  /**
   * Enable or disable debug mode
   */
  async setDebugMode(enabled: boolean): Promise<void> {
    await this.updateConfig({ debugMode: enabled });
    this.info(`Debug mode ${enabled ? 'enabled' : 'disabled'}`, undefined, 'Logger');
  }

  /**
   * Set log level
   */
  async setLogLevel(level: LogLevel): Promise<void> {
    await this.updateConfig({ level });
    this.info(`Log level set to ${LogLevel[level]}`, undefined, 'Logger');
  }

  /**
   * Get current configuration
   */
  getConfig(): Readonly<LoggerConfig> {
    return { ...this.config };
  }

  /**
   * Clean up resources
   */
  cleanup(): void {
    // Clear all timers
    this.timers.clear();
    
    // Clear context loggers
    this.contextLoggers.clear();
    
    // Optionally preserve buffer for post-cleanup analysis
    if (this.config.debugMode) {
      this.info('StructuredLogger cleanup completed', {
        bufferedEntries: this.logBuffer.length
      }, 'Logger');
    }
  }
}
```

## core/VaultOperations.ts

```typescript
/**
 * VaultOperations - Centralized Vault operations using official Obsidian API
 * Location: src/core/VaultOperations.ts
 * 
 * This service replaces all Node.js filesystem operations with Obsidian Vault API calls,
 * ensuring cross-platform compatibility (mobile + desktop) and proper integration
 * with Obsidian's caching and file management systems.
 * 
 * Used by:
 * - All services that need file/directory operations
 * - ChromaDB persistence operations
 * - Plugin data management
 * - Configuration file handling
 */

import { Vault, TFile, TFolder, normalizePath } from 'obsidian';
import { ObsidianPathManager } from './ObsidianPathManager';
import { StructuredLogger } from './StructuredLogger';

export interface BatchWriteOperation {
  path: string;
  content: string;
}

export interface BatchWriteResult {
  success: string[];
  failed: string[];
}

export interface FileStats {
  size: number;
  mtime: number;
  ctime: number;
  type: 'file' | 'folder';
}

/**
 * Centralized Vault operations using official Obsidian API
 * Replaces all Node.js filesystem operations
 */
export class VaultOperations {
  private fileCache = new Map<string, { content: string; mtime: number }>();

  constructor(
    private vault: Vault,
    private pathManager: ObsidianPathManager,
    private logger: StructuredLogger
  ) {}

  /**
   * Get file by path with proper error handling
   */
  async getFile(path: string): Promise<TFile | null> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const file = this.vault.getFileByPath(normalizedPath);
      return file;
    } catch (error) {
      this.logger.warn(`Failed to get file: ${path}`, error);
      return null;
    }
  }

  /**
   * Get folder by path with proper error handling
   */
  async getFolder(path: string): Promise<TFolder | null> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const folder = this.vault.getFolderByPath(normalizedPath);
      return folder;
    } catch (error) {
      this.logger.warn(`Failed to get folder: ${path}`, error);
      return null;
    }
  }

  /**
   * Check if file exists
   */
  async fileExists(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      return await this.vault.adapter.exists(normalizedPath);
    } catch (error) {
      this.logger.debug(`File existence check failed: ${path}`, error);
      return false;
    }
  }

  /**
   * Check if folder exists
   */
  async folderExists(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const stat = await this.vault.adapter.stat(normalizedPath);
      return stat?.type === 'folder';
    } catch (error) {
      this.logger.debug(`Folder existence check failed: ${path}`, error);
      return false;
    }
  }

  /**
   * Read file content with caching support
   */
  async readFile(path: string, useCache: boolean = true): Promise<string | null> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      
      if (useCache) {
        const file = await this.getFile(normalizedPath);
        if (file) {
          const cached = this.fileCache.get(normalizedPath);
          if (cached && cached.mtime === file.stat.mtime) {
            this.logger.debug(`Cache hit for file: ${normalizedPath}`);
            return cached.content;
          }
        }
      }

      const file = await this.getFile(normalizedPath);
      if (!file) {
        this.logger.warn(`File not found: ${normalizedPath}`);
        return null;
      }

      const content = await this.vault.cachedRead(file);
      
      if (useCache) {
        this.fileCache.set(normalizedPath, {
          content,
          mtime: file.stat.mtime
        });
      }

      this.logger.debug(`Successfully read file: ${normalizedPath}`);
      return content;
    } catch (error) {
      this.logger.error(`Failed to read file ${path}`, error instanceof Error ? error : new Error(String(error)));
      return null;
    }
  }

  /**
   * Write file content with automatic directory creation
   */
  async writeFile(path: string, content: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      await this.pathManager.ensureParentExists(normalizedPath);
      
      const existingFile = await this.getFile(normalizedPath);
      if (existingFile) {
        await this.vault.modify(existingFile, content);
      } else {
        await this.vault.create(normalizedPath, content);
      }
      
      // Invalidate cache
      this.fileCache.delete(normalizedPath);
      
      this.logger.debug(`Successfully wrote file: ${normalizedPath}`);
      return true;
    } catch (error) {
      this.logger.error(`Failed to write file ${path}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Create directory if it doesn't exist
   */
  async ensureDirectory(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const existingFolder = await this.getFolder(normalizedPath);
      
      if (!existingFolder) {
        await this.vault.createFolder(normalizedPath);
        this.logger.debug(`Created directory: ${normalizedPath}`);
      }
      
      return true;
    } catch (error) {
      this.logger.error(`Failed to create directory ${path}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Delete file
   */
  async deleteFile(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const file = await this.getFile(normalizedPath);
      
      if (file) {
        await this.vault.delete(file);
        this.fileCache.delete(normalizedPath);
        this.logger.debug(`Deleted file: ${normalizedPath}`);
        return true;
      }
      
      this.logger.warn(`File not found for deletion: ${normalizedPath}`);
      return false;
    } catch (error) {
      this.logger.error(`Failed to delete file ${path}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Delete folder
   */
  async deleteFolder(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const folder = await this.getFolder(normalizedPath);
      
      if (folder) {
        await this.vault.delete(folder);
        this.logger.debug(`Deleted folder: ${normalizedPath}`);
        return true;
      }
      
      this.logger.warn(`Folder not found for deletion: ${normalizedPath}`);
      return false;
    } catch (error) {
      this.logger.error(`Failed to delete folder ${path}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Get file/folder statistics
   */
  async getStats(path: string): Promise<FileStats | null> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const stat = await this.vault.adapter.stat(normalizedPath);
      
      if (stat) {
        return {
          size: stat.size || 0,
          mtime: stat.mtime || 0,
          ctime: stat.ctime || 0,
          type: stat.type as 'file' | 'folder'
        };
      }
      
      return null;
    } catch (error) {
      this.logger.debug(`Failed to get stats for ${path}`, error);
      return null;
    }
  }

  /**
   * List directory contents
   */
  async listDirectory(path: string): Promise<{ files: string[]; folders: string[] }> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const listing = await this.vault.adapter.list(normalizedPath);
      
      return {
        files: listing.files,
        folders: listing.folders
      };
    } catch (error) {
      this.logger.error(`Failed to list directory ${path}`, error instanceof Error ? error : new Error(String(error)));
      return { files: [], folders: [] };
    }
  }

  /**
   * Calculate directory size recursively
   */
  async calculateDirectorySize(path: string): Promise<number> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      let totalSize = 0;
      
      const listing = await this.vault.adapter.list(normalizedPath);
      
      // Calculate size of files
      for (const filePath of listing.files) {
        const stat = await this.getStats(filePath);
        if (stat) {
          totalSize += stat.size;
        }
      }
      
      // Recursively calculate size of subdirectories
      for (const folderPath of listing.folders) {
        totalSize += await this.calculateDirectorySize(folderPath);
      }
      
      return totalSize;
    } catch (error) {
      this.logger.error(`Failed to calculate directory size for ${path}`, error instanceof Error ? error : new Error(String(error)));
      return 0;
    }
  }

  /**
   * Batch read operations
   */
  async batchRead(paths: string[]): Promise<Map<string, string | null>> {
    const results = new Map<string, string | null>();
    
    // Process in parallel for better performance
    const promises = paths.map(async (path) => {
      const content = await this.readFile(path);
      results.set(path, content);
    });
    
    await Promise.all(promises);
    return results;
  }

  /**
   * Batch write operations
   */
  async batchWrite(operations: BatchWriteOperation[]): Promise<BatchWriteResult> {
    const success: string[] = [];
    const failed: string[] = [];
    
    // Process in sequence to avoid race conditions
    for (const operation of operations) {
      const result = await this.writeFile(operation.path, operation.content);
      if (result) {
        success.push(operation.path);
      } else {
        failed.push(operation.path);
      }
    }
    
    return { success, failed };
  }

  /**
   * Copy file
   */
  async copyFile(sourcePath: string, targetPath: string): Promise<boolean> {
    try {
      const content = await this.readFile(sourcePath, false);
      if (content === null) {
        this.logger.error(`Source file not found: ${sourcePath}`);
        return false;
      }
      
      return await this.writeFile(targetPath, content);
    } catch (error) {
      this.logger.error(`Failed to copy file from ${sourcePath} to ${targetPath}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Move/rename file
   */
  async moveFile(sourcePath: string, targetPath: string): Promise<boolean> {
    try {
      const normalizedSource = this.pathManager.normalizePath(sourcePath);
      const normalizedTarget = this.pathManager.normalizePath(targetPath);
      
      const sourceFile = await this.getFile(normalizedSource);
      if (!sourceFile) {
        this.logger.error(`Source file not found: ${sourcePath}`);
        return false;
      }
      
      await this.vault.rename(sourceFile, normalizedTarget);
      this.fileCache.delete(normalizedSource);
      
      this.logger.debug(`Moved file from ${sourcePath} to ${targetPath}`);
      return true;
    } catch (error) {
      this.logger.error(`Failed to move file from ${sourcePath} to ${targetPath}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Clear file cache
   */
  clearCache(): void {
    this.fileCache.clear();
    this.logger.debug('File cache cleared');
  }

  /**
   * Get cache statistics
   */
  getCacheStats(): { size: number; entries: number } {
    const entries = this.fileCache.size;
    let size = 0;
    
    for (const cached of this.fileCache.values()) {
      size += cached.content.length;
    }
    
    return { size, entries };
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.clearCache();
    this.logger.debug('VaultOperations cleaned up');
  }
}
```

## core/background/BackgroundProcessor.ts

```typescript
/**
 * Location: /src/core/background/BackgroundProcessor.ts
 * 
 * Background Processor - Handles background tasks, startup processing, and validation
 * 
 * This service extracts background processing logic from PluginLifecycleManager,
 * managing deferred operations and non-critical startup tasks.
 */

import { Notice } from 'obsidian';
import type { Plugin } from 'obsidian';
import type { Settings } from '../../settings';
import type { SettingsTab } from '../../components/SettingsTab';
import { UpdateManager } from '../../utils/UpdateManager';

export interface BackgroundProcessorConfig {
    plugin: Plugin;
    settings: Settings;
    serviceManager: any;
    settingsTab?: SettingsTab;
    getService: <T>(name: string, timeoutMs?: number) => Promise<T | null>;
    waitForService: <T>(serviceName: string, timeoutMs?: number) => Promise<T | null>;
    isInitialized: () => boolean;
}

export class BackgroundProcessor {
    private config: BackgroundProcessorConfig;
    private hasRunBackgroundStartup: boolean = false;

    constructor(config: BackgroundProcessorConfig) {
        this.config = config;
    }

    /**
     * Start background startup processing - runs independently after plugin initialization
     */
    startBackgroundStartupProcessing(): void {
        // Prevent multiple background startup processes
        if (this.hasRunBackgroundStartup) {
            return;
        }
        
        // Run startup processing in background without blocking plugin initialization
        setTimeout(async () => {
            try {
                // Double-check to prevent race conditions
                if (this.hasRunBackgroundStartup) {
                    return;
                }
                
                this.hasRunBackgroundStartup = true;
                
                // STEP 1: Perform deferred migration first (after file system is ready)
                try {
                    const fileEventManager = await this.config.waitForService('fileEventManager', 5000);
                    if (fileEventManager && typeof (fileEventManager as any).getCoordinator === 'function') {
                        const coordinator = (fileEventManager as any).getCoordinator();
                        if (coordinator && typeof coordinator.getIncompleteFilesManager === 'function') {
                            const incompleteFilesManager = coordinator.getIncompleteFilesManager();
                            await incompleteFilesManager.performDeferredMigration();
                        } else {
                            console.warn('[BackgroundProcessor] ‚ö†Ô∏è FileEventCoordinator or IncompleteFilesStateManager not available');
                        }
                    } else {
                        console.warn('[BackgroundProcessor] ‚ö†Ô∏è Could not access FileEventManager for deferred migration');
                    }
                } catch (error) {
                    console.error('[BackgroundProcessor] ‚ùå Deferred migration failed:', error);
                }
                
                // Background startup processing completed
            } catch (error) {
                console.error('[BackgroundProcessor] Error in background startup processing:', error);
                // Reset flag on error so it can be retried
                this.hasRunBackgroundStartup = false;
            }
        }, 2000); // 2 second delay to ensure Obsidian is fully loaded
    }

    /**
     * Check for updates on startup in background
     */
    async checkForUpdatesOnStartup(): Promise<void> {
        // Run in background to avoid blocking startup
        setTimeout(async () => {
            try {
                const { settings } = this.config;
                const lastCheck = settings.settings.lastUpdateCheckDate;
                if (lastCheck) {
                    const lastCheckTime = new Date(lastCheck);
                    const now = new Date();
                    const daysDiff = (now.getTime() - lastCheckTime.getTime()) / (1000 * 60 * 60 * 24);
                    if (daysDiff < 1) {
                        return;
                    }
                }

                const updateManager = new UpdateManager(this.config.plugin);
                const hasUpdate = await updateManager.checkForUpdate();
                
                settings.settings.lastUpdateCheckDate = new Date().toISOString();
                
                if (hasUpdate) {
                    const release = await (updateManager as any).fetchLatestRelease();
                    const availableVersion = release.tag_name.replace('v', '');
                    
                    settings.settings.availableUpdateVersion = availableVersion;
                    
                    new Notice(`Plugin update available: v${availableVersion}. Check settings to update.`, 8000);
                } else {
                    settings.settings.availableUpdateVersion = undefined;
                }
                
                await settings.saveSettings();
                
            } catch (error) {
                console.error('[BackgroundProcessor] Failed to check for updates:', error);
            }
        }, 2000); // 2 second delay
    }

    /**
     * Validate search functionality - ensure core services are available
     */
    async validateSearchFunctionality(): Promise<void> {
        try {
            // Test 1: Validate search services are available
            const searchService = await this.config.getService('searchService', 5000);
            if (searchService) {
                console.log('[VALIDATION] ‚úÖ Search service available');
            } else {
                console.warn('[VALIDATION] ‚ö†Ô∏è Search service not available');
            }
            
            // Test 2: Validate core services are available
            const serviceManager = this.config.serviceManager;
            if (serviceManager) {
                const metadata = serviceManager.getAllServiceStatus();
                const serviceNames = Object.keys(metadata);
                
                const coreServices = ['searchService', 'workspaceService', 'memoryService'];
                const availableCore = coreServices.filter(service => serviceNames.includes(service));
            }
            
        } catch (error) {
            console.warn('[VALIDATION] Service validation error:', error);
        }
    }

    /**
     * Update settings tab with available services (non-blocking)
     */
    updateSettingsTabServices(): void {
        if (this.config.settingsTab) {
            const services: Record<string, any> = {};
            for (const serviceName of this.config.serviceManager.getReadyServices()) {
                services[serviceName] = this.config.serviceManager.getServiceIfReady(serviceName);
            }
            this.config.settingsTab.updateServices(services);
        }
    }

    /**
     * Update settings tab reference (used when settings tab is created)
     */
    setSettingsTab(settingsTab: SettingsTab): void {
        this.config.settingsTab = settingsTab;
    }

    /**
     * Check if background startup processing has run
     */
    hasRunBackgroundStartupProcessing(): boolean {
        return this.hasRunBackgroundStartup;
    }

    /**
     * Reset background startup flag (useful for testing)
     */
    resetBackgroundStartupFlag(): void {
        this.hasRunBackgroundStartup = false;
    }
}
```

## core/commands/CommandDefinitions.ts

```typescript
/**
 * Command Definitions
 * Basic command definitions for plugin functionality
 */

export interface CommandContext {
  plugin: any;
  serviceManager: any;
  getService?: (name: any, timeoutMs?: any) => any;
  isInitialized?: () => boolean;
}

export const BASIC_COMMAND_DEFINITIONS = [
  {
    id: 'open-settings',
    name: 'Open Plugin Settings',
    callback: (context: CommandContext) => {
      context.plugin.app.setting.open();
      context.plugin.app.setting.openTabById(context.plugin.manifest.id);
    }
  }
];

export const MAINTENANCE_COMMAND_DEFINITIONS = BASIC_COMMAND_DEFINITIONS;
export const TROUBLESHOOT_COMMAND_DEFINITION = BASIC_COMMAND_DEFINITIONS[0];
```

## core/commands/MaintenanceCommandManager.ts

```typescript
/**
 * Maintenance Command Manager
 * Handles maintenance and troubleshooting commands
 */

import { CommandContext } from './CommandDefinitions';

export class MaintenanceCommandManager {
  constructor(private context: CommandContext) {}

  /**
   * Execute maintenance command
   */
  async executeMaintenanceCommand(commandId: string): Promise<void> {
    // Basic maintenance operations
    console.log(`Executing maintenance command: ${commandId}`);
  }

  /**
   * Get available maintenance commands
   */
  getMaintenanceCommands(): string[] {
    return ['open-settings'];
  }

  /**
   * Register maintenance commands
   */
  registerMaintenanceCommands(): void {
    console.log('Maintenance commands registered');
  }

  /**
   * Register troubleshoot command
   */
  registerTroubleshootCommand(): void {
    console.log('Troubleshoot command registered');
  }
}
```

## core/index.ts

```typescript
/**
 * Core Components Index - Obsidian API-First Architecture
 * Location: src/core/index.ts
 * 
 * Central export point for all core architecture components that implement
 * the Obsidian API-first migration. This provides clean imports and ensures
 * consistent usage across the codebase.
 * 
 * Components provided:
 * - VaultOperations: Cross-platform file operations using Vault API
 * - ObsidianPathManager: Path management with security and normalization
 * - PluginDataManager: Type-safe settings and data persistence
 * - StructuredLogger: Configurable logging system
 * - ServiceContainer: Dependency injection container
 * 
 * Usage:
 * import { VaultOperations, StructuredLogger } from './core';
 */

// Core services
export { VaultOperations } from './VaultOperations';
export { ObsidianPathManager } from './ObsidianPathManager';
export { PluginDataManager, SettingsMigrationManager } from './PluginDataManager';
export { StructuredLogger, ContextLogger, LogLevel } from './StructuredLogger';
export { ServiceContainer } from './ServiceContainer';

// Type exports for external usage
export type { 
  BatchWriteOperation, 
  BatchWriteResult, 
  FileStats 
} from './VaultOperations';

export type { 
  PathValidationResult 
} from './ObsidianPathManager';

export type { 
  SettingsSchema, 
  SettingsMigration, 
  BackupData 
} from './PluginDataManager';

export type { 
  LogEntry, 
  LoggerConfig 
} from './StructuredLogger';

export type { 
  ServiceFactory, 
  ServiceRegistration, 
  ServiceMetadata 
} from './ServiceContainer';

/**
 * Utility function to create a complete service setup for a plugin
 * This provides a quick way to bootstrap the new architecture
 */
export async function createCoreServices(plugin: any) {
  // Import components directly to avoid circular dependency
  const { StructuredLogger } = await import('./StructuredLogger');
  const { ObsidianPathManager } = await import('./ObsidianPathManager');
  const { PluginDataManager } = await import('./PluginDataManager');
  const { VaultOperations } = await import('./VaultOperations');
  const { ServiceContainer } = await import('./ServiceContainer');
  
  // Create logger first
  const logger = new StructuredLogger(plugin);
  
  // Create path manager with manifest
  const pathManager = new ObsidianPathManager(plugin.app.vault, plugin.manifest);
  
  // Create data manager with defaults
  const dataManager = new PluginDataManager(plugin);
  await dataManager.load();
  
  // Create vault operations
  const vaultOperations = new VaultOperations(plugin.app.vault, pathManager, logger);
  
  // Create service container
  const container = new ServiceContainer();
  
  // Register core services
  container.register('logger', () => logger);
  container.register('pathManager', () => pathManager);
  container.register('dataManager', () => dataManager);
  container.register('vaultOperations', () => vaultOperations);
  
  return {
    logger,
    pathManager,
    dataManager,
    vaultOperations,
    container
  };
}

/**
 * Architecture validation utility
 * Helps ensure proper implementation of the new patterns
 */
export function validateArchitecture(plugin: any): {
  valid: boolean;
  issues: string[];
  recommendations: string[];
} {
  const issues: string[] = [];
  const recommendations: string[] = [];
  
  // Check if using new core components
  if (!plugin.logger || plugin.logger.constructor.name !== 'StructuredLogger') {
    issues.push('Plugin should use StructuredLogger instead of console.log');
    recommendations.push('Replace console.log statements with this.logger.info/debug/warn/error');
  }
  
  if (!plugin.pathManager || plugin.pathManager.constructor.name !== 'ObsidianPathManager') {
    issues.push('Plugin should use ObsidianPathManager for path operations');
    recommendations.push('Replace manual path construction with pathManager methods');
  }
  
  if (!plugin.vaultOperations || plugin.vaultOperations.constructor.name !== 'VaultOperations') {
    issues.push('Plugin should use VaultOperations instead of Node.js fs');
    recommendations.push('Replace require("fs") operations with vaultOperations methods');
  }
  
  if (!plugin.dataManager || plugin.dataManager.constructor.name !== 'PluginDataManager') {
    issues.push('Plugin should use PluginDataManager for settings');
    recommendations.push('Replace manual Plugin.loadData/saveData with dataManager');
  }
  
  // Check for anti-patterns
  const pluginCode = plugin.toString();
  
  if (pluginCode.includes('require("fs")') || pluginCode.includes('require(\'fs\')')) {
    issues.push('Node.js filesystem usage detected');
    recommendations.push('Use VaultOperations for cross-platform file operations');
  }
  
  if (pluginCode.includes('console.log') || pluginCode.includes('console.error')) {
    issues.push('Direct console logging detected');
    recommendations.push('Use StructuredLogger for proper log management');
  }
  
  if (pluginCode.includes('FileSystemAdapter')) {
    issues.push('Direct FileSystemAdapter usage detected');
    recommendations.push('Use ObsidianPathManager for cross-platform path handling');
  }
  
  return {
    valid: issues.length === 0,
    issues,
    recommendations
  };
}

/**
 * Migration helper to gradually transition from old to new architecture
 */
export class ArchitectureMigrationHelper {
  constructor(private plugin: any) {}
  
  /**
   * Phase 1: Replace console logging
   */
  async migrateLogging(): Promise<void> {
    if (!this.plugin.logger) {
      const { StructuredLogger } = await import('./StructuredLogger');
      this.plugin.logger = new StructuredLogger(this.plugin);
      // StructuredLogger initialized
    }
  }
  
  /**
   * Phase 2: Replace path management
   */
  async migratePaths(): Promise<void> {
    if (!this.plugin.pathManager) {
      const { ObsidianPathManager } = await import('./ObsidianPathManager');
      this.plugin.pathManager = new ObsidianPathManager(
        this.plugin.app.vault, 
        this.plugin.manifest
      );
      // ObsidianPathManager initialized
    }
  }
  
  /**
   * Phase 3: Replace file operations
   */
  async migrateFileOperations(): Promise<void> {
    if (!this.plugin.vaultOperations && this.plugin.pathManager && this.plugin.logger) {
      const { VaultOperations } = await import('./VaultOperations');
      this.plugin.vaultOperations = new VaultOperations(
        this.plugin.app.vault,
        this.plugin.pathManager,
        this.plugin.logger
      );
      // VaultOperations initialized
    }
  }
  
  /**
   * Phase 4: Replace data management
   */
  async migrateDataManagement(defaults: any): Promise<void> {
    if (!this.plugin.dataManager) {
      const { PluginDataManager } = await import('./PluginDataManager');
      this.plugin.dataManager = new PluginDataManager(this.plugin);
      await this.plugin.dataManager.load();
      // PluginDataManager initialized
    }
  }
  
  /**
   * Complete migration in phases
   */
  async performFullMigration(defaults: any): Promise<void> {
    // Starting architecture migration
    
    await this.migrateLogging();
    await this.migratePaths();
    await this.migrateFileOperations();
    await this.migrateDataManagement(defaults);
    
    // Architecture migration completed
    
    // Validate the migration
    const validation = validateArchitecture(this.plugin);
    if (validation.valid) {
      // Architecture validation passed
    } else {
      console.warn('[Migration] ‚ö†Ô∏è Architecture validation issues:', validation.issues);
    }
  }
}
```

## core/services/ServiceDefinitions.ts

```typescript
/**
 * Location: /src/core/services/ServiceDefinitions.ts
 *
 * Service Definitions - Centralized service registration configuration
 *
 * This module defines all services in a data-driven way, making it easy to add
 * new services without modifying the core PluginLifecycleManager.
 *
 * Simplified architecture for JSON-based storage
 */

import type { Plugin } from 'obsidian';
import type { ServiceManager } from '../ServiceManager';
import type { Settings } from '../../settings';

export interface ServiceDefinition {
    name: string;
    dependencies?: string[];
    create: (context: ServiceCreationContext) => Promise<any>;
}

export interface ServiceCreationContext {
    plugin: Plugin;
    app: any;
    settings: Settings;
    serviceManager: ServiceManager;
    connector: any; // MCPConnector
    manifest: any;
}

/**
 * Core service definitions in dependency order
 */
export const CORE_SERVICE_DEFINITIONS: ServiceDefinition[] = [
    // Foundation services (no dependencies)
    {
        name: 'eventManager',
        create: async () => {
            const { EventManager } = await import('../../services/EventManager');
            return new EventManager();
        }
    },

    // Note: ProcessedFilesStateManager and SimpleMemoryService removed in simplify-search-architecture
    // State management is now handled by simplified JSON-based storage

    // Memory service with simplified dependencies
    {
        name: 'memoryService',
        create: async (context) => {
            const { MemoryService } = await import('../../agents/memoryManager/services/MemoryService');
            return new MemoryService(context.plugin);
        }
    },

    // Workspace service with simplified dependencies
    {
        name: 'workspaceService',
        create: async (context) => {
            const { WorkspaceService } = await import('../../agents/memoryManager/services/WorkspaceService');
            return new WorkspaceService(context.plugin);
        }
    },

    // Cache manager for performance
    {
        name: 'cacheManager',
        dependencies: ['workspaceService', 'memoryService'],
        create: async (context) => {
            const { CacheManager } = await import('../../database/services/cache/CacheManager');

            const workspaceService = await context.serviceManager.getService('workspaceService');
            const memoryService = await context.serviceManager.getService('memoryService');

            const cacheManager = new CacheManager(
                context.plugin.app,
                workspaceService as any,
                memoryService as any,
                {
                    enableEntityCache: true,
                    enableFileIndex: true,
                    enablePrefetch: true
                }
            );

            return cacheManager;
        }
    },

    // Session context manager
    {
        name: 'sessionContextManager',
        dependencies: ['workspaceService', 'memoryService'],
        create: async (context) => {
            const { SessionContextManager } = await import('../../services/SessionContextManager');

            const workspaceService = await context.serviceManager.getService('workspaceService');
            const memoryService = await context.serviceManager.getService('memoryService');

            return new SessionContextManager();
        }
    },

    // LLM services for chat functionality
    {
        name: 'llmService',
        create: async (context) => {
            const { LLMService } = await import('../../services/llm/core/LLMService');
            const llmProviders = context.settings.settings.llmProviders;
            if (!llmProviders || typeof llmProviders !== 'object' || !('providers' in llmProviders)) {
                throw new Error('Invalid LLM provider settings');
            }
            return new LLMService(llmProviders);
        }
    },

    // Agent manager for custom AI agents
    {
        name: 'agentManager',
        dependencies: ['llmService'],
        create: async (context) => {
            const { AgentManager } = await import('../../services/AgentManager');

            const llmService = await context.serviceManager.getService('llmService');

            return new AgentManager(
                context.plugin.app,
                llmService,
                {} as any // Placeholder for EventManager
            );
        }
    }
];

/**
 * Additional services for UI and maintenance functionality
 */
export const ADDITIONAL_SERVICE_FACTORIES = [
    // Note: ChatDatabaseService removed in simplify-search-architecture
    // Chat data now stored in simplified JSON format
];

/**
 * Services that require special initialization
 */
export const SPECIALIZED_SERVICES = [
    'cacheManager',           // Requires dependency injection
    'sessionContextManager'   // Requires settings configuration
];
```

## core/services/ServiceRegistrar.ts

```typescript
/**
 * Location: /src/core/services/ServiceRegistrar.ts
 * 
 * Service Registrar - Handles service registration and additional service factories
 * 
 * This service extracts the complex service registration logic from PluginLifecycleManager,
 * making it data-driven and easily extensible for new services.
 */

import type { ServiceManager } from '../ServiceManager';
import { CORE_SERVICE_DEFINITIONS, ADDITIONAL_SERVICE_FACTORIES } from './ServiceDefinitions';
import type { ServiceCreationContext } from './ServiceDefinitions';

export class ServiceRegistrar {
    private context: ServiceCreationContext;

    constructor(context: ServiceCreationContext) {
        this.context = context;
    }

    /**
     * Register all core services with the ServiceManager
     */
    async registerCoreServices(): Promise<void> {
        for (const serviceDef of CORE_SERVICE_DEFINITIONS) {
            await this.context.serviceManager.registerService({
                name: serviceDef.name,
                dependencies: serviceDef.dependencies,
                create: () => serviceDef.create(this.context)
            });
        }
    }

    /**
     * Register additional services needed by UI components using factory pattern
     */
    registerAdditionalServices(): void {
        const { serviceManager, plugin, settings, app } = this.context;
        
        for (const serviceFactory of ADDITIONAL_SERVICE_FACTORIES) {
            serviceManager.registerFactory(
                (serviceFactory as any).name,
                async (deps) => {
                    // Create enhanced dependency context
                    const enhancedDeps = {
                        ...deps,
                        plugin,
                        app,
                        memorySettings: settings.settings.memory || {}
                    };
                    return (serviceFactory as any).factory(enhancedDeps);
                },
                { dependencies: (serviceFactory as any).dependencies }
            );
        }
    }

    /**
     * Get default memory settings
     */
    static getDefaultMemorySettings(dataDir: string) {
        return {};
    }

    /**
     * Initialize data directories asynchronously
     */
    async initializeDataDirectories(): Promise<void> {
        try {
            const { app, plugin, settings, manifest } = this.context;
            
            // Use vault-relative paths for Obsidian adapter
            const pluginDir = `.obsidian/plugins/${manifest.id}`;
            const dataDir = `${pluginDir}/data`;
            const storageDir = `${dataDir}/storage`;

            // Create directories using Obsidian's vault adapter
            const { normalizePath } = require('obsidian');
            await app.vault.adapter.mkdir(normalizePath(dataDir));
            await app.vault.adapter.mkdir(normalizePath(storageDir));

            // Update settings with correct path
            if (!settings.settings.memory) {
                settings.settings.memory = ServiceRegistrar.getDefaultMemorySettings(storageDir);
            }
            // dbStoragePath is no longer needed - using .data directory
            
            // Save settings in background
            settings.saveSettings().catch(error => {
                console.warn('[ServiceRegistrar] Failed to save settings after directory init:', error);
            });
            
        } catch (error) {
            console.error('[ServiceRegistrar] Failed to initialize data directories:', error);
            // Don't throw - plugin should function without directories for now
        }
    }

    /**
     * Initialize essential services that must be ready immediately
     */
    async initializeEssentialServices(): Promise<void> {
        try {
            // Initialize only the most critical services synchronously
            await this.context.serviceManager.getService('eventManager');
            await this.context.serviceManager.getService('stateManager');
            await this.context.serviceManager.getService('simpleMemoryService');
        } catch (error) {
            console.error('[ServiceRegistrar] Essential service initialization failed:', error);
            throw error;
        }
    }

    /**
     * Initialize business services with proper dependency resolution
     */
    async initializeBusinessServices(): Promise<void> {
        try {
            // Initialize services in dependency order
            
            // Initialize dependent services sequentially to avoid circular dependency issues
            await this.context.serviceManager.getService('memoryService');
            await this.context.serviceManager.getService('workspaceService');
            await this.context.serviceManager.getService('memoryTraceService');
            await this.context.serviceManager.getService('fileEventManager');
            
            // Initialize supporting services for chat
            await this.context.serviceManager.getService('agentManager');
            await this.context.serviceManager.getService('llmService');
            await this.context.serviceManager.getService('sessionContextManager');
            
            // Initialize chat services
            await this.context.serviceManager.getService('conversationRepository');
            await this.context.serviceManager.getService('chatService');
        } catch (error) {
            console.error('[ServiceRegistrar] Business service initialization failed:', error);
            throw error;
        }
    }

    /**
     * Pre-initialize UI-critical services to avoid Memory Management loading delays
     */
    async preInitializeUICriticalServices(): Promise<void> {
        if (!this.context.serviceManager) return;
        
        const startTime = Date.now();
        
        try {
            // Initialize services that Memory Management accordion depends on
            const uiCriticalServices = [
                'usageStatsService',
                'cacheManager'
            ];
            
            // Register additional services if not already registered
            this.registerAdditionalServices();
            
            // Initialize in parallel where possible
            await Promise.allSettled(
                uiCriticalServices.map(async (serviceName) => {
                    try {
                        const serviceStart = Date.now();
                        await this.context.serviceManager.getService(serviceName);
                        const serviceTime = Date.now() - serviceStart;
                    } catch (error) {
                        console.warn(`[ServiceRegistrar] Failed to pre-initialize ${serviceName}:`, error);
                    }
                })
            );
            
            const totalTime = Date.now() - startTime;
            
            // Inject vector store into SimpleMemoryService for persistence
            try {
                const vectorStore = await this.context.serviceManager.getService('vectorStore');
                const simpleMemoryService = await this.context.serviceManager.getService<any>('simpleMemoryService');
                
                if (vectorStore && simpleMemoryService && typeof simpleMemoryService.setVectorStore === 'function') {
                    simpleMemoryService.setVectorStore(vectorStore);
                } else {
                    console.warn('[ServiceRegistrar] ‚ùå Vector store or SimpleMemoryService not available for injection');
                }
            } catch (error) {
                console.error('[ServiceRegistrar] Failed to inject vector store:', error);
            }
            
        } catch (error) {
            console.error('[ServiceRegistrar] UI-critical services pre-initialization failed:', error);
        }
    }

    /**
     * Get service helper method with timeout
     */
    async getService<T>(name: string, timeoutMs: number = 10000): Promise<T | null> {
        if (!this.context.serviceManager) {
            return null;
        }
        
        try {
            return await this.context.serviceManager.getService<T>(name);
        } catch (error) {
            console.warn(`[ServiceRegistrar] Failed to get service '${name}':`, error);
            return null;
        }
    }

    /**
     * Wait for a service to be ready with retry logic
     */
    async waitForService<T>(serviceName: string, timeoutMs: number = 30000): Promise<T | null> {
        const startTime = Date.now();
        const retryInterval = 1000; // Check every 1 second
        
        while (Date.now() - startTime < timeoutMs) {
            try {
                const service = await this.getService<T>(serviceName, 2000);
                if (service) {
                    return service;
                }
            } catch (error) {
                // Service not ready yet, continue waiting
            }
            
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, retryInterval));
        }
        
        console.warn(`[ServiceRegistrar] Service '${serviceName}' not ready after ${timeoutMs}ms`);
        return null;
    }
}
```

## core/settings/SettingsTabManager.ts

```typescript
/**
 * Location: /src/core/settings/SettingsTabManager.ts
 * 
 * Settings Tab Manager - Handles settings tab creation and management
 * 
 * This service extracts settings tab management from PluginLifecycleManager,
 * providing focused settings tab lifecycle management.
 */

import type { Plugin } from 'obsidian';
import type { Settings } from '../../settings';
import { SettingsTab } from '../../components/SettingsTab';
import type { MCPConnector } from '../../connector';
import type { BackgroundProcessor } from '../background/BackgroundProcessor';

export interface SettingsTabManagerConfig {
    plugin: Plugin;
    app: any;
    settings: Settings;
    serviceManager: any;
    connector: MCPConnector;
    lifecycleManager: any; // Reference to PluginLifecycleManager for ChatView activation
    backgroundProcessor?: BackgroundProcessor;
}

export class SettingsTabManager {
    private config: SettingsTabManagerConfig;
    private settingsTab?: SettingsTab;

    constructor(config: SettingsTabManagerConfig) {
        this.config = config;
    }

    /**
     * Initialize settings tab asynchronously
     */
    async initializeSettingsTab(): Promise<void> {
        try {
            // Get agent references - may not be available yet
            const vaultLibrarian = this.config.connector?.getVaultLibrarian();
            const memoryManager = this.config.connector?.getMemoryManager();
            
            // Get services from container
            const services: Record<string, any> = {};
            for (const serviceName of this.config.serviceManager.getReadyServices()) {
                services[serviceName] = this.config.serviceManager.getServiceIfReady(serviceName);
            }
            
            // Create settings tab with current state
            this.settingsTab = new SettingsTab(
                this.config.app,
                this.config.plugin,
                this.config.settings,
                services, // Pass current services (may be empty initially)
                vaultLibrarian || undefined,
                memoryManager || undefined,
                this.config.serviceManager as any, // Pass service manager for compatibility
                this.config.lifecycleManager // Pass lifecycle manager for ChatView activation
            );
            this.config.plugin.addSettingTab(this.settingsTab);
            
            // Pass settings tab to background processor for service updates
            if (this.config.backgroundProcessor) {
                this.config.backgroundProcessor.setSettingsTab(this.settingsTab);
            }
            
        } catch (error) {
            console.error('[SettingsTabManager] Settings tab initialization failed:', error);
            // Plugin should still function without settings tab
        }
    }

    /**
     * Set background processor reference (used for dependency injection)
     */
    setBackgroundProcessor(backgroundProcessor: BackgroundProcessor): void {
        this.config.backgroundProcessor = backgroundProcessor;
        
        // Pass settings tab if already created
        if (this.settingsTab && backgroundProcessor) {
            backgroundProcessor.setSettingsTab(this.settingsTab);
        }
    }

    /**
     * Get the settings tab instance
     */
    getSettingsTab(): SettingsTab | undefined {
        return this.settingsTab;
    }

    /**
     * Check if settings tab is initialized
     */
    isInitialized(): boolean {
        return !!this.settingsTab;
    }

    /**
     * Cleanup settings tab (called during shutdown)
     */
    cleanup(): void {
        if (this.settingsTab && typeof (this.settingsTab as any).cleanup === 'function') {
            (this.settingsTab as any).cleanup();
        }
    }
}
```

## core/ui/ChatUIManager.ts

```typescript
/**
 * Location: /src/core/ui/ChatUIManager.ts
 * 
 * Chat UI Manager - Handles ChatView registration, activation, and management
 * 
 * This service extracts ChatView-specific logic from PluginLifecycleManager,
 * providing a focused interface for chat UI operations.
 */

import { Notice } from 'obsidian';
import type { Plugin } from 'obsidian';
import type { Settings } from '../../settings';

export interface ChatUIManagerConfig {
    plugin: Plugin;
    app: any;
    settings: Settings;
    getService: <T>(name: string, timeoutMs?: number) => Promise<T | null>;
}

export class ChatUIManager {
    private config: ChatUIManagerConfig;
    private chatUIRegistered: boolean = false;

    constructor(config: ChatUIManagerConfig) {
        this.config = config;
    }

    /**
     * Register chat UI components
     */
    async registerChatUI(): Promise<void> {
        try {
            const { plugin, app } = this.config;
            
            // Check if ChatView is enabled in settings
            if (!this.isChatViewEnabled()) {
                console.log('[ChatUIManager] ChatView disabled in settings - skipping UI registration');
                return;
            }
            
            // Skip if already registered
            if (this.chatUIRegistered) {
                console.log('[ChatUIManager] ChatView UI already registered');
                return;
            }
            
            // Get ChatService
            const chatService = await this.config.getService<any>('chatService', 5000);
            if (!chatService) {
                console.warn('[ChatUIManager] ChatService not available for UI registration');
                return;
            }
            
            // Import ChatView
            const { ChatView, CHAT_VIEW_TYPE } = await import('../../ui/chat/ChatView');
            
            // Register ChatView with Obsidian
            plugin.registerView(
                CHAT_VIEW_TYPE,
                (leaf) => new ChatView(leaf, chatService)
            );
            
            // Add ribbon icon for chat
            plugin.addRibbonIcon('message-square', 'AI Chat', () => {
                this.activateChatView();
            });
            
            // Add command to open chat
            plugin.addCommand({
                id: 'open-chat',
                name: 'Open AI Chat',
                callback: () => {
                    this.activateChatView();
                }
            });
            
            // Mark as registered
            this.chatUIRegistered = true;
            console.log('[ChatUIManager] ChatView UI registered successfully');
            
        } catch (error) {
            console.error('[ChatUIManager] Failed to register chat UI:', error);
        }
    }

    /**
     * Activate chat view in sidebar
     */
    async activateChatView(): Promise<void> {
        const { app } = this.config;
        
        // Check if ChatView is enabled in settings
        if (!this.isChatViewEnabled()) {
            new Notice('AI Chat is disabled. Enable it in Plugin Settings > Agent Management > AI Chat tab.');
            return;
        }
        
        const { CHAT_VIEW_TYPE } = await import('../../ui/chat/ChatView');
        
        // Check if chat view already exists
        const existingLeaf = app.workspace.getLeavesOfType(CHAT_VIEW_TYPE)[0];
        if (existingLeaf) {
            app.workspace.revealLeaf(existingLeaf);
            return;
        }
        
        // Create new chat view in right sidebar
        const leaf = app.workspace.getRightLeaf(false);
        await leaf.setViewState({
            type: CHAT_VIEW_TYPE,
            active: true
        });
        
        app.workspace.revealLeaf(leaf);
    }
    
    /**
     * Check if ChatView is enabled in settings
     */
    isChatViewEnabled(): boolean {
        const chatViewSettings = this.config.settings.settings.chatView;
        return chatViewSettings?.enabled === true;
    }
    
    /**
     * Enable ChatView UI when user toggles it on in settings
     * This registers the UI components and auto-opens the ChatView
     */
    async enableChatViewUI(): Promise<void> {
        try {
            if (!this.isChatViewEnabled()) {
                console.warn('[ChatUIManager] ChatView not enabled in settings');
                return;
            }
            
            // Register ChatView UI components if not already registered
            await this.registerChatUI();
            
            // Auto-open ChatView in sidebar
            await this.activateChatView();
            
        } catch (error) {
            console.error('[ChatUIManager] Failed to enable ChatView UI:', error);
        }
    }

    /**
     * Check if chat UI is registered
     */
    isChatUIRegistered(): boolean {
        return this.chatUIRegistered;
    }

    /**
     * Reset registration state (useful for testing or reinitialization)
     */
    resetRegistrationState(): void {
        this.chatUIRegistered = false;
    }
}
```

## database/services/cache/CacheManager.ts

```typescript
import { Vault, App } from 'obsidian';
import { EntityCache } from './EntityCache';
import { VaultFileIndex } from './VaultFileIndex';
import { WorkspaceService } from '../../../agents/memoryManager/services/WorkspaceService';
import { MemoryService } from '../../../agents/memoryManager/services/MemoryService';
import { PrefetchManager } from './PrefetchManager';

export interface CacheManagerOptions {
    enableEntityCache?: boolean;
    enableFileIndex?: boolean;
    enablePrefetch?: boolean;
    entityCacheTTL?: number;
    maxCacheSize?: number;
}

export class CacheManager {
    private vault: Vault;
    private entityCache: EntityCache | null = null;
    private vaultFileIndex: VaultFileIndex | null = null;
    private prefetchManager: PrefetchManager | null = null;
    private isInitialized = false;

    constructor(
        private app: App,
        private workspaceService: WorkspaceService,
        private memoryService: MemoryService,
        private options: CacheManagerOptions = {}
    ) {
        this.vault = app.vault;
        // Default options
        this.options.enableEntityCache = options.enableEntityCache ?? true;
        this.options.enableFileIndex = options.enableFileIndex ?? true;
        this.options.enablePrefetch = options.enablePrefetch ?? true;
    }

    async initialize(): Promise<void> {
        if (this.isInitialized) {
            return;
        }

        console.log('Initializing CacheManager...');

        // Initialize EntityCache
        if (this.options.enableEntityCache) {
            this.entityCache = new EntityCache(
                this.vault,
                this.workspaceService,
                this.memoryService,
                {
                    ttl: this.options.entityCacheTTL,
                    maxSize: this.options.maxCacheSize
                }
            );
            console.log('EntityCache initialized');
        }

        // Initialize VaultFileIndex
        if (this.options.enableFileIndex) {
            this.vaultFileIndex = new VaultFileIndex(this.vault, this.app);
            await this.vaultFileIndex.initialize();
            console.log('VaultFileIndex initialized');

            // Set up file event listeners
            this.setupFileEventListeners();
        }

        // Initialize PrefetchManager
        if (this.options.enablePrefetch && this.entityCache) {
            this.prefetchManager = new PrefetchManager(
                this,
                this.workspaceService,
                this.memoryService
            );
            console.log('PrefetchManager initialized');
            
            // Set up prefetch listeners
            this.setupPrefetchListeners();
        }

        this.isInitialized = true;
        console.log('CacheManager initialization complete');
    }

    private setupFileEventListeners(): void {
        if (!this.vaultFileIndex) return;

        // Listen for file events from Obsidian
        this.vault.on('create', async (file) => {
            if ('extension' in file && (file.extension === 'md' || file.extension === 'canvas')) {
                await this.vaultFileIndex!.updateFile(file as any);
            }
        });

        this.vault.on('delete', (file) => {
            this.vaultFileIndex!.removeFile(file.path);
            // Also invalidate entity cache for files
            if (this.entityCache) {
                this.entityCache.invalidateFile(file.path);
            }
        });

        this.vault.on('rename', async (file, oldPath) => {
            if ('extension' in file && (file.extension === 'md' || file.extension === 'canvas')) {
                await this.vaultFileIndex!.renameFile(oldPath, file.path);
            }
        });

        this.vault.on('modify', async (file) => {
            if ('extension' in file && (file.extension === 'md' || file.extension === 'canvas')) {
                await this.vaultFileIndex!.updateFile(file as any);
            }
        });
    }

    private setupPrefetchListeners(): void {
        if (!this.entityCache || !this.prefetchManager) return;

        // Listen for entity cache events to trigger prefetching
        this.entityCache.on('workspace:preloaded', (workspaceId: string) => {
            this.prefetchManager!.onWorkspaceLoaded(workspaceId);
        });

        this.entityCache.on('session:preloaded', (sessionId: string) => {
            this.prefetchManager!.onSessionLoaded(sessionId);
        });

        this.entityCache.on('state:preloaded', (stateId: string) => {
            this.prefetchManager!.onStateLoaded(stateId);
        });
    }

    // Entity cache methods
    async preloadWorkspace(workspaceId: string): Promise<void> {
        if (!this.entityCache) {
            throw new Error('EntityCache not initialized');
        }
        await this.entityCache.preloadWorkspace(workspaceId);
    }

    async preloadSession(sessionId: string): Promise<void> {
        if (!this.entityCache) {
            throw new Error('EntityCache not initialized');
        }
        await this.entityCache.preloadSession(sessionId);
    }

    async preloadState(stateId: string): Promise<void> {
        if (!this.entityCache) {
            throw new Error('EntityCache not initialized');
        }
        await this.entityCache.preloadState(stateId);
    }

    getCachedWorkspace(workspaceId: string) {
        return this.entityCache?.getWorkspace(workspaceId);
    }

    getCachedSession(sessionId: string) {
        return this.entityCache?.getSession(sessionId);
    }

    getCachedState(stateId: string) {
        return this.entityCache?.getState(stateId);
    }

    // File index methods
    getFileMetadata(filePath: string) {
        return this.vaultFileIndex?.getFile(filePath);
    }

    getKeyFiles() {
        return this.vaultFileIndex?.getKeyFiles() || [];
    }

    getRecentFiles(limit?: number, folderPath?: string) {
        return this.vaultFileIndex?.getRecentFiles(limit, folderPath) || [];
    }

    getFilesInFolder(folderPath: string, recursive = false) {
        return this.vaultFileIndex?.getFilesInFolder(folderPath, recursive) || [];
    }

    searchFiles(predicate: (file: any) => boolean) {
        return this.vaultFileIndex?.searchFiles(predicate) || [];
    }

    async getFilesWithMetadata(filePaths: string[]) {
        return this.vaultFileIndex?.getFilesWithMetadata(filePaths) || [];
    }

    // Cache warming
    async warmCache(workspaceId?: string): Promise<void> {
        console.log('Warming cache...');

        // If a specific workspace is provided, preload it
        if (workspaceId) {
            await this.preloadWorkspace(workspaceId);
        }

        // Preload key files metadata
        if (this.vaultFileIndex) {
            const keyFiles = this.getKeyFiles();
            const keyFilePaths = keyFiles.map((f: any) => f.path);
            await this.vaultFileIndex.warmup(keyFilePaths);
        }

        console.log('Cache warming complete');
    }

    // Cache management
    invalidateWorkspace(workspaceId: string): void {
        this.entityCache?.invalidateWorkspace(workspaceId);
    }

    invalidateSession(sessionId: string): void {
        this.entityCache?.invalidateSession(sessionId);
    }

    invalidateState(stateId: string): void {
        this.entityCache?.invalidateState(stateId);
    }

    clearCache(): void {
        this.entityCache?.clear();
        this.vaultFileIndex?.clear();
    }

    // Stats
    getStats() {
        return {
            entityCache: this.entityCache ? {
                workspaces: this.entityCache['workspaceCache'].size,
                sessions: this.entityCache['sessionCache'].size,
                states: this.entityCache['stateCache'].size,
                files: this.entityCache['fileMetadataCache'].size
            } : null,
            fileIndex: this.vaultFileIndex?.getStats() || null,
            prefetch: this.prefetchManager?.getStats() || null
        };
    }

    // Check if caches are ready
    isReady(): boolean {
        const entityCacheReady = !this.options.enableEntityCache || !!this.entityCache;
        const fileIndexReady = !this.options.enableFileIndex || this.vaultFileIndex?.isReady() || false;
        return this.isInitialized && entityCacheReady && fileIndexReady;
    }

    // Cleanup resources
    cleanup(): void {
        console.log('Cleaning up CacheManager...');
        
        // Cleanup VaultFileIndex and its metadata cache events
        if (this.vaultFileIndex) {
            this.vaultFileIndex.cleanup();
            this.vaultFileIndex = null;
        }

        // Clear entity cache
        if (this.entityCache) {
            this.entityCache.clear();
            this.entityCache = null;
        }

        // Reset prefetch manager
        if (this.prefetchManager) {
            this.prefetchManager = null;
        }

        this.isInitialized = false;
        console.log('CacheManager cleanup complete');
    }
}
```

## database/services/cache/ContentCache.ts

```typescript
/**
 * Location: src/database/services/cache/ContentCache.ts
 * 
 * Summary: Consolidated content caching service that provides high-level content
 * caching operations including file content, metadata, searchs, and search results.
 * Consolidates caching functionality from multiple specialized cache services into
 * a unified interface with TTL, memory management, and cache invalidation.
 * 
 * Used by: All services requiring content caching capabilities
 * Dependencies: EntityCache, VaultFileIndex, PrefetchManager patterns
 */

import { EventEmitter } from 'events';
import { Plugin, TFile, Vault } from 'obsidian';
import { getErrorMessage } from '../../../utils/errorUtils';

export interface ContentCacheOptions {
  enableFileContentCache?: boolean;
  enableMetadataCache?: boolean;
  enablesearchDataCache?: boolean;
  enableSearchCache?: boolean;
  defaultTTL?: number;
  maxCacheSize?: number;
  maxMemoryMB?: number;
}

export interface CachedContent {
  data: any;
  timestamp: number;
  size: number;
  ttl: number;
  accessCount: number;
  lastAccess: number;
}

export interface FileContent extends CachedContent {
  filePath: string;
  content: string;
  metadata?: any;
  hash?: string;
}

export interface searchContent extends CachedContent {
  filePath: string;
  search: number[];
  model: string;
  chunkIndex?: number;
}

export interface SearchResult extends CachedContent {
  query: string;
  results: any[];
  type: string;
}

export interface CacheStats {
  totalEntries: number;
  totalSizeMB: number;
  hitRate: number;
  memoryUsageMB: number;
  cachesByType: Record<string, {
    count: number;
    sizeMB: number;
    oldestEntry: number;
    newestEntry: number;
  }>;
}

/**
 * Content Cache Service
 * 
 * Provides unified caching for:
 * - File content and metadata
 * - search data and results
 * - Search results and queries
 * - Computed values and transformations
 */
export class ContentCache extends EventEmitter {
  // Cache storage maps by type
  private fileContentCache = new Map<string, FileContent>();
  private metadataCache = new Map<string, CachedContent>();
  private searchDataCache = new Map<string, searchContent>();
  private searchResultsCache = new Map<string, SearchResult>();
  private computedCache = new Map<string, CachedContent>();

  // Cache statistics
  private hits = 0;
  private misses = 0;
  private currentMemoryMB = 0;

  // Configuration
  private readonly defaultTTL: number;
  private readonly maxCacheSize: number;
  private readonly maxMemoryMB: number;
  
  // Cleanup timer
  private cleanupInterval: NodeJS.Timeout | null = null;

  constructor(
    private plugin: Plugin,
    private options: ContentCacheOptions = {}
  ) {
    super();

    // Apply default configuration
    this.defaultTTL = options.defaultTTL || 30 * 60 * 1000; // 30 minutes
    this.maxCacheSize = options.maxCacheSize || 1000;
    this.maxMemoryMB = options.maxMemoryMB || 100; // 100MB default

    // Start periodic cleanup
    this.startCleanupTimer();
  }

  // =============================================================================
  // FILE CONTENT CACHING
  // =============================================================================

  /**
   * Cache file content with metadata
   */
  async cacheFileContent(
    filePath: string,
    content: string,
    metadata?: any,
    ttl?: number
  ): Promise<void> {
    if (!this.options.enableFileContentCache) {
      return;
    }

    const size = this.estimateSize(content);
    const cacheEntry: FileContent = {
      filePath,
      content,
      metadata,
      hash: this.generateHash(content),
      data: { content, metadata },
      timestamp: Date.now(),
      size,
      ttl: ttl || this.defaultTTL,
      accessCount: 1,
      lastAccess: Date.now()
    };

    this.fileContentCache.set(filePath, cacheEntry);
    this.currentMemoryMB += size / (1024 * 1024);

    this.emit('cached', { type: 'file', filePath, size });
    this.enforceMemoryLimits();
  }

  /**
   * Get cached file content
   */
  getCachedFileContent(filePath: string): FileContent | null {
    const cached = this.fileContentCache.get(filePath);
    
    if (!cached) {
      this.misses++;
      return null;
    }

    if (this.isExpired(cached)) {
      this.fileContentCache.delete(filePath);
      this.misses++;
      return null;
    }

    // Update access statistics
    cached.accessCount++;
    cached.lastAccess = Date.now();
    this.hits++;

    return cached;
  }

  /**
   * Cache file content from TFile
   */
  async cacheFile(file: TFile, ttl?: number): Promise<void> {
    try {
      const content = await this.plugin.app.vault.read(file);
      const metadata = this.plugin.app.metadataCache.getFileCache(file);
      
      await this.cacheFileContent(file.path, content, metadata, ttl);
    } catch (error) {
      console.error(`[ContentCache] Failed to cache file ${file.path}:`, error);
    }
  }

  // =============================================================================
  // search CACHING
  // =============================================================================

  /**
   * Cache search data
   */
  cachesearch(
    filePath: string,
    search: number[],
    model: string,
    chunkIndex?: number,
    ttl?: number
  ): void {
    if (!this.options.enablesearchDataCache) {
      return;
    }

    const cacheKey = this.getsearchDataCacheKey(filePath, model, chunkIndex);
    const size = this.estimateSize(search);

    const cacheEntry: searchContent = {
      filePath,
      search,
      model,
      chunkIndex,
      data: search,
      timestamp: Date.now(),
      size,
      ttl: ttl || this.defaultTTL,
      accessCount: 1,
      lastAccess: Date.now()
    };

    this.searchDataCache.set(cacheKey, cacheEntry);
    this.currentMemoryMB += size / (1024 * 1024);

    this.emit('cached', { type: 'search', filePath, model, size });
    this.enforceMemoryLimits();
  }

  /**
   * Get cached search
   */
  getCachedsearch(
    filePath: string,
    model: string,
    chunkIndex?: number
  ): searchContent | null {
    const cacheKey = this.getsearchDataCacheKey(filePath, model, chunkIndex);
    const cached = this.searchDataCache.get(cacheKey);

    if (!cached) {
      this.misses++;
      return null;
    }

    if (this.isExpired(cached)) {
      this.searchDataCache.delete(cacheKey);
      this.misses++;
      return null;
    }

    cached.accessCount++;
    cached.lastAccess = Date.now();
    this.hits++;

    return cached;
  }

  // =============================================================================
  // SEARCH RESULT CACHING
  // =============================================================================

  /**
   * Cache search results
   */
  cacheSearchResults(
    query: string,
    results: any[],
    searchType: string,
    ttl?: number
  ): void {
    if (!this.options.enableSearchCache) {
      return;
    }

    const cacheKey = this.getSearchCacheKey(query, searchType);
    const size = this.estimateSize(results);

    const cacheEntry: SearchResult = {
      query,
      results,
      type: searchType,
      data: results,
      timestamp: Date.now(),
      size,
      ttl: ttl || this.defaultTTL / 2, // Search results expire faster
      accessCount: 1,
      lastAccess: Date.now()
    };

    this.searchResultsCache.set(cacheKey, cacheEntry);
    this.currentMemoryMB += size / (1024 * 1024);

    this.emit('cached', { type: 'search', query, searchType, size });
    this.enforceMemoryLimits();
  }

  /**
   * Get cached search results
   */
  getCachedSearchResults(query: string, searchType: string): SearchResult | null {
    const cacheKey = this.getSearchCacheKey(query, searchType);
    const cached = this.searchResultsCache.get(cacheKey);

    if (!cached) {
      this.misses++;
      return null;
    }

    if (this.isExpired(cached)) {
      this.searchResultsCache.delete(cacheKey);
      this.misses++;
      return null;
    }

    cached.accessCount++;
    cached.lastAccess = Date.now();
    this.hits++;

    return cached;
  }

  // =============================================================================
  // GENERIC COMPUTED VALUE CACHING
  // =============================================================================

  /**
   * Cache computed value with custom key
   */
  cacheValue(key: string, value: any, ttl?: number): void {
    const size = this.estimateSize(value);

    const cacheEntry: CachedContent = {
      data: value,
      timestamp: Date.now(),
      size,
      ttl: ttl || this.defaultTTL,
      accessCount: 1,
      lastAccess: Date.now()
    };

    this.computedCache.set(key, cacheEntry);
    this.currentMemoryMB += size / (1024 * 1024);

    this.emit('cached', { type: 'computed', key, size });
    this.enforceMemoryLimits();
  }

  /**
   * Get cached computed value
   */
  getCachedValue(key: string): any | null {
    const cached = this.computedCache.get(key);

    if (!cached) {
      this.misses++;
      return null;
    }

    if (this.isExpired(cached)) {
      this.computedCache.delete(key);
      this.misses++;
      return null;
    }

    cached.accessCount++;
    cached.lastAccess = Date.now();
    this.hits++;

    return cached.data;
  }

  // =============================================================================
  // CACHE INVALIDATION AND MANAGEMENT
  // =============================================================================

  /**
   * Invalidate all caches for a specific file
   */
  invalidateFile(filePath: string): void {
    // Remove file content cache
    this.fileContentCache.delete(filePath);

    // Remove search caches for this file
    const searchKeys = Array.from(this.searchDataCache.keys())
      .filter(key => key.startsWith(`${filePath}:`));
    
    for (const key of searchKeys) {
      this.searchDataCache.delete(key);
    }

    // Remove metadata cache
    this.metadataCache.delete(filePath);

    this.emit('invalidated', { type: 'file', filePath });
  }

  /**
   * Clear all caches
   */
  clearAll(): void {
    this.fileContentCache.clear();
    this.metadataCache.clear();
    this.searchDataCache.clear();
    this.searchResultsCache.clear();
    this.computedCache.clear();
    
    this.currentMemoryMB = 0;
    this.hits = 0;
    this.misses = 0;

    this.emit('cleared');
  }

  /**
   * Clean up expired entries
   */
  cleanup(): void {
    const now = Date.now();
    let cleanedCount = 0;

    // Clean file content cache
    for (const [key, entry] of this.fileContentCache.entries()) {
      if (this.isExpired(entry, now)) {
        this.fileContentCache.delete(key);
        cleanedCount++;
      }
    }

    // Clean search data cache
    for (const [key, entry] of this.searchDataCache.entries()) {
      if (this.isExpired(entry, now)) {
        this.searchDataCache.delete(key);
        cleanedCount++;
      }
    }

    // Clean search results cache
    for (const [key, entry] of this.searchResultsCache.entries()) {
      if (this.isExpired(entry, now)) {
        this.searchResultsCache.delete(key);
        cleanedCount++;
      }
    }

    // Clean computed cache
    for (const [key, entry] of this.computedCache.entries()) {
      if (this.isExpired(entry, now)) {
        this.computedCache.delete(key);
        cleanedCount++;
      }
    }

    if (cleanedCount > 0) {
      this.emit('cleaned', { removedEntries: cleanedCount });
    }
  }

  /**
   * Get cache statistics
   */
  getStats(): CacheStats {
    const totalRequests = this.hits + this.misses;
    const hitRate = totalRequests > 0 ? this.hits / totalRequests : 0;

    return {
      totalEntries: this.getTotalEntries(),
      totalSizeMB: this.currentMemoryMB,
      hitRate,
      memoryUsageMB: this.currentMemoryMB,
      cachesByType: {
        fileContent: this.getCacheTypeStats(this.fileContentCache),
        searchData: this.getCacheTypeStats(this.searchDataCache),
        searchResults: this.getCacheTypeStats(this.searchResultsCache),
        computed: this.getCacheTypeStats(this.computedCache)
      }
    };
  }

  /**
   * Shutdown the cache service
   */
  shutdown(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
    
    this.clearAll();
    this.removeAllListeners();
  }

  // =============================================================================
  // PRIVATE HELPER METHODS
  // =============================================================================

  private startCleanupTimer(): void {
    // Clean up every 5 minutes
    this.cleanupInterval = setInterval(() => {
      this.cleanup();
    }, 5 * 60 * 1000);
  }

  private isExpired(entry: CachedContent, now?: number): boolean {
    const currentTime = now || Date.now();
    return (currentTime - entry.timestamp) > entry.ttl;
  }

  private enforceMemoryLimits(): void {
    if (this.currentMemoryMB <= this.maxMemoryMB) {
      return;
    }

    // Remove least recently used entries until under limit
    const allEntries: { key: string; entry: CachedContent; type: string }[] = [];

    // Collect all entries with their keys and types
    this.fileContentCache.forEach((entry, key) => 
      allEntries.push({ key, entry, type: 'file' }));
    this.searchDataCache.forEach((entry, key) =>
      allEntries.push({ key, entry, type: 'searchData' }));
    this.searchResultsCache.forEach((entry, key) =>
      allEntries.push({ key, entry, type: 'searchResults' }));
    this.computedCache.forEach((entry, key) => 
      allEntries.push({ key, entry, type: 'computed' }));

    // Sort by last access time (oldest first)
    allEntries.sort((a, b) => a.entry.lastAccess - b.entry.lastAccess);

    // Remove entries until under memory limit
    let removedCount = 0;
    for (const { key, entry, type } of allEntries) {
      if (this.currentMemoryMB <= this.maxMemoryMB * 0.8) {
        break; // Stop when under 80% of limit
      }

      this.removeEntry(key, type);
      this.currentMemoryMB -= entry.size / (1024 * 1024);
      removedCount++;
    }

    if (removedCount > 0) {
      this.emit('memoryLimitEnforced', { removedEntries: removedCount });
    }
  }

  private removeEntry(key: string, type: string): void {
    switch (type) {
      case 'file':
        this.fileContentCache.delete(key);
        break;
      case 'searchData':
        this.searchDataCache.delete(key);
        break;
      case 'searchResults':
        this.searchResultsCache.delete(key);
        break;
      case 'computed':
        this.computedCache.delete(key);
        break;
    }
  }

  private getTotalEntries(): number {
    return this.fileContentCache.size + this.searchDataCache.size +
           this.searchResultsCache.size + this.computedCache.size + this.metadataCache.size;
  }

  private getCacheTypeStats(cache: Map<string, any>): any {
    const entries = Array.from(cache.values());
    const count = entries.length;
    
    if (count === 0) {
      return { count: 0, sizeMB: 0, oldestEntry: 0, newestEntry: 0 };
    }

    const sizeMB = entries.reduce((sum, entry) => sum + (entry.size / (1024 * 1024)), 0);
    const timestamps = entries.map(entry => entry.timestamp);
    
    return {
      count,
      sizeMB,
      oldestEntry: Math.min(...timestamps),
      newestEntry: Math.max(...timestamps)
    };
  }

  private estimateSize(data: any): number {
    // Rough estimation of object size in bytes
    try {
      const jsonString = JSON.stringify(data);
      return jsonString.length * 2; // Assume 2 bytes per character for Unicode
    } catch {
      return 1024; // Default 1KB if cannot stringify
    }
  }

  private generateHash(content: string): string {
    // Simple hash function for content comparison
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString(36);
  }

  private getsearchDataCacheKey(
    filePath: string, 
    model: string, 
    chunkIndex?: number
  ): string {
    return `${filePath}:${model}${chunkIndex !== undefined ? `:${chunkIndex}` : ''}`;
  }

  private getSearchCacheKey(query: string, searchType: string): string {
    return `${searchType}:${this.generateHash(query)}`;
  }
}
```

## database/services/cache/EntityCache.ts

```typescript
import { EventEmitter } from 'events';
import { Vault, TFile } from 'obsidian';
import { WorkspaceService } from '../../../agents/memoryManager/services/WorkspaceService';
import { MemoryService } from '../../../agents/memoryManager/services/MemoryService';

interface CachedWorkspace {
    data: any;
    sessionIds: string[];
    stateIds: string[];
    associatedFiles: string[];
    timestamp: number;
}

interface CachedSession {
    data: any;
    traceIds: string[];
    associatedFiles: string[];
    timestamp: number;
}

interface CachedState {
    data: any;
    associatedFiles: string[];
    timestamp: number;
}

interface FileMetadata {
    path: string;
    name: string;
    modified: number;
    size: number;
    isKeyFile: boolean;
    frontmatter?: any;
    workspaceIds?: string[];
}

interface CacheOptions {
    ttl?: number; // Time to live in milliseconds
    maxSize?: number; // Maximum number of items per cache
}

export class EntityCache extends EventEmitter {
    private workspaceCache = new Map<string, CachedWorkspace>();
    private sessionCache = new Map<string, CachedSession>();
    private stateCache = new Map<string, CachedState>();
    private fileMetadataCache = new Map<string, FileMetadata>();
    
    private readonly defaultTTL = 30 * 60 * 1000; // 30 minutes
    private readonly maxCacheSize = 1000;
    
    constructor(
        private vault: Vault,
        private workspaceService: WorkspaceService,
        private memoryService: MemoryService,
        private options: CacheOptions = {}
    ) {
        super();
        this.options.ttl = options.ttl || this.defaultTTL;
        this.options.maxSize = options.maxSize || this.maxCacheSize;
    }

    // Workspace caching methods
    async preloadWorkspace(workspaceId: string): Promise<void> {
        try {
            // Check if already cached and valid
            const cached = this.workspaceCache.get(workspaceId);
            if (cached && this.isValid(cached.timestamp)) {
                return;
            }

            // Load workspace data
            const workspace = await this.workspaceService.getWorkspace(workspaceId);
            
            if (!workspace) {
                return;
            }

            // Collect related IDs
            const sessionIds: string[] = [];
            const stateIds: string[] = [];
            const associatedFiles = new Set<string>();

            // Get sessions for this workspace
            const sessions = await this.memoryService.getSessions(workspaceId);
            sessionIds.push(...sessions.map(s => s.id));

            // Get states for this workspace
            const snapshots = await this.memoryService.getSnapshots(workspaceId);
            stateIds.push(...snapshots.map(s => s.id));

            // Collect associated files
            if (workspace.rootFolder) {
                associatedFiles.add(workspace.rootFolder);
            }
            // Note: ProjectWorkspace doesn't have associatedFiles property

            // Cache the workspace
            this.workspaceCache.set(workspaceId, {
                data: workspace,
                sessionIds,
                stateIds,
                associatedFiles: Array.from(associatedFiles),
                timestamp: Date.now()
            });

            // Preload related entities in parallel
            await Promise.all([
                ...sessionIds.map(id => this.preloadSession(id)),
                ...stateIds.slice(0, 5).map(id => this.preloadState(id)) // Limit states
            ]);

            // Preload file metadata
            await this.preloadFiles(Array.from(associatedFiles));

            this.emit('workspace:preloaded', workspaceId);
        } catch (error) {
            console.error('Error preloading workspace:', error);
        }
    }

    async preloadSession(sessionId: string): Promise<void> {
        try {
            // Check if already cached and valid
            const cached = this.sessionCache.get(sessionId);
            if (cached && this.isValid(cached.timestamp)) {
                return;
            }

            // Load session data
            // First try to get the session directly
            const sessionData = await this.memoryService.getSession(sessionId);
            if (!sessionData) {
                return;
            }
            const session = sessionData;

            // Get memory traces for this session
            const traces = await this.memoryService.getMemoryTraces(sessionId);
            const traceIds = traces.map(t => t.id);
            
            // Collect associated files
            const associatedFiles = new Set<string>();
            // Note: WorkspaceSession doesn't have activeNote property
            traces.forEach(trace => {
                if (trace.metadata?.relatedFiles) {
                    trace.metadata.relatedFiles.forEach((f: string) => associatedFiles.add(f));
                }
            });

            // Cache the session
            this.sessionCache.set(sessionId, {
                data: session,
                traceIds,
                associatedFiles: Array.from(associatedFiles),
                timestamp: Date.now()
            });

            // Preload file metadata
            await this.preloadFiles(Array.from(associatedFiles));

            this.emit('session:preloaded', sessionId);
        } catch (error) {
            console.error('Error preloading session:', error);
        }
    }

    async preloadState(stateId: string): Promise<void> {
        try {
            // Check if already cached and valid
            const cached = this.stateCache.get(stateId);
            if (cached && this.isValid(cached.timestamp)) {
                return;
            }

            // Load state data  
            const snapshots = await this.memoryService.getSnapshots();
            const state = snapshots.find(s => s.id === stateId);
            
            if (!state) {
                return;
            }

            // Collect associated files from state context
            const associatedFiles = new Set<string>();
            // Note: WorkspaceStateSnapshot structure may vary

            // Cache the state
            this.stateCache.set(stateId, {
                data: state,
                associatedFiles: Array.from(associatedFiles),
                timestamp: Date.now()
            });

            // Preload file metadata
            await this.preloadFiles(Array.from(associatedFiles));

            this.emit('state:preloaded', stateId);
        } catch (error) {
            console.error('Error preloading state:', error);
        }
    }

    async preloadFiles(filePaths: string[]): Promise<void> {
        const files = filePaths
            .map(path => this.vault.getAbstractFileByPath(path))
            .filter(file => file instanceof TFile) as TFile[];

        await Promise.all(files.map(file => this.cacheFileMetadata(file)));
    }

    private async cacheFileMetadata(file: TFile): Promise<void> {
        const keyFilePatterns = [/readme\.md$/i, /index\.md$/i, /\.canvas$/];
        
        this.fileMetadataCache.set(file.path, {
            path: file.path,
            name: file.name,
            modified: file.stat.mtime,
            size: file.stat.size,
            isKeyFile: keyFilePatterns.some(p => p.test(file.path)),
            // Frontmatter will be loaded lazily when needed
        });
    }

    // Batch loading methods
    async batchLoadSessions(sessionIds: string[]): Promise<any[]> {
        const uncached: string[] = [];
        const results: any[] = [];

        // Check cache first
        for (const id of sessionIds) {
            const cached = this.sessionCache.get(id);
            if (cached && this.isValid(cached.timestamp)) {
                results.push(cached.data);
            } else {
                uncached.push(id);
            }
        }

        // Batch load uncached items
        if (uncached.length > 0) {
            // Load sessions individually
            const sessionPromises = uncached.map(id => this.memoryService.getSession(id));
            const sessionResults = await Promise.all(sessionPromises);
            const sessions = sessionResults.filter((s): s is any => s !== undefined);
            
            // Cache the loaded sessions
            for (const session of sessions) {
                if (session) {
                    this.sessionCache.set(session.id, {
                        data: session,
                        traceIds: [],
                        associatedFiles: [],
                        timestamp: Date.now()
                    });
                    results.push(session);
                }
            }
        }

        return results;
    }

    async batchLoadStates(stateIds: string[]): Promise<any[]> {
        const uncached: string[] = [];
        const results: any[] = [];

        // Check cache first
        for (const id of stateIds) {
            const cached = this.stateCache.get(id);
            if (cached && this.isValid(cached.timestamp)) {
                results.push(cached.data);
            } else {
                uncached.push(id);
            }
        }

        // Batch load uncached items
        if (uncached.length > 0) {
            // Load all snapshots and filter
            const allSnapshots = await this.memoryService.getSnapshots();
            const states = allSnapshots.filter(s => uncached.includes(s.id));
            
            // Cache the loaded states
            for (const state of states) {
                if (state) {
                    this.stateCache.set(state.id, {
                        data: state,
                        associatedFiles: [],
                        timestamp: Date.now()
                    });
                    results.push(state);
                }
            }
        }

        return results;
    }


    // Cache access methods
    getWorkspace(workspaceId: string): CachedWorkspace | undefined {
        const cached = this.workspaceCache.get(workspaceId);
        if (cached && this.isValid(cached.timestamp)) {
            return cached;
        }
        this.workspaceCache.delete(workspaceId);
        return undefined;
    }

    getSession(sessionId: string): CachedSession | undefined {
        const cached = this.sessionCache.get(sessionId);
        if (cached && this.isValid(cached.timestamp)) {
            return cached;
        }
        this.sessionCache.delete(sessionId);
        return undefined;
    }

    getState(stateId: string): CachedState | undefined {
        const cached = this.stateCache.get(stateId);
        if (cached && this.isValid(cached.timestamp)) {
            return cached;
        }
        this.stateCache.delete(stateId);
        return undefined;
    }

    getFileMetadata(filePath: string): FileMetadata | undefined {
        return this.fileMetadataCache.get(filePath);
    }

    // Cache management
    invalidateWorkspace(workspaceId: string): void {
        this.workspaceCache.delete(workspaceId);
        this.emit('workspace:invalidated', workspaceId);
    }

    invalidateSession(sessionId: string): void {
        this.sessionCache.delete(sessionId);
        this.emit('session:invalidated', sessionId);
    }

    invalidateState(stateId: string): void {
        this.stateCache.delete(stateId);
        this.emit('state:invalidated', stateId);
    }

    invalidateFile(filePath: string): void {
        this.fileMetadataCache.delete(filePath);
    }

    clear(): void {
        this.workspaceCache.clear();
        this.sessionCache.clear();
        this.stateCache.clear();
        this.fileMetadataCache.clear();
        this.emit('cache:cleared');
    }

    private isValid(timestamp: number): boolean {
        return Date.now() - timestamp < (this.options.ttl || this.defaultTTL);
    }

    // Enforce cache size limits
    private enforceLimit<T>(cache: Map<string, T>): void {
        if (cache.size > (this.options.maxSize || this.maxCacheSize)) {
            // Remove oldest entries
            const entries = Array.from(cache.entries());
            entries.sort((a, b) => {
                const timestampA = (a[1] as any).timestamp || 0;
                const timestampB = (b[1] as any).timestamp || 0;
                return timestampA - timestampB;
            });
            
            const toRemove = entries.slice(0, Math.floor(cache.size * 0.2)); // Remove 20%
            toRemove.forEach(([key]) => cache.delete(key));
        }
    }
}
```

## database/services/cache/PrefetchManager.ts

```typescript
import { EventEmitter } from 'events';
import { CacheManager } from './CacheManager';
import { WorkspaceService } from '../../../agents/memoryManager/services/WorkspaceService';
import { MemoryService } from '../../../agents/memoryManager/services/MemoryService';

export interface PrefetchOptions {
    maxConcurrentPrefetches?: number;
    prefetchDelay?: number;
    enableSmartPrefetch?: boolean;
}

export class PrefetchManager extends EventEmitter {
    private prefetchQueue: string[] = [];
    private isPrefetching = false;
    private prefetchHistory = new Map<string, number>(); // entityId -> last prefetch timestamp
    
    private readonly defaultMaxConcurrent = 3;
    private readonly defaultPrefetchDelay = 1000; // 1 second between prefetches
    private readonly prefetchCooldown = 5 * 60 * 1000; // 5 minutes cooldown

    constructor(
        private cacheManager: CacheManager,
        private workspaceService: WorkspaceService,
        private memoryService: MemoryService,
        private options: PrefetchOptions = {}
    ) {
        super();
        this.options.maxConcurrentPrefetches = options.maxConcurrentPrefetches || this.defaultMaxConcurrent;
        this.options.prefetchDelay = options.prefetchDelay || this.defaultPrefetchDelay;
        this.options.enableSmartPrefetch = options.enableSmartPrefetch ?? true;
    }

    /**
     * Called when a workspace is loaded - prefetch likely next items
     */
    async onWorkspaceLoaded(workspaceId: string): Promise<void> {
        if (!this.options.enableSmartPrefetch) return;

        try {
            // Get recent sessions for this workspace
            const sessions = await this.memoryService.getSessions(workspaceId);
            const recentSessions = sessions
                .sort((a, b) => (a.name || '').localeCompare(b.name || ''))
                .slice(0, 5);

            // Queue prefetch for recent sessions
            for (const session of recentSessions) {
                this.queuePrefetch('session', session.id);
            }

            // Start processing the queue
            this.processPrefetchQueue();
        } catch (error) {
            console.error('Error in onWorkspaceLoaded prefetch:', error);
        }
    }

    /**
     * Called when a session is loaded - prefetch associated data
     */
    async onSessionLoaded(sessionId: string): Promise<void> {
        if (!this.options.enableSmartPrefetch) return;

        try {
            // Get the session to find its workspace
            const session = await this.memoryService.getSession(sessionId);
            
            if (session && session.workspaceId) {
                // Prefetch the parent workspace if not already cached
                this.queuePrefetch('workspace', session.workspaceId);
            }

            // Get recent memory traces
            const traces = await this.memoryService.getMemoryTraces(sessionId);
            const relatedFiles = new Set<string>();

            for (const trace of traces) {
                if (trace.metadata?.relatedFiles) {
                    trace.metadata.relatedFiles.forEach(f => relatedFiles.add(f));
                }
            }

            // Prefetch file metadata
            if (relatedFiles.size > 0) {
                await this.cacheManager.getFilesWithMetadata(Array.from(relatedFiles));
            }

            // Start processing the queue
            this.processPrefetchQueue();
        } catch (error) {
            console.error('Error in onSessionLoaded prefetch:', error);
        }
    }

    /**
     * Called when a state is loaded - prefetch related states
     */
    async onStateLoaded(stateId: string): Promise<void> {
        if (!this.options.enableSmartPrefetch) return;

        try {
            // Get the state to find related states
            const snapshots = await this.memoryService.getSnapshots();
            const state = snapshots.find(s => s.id === stateId);
            
            if (state) {
                // Prefetch parent session
                if (state.sessionId) {
                    this.queuePrefetch('session', state.sessionId);
                }

                // Prefetch sibling states (same session)
                if (state.sessionId) {
                    const siblingStates = snapshots
                        .filter(s => s.sessionId === state.sessionId && s.id !== stateId)
                        .sort((a, b) => (b.timestamp ?? 0) - (a.timestamp ?? 0))
                        .slice(0, 3);

                    for (const sibling of siblingStates) {
                        this.queuePrefetch('state', sibling.id);
                    }
                }
            }

            // Start processing the queue
            this.processPrefetchQueue();
        } catch (error) {
            console.error('Error in onStateLoaded prefetch:', error);
        }
    }

    /**
     * Queue an entity for prefetching
     */
    private queuePrefetch(type: 'workspace' | 'session' | 'state', id: string): void {
        const key = `${type}:${id}`;
        
        // Check if recently prefetched
        const lastPrefetch = this.prefetchHistory.get(key);
        if (lastPrefetch && Date.now() - lastPrefetch < this.prefetchCooldown) {
            return; // Skip if recently prefetched
        }

        // Add to queue if not already there
        if (!this.prefetchQueue.includes(key)) {
            this.prefetchQueue.push(key);
            this.emit('prefetch:queued', { type, id });
        }
    }

    /**
     * Process the prefetch queue
     */
    private async processPrefetchQueue(): Promise<void> {
        if (this.isPrefetching || this.prefetchQueue.length === 0) {
            return;
        }

        this.isPrefetching = true;

        try {
            // Process up to maxConcurrent items
            const itemsToProcess = this.prefetchQueue.splice(0, this.options.maxConcurrentPrefetches || this.defaultMaxConcurrent);
            
            const prefetchPromises = itemsToProcess.map(async (item) => {
                const [type, id] = item.split(':');
                
                try {
                    switch (type) {
                        case 'workspace':
                            await this.cacheManager.preloadWorkspace(id);
                            break;
                        case 'session':
                            await this.cacheManager.preloadSession(id);
                            break;
                        case 'state':
                            await this.cacheManager.preloadState(id);
                            break;
                    }
                    
                    // Record successful prefetch
                    this.prefetchHistory.set(item, Date.now());
                    this.emit('prefetch:completed', { type, id });
                } catch (error) {
                    console.warn(`Failed to prefetch ${type} ${id}:`, error);
                    this.emit('prefetch:failed', { type, id, error });
                }
            });

            await Promise.all(prefetchPromises);

            // If there are more items, continue after a delay
            if (this.prefetchQueue.length > 0) {
                setTimeout(() => {
                    this.isPrefetching = false;
                    this.processPrefetchQueue();
                }, this.options.prefetchDelay || this.defaultPrefetchDelay);
            } else {
                this.isPrefetching = false;
            }
        } catch (error) {
            console.error('Error processing prefetch queue:', error);
            this.isPrefetching = false;
        }
    }

    /**
     * Clear the prefetch queue
     */
    clearQueue(): void {
        this.prefetchQueue = [];
        this.isPrefetching = false;
        this.emit('prefetch:queueCleared');
    }

    /**
     * Get prefetch statistics
     */
    getStats() {
        return {
            queueLength: this.prefetchQueue.length,
            isPrefetching: this.isPrefetching,
            historySize: this.prefetchHistory.size,
            recentPrefetches: Array.from(this.prefetchHistory.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([key, timestamp]) => ({
                    key,
                    timestamp,
                    age: Date.now() - timestamp
                }))
        };
    }
}
```

## database/services/cache/VaultFileIndex.ts

```typescript
import { EventEmitter } from 'events';
import { Vault, TFile, TFolder, FileStats, MetadataCache, App, EventRef } from 'obsidian';

export interface IndexedFile {
    path: string;
    name: string;
    basename: string;
    extension: string;
    parent: string;
    modified: number;
    created: number;
    size: number;
    isKeyFile: boolean;
    tags?: string[];
    aliases?: string[];
    frontmatter?: any;
    backlinks?: string[];
    forwardLinks?: string[];
}

export interface IndexStats {
    totalFiles: number;
    keyFiles: number;
    lastUpdated: number;
    indexingTime: number;
}

export class VaultFileIndex extends EventEmitter {
    private fileIndex = new Map<string, IndexedFile>();
    private keyFilePatterns = [
        /readme\.md$/i,
        /index\.md$/i,
        /\.canvas$/,
        /overview\.md$/i,
        /summary\.md$/i,
        /main\.md$/i
    ];
    
    private folderIndex = new Map<string, string[]>(); // folder path -> file paths
    private tagIndex = new Map<string, string[]>(); // tag -> file paths
    private stats: IndexStats = {
        totalFiles: 0,
        keyFiles: 0,
        lastUpdated: 0,
        indexingTime: 0
    };

    private isIndexing = false;
    private indexPromise: Promise<void> | null = null;
    private metadataEventRefs: EventRef[] = [];

    constructor(private vault: Vault, private app?: App) {
        super();
    }

    async initialize(): Promise<void> {
        if (this.isIndexing) {
            return this.indexPromise || Promise.resolve();
        }

        this.isIndexing = true;
        const startTime = Date.now();

        this.indexPromise = this.buildIndex().then(() => {
            this.stats.indexingTime = Date.now() - startTime;
            this.stats.lastUpdated = Date.now();
            this.isIndexing = false;
            this.indexPromise = null;
            this.setupMetadataCacheEvents();
            this.emit('index:ready', this.stats);
        }).catch(error => {
            console.error('Error building file index:', error);
            this.isIndexing = false;
            this.indexPromise = null;
            throw error;
        });

        return this.indexPromise;
    }

    private async buildIndex(): Promise<void> {
        this.clear();
        
        const files = this.vault.getFiles();
        const markdownFiles = files.filter(file => file.extension === 'md' || file.extension === 'canvas');
        
        // First pass: Create basic index entries
        for (const file of markdownFiles) {
            await this.indexFile(file, false);
        }


        // Second pass: Process metadata for key files (lazy load for others)
        const keyFiles = Array.from(this.fileIndex.values()).filter(f => f.isKeyFile);
        await Promise.all(keyFiles.map(f => this.loadFileMetadata(f.path)));

        this.updateStats();
        this.emit('index:built', this.stats);
    }

    private async indexFile(file: TFile, loadMetadata = false): Promise<void> {
        const isKeyFile = this.keyFilePatterns.some(pattern => pattern.test(file.path));
        
        const indexed: IndexedFile = {
            path: file.path,
            name: file.name,
            basename: file.basename,
            extension: file.extension,
            parent: file.parent?.path || '/',
            modified: file.stat.mtime,
            created: file.stat.ctime,
            size: file.stat.size,
            isKeyFile
        };

        this.fileIndex.set(file.path, indexed);

        // Update folder index
        const folderPath = file.parent?.path || '/';
        if (!this.folderIndex.has(folderPath)) {
            this.folderIndex.set(folderPath, []);
        }
        this.folderIndex.get(folderPath)!.push(file.path);

        // Load metadata if requested or if it's a key file
        if (loadMetadata || isKeyFile) {
            await this.loadFileMetadata(file.path);
        }
    }

    private async loadFileMetadata(filePath: string): Promise<void> {
        const file = this.vault.getAbstractFileByPath(filePath);
        if (!(file instanceof TFile)) return;

        const indexed = this.fileIndex.get(filePath);
        if (!indexed) return;

        try {
            // Load frontmatter - Note: getFileCache may not be available in all vault types
            const cache = (this.vault as any).metadataCache?.getFileCache(file);
            if (cache) {
                indexed.frontmatter = cache.frontmatter;
                indexed.tags = cache.tags?.map((t: any) => t.tag) || [];
                indexed.aliases = cache.frontmatter?.aliases || [];

                // Update tag index
                if (indexed.tags) {
                    indexed.tags.forEach(tag => {
                        if (!this.tagIndex.has(tag)) {
                            this.tagIndex.set(tag, []);
                        }
                        this.tagIndex.get(tag)!.push(filePath);
                    });
                }

                // Extract links
                indexed.forwardLinks = cache.links?.map((l: any) => l.link) || [];
            }
        } catch (error) {
            console.error(`Error loading metadata for ${filePath}:`, error);
        }
    }

    // File operations
    async updateFile(file: TFile): Promise<void> {
        await this.indexFile(file, true);
        this.updateStats();
        this.emit('file:updated', file.path);
    }

    removeFile(filePath: string): void {
        const indexed = this.fileIndex.get(filePath);
        if (!indexed) return;

        // Remove from main index
        this.fileIndex.delete(filePath);

        // Remove from folder index
        const folderFiles = this.folderIndex.get(indexed.parent);
        if (folderFiles) {
            const index = folderFiles.indexOf(filePath);
            if (index > -1) {
                folderFiles.splice(index, 1);
            }
        }

        // Remove from tag index
        indexed.tags?.forEach(tag => {
            const tagFiles = this.tagIndex.get(tag);
            if (tagFiles) {
                const index = tagFiles.indexOf(filePath);
                if (index > -1) {
                    tagFiles.splice(index, 1);
                }
            }
        });

        this.updateStats();
        this.emit('file:removed', filePath);
    }

    async renameFile(oldPath: string, newPath: string): Promise<void> {
        const indexed = this.fileIndex.get(oldPath);
        if (!indexed) return;

        // Remove old entry
        this.removeFile(oldPath);

        // Add new entry
        const file = this.vault.getAbstractFileByPath(newPath);
        if (file instanceof TFile) {
            await this.updateFile(file);
        }

        this.emit('file:renamed', { oldPath, newPath });
    }

    // Query methods
    getFile(filePath: string): IndexedFile | undefined {
        return this.fileIndex.get(filePath);
    }

    getFiles(): IndexedFile[] {
        return Array.from(this.fileIndex.values());
    }

    getKeyFiles(): IndexedFile[] {
        return Array.from(this.fileIndex.values()).filter(f => f.isKeyFile);
    }


    getFilesInFolder(folderPath: string, recursive = false): IndexedFile[] {
        if (!recursive) {
            const filePaths = this.folderIndex.get(folderPath) || [];
            return filePaths.map(path => this.fileIndex.get(path)).filter(Boolean) as IndexedFile[];
        }

        // Recursive search
        const results: IndexedFile[] = [];
        const processFolder = (path: string) => {
            const filePaths = this.folderIndex.get(path) || [];
            filePaths.forEach(filePath => {
                const file = this.fileIndex.get(filePath);
                if (file) results.push(file);
            });

            // Process subfolders
            this.folderIndex.forEach((_, folderPath) => {
                if (folderPath.startsWith(path + '/')) {
                    processFolder(folderPath);
                }
            });
        };

        processFolder(folderPath);
        return results;
    }

    getFilesWithTag(tag: string): IndexedFile[] {
        const filePaths = this.tagIndex.get(tag) || [];
        return filePaths.map(path => this.fileIndex.get(path)).filter(Boolean) as IndexedFile[];
    }

    getRecentFiles(limit = 10, folderPath?: string): IndexedFile[] {
        const files = folderPath 
            ? this.getFilesInFolder(folderPath, true)
            : this.getFiles();

        return files
            .sort((a, b) => b.modified - a.modified)
            .slice(0, limit);
    }

    searchFiles(predicate: (file: IndexedFile) => boolean): IndexedFile[] {
        return Array.from(this.fileIndex.values()).filter(predicate);
    }

    // Batch operations
    async getFilesWithMetadata(filePaths: string[]): Promise<IndexedFile[]> {
        const results: IndexedFile[] = [];
        
        for (const path of filePaths) {
            let indexed = this.fileIndex.get(path);
            if (indexed) {
                // Ensure metadata is loaded
                if (!indexed.frontmatter && !indexed.tags) {
                    await this.loadFileMetadata(path);
                    indexed = this.fileIndex.get(path);
                }
                if (indexed) {
                    results.push(indexed);
                }
            }
        }

        return results;
    }

    // Stats and maintenance
    getStats(): IndexStats {
        return { ...this.stats };
    }

    private updateStats(): void {
        this.stats.totalFiles = this.fileIndex.size;
        this.stats.keyFiles = Array.from(this.fileIndex.values()).filter(f => f.isKeyFile).length;
        this.stats.lastUpdated = Date.now();
    }

    clear(): void {
        this.fileIndex.clear();
        this.folderIndex.clear();
        this.tagIndex.clear();
        this.stats = {
            totalFiles: 0,
            keyFiles: 0,
            lastUpdated: 0,
            indexingTime: 0
        };
        this.emit('index:cleared');
    }

    // Performance helpers
    async warmup(filePaths: string[]): Promise<void> {
        // Preload metadata for specified files
        await Promise.all(
            filePaths.map(path => this.loadFileMetadata(path))
        );
    }

    isReady(): boolean {
        return !this.isIndexing && this.fileIndex.size > 0;
    }

    /**
     * Set up metadata cache event listeners for real-time updates
     */
    private setupMetadataCacheEvents(): void {
        if (!this.app?.metadataCache) {
            console.warn('MetadataCache not available - metadata events will not be tracked');
            return;
        }

        const metadataCache = this.app.metadataCache;

        // Listen for metadata changes (tags, frontmatter, links)
        const metadataChangedRef = metadataCache.on('changed', (file: TFile) => {
            this.handleMetadataChanged(file);
        });

        // Listen for resolved metadata (when a file's metadata is fully processed)
        const resolvedRef = metadataCache.on('resolved', () => {
            this.handleMetadataResolved();
        });

        // Store references for cleanup
        this.metadataEventRefs = [
            metadataChangedRef,
            resolvedRef
        ];

        console.log('[VaultFileIndex] Metadata cache events set up successfully');
    }

    /**
     * Handle metadata cache changes for a specific file
     */
    private async handleMetadataChanged(file: TFile): Promise<void> {
        const indexed = this.fileIndex.get(file.path);
        if (!indexed) {
            // File not in our index yet, add it
            await this.indexFile(file, true);
            return;
        }

        // Clear old tag index entries for this file
        if (indexed.tags) {
            indexed.tags.forEach(tag => {
                const tagFiles = this.tagIndex.get(tag);
                if (tagFiles) {
                    const index = tagFiles.indexOf(file.path);
                    if (index > -1) {
                        tagFiles.splice(index, 1);
                        if (tagFiles.length === 0) {
                            this.tagIndex.delete(tag);
                        }
                    }
                }
            });
        }

        // Reload metadata and update index
        await this.loadFileMetadata(file.path);
        this.updateStats();
        this.emit('metadata:updated', file.path, indexed);
    }

    /**
     * Handle when metadata cache resolution is complete
     */
    private handleMetadataResolved(): void {
        this.emit('metadata:resolved');
    }

    /**
     * Clean up metadata cache event listeners
     */
    cleanup(): void {
        // Remove all metadata event listeners
        if (this.app?.metadataCache) {
            this.metadataEventRefs.forEach(eventRef => {
                this.app!.metadataCache.offref(eventRef);
            });
        }
        this.metadataEventRefs = [];
        
        // Clear all data
        this.clear();
        
        console.log('[VaultFileIndex] Cleaned up metadata cache events');
    }
}
```

## database/services/cache/index.ts

```typescript
/**
 * Cache Services Exports
 */

export { CacheManager } from './CacheManager';
export { EntityCache } from './EntityCache';
export { ContentCache } from './ContentCache';
export { PrefetchManager } from './PrefetchManager';
export { VaultFileIndex } from './VaultFileIndex';
```

## database/types/cache/CacheTypes.ts

```typescript
/**
 * Cache Types
 * Extracted from workspace-types.ts for better organization
 */

/**
 * In-memory cache for workspace data
 */
export interface WorkspaceCache {
  /**
   * Hot cache (in-memory, limited size, instant access)
   */
  hotCache: Map<string, {
    search: number[];
    metadata: any;
    lastAccessed: number;
    accessCount: number;
  }>;
  
  /**
   * IndexedDB store prefix for this workspace
   */
  warmCachePrefix: string;
  
  /**
   * Usage statistics
   */
  cacheHits: number;
  cacheMisses: number;
  
  /**
   * Cache management settings
   */
  maxHotCacheSize: number;
  pruneThreshold: number;
}
```

## database/types/index.ts

```typescript
/**
 * Database Types Export Barrel
 * Provides centralized access to all database-related types
 * Organized by domain for better maintainability
 */

// Workspace types
export type {
  ItemStatus,
  ProjectWorkspace
} from './workspace/WorkspaceTypes';

export type {
  WorkspaceParameters,
  WorkspaceResult,
  ListWorkspacesParameters,
  ListWorkspacesResult,
  CreateWorkspaceParameters,
  CreateWorkspaceResult,
  EditWorkspaceParameters,
  DeleteWorkspaceParameters,
  LoadWorkspaceParameters,
  LoadWorkspaceResult,
  AddFilesToWorkspaceParameters,
  AddFilesToWorkspaceResult,
  QuickCreateWorkspaceParameters
} from './workspace/ParameterTypes';

// Session types
export type {
  WorkspaceSession,
  WorkspaceStateSnapshot
} from './session/SessionTypes';

// Memory types
export type {
  WorkspaceMemoryTrace
} from './memory/MemoryTypes';

// Cache types
export type {
  WorkspaceCache
} from './cache/CacheTypes';
```

## database/types/memory/MemoryTypes.ts

```typescript
/**
 * Memory Types
 * Extracted from workspace-types.ts for better organization
 * Uses simplified JSON-based storage
 */

/**
 * Memory trace for workspace activity
 * Records tool interactions for JSON-based storage and search
 */
export interface WorkspaceMemoryTrace {
  /**
   * Unique identifier
   */
  id: string;

  /**
   * Associated workspace ID
   */
  workspaceId: string;

  /**
   * When this interaction occurred
   */
  timestamp: number;

  /**
   * Type of memory trace interaction
   */
  type: string;

  /**
   * The actual interaction content
   */
  content: string;

  /**
   * Additional information about the interaction
   */
  metadata?: {
    tool?: string;
    params?: any;
    result?: any;
    relatedFiles?: string[];
  };

  /**
   * Associated session ID (if created during a session)
   */
  sessionId?: string;
}
```

## database/types/session/SessionTypes.ts

```typescript
/**
 * Session Types
 * Simple session and state types focused on LLM restoration
 */

import { WorkspaceContext } from '../workspace/WorkspaceTypes';

/**
 * Session tracking for workspace activities
 * Simplified to only essential fields for clean auto-session creation
 */
export interface WorkspaceSession {
  /**
   * Unique session identifier
   */
  id: string;
  
  /**
   * Associated workspace ID
   */
  workspaceId: string;
  
  /**
   * Optional session name
   */
  name?: string;
  
  /**
   * Optional session description
   */
  description?: string;
}

/**
 * State snapshot data - everything needed to resume work
 */
export interface StateSnapshot {
  /**
   * Workspace context at save time
   */
  workspaceContext: WorkspaceContext;
  
  /**
   * What was happening when you decided to save this state?
   */
  conversationContext: string;
  
  /**
   * What task were you actively working on?
   */
  activeTask: string;
  
  /**
   * Which files were you working with?
   */
  activeFiles: string[];
  
  /**
   * What are the immediate next steps when you resume?
   */
  nextSteps: string[];
  
  /**
   * Why are you saving this state right now?
   */
  reasoning: string;
}

/**
 * Simple state interface - our agreed-upon clean schema
 */
export interface State {
  id: string;
  name: string;
  workspaceId: string;
  created: number;
  snapshot: StateSnapshot;
}

/**
 * Legacy WorkspaceStateSnapshot interface for backward compatibility
 * Extends the simple State with optional legacy fields
 */
export interface WorkspaceStateSnapshot extends State {
  // Legacy fields for backward compatibility
  sessionId?: string;
  timestamp?: number;
  description?: string;
  state?: {
    workspace: any;
    recentTraces: string[];
    contextFiles: string[];
    metadata: Record<string, any>;
  };
}
```

## database/types/workspace/ParameterTypes.ts

```typescript
/**
 * Workspace Parameter Types
 * Parameter types that prompt LLMs to provide the correct structured workspace data
 */

import { CommonParameters, CommonResult } from '../../../types/mcp';
import { ProjectWorkspace, WorkspaceContext } from './WorkspaceTypes';
import { StateSnapshot } from '../session/SessionTypes';

/**
 * Create workspace parameters - LLM must provide complete WorkspaceContext structure
 */
export interface CreateWorkspaceParameters extends CommonParameters {
  /**
   * Workspace name (required)
   */
  name: string;
  
  /**
   * Root folder path (required)
   */
  rootFolder: string;
  
  /**
   * What is this workspace for? (required)
   * Example: "Apply for marketing manager positions"
   */
  purpose: string;
  
  /**
   * What are you trying to accomplish right now? (required)
   * Example: "Submit 10 applications this week"
   */
  currentGoal: string;
  
  /**
   * Workflows for different situations (required)
   * Provide an array of workflows with name, when to use, and steps
   * Example: [{"name": "New Application", "when": "When applying to new position", "steps": ["Research company", "Customize cover letter", "Apply", "Track"]}]
   */
  workflows: Array<{
    name: string;
    when: string;
    steps: string[];
  }>;

  /**
   * Simple key files list for quick reference (optional)
   * Provide array of file paths for key files in this workspace
   * Example: ["path/to/resume.md", "path/to/portfolio.md"]
   */
  keyFiles?: string[];

  /**
   * User preferences as actionable guidelines (optional)
   * Provide specific preferences about how to work
   * Example: "Use professional tone. Focus on tech companies. Keep cover letters under 300 words."
   */
  preferences?: string;

  /**
   * ID of dedicated agent for this workspace (optional)
   * This agent's systemPrompt will be included when loading the workspace
   * Example: "agent_12345"
   */
  dedicatedAgentId?: string;
  
  
  // Optional legacy fields for backward compatibility
  description?: string;
  relatedFolders?: string[];
  relatedFiles?: string[];
  keyFileInstructions?: string;
}

/**
 * Create workspace result
 */
export interface CreateWorkspaceResult extends CommonResult {
  data: {
    workspaceId: string;
    workspace: ProjectWorkspace;
  };
}

/**
 * Load workspace result - returns actionable briefing instead of raw data
 */
export interface LoadWorkspaceResult extends CommonResult {
  data: {
    context: {
      name: string;
      description?: string;
      purpose?: string;
      rootFolder: string;
      recentActivity: string[];
    };
    workflow: string;
    keyFiles: Record<string, string>;
    preferences: string;
    sessions: Array<{
      id: string;
      name: string;
      description?: string;
      created: number;
    }>;
    states: Array<{
      id: string;
      name: string;
      description?: string;
      sessionId: string;
      created: number;
      tags?: string[];
    }>;
  };
}

/**
 * Create state parameters - LLM must provide complete StateSnapshot structure
 */
export interface CreateStateParameters extends CommonParameters {
  /**
   * State name (required)
   */
  name: string;
  
  /**
   * What was happening when you decided to save this state? (required)
   * Provide a summary of the conversation and what you were working on
   * Example: "We were customizing the cover letter for Google's Marketing Manager position. We researched their team and identified key requirements."
   */
  conversationContext: string;
  
  /**
   * What task were you actively working on? (required)
   * Be specific about the current task
   * Example: "Finishing the cover letter paragraph about data-driven campaign optimization results"
   */
  activeTask: string;
  
  /**
   * Which files were you working with? (required)
   * List the files that were being edited or referenced
   * Example: ["cover-letter-google.md", "application-tracker.md"]
   */
  activeFiles: string[];
  
  /**
   * What are the immediate next steps when you resume? (required)
   * Provide specific actionable next steps
   * Example: ["Complete cover letter customization", "Review resume for Google-specific keywords", "Submit application"]
   */
  nextSteps: string[];
  
  /**
   * Why are you saving this state right now? (required)
   * Explain the reason for saving at this point
   * Example: "Saving before context limit, about to submit application"
   */
  reasoning: string;
  
  // Optional legacy fields
  description?: string;
  workspaceContext?: any;
  targetSessionId?: string;
  includeSummary?: boolean;
  includeFileContents?: boolean;
  maxFiles?: number;
  maxTraces?: number;
  tags?: string[];
  reason?: string;
}

/**
 * Load state result - returns actionable restoration context
 */
export interface LoadStateResult extends CommonResult {
  data: {
    resumingFrom: string;
    workspaceContext: string;
    whereYouLeftOff: string;
    currentTask: string;
    activeFiles: string[];
    nextSteps: string[];
    workflow: string;
  };
}

// Legacy parameter types for backward compatibility
export interface LoadWorkspaceParameters extends CommonParameters {
  id: string;
}

export interface LoadStateParams extends CommonParameters {
  stateId: string;
  sessionName?: string;
  sessionDescription?: string;
  restorationGoal?: string;
  createContinuationSession?: boolean;
  tags?: string[];
}

export interface ListWorkspacesParameters extends CommonParameters {
  sortBy?: 'name' | 'created' | 'lastAccessed';
  order?: 'asc' | 'desc';
}

export interface EditWorkspaceParameters extends CommonParameters {
  id: string;
  name?: string;
  description?: string;
  rootFolder?: string;
  relatedFolders?: string[];
  relatedFiles?: string[];
  preferences?: Record<string, any>;
  keyFileInstructions?: string;
}

export interface DeleteWorkspaceParameters extends CommonParameters {
  id: string;
  deleteChildren?: boolean;
  preserveSettings?: boolean;
}

export interface AddFilesToWorkspaceParameters extends CommonParameters {
  workspaceId: string;
  files?: string[];
  folders?: string[];
  addAsRelated?: boolean;
  markAsKeyFiles?: boolean;
}

// Legacy result types
export interface StateResult extends CommonResult {
  data?: {
    stateId: string;
    name: string;
    workspaceId: string;
    sessionId: string;
    timestamp: number;
    capturedContext?: any;
  };
}

export interface ListWorkspacesResult extends CommonResult {
  data: {
    workspaces: Array<{
      id: string;
      name: string;
      description?: string;
      rootFolder: string;
      lastAccessed: number;
      childCount: number;
    }>;
  };
}

export interface AddFilesToWorkspaceResult extends CommonResult {
  data: {
    filesAdded: number;
    foldersAdded: number;
    addedFiles: string[];
    failedFiles: Array<{
      path: string;
      reason: string;
    }>;
    workspace: {
      id: string;
      name: string;
      totalFiles: number;
      totalRelatedFiles: number;
    };
  };
}

// Legacy exports for backward compatibility
export interface WorkspaceParameters extends LoadWorkspaceParameters {}
export interface WorkspaceResult extends LoadWorkspaceResult {}
export interface QuickCreateWorkspaceParameters extends CreateWorkspaceParameters {}
```

## database/types/workspace/WorkspaceTypes.ts

```typescript
/**
 * Core Workspace Types
 * Simple, clean workspace types focused on LLM usability
 */


/**
 * Status types for individual items within a workspace
 */
export type ItemStatus = 'not_started' | 'in_progress' | 'completed';

/**
 * Simple workspace context for LLM understanding
 */
export interface WorkspaceContext {
  /**
   * What is this workspace for?
   * Example: "Apply for marketing manager positions"
   */
  purpose: string;

  /**
   * What are you trying to accomplish right now?
   * Example: "Submit 10 applications this week"
   */
  currentGoal: string;

  /**
   * Workflows for different situations
   */
  workflows: Array<{
    name: string;           // "New Application", "Follow-up", "Interview Prep"
    when: string;           // "When applying to new position"
    steps: string[];        // ["Research company", "Customize cover letter", "Apply", "Track"]
  }>;

  /**
   * Simple key files list for quick reference
   */
  keyFiles: string[];       // ["path/to/resume.md", "path/to/portfolio.md"]

  /**
   * User preferences as actionable guidelines
   */
  preferences: string;      // "Use professional tone. Focus on tech companies."

  /**
   * Single dedicated agent for this workspace
   */
  dedicatedAgent?: {
    agentId: string;        // Unique identifier for the agent
    agentName: string;      // Display name of the agent
  };

}

/**
 * Simple workspace interface - our agreed-upon clean schema
 */
export interface Workspace {
  id: string;
  name: string;
  context?: WorkspaceContext;  // Optional for backward compatibility
  rootFolder: string;
  created: number;
  lastAccessed: number;
}

/**
 * Legacy ProjectWorkspace interface for backward compatibility
 * Extends the simple Workspace with optional legacy fields
 */
export interface ProjectWorkspace extends Workspace {
  // Core functionality
  isActive?: boolean;

  // Legacy fields for backward compatibility
  description?: string;
  relatedFolders?: string[];
  relatedFiles?: string[];
  associatedNotes?: string[];
  keyFileInstructions?: string;
  activityHistory?: Array<{
    timestamp: number;
    action: 'view' | 'edit' | 'create' | 'tool';
    toolName?: string;
    duration?: number;
    context?: string;
  }>;
  preferences?: Record<string, any>;
  projectPlan?: string;
  checkpoints?: Array<{
    id: string;
    date: number;
    description: string;
    completed: boolean;
  }>;
  completionStatus?: Record<string, {
    status: ItemStatus;
    completedDate?: number;
    completionNotes?: string;
  }>;
}
```

## database/utils/ContentCache.ts

```typescript
/**
 * Cache entry for file content
 */
interface CacheEntry {
  content: string;
  timestamp: number;
  size: number;
}

/**
 * LRU (Least Recently Used) cache for file contents
 * Used to temporarily store file contents before modifications
 */
export class ContentCache {
  private cache: Map<string, CacheEntry> = new Map();
  private maxSize: number;
  private currentSize = 0;
  private ttl: number;
  
  /**
   * Create a new content cache
   * @param maxSize Maximum cache size in bytes (default: 10MB)
   * @param ttl Time to live in milliseconds (default: 5 minutes)
   */
  constructor(maxSize: number = 10 * 1024 * 1024, ttl: number = 5 * 60 * 1000) {
    this.maxSize = maxSize;
    this.ttl = ttl;
    
    // Periodically clean up expired entries
    setInterval(() => this.cleanupExpired(), 60 * 1000); // Every minute
  }
  
  /**
   * Get content from cache
   * @param filePath File path
   * @returns Content if found and not expired, undefined otherwise
   */
  get(filePath: string): string | undefined {
    const entry = this.cache.get(filePath);
    if (!entry) return undefined;
    
    // Check if expired
    if (Date.now() - entry.timestamp > this.ttl) {
      this.delete(filePath);
      return undefined;
    }
    
    // Move to end (most recently used)
    this.cache.delete(filePath);
    this.cache.set(filePath, entry);
    
    return entry.content;
  }
  
  /**
   * Store content in cache
   * @param filePath File path
   * @param content File content
   */
  set(filePath: string, content: string): void {
    // Remove existing entry if present
    if (this.cache.has(filePath)) {
      this.delete(filePath);
    }
    
    const size = content.length * 2; // Approximate size in bytes (UTF-16)
    
    // Make room if needed
    while (this.currentSize + size > this.maxSize && this.cache.size > 0) {
      // Remove least recently used (first item)
      const firstKey = this.cache.keys().next().value;
      if (firstKey) {
        this.delete(firstKey);
      }
    }
    
    // Add new entry
    this.cache.set(filePath, {
      content,
      timestamp: Date.now(),
      size
    });
    
    this.currentSize += size;
  }
  
  /**
   * Delete an entry from cache
   * @param filePath File path
   */
  delete(filePath: string): boolean {
    const entry = this.cache.get(filePath);
    if (!entry) return false;
    
    this.cache.delete(filePath);
    this.currentSize -= entry.size;
    return true;
  }
  
  /**
   * Clear all entries from cache
   */
  clear(): void {
    this.cache.clear();
    this.currentSize = 0;
  }
  
  /**
   * Clean up expired entries
   */
  private cleanupExpired(): void {
    const now = Date.now();
    const expiredKeys: string[] = [];
    
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttl) {
        expiredKeys.push(key);
      }
    }
    
    for (const key of expiredKeys) {
      this.delete(key);
    }
  }
  
  /**
   * Get cache statistics
   */
  getStats(): {
    size: number;
    maxSize: number;
    entries: number;
    utilization: number;
  } {
    return {
      size: this.currentSize,
      maxSize: this.maxSize,
      entries: this.cache.size,
      utilization: this.currentSize / this.maxSize
    };
  }
}
```

## database/utils/FileUtils.ts

```typescript
/**
 * FileUtils - Utility functions for file operations and validation
 * 
 * This utility module provides common file validation and checking patterns
 * used across the hash comparison and search services. Consolidates
 * repeated file existence checking logic into reusable methods.
 */

import { TAbstractFile, TFile } from 'obsidian';

export class FileUtils {
  /**
   * Check if an abstract file is a valid readable file (not a folder)
   * @param file Abstract file to check
   * @returns True if file is valid and readable
   */
  static isValidFile(file: TAbstractFile | null): file is TFile {
    return file !== null && !('children' in file);
  }

  /**
   * Check if a file path points to a valid readable file
   * @param app Obsidian app instance
   * @param filePath Path to check
   * @returns True if path points to a valid file
   */
  static isValidFilePath(app: any, filePath: string): boolean {
    const file = app.vault.getAbstractFileByPath(filePath);
    return this.isValidFile(file);
  }

  /**
   * Normalize file path to use forward slashes consistently
   * @param filePath Path to normalize
   * @returns Normalized path with forward slashes
   */
  static normalizePath(filePath: string): string {
    return filePath.replace(/\\/g, '/');
  }
}
```

## database/utils/graph/GraphOperations.ts

```typescript
import { DEFAULT_GRAPH_BOOST_FACTOR, DEFAULT_GRAPH_MAX_DISTANCE } from './constants';
import { LinkUtils } from './LinkUtils';

// Types needed for graph operations
interface searchRecord {
    id: string;
    filePath: string;
    content: string;
    metadata: {
        links?: {
            outgoing: Array<{
                displayText: string;
                targetPath: string;
            }>;
            incoming: Array<{
                sourcePath: string;
                displayText: string;
            }>;
        };
        [key: string]: any;
    };
}

interface GraphOptions {
    useGraphBoost: boolean;
    boostFactor?: number;
    includeNeighbors?: boolean;
    maxDistance?: number;
    seedNotes?: string[];
}

/**
 * Handles graph-based operations for relevance boosting
 */
export class GraphOperations {
    private linkUtils: LinkUtils;
    
    constructor() {
        this.linkUtils = new LinkUtils();
    }
    
    /**
     * Apply graph-based boost to search results
     * Increases scores for records that are connected to high-scoring records
     * 
     * @param records Records with similarity scores
     * @param graphOptions Graph boosting options
     */
    applyGraphBoost(
        records: Array<{ record: searchRecord; similarity: number }>,
        graphOptions: GraphOptions
    ): Array<{ record: searchRecord; similarity: number }> {
        const boostFactor = graphOptions.boostFactor || DEFAULT_GRAPH_BOOST_FACTOR;
        const maxDistance = graphOptions.maxDistance || DEFAULT_GRAPH_MAX_DISTANCE;
        const seedNotes = graphOptions.seedNotes || [];
        
        // If no records, return as-is
        if (!records.length) {
            return records;
        }
        
        // If not using graph boost, return as-is
        if (!graphOptions.useGraphBoost) {
            return records;
        }
        
        // Create a graph of connections
        const graph = this.buildConnectionGraph(records);
        
        // Apply boost to seed notes if specified
        let resultsearchs = records;
        if (seedNotes.length > 0) {
            resultsearchs = this.applySeedBoost(resultsearchs, seedNotes);
        }
        
        // Apply multi-level graph boosting
        // Start with initial scores
        const currentScores = new Map<string, number>();
        resultsearchs.forEach(item => {
            currentScores.set(item.record.filePath, item.similarity);
        });
        
        // Apply boost for each level of depth up to maxDistance
        for (let distance = 1; distance <= maxDistance; distance++) {
            const nextScores = new Map<string, number>();
            
            // Start with current scores - convert to array for compatibility
            Array.from(currentScores.entries()).forEach(([filePath, score]) => {
                nextScores.set(filePath, score);
            });
            
            // Apply boost for this distance level - convert to array for compatibility
            Array.from(currentScores.entries()).forEach(([filePath, score]) => {
                const connections = graph.get(filePath) || new Set<string>();
                const levelBoostFactor = boostFactor / distance; // Reduce boost for higher distances
                
                connections.forEach(connectedPath => {
                    // Only boost if the connected path is in our results
                    if (currentScores.has(connectedPath)) {
                        const currentScore = nextScores.get(connectedPath) || 0;
                        // Add a boost proportional to this file's score
                        const boost = score * levelBoostFactor;
                        nextScores.set(connectedPath, currentScore + boost);
                    }
                });
            });
            
            // Update current scores for next iteration
            currentScores.clear();
            // We need to manually copy the values to avoid TypeScript errors
            const entries = Array.from(nextScores.entries());
            for (let i = 0; i < entries.length; i++) {
                const [key, value] = entries[i];
                currentScores.set(key, value);
            }
        }
        
        // Apply final boosted scores
        return resultsearchs.map(item => {
            const filePath = item.record.filePath;
            const boostedScore = currentScores.get(filePath) || item.similarity;
            return {
                record: item.record,
                similarity: boostedScore
            };
        });
    }
    
    /**
     * Apply seed note boosting to search results
     * @param records Records with similarity scores
     * @param seedNotes Array of seed note paths
     */
    applySeedBoost(
        records: Array<{ record: searchRecord; similarity: number }>,
        seedNotes: string[]
    ): Array<{ record: searchRecord; similarity: number }> {
        // If no seed notes, return as-is
        if (!seedNotes.length) {
            return records;
        }
        
        // Create a set of seed note paths for quick lookup
        const seedNoteSet = new Set(seedNotes);
        
        // Create a map of file paths to base name (without extension) for fuzzy matching
        const fileBaseNames = new Map<string, string>();
        records.forEach(item => {
            const baseName = item.record.filePath.split('/').pop()?.replace(/\.[^/.]+$/, '') || '';
            fileBaseNames.set(item.record.filePath, baseName.toLowerCase());
        });
        
        // Create a set of normalized seed note names for fuzzy matching
        const normalizedSeedNames = new Set<string>();
        seedNotes.forEach(path => {
            const baseName = path.split('/').pop()?.replace(/\.[^/.]+$/, '') || '';
            normalizedSeedNames.add(baseName.toLowerCase());
        });
        
        // Apply boost to seed notes and their connections
        return records.map(item => {
            let boostFactor = 1.0; // No boost by default
            
            // Direct exact match with seed note
            if (seedNoteSet.has(item.record.filePath)) {
                boostFactor = 1.5; // 50% boost for direct seed note match
            } 
            // Fuzzy match with seed note name
            else if (normalizedSeedNames.has(fileBaseNames.get(item.record.filePath) || '')) {
                boostFactor = 1.3; // 30% boost for fuzzy seed note match
            }
            
            return {
                record: item.record,
                similarity: item.similarity * boostFactor
            };
        });
    }
    
    /**
     * Build a graph of connections between documents
     * @param records Records with similarity scores
     * @returns Map of file paths to sets of connected file paths
     */
    private buildConnectionGraph(
        records: Array<{ record: searchRecord; similarity: number }>
    ): Map<string, Set<string>> {
        // Create a graph of connections
        const graph = new Map<string, Set<string>>();
        
        // Create a map of normalized link text to file paths
        // This helps with resolving unresolved links
        const normalizedLinkMap = new Map<string, string[]>();
        const fullPathMap = new Map<string, string>(); // Map from filename to full path
        
        // First pass: build normalized link map
        records.forEach(item => {
            const filePath = item.record.filePath;
            const fileName = filePath.split('/').pop() || '';
            const baseName = fileName.replace(/\.[^/.]+$/, '');
            
            // Store multiple ways to reference this file
            this.linkUtils.addToLinkMap(normalizedLinkMap, baseName, filePath);
            this.linkUtils.addToLinkMap(normalizedLinkMap, fileName, filePath);
            
            // Also store the path components
            const pathParts = filePath.split('/');
            pathParts.forEach(part => {
                if (part && part !== baseName && part !== fileName) {
                    this.linkUtils.addToLinkMap(normalizedLinkMap, part, filePath);
                }
            });
            
            // Add to full path map
            fullPathMap.set(fileName, filePath);
            fullPathMap.set(baseName, filePath);
            
            // Initialize graph
            if (!graph.has(filePath)) {
                graph.set(filePath, new Set<string>());
            }
        });
        
        // Second pass: process links from metadata
        records.forEach(item => {
            const filePath = item.record.filePath;
            const links = item.record.metadata.links;
            
            if (!links) {
                return;
            }
            
            // Process outgoing links
            if (links.outgoing && links.outgoing.length > 0) {
                links.outgoing.forEach(link => {
                    const targetPath = link.targetPath;
                    
                    // Ensure source node exists in graph
                    if (!graph.has(filePath)) {
                        graph.set(filePath, new Set<string>());
                    }
                    
                    // Add direct link
                    const connections = graph.get(filePath);
                    connections?.add(targetPath);
                    
                    // Ensure target node exists in graph (bidirectional connection)
                    if (!graph.has(targetPath)) {
                        graph.set(targetPath, new Set<string>());
                    }
                    
                    // Add reverse link
                    const targetConnections = graph.get(targetPath);
                    targetConnections?.add(filePath);
                });
            }
            
            // Process incoming links
            if (links.incoming && links.incoming.length > 0) {
                links.incoming.forEach(link => {
                    const sourcePath = link.sourcePath;
                    
                    // Ensure target node exists in graph
                    if (!graph.has(filePath)) {
                        graph.set(filePath, new Set<string>());
                    }
                    
                    // Add reverse link
                    const connections = graph.get(filePath);
                    connections?.add(sourcePath);
                    
                    // Ensure source node exists in graph (bidirectional connection)
                    if (!graph.has(sourcePath)) {
                        graph.set(sourcePath, new Set<string>());
                    }
                    
                    // Add direct link
                    const sourceConnections = graph.get(sourcePath);
                    sourceConnections?.add(filePath);
                });
            }
        });
        
        // Third pass: process unresolved links and content links
        records.forEach(item => {
            const filePath = item.record.filePath;
            const content = item.record.content || '';
            
            // Extract potential link mentions from content (using a mock implementation)
            const potentialLinks: string[] = [];
            // This is a simple regex to find potential links in markdown/wikilinks syntax
            const linkRegex = /\[\[([^\]]+)\]\]|\[([^\]]+)\]\([^\)]+\)/g;
            let match;
            while ((match = linkRegex.exec(content)) !== null) {
                potentialLinks.push(match[1] || match[2]);
            }
            
            potentialLinks.forEach((linkText: string) => {
                const normalizedLink = this.linkUtils.normalizeLinkText(linkText);
                
                // Try to resolve link from our normalized link map
                const matchingPaths = normalizedLinkMap.get(normalizedLink) || [];
                
                matchingPaths.forEach(targetPath => {
                    // Skip self-links
                    if (targetPath === filePath) {
                        return;
                    }
                    
                    // Add to graph
                    const connections = graph.get(filePath) || new Set<string>();
                    connections.add(targetPath);
                    graph.set(filePath, connections);
                    
                    // Add reverse connection
                    const targetConnections = graph.get(targetPath) || new Set<string>();
                    targetConnections.add(filePath);
                    graph.set(targetPath, targetConnections);
                });
            });
        });
        
        return graph;
    }
}
```

## database/utils/graph/LinkUtils.ts

```typescript
/**
 * Utility class for handling link operations
 * Provides methods for normalizing links and finding fuzzy matches
 */
export class LinkUtils {
    /**
     * Normalize link text for more robust matching
     * Removes spaces, special characters, and converts to lowercase
     * 
     * @param linkText The link text to normalize
     * @returns Normalized link text
     */
    normalizeLinkText(linkText: string): string {
        return linkText
            .toLowerCase()
            .replace(/\s+/g, '_')
            .replace(/[^\w\s-]/g, '');
    }
    
    /**
     * Add a filename to the normalized link map
     * 
     * @param linkMap The map to add to
     * @param text The text to normalize and add
     * @param filePath The file path to associate with the text
     */
    addToLinkMap(linkMap: Map<string, string[]>, text: string, filePath: string): void {
        const normalizedText = this.normalizeLinkText(text);
        
        if (!linkMap.has(normalizedText)) {
            linkMap.set(normalizedText, []);
        }
        
        const paths = linkMap.get(normalizedText);
        if (paths && !paths.includes(filePath)) {
            paths.push(filePath);
        }
    }
    
    /**
     * Generate different normalized variants of a link text
     * 
     * @param text The text to generate variants for
     * @returns Array of normalized variants
     */
    getNormalizedVariants(text: string): string[] {
        const variants = new Set<string>();
        
        // Add original
        variants.add(this.normalizeLinkText(text));
        
        // Add with spaces replaced by underscores
        variants.add(this.normalizeLinkText(text.replace(/\s+/g, '_')));
        
        // Add with spaces replaced by hyphens
        variants.add(this.normalizeLinkText(text.replace(/\s+/g, '-')));
        
        // Add without special characters
        variants.add(this.normalizeLinkText(text.replace(/[^\w\s]/g, '')));
        
        // Handle common file extensions (.md)
        const withoutExt = text.endsWith('.md') ? text.slice(0, -3) : text;
        variants.add(this.normalizeLinkText(withoutExt));
        
        return Array.from(variants);
    }
    
    /**
     * Find fuzzy matches for a link text
     * 
     * @param linkMap The normalized link map
     * @param text The text to find fuzzy matches for
     * @returns Array of matching file paths
     */
    findFuzzyMatches(linkMap: Map<string, string[]>, text: string): string[] {
        const matches = new Set<string>();
        const normalizedText = this.normalizeLinkText(text);
        
        // For each key in the map, check if either contains the other
        // Convert to array for compatibility
        Array.from(linkMap.entries()).forEach(([key, paths]) => {
            // If the key contains our text or our text contains the key
            if (key.includes(normalizedText) || normalizedText.includes(key)) {
                paths.forEach(path => matches.add(path));
            }
        });
        
        return Array.from(matches);
    }
}
```

## database/utils/graph/constants.ts

```typescript
/**
 * Default graph boost factor
 */
export const DEFAULT_GRAPH_BOOST_FACTOR = 0.3;

/**
 * Default max distance for graph boosting
 */
export const DEFAULT_GRAPH_MAX_DISTANCE = 1;
```

## database/utils/progressTracker.ts

```typescript
/**
 * Tracks progress for long-running operations
 */
export class ProgressTracker {
  /**
   * Update progress
   */
  updateProgress(data: {
    processed: number;
    total: number;
    remaining: number;
    operationId: string | null;
  }): void {
    // Use global handler if available
    if ((window as any).mcpProgressHandlers?.updateProgress) {
      (window as any).mcpProgressHandlers.updateProgress(data);
    }
  }

  /**
   * Complete progress
   */
  completeProgress(data: {
    success: boolean;
    processed: number;
    failed: number;
    error?: string;
    operationId: string;
  }): void {
    // Use global handler if available
    if ((window as any).mcpProgressHandlers?.completeProgress) {
      (window as any).mcpProgressHandlers.completeProgress(data);
    }
  }

  /**
   * Cancel progress
   */
  cancelProgress(data: {
    operationId: string;
  }): void {
    // Use global handler if available
    if ((window as any).mcpProgressHandlers?.cancelProgress) {
      (window as any).mcpProgressHandlers.cancelProgress(data);
    }
  }
}
```

## database/workspace-types.ts

```typescript
/**
 * Legacy Workspace Types File - Refactored for Modular Organization
 * 
 * This file now re-exports all types from the organized modular structure.
 * The original workspace-types.ts file has been broken down into domain-specific modules:
 * 
 * - src/database/types/workspace/: Core workspace types and parameter definitions
 * - src/database/types/session/: Session tracking and state snapshot types
 * - src/database/types/memory/: Memory traces and file search types
 * - src/database/types/cache/: Cache management types
 * 
 * This approach follows SOLID principles:
 * - Single Responsibility: Each module handles one domain
 * - Open/Closed: Easy to extend without modifying existing code
 * - Interface Segregation: Clients depend only on what they use
 * - Dependency Inversion: Modules depend on abstractions
 */

// Re-export all types from the modular structure for backward compatibility
export * from './types';
```

## handlers/RequestRouter.ts

```typescript
import { App } from 'obsidian';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IAgent } from '../agents/interfaces/IAgent';
import { SessionContextManager } from '../services/SessionContextManager';
import { IRequestHandlerDependencies } from './interfaces/IRequestHandlerServices';
import { IRequestStrategy } from './strategies/IRequestStrategy';

// Import services
import { ValidationService } from './services/ValidationService';
import { SessionService } from './services/SessionService';
import { ToolExecutionService } from './services/ToolExecutionService';
import { ResponseFormatter } from './services/ResponseFormatter';
import { ToolListService } from './services/ToolListService';
import { ResourceListService } from './services/ResourceListService';
import { ResourceReadService } from './services/ResourceReadService';
import { PromptsListService } from './services/PromptsListService';
import { CustomPromptStorageService } from "../agents/agentManager/services/CustomPromptStorageService";
import { ToolHelpService } from './services/ToolHelpService';
import { SchemaEnhancementService } from './services/SchemaEnhancementService';
import { VaultSchemaProvider } from './services/providers/VaultSchemaProvider';
import { WorkspaceSchemaProvider } from './services/providers/WorkspaceSchemaProvider';
import { AgentSchemaProvider } from './services/providers/AgentSchemaProvider';

// Import strategies
import { ToolExecutionStrategy } from './strategies/ToolExecutionStrategy';
import { ToolListStrategy } from './strategies/ToolListStrategy';
import { ResourceListStrategy } from './strategies/ResourceListStrategy';
import { ResourceReadStrategy } from './strategies/ResourceReadStrategy';
import { PromptsListStrategy } from './strategies/PromptsListStrategy';
import { PromptsGetStrategy } from './strategies/PromptsGetStrategy';
import { ToolHelpStrategy } from './strategies/ToolHelpStrategy';

// All requests now handled through modern strategy pattern

export class RequestRouter {
    private dependencies!: IRequestHandlerDependencies;
    private strategies: IRequestStrategy[] = [];

    constructor(
        private app: App,
        private agents: Map<string, IAgent>,
        private isVaultEnabled: boolean,
        private vaultName?: string,
        private sessionContextManager?: SessionContextManager,
        private customPromptStorage?: CustomPromptStorageService,
        private onToolResponse?: (toolName: string, params: any, response: any, success: boolean, executionTime: number) => Promise<void>
    ) {
        this.initializeDependencies();
        this.initializeStrategies();
    }

    private initializeDependencies(): void {
        const schemaEnhancementService = new SchemaEnhancementService();
        const toolListService = new ToolListService();
        
        // Register schema enhancement providers
        if (this.app) {
            const vaultSchemaProvider = new VaultSchemaProvider(this.app);
            schemaEnhancementService.registerProvider(vaultSchemaProvider);
        }
        
        // Register AgentSchemaProvider with access to agents and custom prompt storage
        const agentSchemaProvider = new AgentSchemaProvider();
        agentSchemaProvider.setAgentsMap(this.agents);
        if (this.customPromptStorage) {
            agentSchemaProvider.setCustomPromptStorage(this.customPromptStorage);
        }
        schemaEnhancementService.registerProvider(agentSchemaProvider);
        
        // Inject schema enhancement service into tool list service
        toolListService.setSchemaEnhancementService(schemaEnhancementService);
        
        this.dependencies = {
            validationService: new ValidationService(),
            sessionService: new SessionService(),
            toolExecutionService: new ToolExecutionService(),
            responseFormatter: new ResponseFormatter(),
            toolListService: toolListService,
            resourceListService: new ResourceListService(this.app),
            resourceReadService: new ResourceReadService(this.app),
            promptsListService: new PromptsListService(this.customPromptStorage),
            toolHelpService: new ToolHelpService(),
            schemaEnhancementService: schemaEnhancementService
        };
    }

    private initializeStrategies(): void {
        this.strategies = [
            new ToolListStrategy(
                this.dependencies,
                this.agents,
                this.isVaultEnabled,
                this.vaultName
            ),
            new ToolExecutionStrategy(
                this.dependencies,
                this.getAgent.bind(this),
                this.sessionContextManager,
                this.onToolResponse
            ),
            new ResourceListStrategy(
                this.dependencies,
                this.app
            ),
            new ResourceReadStrategy(
                this.dependencies,
                this.app
            ),
            new PromptsListStrategy(
                this.dependencies
            ),
            new PromptsGetStrategy(
                this.dependencies
            ),
            new ToolHelpStrategy(
                this.dependencies,
                this.getAgent.bind(this)
            )
        ];
    }

    async handleRequest(method: string, request: any): Promise<any> {
        // All requests now handled through strategy pattern
        const requestWithMethod = { method, ...request };
        return await this.handleWithStrategy(requestWithMethod);
    }

    private async handleWithStrategy(request: any): Promise<any> {
        for (const strategy of this.strategies) {
            if (strategy.canHandle(request)) {
                return await strategy.handle(request);
            }
        }
        
        throw new McpError(
            ErrorCode.MethodNotFound,
            `No strategy found for request: ${request.method || 'unknown'}`
        );
    }

    private getAgent(name: string): IAgent {
        const agent = this.agents.get(name);
        if (!agent) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `Agent not found: ${name}`
            );
        }
        return agent;
    }

    // Expose dependencies for testing or extended functionality
    getDependencies(): IRequestHandlerDependencies {
        return this.dependencies;
    }

    // Allow adding custom strategies
    addStrategy(strategy: IRequestStrategy): void {
        this.strategies.push(strategy);
    }

    /**
     * Register WorkspaceSchemaProvider with the schema enhancement service
     * This is called after agents are initialized to ensure WorkspaceService is available
     */
    async registerWorkspaceSchemaProvider(): Promise<void> {
        try {
            // Get MemoryManager agent to access WorkspaceService
            const memoryManagerAgent = this.agents.get('memoryManager');
            if (!memoryManagerAgent) {
                return;
            }

            // Get WorkspaceService from MemoryManager agent
            const workspaceService = await (memoryManagerAgent as any).getWorkspaceServiceAsync();
            if (!workspaceService) {
                return;
            }

            // Create and register WorkspaceSchemaProvider
            const workspaceSchemaProvider = WorkspaceSchemaProvider.forMemoryManager(workspaceService);
            this.dependencies.schemaEnhancementService.registerProvider(workspaceSchemaProvider);
            
        } catch (error) {
        }
    }
}
```

## handlers/index.ts

```typescript
// Main router
export { RequestRouter } from './RequestRouter';

// Interfaces
export type * from './interfaces/IRequestHandlerServices';

// Services
export { ValidationService } from './services/ValidationService';
export { SessionService } from './services/SessionService';
export { ToolExecutionService } from './services/ToolExecutionService';
export { ResponseFormatter } from './services/ResponseFormatter';
export { ToolListService } from './services/ToolListService';

// Strategies
export type { IRequestStrategy } from './strategies/IRequestStrategy';
export { ToolExecutionStrategy } from './strategies/ToolExecutionStrategy';
export { ToolListStrategy } from './strategies/ToolListStrategy';

// All request handling is now done through RequestRouter using the strategy pattern
```

## handlers/interfaces/IRequestHandlerServices.ts

```typescript
import { IAgent } from '../../agents/interfaces/IAgent';
import { SessionContextManager } from '../../services/SessionContextManager';
import { ModeCall, ModeCallResult } from '../../types';
import { ISchemaProvider } from './ISchemaProvider';

export interface IValidationService {
    validateToolParams(params: any, schema?: any, toolName?: string): Promise<any>;
    validateSessionId(sessionId: string): Promise<string>;
    validateBatchOperations(operations: any[]): Promise<void>;
    validateBatchPaths(paths: any[]): Promise<void>;
}

export interface ISessionService {
    processSessionId(sessionId: string): Promise<{
        sessionId: string;
        isNewSession: boolean;
        isNonStandardId: boolean;
        originalSessionId?: string;
    }>;
    generateSessionId(): string;
    isStandardSessionId(sessionId: string): boolean;
    shouldInjectInstructions(sessionId: string, sessionContextManager?: SessionContextManager): boolean;
}

export interface IToolExecutionService {
    executeAgent(
        agent: IAgent,
        mode: string,
        params: any
    ): Promise<any>;
}


export interface IResponseFormatter {
    formatToolExecutionResponse(result: any, sessionInfo?: any): any;
    formatSessionInstructions(sessionId: string, result: any): any;
    formatErrorResponse(error: Error): any;
}

export interface IToolListService {
    generateToolList(
        agents: Map<string, IAgent>,
        isVaultEnabled: boolean,
        vaultName?: string
    ): Promise<{ tools: any[] }>;
    buildAgentSchema(agent: IAgent): any;
    mergeModeSchemasIntoAgent(agent: IAgent, agentSchema: any): any;
    setSchemaEnhancementService(service: ISchemaEnhancementService): void;
}

export interface IResourceListService {
    listResources(): Promise<{ resources: Array<{ uri: string; name: string; mimeType: string }> }>;
    listResourcesByPath(pathPrefix?: string): Promise<{ resources: Array<{ uri: string; name: string; mimeType: string }> }>;
}

export interface IResourceReadService {
    readResource(uri: string): Promise<{ contents: Array<{ uri: string; text: string; mimeType: string }> }>;
    readMultipleResources(uris: string[]): Promise<{ contents: Array<{ uri: string; text: string; mimeType: string }> }>;
    resourceExists(uri: string): Promise<boolean>;
}

export interface IPromptsListService {
    listPrompts(): Promise<{ prompts: Array<{ name: string; description?: string; arguments?: any[] }> }>;
    listPromptsByCategory(category?: string): Promise<{ prompts: Array<{ name: string; description?: string; arguments?: any[] }> }>;
    promptExists(name: string): Promise<boolean>;
    getPrompt(name: string): Promise<string | null>;
}

export interface IToolHelpService {
    generateToolHelp(
        getAgent: (name: string) => IAgent,
        toolName: string,
        mode: string
    ): Promise<{ content: Array<{ type: string; text: string }> }>;
    generateAgentHelp(
        getAgent: (name: string) => IAgent,
        toolName: string
    ): Promise<{ content: Array<{ type: string; text: string }> }>;
    validateModeExists(
        getAgent: (name: string) => IAgent,
        toolName: string,
        mode: string
    ): Promise<boolean>;
}

export interface IRequestContext {
    agentName: string;
    mode: string;
    params: any;
    sessionId: string;
    fullToolName: string;
    sessionContextManager?: SessionContextManager;
}

export interface ISchemaEnhancementService {
    enhanceToolSchema(toolName: string, baseSchema: any): Promise<any>;
    getAvailableEnhancements(): Promise<string[]>;
    registerProvider(provider: ISchemaProvider): void;
    unregisterProvider(providerName: string): boolean;
    hasProvider(providerName: string): boolean;
    clearProviders(): void;
    getProviderInfo(): Array<{ name: string; description: string; priority: number }>;
}

export interface IRequestHandlerDependencies {
    validationService: IValidationService;
    sessionService: ISessionService;
    toolExecutionService: IToolExecutionService;
    responseFormatter: IResponseFormatter;
    toolListService: IToolListService;
    resourceListService: IResourceListService;
    resourceReadService: IResourceReadService;
    promptsListService: IPromptsListService;
    toolHelpService: IToolHelpService;
    schemaEnhancementService: ISchemaEnhancementService;
}
```

## handlers/interfaces/ISchemaProvider.ts

```typescript
/**
 * Location: src/handlers/interfaces/ISchemaProvider.ts
 * 
 * Interface for schema enhancement providers that can enhance tool schemas
 * with additional properties, validation rules, and improvements.
 * Used by SchemaEnhancementService to provide modular enhancement capabilities.
 */

export interface ISchemaProvider {
    /**
     * The name of this schema provider
     */
    readonly name: string;
    
    /**
     * The description of what this provider enhances
     */
    readonly description: string;
    
    /**
     * Check if this provider can enhance the given tool schema
     * @param toolName The name of the tool to check
     * @param baseSchema The base schema to potentially enhance
     * @returns Promise<boolean> true if this provider can enhance the schema
     */
    canEnhance(toolName: string, baseSchema: any): Promise<boolean>;
    
    /**
     * Enhance the given schema with additional properties or validation
     * @param toolName The name of the tool being enhanced
     * @param baseSchema The base schema to enhance
     * @returns Promise<any> The enhanced schema
     */
    enhanceSchema(toolName: string, baseSchema: any): Promise<any>;
    
    /**
     * Get the priority of this provider (higher numbers = higher priority)
     * Used to determine the order of enhancement application
     * @returns number The priority value
     */
    getPriority(): number;
}
```

## handlers/services/BaseSchemaProvider.ts

```typescript
/**
 * Location: src/handlers/services/BaseSchemaProvider.ts
 * 
 * Base abstract class for schema enhancement providers. Implements common
 * functionality for schema enhancement and provides DRY foundation for
 * specific enhancement providers.
 * Extends this class to create specific enhancement providers.
 */

import { ISchemaProvider } from '../interfaces/ISchemaProvider';
import { logger } from '../../utils/logger';
import { getErrorMessage } from '../../utils/errorUtils';

export abstract class BaseSchemaProvider implements ISchemaProvider {
    abstract readonly name: string;
    abstract readonly description: string;

    /**
     * Default priority - can be overridden by implementations
     */
    getPriority(): number {
        return 100;
    }

    /**
     * Default implementation - checks tool name patterns.
     * Override for more sophisticated logic.
     */
    async canEnhance(toolName: string, baseSchema: any): Promise<boolean> {
        try {
            return this.shouldEnhanceToolName(toolName) && this.hasValidSchema(baseSchema);
        } catch (error) {
            logger.systemError(error as Error, `${this.name} - Error in canEnhance`);
            return false;
        }
    }

    abstract enhanceSchema(toolName: string, baseSchema: any): Promise<any>;

    /**
     * Common utility: Check if tool name should be enhanced by this provider
     * Override this method to define tool name patterns for enhancement
     */
    protected shouldEnhanceToolName(toolName: string): boolean {
        // Default: enhance all tools (override in subclasses for specific patterns)
        return true;
    }

    /**
     * Common utility: Validate that base schema is valid for enhancement
     */
    protected hasValidSchema(baseSchema: any): boolean {
        return baseSchema && typeof baseSchema === 'object' && baseSchema.properties;
    }

    /**
     * Common utility: Deep clone schema to avoid mutations
     */
    protected cloneSchema(schema: any): any {
        try {
            return JSON.parse(JSON.stringify(schema));
        } catch (error) {
            logger.systemError(error as Error, `${this.name} - Error cloning schema`);
            return { ...schema }; // Shallow clone fallback
        }
    }

    /**
     * Common utility: Merge enhanced properties into base schema
     */
    protected mergeProperties(baseSchema: any, enhancedProperties: any): any {
        const enhanced = this.cloneSchema(baseSchema);
        
        if (enhancedProperties) {
            enhanced.properties = {
                ...enhanced.properties,
                ...enhancedProperties
            };
        }
        
        return enhanced;
    }

    /**
     * Common utility: Add conditional validation rules to schema
     */
    protected addConditionalValidation(schema: any, condition: any, validation: any): any {
        const enhanced = this.cloneSchema(schema);
        
        if (!enhanced.allOf) {
            enhanced.allOf = [];
        }
        
        enhanced.allOf.push({
            if: condition,
            then: validation
        });
        
        return enhanced;
    }

    /**
     * Common utility: Add required fields conditionally
     */
    protected addConditionalRequired(schema: any, condition: any, requiredFields: string[]): any {
        return this.addConditionalValidation(schema, condition, {
            required: requiredFields
        });
    }

    /**
     * Common utility: Log enhancement activity for debugging
     */
    protected logEnhancement(toolName: string, action: string, details?: any): void {
        logger.systemLog(`[${this.name}] Enhanced ${toolName}: ${action}`, details);
    }

    /**
     * Common utility: Safe error handling wrapper for enhancement operations
     */
    protected async safeEnhance<T>(
        operation: () => Promise<T>,
        fallbackValue: T,
        operationName: string
    ): Promise<T> {
        try {
            return await operation();
        } catch (error) {
            logger.systemError(
                error as Error, 
                `${this.name} - Error in ${operationName}: ${getErrorMessage(error)}`
            );
            return fallbackValue;
        }
    }
}
```

## handlers/services/PromptsListService.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IPromptsListService } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';
import { CustomPromptStorageService } from "../../agents/agentManager/services/CustomPromptStorageService";

/**
 * Prompt interface for MCP prompt listing
 */
interface Prompt {
    name: string;
    description?: string;
    arguments?: Array<{
        name: string;
        description?: string;
        required?: boolean;
    }>;
}

/**
 * Service for listing available prompts
 * Applies Single Responsibility Principle by focusing solely on prompt enumeration
 * 
 * Includes both system prompts and user-defined custom prompts
 */
export class PromptsListService implements IPromptsListService {
    private customPromptStorage?: CustomPromptStorageService;

    constructor(customPromptStorage?: CustomPromptStorageService) {
        this.customPromptStorage = customPromptStorage;
    }

    /**
     * Get all available prompts
     * @returns Promise resolving to array of prompts
     */
    async listPrompts(): Promise<{ prompts: Prompt[] }> {
        try {
            
            const prompts: Prompt[] = [];
            
            // Add system prompts (currently none)
            // Future enhancement: Could add predefined system prompt templates
            
            // Add custom prompts if storage service is available
            if (this.customPromptStorage && this.customPromptStorage.isEnabled()) {
                const customPrompts = this.customPromptStorage.getEnabledPrompts();
                
                // Convert custom prompts to MCP Prompt format
                const mcpPrompts = customPrompts.map(customPrompt => ({
                    name: customPrompt.name,
                    description: customPrompt.description,
                    // Custom prompts don't have arguments for now
                    arguments: []
                }));
                
                prompts.push(...mcpPrompts);
            }
            
            return { prompts };
        } catch (error) {
            logger.systemError(error as Error, 'PromptsListService');
            throw new McpError(ErrorCode.InternalError, 'Failed to list prompts', error);
        }
    }

    /**
     * Get prompts by category (future enhancement)
     * @param category Optional category to filter prompts
     * @returns Promise resolving to filtered prompts
     */
    async listPromptsByCategory(category?: string): Promise<{ prompts: Prompt[] }> {
        try {
            const allPrompts = await this.listPrompts();
            
            if (!category) {
                return allPrompts;
            }
            
            // Future: Filter prompts by category when implemented
            return { prompts: [] };
        } catch (error) {
            logger.systemError(error as Error, 'PromptsListService');
            throw new McpError(ErrorCode.InternalError, 'Failed to list prompts by category', error);
        }
    }

    /**
     * Check if prompt exists by name
     * @param name Prompt name
     * @returns Promise resolving to boolean
     */
    async promptExists(name: string): Promise<boolean> {
        try {
            // Check custom prompts first if available
            if (this.customPromptStorage && this.customPromptStorage.isEnabled()) {
                const customPrompt = this.customPromptStorage.getPromptByName(name);
                if (customPrompt && customPrompt.isEnabled) {
                    return true;
                }
            }
            
            // Check system prompts (currently none)
            // Future: Add system prompt checking here
            
            return false;
        } catch (error) {
            logger.systemWarn(`PromptsListService: Prompt existence check failed for ${name}`);
            return false;
        }
    }

    /**
     * Get a specific prompt by name (for MCP prompts/get endpoint)
     * @param name Prompt name
     * @returns Promise resolving to prompt content or null
     */
    async getPrompt(name: string): Promise<string | null> {
        try {
            if (this.customPromptStorage && this.customPromptStorage.isEnabled()) {
                const customPrompt = this.customPromptStorage.getPromptByName(name);
                if (customPrompt && customPrompt.isEnabled) {
                    return customPrompt.prompt;
                }
            }
            
            // Check system prompts (currently none)
            // Future: Add system prompt retrieval here
            
            return null;
        } catch (error) {
            logger.systemError(error as Error, 'PromptsListService');
            return null;
        }
    }
}
```

## handlers/services/ResourceListService.ts

```typescript
import { App } from 'obsidian';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IResourceListService } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

/**
 * Resource interface for MCP resource listing
 */
interface Resource {
    uri: string;
    name: string;
    mimeType: string;
}

/**
 * Service for listing vault resources
 * Applies Single Responsibility Principle by focusing solely on resource enumeration
 */
export class ResourceListService implements IResourceListService {
    constructor(private app: App) {}

    /**
     * Get all vault resources as MCP resources
     * @returns Promise resolving to array of resources
     */
    async listResources(): Promise<{ resources: Resource[] }> {
        try {
            
            const resources: Resource[] = [];
            const files = this.app.vault.getMarkdownFiles();
            
            for (const file of files) {
                resources.push({
                    uri: `obsidian://${file.path}`,
                    name: file.basename,
                    mimeType: "text/markdown"
                });
            }
            
            return { resources };
        } catch (error) {
            logger.systemError(error as Error, 'ResourceListService');
            throw new McpError(ErrorCode.InternalError, 'Failed to list resources', error);
        }
    }

    /**
     * Get resources filtered by path prefix (future enhancement)
     * @param pathPrefix Optional path prefix to filter resources
     * @returns Promise resolving to filtered resources
     */
    async listResourcesByPath(pathPrefix?: string): Promise<{ resources: Resource[] }> {
        try {
            const allResources = await this.listResources();
            
            if (!pathPrefix) {
                return allResources;
            }
            
            const filteredResources = allResources.resources.filter(resource => 
                resource.uri.includes(pathPrefix)
            );
            
            return { resources: filteredResources };
        } catch (error) {
            logger.systemError(error as Error, 'ResourceListService');
            throw new McpError(ErrorCode.InternalError, 'Failed to list resources by path', error);
        }
    }
}
```

## handlers/services/ResourceReadService.ts

```typescript
import { App, TFile } from 'obsidian';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IResourceReadService } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

/**
 * Resource content interface for MCP resource reading
 */
interface ResourceContent {
    uri: string;
    text: string;
    mimeType: string;
}

/**
 * Service for reading vault resource content
 * Applies Single Responsibility Principle by focusing solely on resource content retrieval
 */
export class ResourceReadService implements IResourceReadService {
    constructor(private app: App) {}

    /**
     * Read resource content by URI
     * @param uri Resource URI to read
     * @returns Promise resolving to resource content
     */
    async readResource(uri: string): Promise<{ contents: ResourceContent[] }> {
        try {
            logger.systemLog(`ResourceReadService: Reading resource ${uri}`);
            
            const content = await this.getResourceContent(uri);
            
            return {
                contents: [{
                    uri,
                    text: content,
                    mimeType: "text/markdown"
                }]
            };
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ResourceReadService');
            throw new McpError(ErrorCode.InternalError, 'Failed to read resource', error);
        }
    }

    /**
     * Read multiple resources by URIs (future enhancement)
     * @param uris Array of resource URIs to read
     * @returns Promise resolving to array of resource contents
     */
    async readMultipleResources(uris: string[]): Promise<{ contents: ResourceContent[] }> {
        try {
            logger.systemLog(`ResourceReadService: Reading ${uris.length} resources`);
            
            const contents: ResourceContent[] = [];
            
            for (const uri of uris) {
                try {
                    const content = await this.getResourceContent(uri);
                    contents.push({
                        uri,
                        text: content,
                        mimeType: "text/markdown"
                    });
                } catch (error) {
                    logger.systemWarn(`ResourceReadService: Failed to read resource ${uri}`);
                    // Continue with other resources, but log the failure
                }
            }
            
            return { contents };
        } catch (error) {
            logger.systemError(error as Error, 'ResourceReadService');
            throw new McpError(ErrorCode.InternalError, 'Failed to read multiple resources', error);
        }
    }

    /**
     * Get resource content from vault file
     * @param uri Resource URI
     * @returns Promise resolving to file content
     * @private
     */
    private async getResourceContent(uri: string): Promise<string> {
        // Parse obsidian:// URI to get file path
        const path = this.parseResourceUri(uri);
        
        // Get file from vault
        const file = this.app.vault.getAbstractFileByPath(path);
        
        if (!(file instanceof TFile)) {
            throw new McpError(ErrorCode.InvalidParams, `Resource not found: ${uri}`);
        }
        
        // Read file content
        return await this.app.vault.read(file);
    }


    /**
     * Parse resource URI to extract file path
     * @param uri Resource URI (e.g., "obsidian://path/to/file.md")
     * @returns File path
     * @private
     */
    private parseResourceUri(uri: string): string {
        if (!uri.startsWith('obsidian://')) {
            throw new McpError(ErrorCode.InvalidParams, `Invalid resource URI format: ${uri}`);
        }
        
        return uri.replace('obsidian://', '');
    }

    /**
     * Check if resource exists in vault
     * @param uri Resource URI
     * @returns Promise resolving to boolean
     */
    async resourceExists(uri: string): Promise<boolean> {
        try {
            const path = this.parseResourceUri(uri);
            const file = this.app.vault.getAbstractFileByPath(path);
            return file instanceof TFile;
        } catch (error) {
            logger.systemWarn(`ResourceReadService: Resource existence check failed for ${uri}`);
            return false;
        }
    }
}
```

## handlers/services/ResponseFormatter.ts

```typescript
import { IResponseFormatter } from '../interfaces/IRequestHandlerServices';
import { safeStringify } from '../../utils/jsonUtils';
import { 
    formatSessionInstructions,
    enhanceContextWithSessionInstructions 
} from '../../utils/sessionUtils';

export class ResponseFormatter implements IResponseFormatter {
    formatToolExecutionResponse(result: any, sessionInfo?: any): any {
        if (sessionInfo && this.needsSessionInstructions(sessionInfo, result)) {
            return this.formatWithSessionInstructions(result, sessionInfo);
        }
        
        return {
            content: [{
                type: "text",
                text: safeStringify(result)
            }]
        };
    }

    formatSessionInstructions(sessionId: string, result: any): any {
        result.sessionId = sessionId;
        return result;
    }


    formatErrorResponse(error: Error): any {
        return {
            content: [{
                type: "text",
                text: `Error: ${error.message}`
            }]
        };
    }

    private needsSessionInstructions(sessionInfo: any, result: any): boolean {
        return (sessionInfo.isNewSession || sessionInfo.isNonStandardId) &&
               result &&
               sessionInfo.shouldInjectInstructions;
    }

    private formatWithSessionInstructions(result: any, sessionInfo: any): any {
        this.formatSessionInstructions(sessionInfo.sessionId, result);
        
        let responseText = "";
        
        if (sessionInfo.isNonStandardId) {
            responseText += `üîÑ SESSION ID: ${sessionInfo.sessionId} - MANDATORY: Use this ID in all future requests, do NOT use the name.\n\n`;
        } else if (sessionInfo.isNewSession) {
            responseText += `üÜï SESSION ID: ${sessionInfo.sessionId} - MANDATORY: Use this ID in all future requests, do NOT use the name.\n\n`;
        }
        
        responseText += safeStringify(result);
        
        return {
            content: [{
                type: "text",
                text: responseText
            }]
        };
    }
}
```

## handlers/services/SchemaEnhancementService.ts

```typescript
/**
 * Location: src/handlers/services/SchemaEnhancementService.ts
 * 
 * Central service for enhancing tool schemas with additional properties,
 * validation rules, and improvements through registered schema providers.
 * Used by ToolListService to enhance schemas before returning to clients.
 */

import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { ISchemaEnhancementService } from '../interfaces/IRequestHandlerServices';
import { ISchemaProvider } from '../interfaces/ISchemaProvider';
import { logger } from '../../utils/logger';
import { getErrorMessage } from '../../utils/errorUtils';

export class SchemaEnhancementService implements ISchemaEnhancementService {
    private providers: ISchemaProvider[] = [];

    /**
     * Register a schema enhancement provider
     */
    registerProvider(provider: ISchemaProvider): void {
        try {
            // Check if provider is already registered
            if (this.providers.some(p => p.name === provider.name)) {
                logger.systemLog(`Schema provider ${provider.name} already registered, skipping`);
                return;
            }

            this.providers.push(provider);
            
            // Sort providers by priority (highest first)
            this.providers.sort((a, b) => b.getPriority() - a.getPriority());
            
            logger.systemLog(`Registered schema provider: ${provider.name} (priority: ${provider.getPriority()})`);
        } catch (error) {
            logger.systemError(error as Error, `Error registering schema provider: ${provider.name}`);
        }
    }

    /**
     * Unregister a schema enhancement provider
     */
    unregisterProvider(providerName: string): boolean {
        try {
            const initialLength = this.providers.length;
            this.providers = this.providers.filter(p => p.name !== providerName);
            
            const wasRemoved = this.providers.length < initialLength;
            if (wasRemoved) {
                logger.systemLog(`Unregistered schema provider: ${providerName}`);
            }
            
            return wasRemoved;
        } catch (error) {
            logger.systemError(error as Error, `Error unregistering schema provider: ${providerName}`);
            return false;
        }
    }

    /**
     * Enhance a tool schema using all applicable registered providers
     */
    async enhanceToolSchema(toolName: string, baseSchema: any): Promise<any> {
        try {
            // Validate input
            if (!toolName || typeof toolName !== 'string') {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Tool name must be a non-empty string'
                );
            }

            if (!baseSchema || typeof baseSchema !== 'object') {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Base schema must be a valid object'
                );
            }

            // Start with a deep clone of the base schema to avoid mutations
            let enhancedSchema = JSON.parse(JSON.stringify(baseSchema));

            // Track which providers were applied for debugging
            const appliedProviders: string[] = [];

            // Apply each provider that can enhance this tool
            for (const provider of this.providers) {
                try {
                    const canEnhance = await provider.canEnhance(toolName, enhancedSchema);
                    if (canEnhance) {
                        const providerResult = await provider.enhanceSchema(toolName, enhancedSchema);
                        
                        // Validate the provider returned a valid schema
                        if (providerResult && typeof providerResult === 'object') {
                            enhancedSchema = providerResult;
                            appliedProviders.push(provider.name);
                            logger.systemLog(`Applied schema enhancement: ${provider.name} to ${toolName}`);
                        } else {
                            logger.systemError(
                                new Error(`Invalid schema returned from provider: ${provider.name}`),
                                'Schema Enhancement'
                            );
                        }
                    }
                } catch (error) {
                    logger.systemError(
                        error as Error,
                        `Error applying schema provider ${provider.name} to tool ${toolName}: ${getErrorMessage(error)}`
                    );
                    // Continue with other providers instead of failing completely
                }
            }

            // Log enhancement summary
            if (appliedProviders.length > 0) {
                logger.systemLog(`Enhanced schema for ${toolName} with providers: ${appliedProviders.join(', ')}`);
            }

            return enhancedSchema;

        } catch (error) {
            logger.systemError(error as Error, `Error enhancing schema for tool ${toolName}`);
            
            // Return original schema on error to avoid breaking tool functionality
            if (error instanceof McpError) {
                throw error;
            } else {
                throw new McpError(
                    ErrorCode.InternalError,
                    `Failed to enhance schema for tool ${toolName}`,
                    error
                );
            }
        }
    }

    /**
     * Get list of available enhancement provider names
     */
    async getAvailableEnhancements(): Promise<string[]> {
        try {
            return this.providers.map(provider => provider.name);
        } catch (error) {
            logger.systemError(error as Error, 'Error getting available enhancements');
            return [];
        }
    }

    /**
     * Get detailed information about registered providers
     */
    getProviderInfo(): Array<{ name: string; description: string; priority: number }> {
        try {
            return this.providers.map(provider => ({
                name: provider.name,
                description: provider.description,
                priority: provider.getPriority()
            }));
        } catch (error) {
            logger.systemError(error as Error, 'Error getting provider info');
            return [];
        }
    }

    /**
     * Check if a specific provider is registered
     */
    hasProvider(providerName: string): boolean {
        return this.providers.some(p => p.name === providerName);
    }

    /**
     * Clear all registered providers (mainly for testing)
     */
    clearProviders(): void {
        const count = this.providers.length;
        this.providers = [];
        logger.systemLog(`Cleared ${count} schema enhancement providers`);
    }
}
```

## handlers/services/SessionService.ts

```typescript
import { ISessionService } from '../interfaces/IRequestHandlerServices';
import { SessionContextManager } from '../../services/SessionContextManager';
import { 
    generateSessionId, 
    isStandardSessionId 
} from '../../utils/sessionUtils';
import { logger } from '../../utils/logger';

export class SessionService implements ISessionService {
    async processSessionId(sessionId: string): Promise<{
        sessionId: string;
        isNewSession: boolean;
        isNonStandardId: boolean;
        originalSessionId?: string;
    }> {
        if (!sessionId) {
            const newSessionId = this.generateSessionId();
            logger.systemLog(`Created new session with standardized ID: ${newSessionId}`);
            
            return {
                sessionId: newSessionId,
                isNewSession: true,
                isNonStandardId: false
            };
        }
        
        if (!this.isStandardSessionId(sessionId)) {
            const standardizedId = this.generateSessionId();
            logger.systemLog(`Replaced non-standard session ID: ${sessionId} with standardized ID: ${standardizedId}`);
            
            return {
                sessionId: standardizedId,
                isNewSession: false,
                isNonStandardId: true,
                originalSessionId: sessionId
            };
        }
        
        return {
            sessionId,
            isNewSession: false,
            isNonStandardId: false
        };
    }

    generateSessionId(): string {
        return generateSessionId();
    }

    isStandardSessionId(sessionId: string): boolean {
        return isStandardSessionId(sessionId);
    }

    shouldInjectInstructions(
        sessionId: string, 
        sessionContextManager?: SessionContextManager
    ): boolean {
        return sessionContextManager ? 
            !sessionContextManager.hasReceivedInstructions(sessionId) : 
            false;
    }
}
```

## handlers/services/ToolExecutionService.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IToolExecutionService } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { logger } from '../../utils/logger';
import { getErrorMessage } from '../../utils/errorUtils';

export class ToolExecutionService implements IToolExecutionService {
    async executeAgent(
        agent: IAgent,
        mode: string,
        params: any
    ): Promise<any> {
        try {
            this.validateModeSpecificParams(agent.name, mode, params);
            return await agent.executeMode(mode, params);
        } catch (error) {
            logger.systemError(error as Error, `Tool Execution - ${agent.name}:${mode}`);
            throw error;
        }
    }

    private validateModeSpecificParams(agentName: string, mode: string, params: any): void {
        switch (agentName) {
            case 'memoryManager':
                this.validateMemoryManagerParams(mode, params);
                break;
            case 'vaultManager':
                this.validateVaultManagerParams(mode, params);
                break;
            case 'contentManager':
                this.validateContentManagerParams(mode, params);
                break;
        }
    }

    private validateMemoryManagerParams(mode: string, params: any): void {
        if (mode === 'createState' && !params.name) {
            throw new McpError(
                ErrorCode.InvalidParams,
                'Missing required parameter: name for createState mode'
            );
        }
    }

    private validateVaultManagerParams(mode: string, params: any): void {
        if (['listFolders', 'createFolder', 'listFiles'].includes(mode) && 
            params.path === undefined) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `Missing required parameter: path for ${mode} mode`
            );
        }
    }

    private validateContentManagerParams(mode: string, params: any): void {
        if (mode === 'createContent') {
            if (!params.filePath) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Missing required parameter: filePath for createContent mode'
                );
            }
            if (params.content === undefined || params.content === null) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Missing required parameter: content for createContent mode'
                );
            }
        }
    }
}
```

## handlers/services/ToolHelpService.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IToolHelpService } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { logger } from '../../utils/logger';
import {
    generateModeHelp,
    formatModeHelp
} from '../../utils/parameterHintUtils';

/**
 * Help content interface for MCP tool help
 */
interface HelpContent {
    type: string;
    text: string;
}

/**
 * Service for generating tool help content
 * Applies Single Responsibility Principle by focusing solely on help generation
 */
export class ToolHelpService implements IToolHelpService {
    constructor() {}

    /**
     * Generate help content for a specific agent mode
     * @param getAgent Function to retrieve agent by name
     * @param toolName Full tool name (may include vault suffix)
     * @param mode Mode name to get help for
     * @returns Promise resolving to help content
     */
    async generateToolHelp(
        getAgent: (name: string) => IAgent,
        toolName: string,
        mode: string
    ): Promise<{ content: HelpContent[] }> {
        try {
            logger.systemLog(`ToolHelpService: Generating help for tool ${toolName}, mode ${mode}`);
            
            // Extract agent name from tool name (removes vault suffix if present)
            const agentName = this.extractAgentName(toolName);
            
            // Validate mode parameter
            if (!mode) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    `Missing required parameter: mode for help on agent ${agentName}`
                );
            }
            
            // Get the agent
            const agent = getAgent(agentName);
            if (!agent) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    `Agent ${agentName} not found`
                );
            }
            
            // Get the mode instance
            const modeInstance = agent.getMode(mode);
            if (!modeInstance) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    `Mode ${mode} not found in agent ${agentName}`
                );
            }
            
            // Get the mode's parameter schema
            const schema = modeInstance.getParameterSchema();
            
            // Generate help content
            const help = generateModeHelp(
                mode,
                modeInstance.description,
                schema
            );
            
            // Format the help text
            const helpText = formatModeHelp(help);
            
            logger.systemLog(`ToolHelpService: Generated help for ${agentName}.${mode}`);
            
            return {
                content: [{
                    type: "text",
                    text: helpText
                }]
            };
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ToolHelpService');
            throw new McpError(ErrorCode.InternalError, 'Failed to get tool help', error);
        }
    }

    /**
     * Generate help for all modes of an agent (future enhancement)
     * @param getAgent Function to retrieve agent by name
     * @param toolName Full tool name
     * @returns Promise resolving to comprehensive help content
     */
    async generateAgentHelp(
        getAgent: (name: string) => IAgent,
        toolName: string
    ): Promise<{ content: HelpContent[] }> {
        try {
            const agentName = this.extractAgentName(toolName);
            const agent = getAgent(agentName);
            
            if (!agent) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    `Agent ${agentName} not found`
                );
            }
            
            const modes = agent.getModes().map(mode => mode.slug);
            const helpContent: HelpContent[] = [];
            
            // Add agent overview
            helpContent.push({
                type: "text",
                text: `# ${agentName} Agent\n\n${agent.description}\n\n## Available Modes:\n`
            });
            
            // Add help for each mode
            for (const modeName of modes) {
                try {
                    const modeHelp = await this.generateToolHelp(getAgent, toolName, modeName);
                    helpContent.push(...modeHelp.content);
                    helpContent.push({
                        type: "text",
                        text: "\n---\n"
                    });
                } catch (error) {
                    logger.systemWarn(`ToolHelpService: Failed to generate help for mode ${modeName}`);
                }
            }
            
            return { content: helpContent };
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ToolHelpService');
            throw new McpError(ErrorCode.InternalError, 'Failed to get agent help', error);
        }
    }

    /**
     * Extract the agent name from a tool name that may have a vault name suffix
     * @param toolName Tool name (e.g., "contentManager_vaultName" or "contentManager")
     * @returns Agent name without vault suffix
     * @private
     */
    private extractAgentName(toolName: string): string {
        const lastUnderscoreIndex = toolName.lastIndexOf('_');
        
        if (lastUnderscoreIndex === -1) {
            // No underscore found, return the tool name as-is
            return toolName;
        }
        
        // Extract everything before the last underscore as the agent name
        return toolName.substring(0, lastUnderscoreIndex);
    }

    /**
     * Validate if mode exists for agent (utility method)
     * @param getAgent Function to retrieve agent by name
     * @param toolName Full tool name
     * @param mode Mode name to validate
     * @returns Promise resolving to boolean
     */
    async validateModeExists(
        getAgent: (name: string) => IAgent,
        toolName: string,
        mode: string
    ): Promise<boolean> {
        try {
            const agentName = this.extractAgentName(toolName);
            const agent = getAgent(agentName);
            
            if (!agent) {
                return false;
            }
            
            const modeInstance = agent.getMode(mode);
            return modeInstance !== undefined;
        } catch (error) {
            logger.systemWarn(`ToolHelpService: Mode validation failed for ${toolName}.${mode}`);
            return false;
        }
    }
}
```

## handlers/services/ToolListService.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IToolListService, ISchemaEnhancementService } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { logger } from '../../utils/logger';

interface AgentSchema {
    type: string;
    properties: {
        mode: {
            type: string;
            enum: string[];
            description: string;
        };
        [key: string]: any;
    };
    required: string[];
    allOf: any[];
}

export class ToolListService implements IToolListService {
    private schemaEnhancementService?: ISchemaEnhancementService;
    async generateToolList(
        agents: Map<string, IAgent>,
        isVaultEnabled: boolean,
        vaultName?: string
    ): Promise<{ tools: any[] }> {
        try {
            if (!isVaultEnabled) {
                return { tools: [] };
            }
            
            const tools: any[] = [];
            
            for (const agent of agents.values()) {
                const agentSchema = this.buildAgentSchema(agent);
                this.mergeModeSchemasIntoAgent(agent, agentSchema);
                
                const toolName = vaultName ? `${agent.name}_${vaultName}` : agent.name;
                
                // Enhance the schema and description if enhancement service is available
                let finalSchema = agentSchema;
                let finalDescription = agent.description;
                
                if (this.schemaEnhancementService) {
                    try {
                        // Cast to our enhanced interface if available
                        const enhancedService = this.schemaEnhancementService as any;
                        
                        // Enhance schema with agent context
                        finalSchema = await this.schemaEnhancementService.enhanceToolSchema(
                            toolName, 
                            agentSchema
                        );
                        
                        // Enhance description if the service supports it
                        if (enhancedService.enhanceAgentDescription) {
                            finalDescription = await enhancedService.enhanceAgentDescription(agent, vaultName);
                        }
                    } catch (error) {
                        logger.systemError(error as Error, `Error enhancing schema for ${toolName}`);
                        // Use original schema and description on enhancement failure
                        finalSchema = agentSchema;
                        finalDescription = agent.description;
                    }
                }
                
                tools.push({
                    name: toolName,
                    description: finalDescription,
                    inputSchema: finalSchema
                });
            }
            
            return { tools };
        } catch (error) {
            logger.systemError(error as Error, "Error in generateToolList");
            throw new McpError(ErrorCode.InternalError, 'Failed to list tools', error);
        }
    }

    buildAgentSchema(agent: IAgent): AgentSchema {
        return {
            type: 'object',
            properties: {
                mode: {
                    type: 'string',
                    enum: [] as string[],
                    description: 'The operation mode for this agent'
                },
                sessionId: {
                    type: 'string',
                    description: 'Session identifier to track related tool calls'
                }
            },
            required: ['mode', 'sessionId'],
            allOf: []
        };
    }

    mergeModeSchemasIntoAgent(agent: IAgent, agentSchema: AgentSchema): any {
        const agentModes = agent.getModes();
        
        for (const mode of agentModes) {
            agentSchema.properties.mode.enum.push(mode.slug);
            
            try {
                const modeSchema = mode.getParameterSchema();
                
                if (modeSchema && typeof modeSchema === 'object') {
                    const modeSchemaCopy = JSON.parse(JSON.stringify(modeSchema));
                    
                    if (modeSchemaCopy.properties && modeSchemaCopy.properties.mode) {
                        delete modeSchemaCopy.properties.mode;
                    }
                    
                    if (modeSchemaCopy.required && modeSchemaCopy.required.length > 0) {
                        const conditionalRequired = modeSchemaCopy.required.filter(
                            (prop: string) => prop !== 'mode' && prop !== 'sessionId'
                        );
                        
                        if (conditionalRequired.length > 0) {
                            agentSchema.allOf.push({
                                if: {
                                    properties: {
                                        mode: { enum: [mode.slug] }
                                    }
                                },
                                then: {
                                    required: conditionalRequired
                                }
                            });
                        }
                    }
                    
                    if (modeSchemaCopy.properties) {
                        for (const [propName, propSchema] of Object.entries(modeSchemaCopy.properties)) {
                            if (propName !== 'mode' && propName !== 'sessionId') {
                                agentSchema.properties[propName] = propSchema;
                            }
                        }
                    }
                    
                    ['allOf', 'anyOf', 'oneOf', 'not'].forEach(validationType => {
                        if (modeSchemaCopy[validationType]) {
                            agentSchema.allOf.push({
                                if: {
                                    properties: {
                                        mode: { enum: [mode.slug] }
                                    }
                                },
                                then: {
                                    [validationType]: modeSchemaCopy[validationType]
                                }
                            });
                        }
                    });
                }
            } catch (error) {
                logger.systemError(error as Error, `Error processing schema for mode ${mode.slug}`);
            }
        }
        
        return agentSchema;
    }

    setSchemaEnhancementService(service: ISchemaEnhancementService): void {
        this.schemaEnhancementService = service;
    }
}
```

## handlers/services/ValidationService.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IValidationService } from '../interfaces/IRequestHandlerServices';
import { validateParams, formatValidationErrors, ValidationError } from '../../utils/validationUtils';
import { generateHintsForErrors } from '../../utils/parameterHintUtils';
import { getErrorMessage } from '../../utils/errorUtils';
import { logger } from '../../utils/logger';
import { smartNormalizePath, normalizePath, OperationType } from '../../utils/pathUtils';

export class ValidationService implements IValidationService {
    async validateToolParams(params: any, schema?: any, toolName?: string): Promise<any> {
        const enhancedParams = { ...params };
        
        // Apply smart path normalization to common path parameters before validation
        this.normalizePathParameters(enhancedParams, toolName);
        
        if (schema) {
            await this.validateAgainstSchema(enhancedParams, schema);
        }
        
        if (enhancedParams.operations && Array.isArray(enhancedParams.operations)) {
            await this.validateBatchOperations(enhancedParams.operations);
        }
        
        if (enhancedParams.paths) {
            await this.validateBatchPaths(enhancedParams.paths);
        }
        
        return enhancedParams;
    }

    async validateSessionId(sessionId: string): Promise<string> {
        if (!sessionId || typeof sessionId !== 'string') {
            throw new McpError(
                ErrorCode.InvalidParams,
                'Session ID must be a non-empty string'
            );
        }
        return sessionId;
    }

    /**
     * Apply appropriate path normalization based on operation type
     */
    private normalizePathParameters(params: any, toolName?: string): void {
        const operationType = this.getOperationType(toolName);
        
        // Common path parameter names used across modes
        const pathParameterNames = [
            'path',           
            'filePath',       
            'sourcePath',     
            'targetPath',     
            'newPath',        
            'oldPath'         
        ];

        // Normalize individual path parameters
        for (const paramName of pathParameterNames) {
            if (params[paramName] && typeof params[paramName] === 'string') {
                if (operationType === 'DIRECTORY') {
                    // Directory operations: only basic normalization
                    params[paramName] = normalizePath(params[paramName]);
                } else {
                    // Note operations: smart normalization with .md extension
                    params[paramName] = smartNormalizePath(params[paramName], false, operationType);
                }
            }
        }

        // Handle array of paths (like in batch operations)
        if (params.paths && Array.isArray(params.paths)) {
            params.paths = params.paths.map((path: any) => {
                if (typeof path === 'string') {
                    return operationType === 'DIRECTORY' 
                        ? normalizePath(path) 
                        : smartNormalizePath(path, false, operationType);
                }
                return path;
            });
        }

        // Handle file paths in operations arrays (batch operations)
        // These typically need NOTE operation type for .md extension handling
        if (params.operations && Array.isArray(params.operations)) {
            params.operations.forEach((operation: any) => {
                if (operation && operation.params) {
                    // For batch operations, we need to check the operation type
                    const operationType = operation.type || '';
                    this.normalizePathParameters(operation.params, operationType);
                }
            });
        }

        // Handle contextFiles arrays in agent operations (these are typically file paths)
        if (params.contextFiles && Array.isArray(params.contextFiles)) {
            params.contextFiles = params.contextFiles.map((path: any) => 
                typeof path === 'string' ? smartNormalizePath(path, false, 'NOTE') : path
            );
        }

        // Handle filepaths arrays (used in some prompt execution modes - these are typically file paths)
        if (params.filepaths && Array.isArray(params.filepaths)) {
            params.filepaths = params.filepaths.map((path: any) => 
                typeof path === 'string' ? smartNormalizePath(path, false, 'NOTE') : path
            );
        }
    }

    /**
     * Determine operation type based on tool name
     */
    private getOperationType(toolName?: string): OperationType {
        if (!toolName) return 'GENERIC';

        // Directory operations - never need .md extension
        const directoryOperations = [
            'listFiles', 'listFolders', 'createFolder', 
            'deleteFolder', 'moveFolder', 'editFolder'
        ];

        // Note operations - need .md extension when no extension present
        const noteOperations = [
            'openNote', 'readNote', 'editNote', 'deleteNote',
            'readContent', 'createContent', 'appendContent', 
            'prependContent', 'replaceContent', 'deleteContent'
        ];

        if (directoryOperations.some(op => toolName.includes(op) || toolName.endsWith(op))) {
            return 'DIRECTORY';
        }

        if (noteOperations.some(op => toolName.includes(op) || toolName.endsWith(op))) {
            return 'NOTE';
        }

        return 'GENERIC';
    }

    async validateBatchOperations(operations: any[]): Promise<void> {
        const batchErrors: ValidationError[] = [];
        
        operations.forEach((operation: any, index: number) => {
            if (!operation || typeof operation !== 'object') {
                batchErrors.push({
                    path: ['operations', index.toString()],
                    message: 'Operation must be an object',
                    code: 'TYPE_ERROR',
                    expectedType: 'object',
                    receivedType: typeof operation
                });
                return;
            }
            
            if (!operation.type) {
                batchErrors.push({
                    path: ['operations', index.toString(), 'type'],
                    message: "Missing 'type' property",
                    code: 'MISSING_REQUIRED',
                    hint: "Each operation must have a 'type' property that specifies the operation type"
                });
            }
            
            if (!operation.params) {
                batchErrors.push({
                    path: ['operations', index.toString(), 'params'],
                    message: "Missing 'params' property",
                    code: 'MISSING_REQUIRED',
                    hint: "Each operation must have a 'params' object containing the operation parameters"
                });
            } else if (typeof operation.params !== 'object' || Array.isArray(operation.params)) {
                batchErrors.push({
                    path: ['operations', index.toString(), 'params'],
                    message: "'params' must be an object",
                    code: 'TYPE_ERROR',
                    expectedType: 'object',
                    receivedType: Array.isArray(operation.params) ? 'array' : typeof operation.params
                });
            }
        });
        
        if (batchErrors.length > 0) {
            throw new McpError(
                ErrorCode.InvalidParams,
                formatValidationErrors(batchErrors)
            );
        }
    }

    async validateBatchPaths(paths: any): Promise<void> {
        const pathErrors: ValidationError[] = [];
        
        if (!Array.isArray(paths)) {
            if (typeof paths === 'string' &&
                paths.trim().startsWith('[') &&
                paths.trim().endsWith(']')) {
                try {
                    JSON.parse(paths);
                    return;
                } catch (error) {
                    pathErrors.push({
                        path: ['paths'],
                        message: `Failed to parse 'paths' as JSON array: ${getErrorMessage(error)}`,
                        code: 'PARSE_ERROR',
                        expectedType: 'array',
                        receivedType: 'string',
                        hint: "The 'paths' parameter must be a valid JSON array of strings"
                    });
                }
            } else {
                pathErrors.push({
                    path: ['paths'],
                    message: `'paths' must be an array`,
                    code: 'TYPE_ERROR',
                    expectedType: 'array',
                    receivedType: typeof paths,
                    hint: "The 'paths' parameter must be an array of strings specifying the paths to read"
                });
            }
        } else {
            paths.forEach((path: any, index: number) => {
                if (typeof path !== 'string') {
                    pathErrors.push({
                        path: ['paths', index.toString()],
                        message: 'Path must be a string',
                        code: 'TYPE_ERROR',
                        expectedType: 'string',
                        receivedType: typeof path,
                        hint: "Each path in the 'paths' array must be a string"
                    });
                }
            });
        }
        
        if (pathErrors.length > 0) {
            throw new McpError(
                ErrorCode.InvalidParams,
                formatValidationErrors(pathErrors)
            );
        }
    }

    private async validateAgainstSchema(params: any, schema: any): Promise<void> {
        const validationErrors = validateParams(params, schema);
        if (validationErrors.length > 0) {
            logger.systemLog('DEBUG: Validation errors found:', JSON.stringify(validationErrors, null, 2));
            logger.systemLog('DEBUG: Schema used for validation:', JSON.stringify(schema, null, 2));
            logger.systemLog('DEBUG: Params being validated:', JSON.stringify(params, null, 2));
            
            const hints = generateHintsForErrors(validationErrors, schema);
            
            for (const error of validationErrors) {
                if (error.path.length === 1) {
                    const paramName = error.path[0];
                    if (hints[paramName] && !error.hint) {
                        error.hint = hints[paramName];
                    }
                }
            }
            
            if (schema.required && Array.isArray(schema.required) && schema.required.length > 0) {
                const missingRequiredParams = schema.required.filter(
                    (param: string) => !params[param]
                );
                
                if (missingRequiredParams.length > 0) {
                    const missingParamsInfo = missingRequiredParams.map((param: string) => {
                        const paramSchema = schema.properties[param];
                        return `- ${param}: ${paramSchema?.description || 'No description'}` + 
                               `${paramSchema?.type ? ` (${paramSchema.type})` : ''}`;
                    }).join('\n');
                    
                    const requiredParamsMessage = `\nRequired parameters:\n${missingParamsInfo}`;
                    
                    throw new McpError(
                        ErrorCode.InvalidParams,
                        formatValidationErrors(validationErrors) + requiredParamsMessage
                    );
                }
            }
            
            throw new McpError(
                ErrorCode.InvalidParams,
                formatValidationErrors(validationErrors)
            );
        }
    }
}

```

## handlers/services/providers/AgentSchemaProvider.ts

```typescript
/**
 * Location: src/handlers/services/providers/AgentSchemaProvider.ts
 * 
 * Schema provider for dynamic agent and prompt ID injection into AgentManager tool schemas.
 * Extends BaseSchemaProvider to enhance AgentManager tool schemas with available agent names,
 * custom prompt IDs, and contextual descriptions. Used by SchemaEnhancementService to
 * provide dynamic agent and prompt context for better AI assistant understanding.
 */

import { BaseSchemaProvider } from '../BaseSchemaProvider';
import { IAgent } from '../../../agents/interfaces/IAgent';
import { CustomPromptStorageService } from '../../../agents/agentManager/services/CustomPromptStorageService';
import { CustomPrompt } from '../../../types';
import { logger } from '../../../utils/logger';

interface AgentInfo {
    name: string;
    description: string;
    enabled: boolean;
}

interface PromptInfo {
    id: string;
    name: string;
    description: string;
    enabled: boolean;
}

interface CachedData {
    agents: AgentInfo[];
    prompts: PromptInfo[];
    timestamp: number;
}

/**
 * Schema provider that injects available agent names and custom prompt IDs
 * into AgentManager tool schemas for dynamic context enhancement
 */
export class AgentSchemaProvider extends BaseSchemaProvider {
    readonly name = 'AgentSchemaProvider';
    readonly description = 'Injects available agent names and custom prompt IDs into AgentManager tool schemas';
    
    private cache: CachedData | null = null;
    private readonly CACHE_DURATION_MS = 30000; // 30 seconds
    private readonly MAX_AGENTS_TO_SHOW = 15;
    private readonly MAX_PROMPTS_TO_SHOW = 10;

    private agentsMap: Map<string, IAgent> | null = null;
    private customPromptStorage: CustomPromptStorageService | null = null;

    /**
     * Set the agents map for querying available agents
     */
    setAgentsMap(agentsMap: Map<string, IAgent>): void {
        this.agentsMap = agentsMap;
        this.clearCache(); // Clear cache when agents change
    }

    /**
     * Set the custom prompt storage service for querying custom prompts
     */
    setCustomPromptStorage(customPromptStorage: CustomPromptStorageService): void {
        this.customPromptStorage = customPromptStorage;
        this.clearCache(); // Clear cache when storage changes
    }

    /**
     * Get priority for this provider (higher than base providers)
     */
    getPriority(): number {
        return 200; // High priority for agent-specific enhancements
    }

    /**
     * Check if this provider should enhance the given tool schema
     * Only enhances AgentManager tool schemas
     */
    protected shouldEnhanceToolName(toolName: string): boolean {
        return toolName.startsWith('agentManager-');
    }

    /**
     * Enhance AgentManager tool schemas with agent names and prompt IDs
     */
    async enhanceSchema(toolName: string, baseSchema: any): Promise<any> {
        return await this.safeEnhance(
            async () => this.performEnhancement(toolName, baseSchema),
            baseSchema,
            'enhanceSchema'
        );
    }

    /**
     * Perform the actual schema enhancement
     */
    private async performEnhancement(toolName: string, baseSchema: any): Promise<any> {
        // Get cached or fresh data
        const data = await this.getCachedData();
        
        // Clone the base schema
        const enhanced = this.cloneSchema(baseSchema);
        
        // Extract the mode from tool name (e.g., 'agentManager-executePrompt' -> 'executePrompt')
        const mode = toolName.replace('agentManager-', '');
        
        // Enhance based on the mode
        switch (mode) {
            case 'executePrompt':
            case 'batchExecutePrompt':
                this.enhanceExecutePromptSchema(enhanced, data);
                break;
            case 'createPrompt':
            case 'updatePrompt':
            case 'getPrompt':
            case 'deletePrompt':
            case 'togglePrompt':
                this.enhancePromptManagementSchema(enhanced, data);
                break;
            case 'listPrompts':
                this.enhanceListPromptsSchema(enhanced, data);
                break;
            default:
                // For other modes, add general context
                this.enhanceGeneralSchema(enhanced, data);
                break;
        }
        
        this.logEnhancement(toolName, 'injected agent and prompt context', {
            agentsCount: data.agents.length,
            promptsCount: data.prompts.length
        });
        
        return enhanced;
    }

    /**
     * Enhance executePrompt and batchExecutePrompt schemas
     */
    private enhanceExecutePromptSchema(schema: any, data: CachedData): void {
        // Enhance agent parameter with available agent names
        if (schema.properties?.agent) {
            schema.properties.agent.enum = data.agents
                .filter(agent => agent.enabled)
                .slice(0, this.MAX_AGENTS_TO_SHOW)
                .map(agent => agent.name);
            
            schema.properties.agent.description = this.buildAgentDescription(data.agents);
            
            // Add examples
            const enabledAgents = data.agents.filter(agent => agent.enabled);
            if (enabledAgents.length > 0) {
                schema.properties.agent.examples = enabledAgents.slice(0, 3).map(agent => agent.name);
            }
        }

        // Add prompt ID parameter if not present
        if (!schema.properties?.promptId && data.prompts.length > 0) {
            schema.properties.promptId = {
                type: 'string',
                description: this.buildPromptIdDescription(data.prompts),
                enum: data.prompts
                    .filter(prompt => prompt.enabled)
                    .slice(0, this.MAX_PROMPTS_TO_SHOW)
                    .map(prompt => prompt.id),
                examples: data.prompts
                    .filter(prompt => prompt.enabled)
                    .slice(0, 3)
                    .map(prompt => prompt.id)
            };
        }

        // Update tool description with agent and prompt context
        if (data.agents.length > 0 || data.prompts.length > 0) {
            schema.description = `${schema.description}\n\n${this.buildContextSummary(data)}`;
        }
    }

    /**
     * Enhance prompt management schemas (create, update, get, delete, toggle)
     */
    private enhancePromptManagementSchema(schema: any, data: CachedData): void {
        // For ID-based operations, enhance with available prompt IDs
        if (schema.properties?.id && data.prompts.length > 0) {
            schema.properties.id.enum = data.prompts.map(prompt => prompt.id);
            schema.properties.id.description = `${schema.properties.id.description || 'Prompt ID'}\n\nAvailable prompt IDs:\n${
                data.prompts.map(prompt => `‚Ä¢ ${prompt.id}: ${prompt.name} ${prompt.enabled ? '‚úÖ' : '‚ùå'}`).join('\n')
            }`;
        }

        // For name-based operations, enhance with available prompt names
        if (schema.properties?.name && data.prompts.length > 0) {
            schema.properties.name.enum = data.prompts.map(prompt => prompt.name);
            schema.properties.name.examples = data.prompts.slice(0, 3).map(prompt => prompt.name);
        }
    }

    /**
     * Enhance listPrompts schema
     */
    private enhanceListPromptsSchema(schema: any, data: CachedData): void {
        if (data.prompts.length > 0) {
            schema.description = `${schema.description}\n\nCurrent prompts: ${data.prompts.length} total (${
                data.prompts.filter(p => p.enabled).length
            } enabled)`;
        }
    }

    /**
     * Enhance general schemas with basic context
     */
    private enhanceGeneralSchema(schema: any, data: CachedData): void {
        if (data.agents.length > 0 || data.prompts.length > 0) {
            schema.description = `${schema.description}\n\n${this.buildContextSummary(data)}`;
        }
    }

    /**
     * Build agent parameter description with available agents
     */
    private buildAgentDescription(agents: AgentInfo[]): string {
        const enabledAgents = agents.filter(agent => agent.enabled);
        
        if (enabledAgents.length === 0) {
            return 'Agent name to use for prompt execution. No custom prompt agents currently available.';
        }
        
        const agentsList = enabledAgents
            .slice(0, this.MAX_AGENTS_TO_SHOW)
            .map(agent => `‚Ä¢ ${agent.name}: ${agent.description || 'No description'}`)
            .join('\n');
        
        return `Agent name to use for prompt execution. Available custom prompt agents:\n${agentsList}${
            enabledAgents.length > this.MAX_AGENTS_TO_SHOW ? '\n...and more' : ''
        }`;
    }

    /**
     * Build prompt ID parameter description with available prompts
     */
    private buildPromptIdDescription(prompts: PromptInfo[]): string {
        const enabledPrompts = prompts.filter(prompt => prompt.enabled);
        
        if (enabledPrompts.length === 0) {
            return 'Custom prompt ID to execute directly (alternative to specifying agent). No custom prompts currently available.';
        }
        
        const promptsList = enabledPrompts
            .slice(0, this.MAX_PROMPTS_TO_SHOW)
            .map(prompt => `‚Ä¢ ${prompt.id}: ${prompt.name} - ${prompt.description || 'No description'}`)
            .join('\n');
        
        return `Custom prompt ID to execute directly (alternative to specifying agent). Available custom prompts:\n${promptsList}${
            enabledPrompts.length > this.MAX_PROMPTS_TO_SHOW ? '\n...and more' : ''
        }`;
    }

    /**
     * Build context summary for tool descriptions
     */
    private buildContextSummary(data: CachedData): string {
        const parts: string[] = [];
        
        const enabledAgents = data.agents.filter(agent => agent.enabled);
        if (enabledAgents.length > 0) {
            parts.push(`Available agents: ${enabledAgents.length} enabled`);
        }
        
        const enabledPrompts = data.prompts.filter(prompt => prompt.enabled);
        if (enabledPrompts.length > 0) {
            parts.push(`Custom prompts: ${enabledPrompts.length} enabled`);
        }
        
        if (parts.length === 0) {
            return 'No custom agents or prompts currently available.';
        }
        
        return `ü§ñ ${parts.join(' | ')}`;
    }

    /**
     * Get cached data or refresh if stale
     */
    private async getCachedData(): Promise<CachedData> {
        const now = Date.now();
        
        if (this.cache && (now - this.cache.timestamp) < this.CACHE_DURATION_MS) {
            return this.cache;
        }
        
        // Refresh cache
        const agents = await this.queryAvailableAgents();
        const prompts = await this.queryAvailablePrompts();
        
        this.cache = {
            agents,
            prompts,
            timestamp: now
        };
        
        return this.cache;
    }

    /**
     * Query available agents from the agents map
     */
    private async queryAvailableAgents(): Promise<AgentInfo[]> {
        if (!this.agentsMap) {
            return [];
        }
        
        try {
            const agents: AgentInfo[] = [];
            
            for (const [name, agent] of this.agentsMap.entries()) {
                // Skip the AgentManager agent itself to avoid confusion
                if (name === 'agentManager') {
                    continue;
                }
                
                agents.push({
                    name,
                    description: agent.description || 'No description available',
                    enabled: true // Regular agents are always considered enabled
                });
            }
            
            return agents;
        } catch (error) {
            logger.systemError(error as Error, `${this.name} - Error querying available agents`);
            return [];
        }
    }

    /**
     * Query available custom prompts from storage service
     */
    private async queryAvailablePrompts(): Promise<PromptInfo[]> {
        if (!this.customPromptStorage) {
            return [];
        }
        
        try {
            // Check if custom prompts are enabled globally
            if (!this.customPromptStorage.isEnabled()) {
                return [];
            }
            
            const allPrompts = this.customPromptStorage.getAllPrompts();
            
            return allPrompts.map(prompt => ({
                id: prompt.id,
                name: prompt.name,
                description: prompt.description || 'No description available',
                enabled: prompt.isEnabled
            }));
        } catch (error) {
            logger.systemError(error as Error, `${this.name} - Error querying available prompts`);
            return [];
        }
    }

    /**
     * Clear cache (useful when agents or prompts change)
     */
    private clearCache(): void {
        this.cache = null;
    }
}
```

## handlers/services/providers/VaultSchemaProvider.ts

```typescript
/**
 * VaultSchemaProvider - Dynamic vault structure injection for VaultManager tool schemas
 * Location: /src/handlers/services/providers/VaultSchemaProvider.ts
 * 
 * This file provides dynamic enhancement of VaultManager tool schemas by injecting
 * current vault folder and file structure information. Uses the Obsidian Vault API
 * to query vault structure and enhance tool descriptions and parameter schemas
 * with contextual vault information for better Claude understanding.
 */

import { ISchemaProvider } from '../../interfaces/ISchemaProvider';
import { BaseSchemaProvider } from '../BaseSchemaProvider';
import { App, TFile, TFolder } from 'obsidian';
import { logger } from '../../../utils/logger';
import { FileUtils } from '../../../database/utils/FileUtils';

interface VaultStructureInfo {
  rootFolders: Array<{
    name: string;
    fileCount: number;
    subfolderCount: number;
  }>;
  rootFileCount: number;
  totalFiles: number;
  totalFolders: number;
  recentFiles: Array<{
    name: string;
    path: string;
    folder?: string;
  }>;
}

interface CachedVaultData {
  structure: VaultStructureInfo;
  timestamp: number;
  vaultName: string;
}

/**
 * Schema provider that injects current vault structure into VaultManager tool schemas
 * Extends BaseSchemaProvider to provide vault-specific context for file operations
 */
export class VaultSchemaProvider extends BaseSchemaProvider {
  readonly name = 'VaultSchemaProvider';
  readonly description = 'Injects current vault structure into VaultManager tool schemas for better context';
  
  private cache: CachedVaultData | null = null;
  private readonly CACHE_DURATION_MS = 30000; // 30 seconds
  private readonly MAX_FOLDERS_TO_SHOW = 10;
  private readonly MAX_FILES_TO_SHOW = 8;
  private readonly MAX_DEPTH = 2; // Root + 1 sublevel
  private app: App;

  constructor(app: App) {
    super();
    this.app = app;
  }

  /**
   * Get provider priority (higher numbers = higher priority)
   * VaultSchemaProvider has medium priority
   */
  getPriority(): number {
    return 50;
  }

  /**
   * Check if tool name should be enhanced by this provider
   * Only enhances VaultManager tools
   */
  protected shouldEnhanceToolName(toolName: string): boolean {
    // Check if this is a VaultManager tool
    return toolName.toLowerCase().includes('vault') || 
           toolName.toLowerCase().includes('vaultmanager');
  }

  /**
   * Enhance the schema with vault structure information
   * Adds vault context to relevant parameters and descriptions
   */
  async enhanceSchema(toolName: string, baseSchema: any): Promise<any> {
    return this.safeEnhance(async () => {
      const vaultInfo = await this.getVaultStructure();
      if (!vaultInfo) {
        return baseSchema;
      }

      // Deep clone to avoid modifying original using BaseSchemaProvider utility
      const enhanced = this.cloneSchema(baseSchema);

      // Enhance the schema based on available modes and properties
      this.enhanceSchemaWithVaultContext(enhanced, vaultInfo);
      
      // Log enhancement activity for debugging
      this.logEnhancement(toolName, 'Added vault structure context', {
        rootFolders: vaultInfo.rootFolders.length,
        totalFiles: vaultInfo.totalFiles
      });

      return enhanced;
    }, baseSchema, 'vault structure enhancement');
  }

  /**
   * Get vault structure information with caching
   * Limits depth to avoid schema bloat while providing useful context
   */
  private async getVaultStructure(): Promise<VaultStructureInfo | null> {
    try {
      // Check cache first
      const now = Date.now();
      if (this.cache && (now - this.cache.timestamp) < this.CACHE_DURATION_MS) {
        return this.cache.structure;
      }

      const markdownFiles = this.app.vault.getMarkdownFiles();
      const rootFolder = this.app.vault.getRoot();

      // Get root folders with file counts
      const rootFolders = rootFolder.children
        .filter(child => child instanceof TFolder)
        .slice(0, this.MAX_FOLDERS_TO_SHOW) // Limit to prevent schema bloat
        .map(folder => {
          const typedFolder = folder as TFolder;
          const filesInFolder = markdownFiles.filter(file => 
            file.path.startsWith(typedFolder.path + '/')
          ).length;

          const subfolderCount = typedFolder.children
            .filter(child => child instanceof TFolder)
            .length;

          return {
            name: typedFolder.name,
            fileCount: filesInFolder,
            subfolderCount
          };
        });

      // Get root files count
      const rootFileCount = markdownFiles.filter(file => !file.path.includes('/')).length;

      // Get recent files for examples
      const recentFiles = markdownFiles
        .sort((a, b) => b.stat.mtime - a.stat.mtime)
        .slice(0, this.MAX_FILES_TO_SHOW)
        .map(file => ({
          name: file.name,
          path: file.path,
          folder: file.path.includes('/') ? file.path.split('/')[0] : undefined
        }));

      const structure: VaultStructureInfo = {
        rootFolders,
        rootFileCount,
        totalFiles: markdownFiles.length,
        totalFolders: rootFolders.length,
        recentFiles
      };

      // Update cache
      this.cache = {
        structure,
        timestamp: now,
        vaultName: this.app.vault.getName()
      };

      return structure;
    } catch (error) {
      logger.systemError(error as Error, 'VaultSchemaProvider: Failed to get vault structure');
      return null;
    }
  }

  /**
   * Enhance schema with vault structure context
   * Adds contextual information to relevant parameters
   */
  private enhanceSchemaWithVaultContext(schema: any, vaultInfo: VaultStructureInfo): void {
    try {
      // Add vault structure information to the schema description
      if (schema.description) {
        const vaultContext = this.formatVaultStructureForDescription(vaultInfo);
        schema.description = `${schema.description}\n\n${vaultContext}`;
      }

      // Enhance properties based on their names and types
      if (schema.properties) {
        this.enhancePropertiesWithVaultContext(schema.properties, vaultInfo);
      }

      // Enhance conditional schemas in allOf array (used by ToolListService)
      if (schema.allOf && Array.isArray(schema.allOf)) {
        schema.allOf.forEach((condition: any) => {
          if (condition.then && condition.then.properties) {
            this.enhancePropertiesWithVaultContext(condition.then.properties, vaultInfo);
          }
        });
      }
    } catch (error) {
      logger.systemWarn(`VaultSchemaProvider: Failed to enhance schema with vault context: ${String(error)}`);
    }
  }

  /**
   * Enhance individual properties with vault context
   */
  private enhancePropertiesWithVaultContext(properties: any, vaultInfo: VaultStructureInfo): void {
    Object.keys(properties).forEach(propName => {
      const prop = properties[propName];
      
      // Enhance path-related properties
      if (this.isPathProperty(propName) && prop.type === 'string') {
        this.enhancePathProperty(prop, propName, vaultInfo);
      }
      
      // Enhance mode enum with contextual information
      if (propName === 'mode' && prop.enum && Array.isArray(prop.enum)) {
        this.enhanceModeProperty(prop, vaultInfo);
      }
    });
  }

  /**
   * Check if a property name indicates a file/folder path
   */
  private isPathProperty(propName: string): boolean {
    const pathKeywords = ['path', 'file', 'folder', 'directory', 'target', 'source', 'note'];
    return pathKeywords.some(keyword => propName.toLowerCase().includes(keyword));
  }

  /**
   * Enhance path properties with vault examples and context
   */
  private enhancePathProperty(prop: any, propName: string, vaultInfo: VaultStructureInfo): void {
    // Add vault-specific examples based on property type
    if (propName.toLowerCase().includes('folder') || propName.toLowerCase().includes('directory')) {
      // Folder-related properties
      const folderExamples = vaultInfo.rootFolders.slice(0, 3).map(f => f.name);
      if (folderExamples.length > 0) {
        prop.examples = folderExamples;
        
        prop.description = prop.description + 
          `\n\nAvailable folders: ${folderExamples.join(', ')}` +
          (vaultInfo.rootFolders.length > 3 ? ` (and ${vaultInfo.rootFolders.length - 3} more)` : '');
      }
    } else if (propName.toLowerCase().includes('file') || propName.toLowerCase().includes('note')) {
      // File-related properties
      const fileExamples = vaultInfo.recentFiles.slice(0, 3).map(f => f.path);
      if (fileExamples.length > 0) {
        prop.examples = fileExamples;
        
        prop.description = prop.description + 
          `\n\nRecent files: ${fileExamples.join(', ')}`;
      }
    } else {
      // General path properties (could be files or folders)
      const pathExamples = vaultInfo.rootFolders.slice(0, 2).map(f => f.name)
        .concat(vaultInfo.recentFiles.slice(0, 2).map(f => f.path));
      
      if (pathExamples.length > 0) {
        prop.examples = pathExamples.slice(0, 4);
        
        prop.description = prop.description + 
          `\n\nExample paths: ${pathExamples.slice(0, 3).join(', ')}`;
      }
    }
  }

  /**
   * Enhance mode property with contextual descriptions
   */
  private enhanceModeProperty(prop: any, vaultInfo: VaultStructureInfo): void {
    // Add vault context to mode description
    prop.description = prop.description + 
      `\n\nCurrent vault has ${vaultInfo.totalFiles} files in ${vaultInfo.totalFolders} folders.`;
  }

  /**
   * Format vault structure for schema description
   * Follows existing VaultManagerAgent.getVaultStructureSummary() pattern
   */
  private formatVaultStructureForDescription(structure: VaultStructureInfo): string {
    const summary = [
      `üìÅ Vault Structure: ${structure.totalFiles} files, ${structure.totalFolders} root folders`
    ];

    if (structure.rootFileCount > 0) {
      summary.push(`   ‚îî‚îÄ‚îÄ / (${structure.rootFileCount} files in root)`);
    }

    // Add folder structure (limited to prevent schema bloat)
    structure.rootFolders.slice(0, 5).forEach(folder => {
      const subfolderText = folder.subfolderCount > 0 ? `, ${folder.subfolderCount} subfolders` : '';
      summary.push(`   ‚îî‚îÄ‚îÄ ${folder.name}/ (${folder.fileCount} files${subfolderText})`);
    });

    if (structure.rootFolders.length > 5) {
      summary.push(`   ‚îî‚îÄ‚îÄ ... and ${structure.rootFolders.length - 5} more folders`);
    }

    // Add recent files as examples
    if (structure.recentFiles.length > 0) {
      summary.push(`\nüìÑ Recent files: ${structure.recentFiles.slice(0, 4).map(f => f.name).join(', ')}`);
    }

    return summary.join('\n');
  }

  /**
   * Clear cache (useful for testing or vault changes)
   */
  clearCache(): void {
    this.cache = null;
  }
}
```

## handlers/services/providers/WorkspaceSchemaProvider.ts

```typescript
/**
 * Location: /src/handlers/services/providers/WorkspaceSchemaProvider.ts
 * Purpose: Schema provider for injecting dynamic workspace information into MemoryManager tool schemas
 * 
 * This file enhances MemoryManager workspace-related modes with actual workspace IDs, names,
 * descriptions, and counts to help Claude understand available workspace options.
 * 
 * Used by: SchemaEnhancementService to enhance MemoryManager schemas during tool registration
 * Integrates with: WorkspaceService to query current workspace information
 */

import { ISchemaProvider } from '../../interfaces/ISchemaProvider';
import { WorkspaceService, GLOBAL_WORKSPACE_ID } from '../../../agents/memoryManager/services/WorkspaceService';
import { logger } from '../../../utils/logger';

/**
 * Workspace enhancement data structure
 */
interface WorkspaceEnhancementData {
  /** Available workspace IDs for enum options */
  workspaceIds: string[];
  /** Workspace details for descriptions */
  workspaces: Array<{
    id: string;
    name: string;
    description?: string;
  }>;
  /** Statistics for schema descriptions */
  stats: {
    totalCount: number;
  };
}

/**
 * Schema provider for workspace-related enhancements
 */
export class WorkspaceSchemaProvider implements ISchemaProvider {
  public readonly name = 'WorkspaceSchemaProvider';
  public readonly description = 'Enhances MemoryManager schemas with dynamic workspace information';

  private workspaceService: WorkspaceService;
  private targetModes: string[];
  private cache: Map<string, WorkspaceEnhancementData> = new Map();
  private enableCaching: boolean;

  /**
   * Create a new WorkspaceSchemaProvider
   * @param workspaceService WorkspaceService instance for querying workspaces
   * @param targetModes Specific modes to target (defaults to workspace modes)
   * @param enableCaching Whether to enable caching (defaults to true)
   */
  constructor(
    workspaceService: WorkspaceService,
    targetModes: string[] = ['loadWorkspace', 'listWorkspaces'],
    enableCaching: boolean = true
  ) {
    this.workspaceService = workspaceService;
    this.targetModes = targetModes;
    this.enableCaching = enableCaching;
  }

  /**
   * Check if this provider can enhance the given tool schema
   * @param toolName Tool name (e.g., "memoryManager")
   * @param baseSchema Base schema to potentially enhance
   * @returns Promise<boolean> true if this provider can enhance the schema
   */
  async canEnhance(toolName: string, baseSchema: any): Promise<boolean> {
    try {
      // Extract agent name from tool name (handle both "memoryManager" and "memoryManager_vaultName" formats)
      const agentName = toolName.split('_')[0];
      
      // Only enhance memoryManager agent
      if (agentName !== 'memoryManager') {
        return false;
      }

      // Check if the schema has mode property with workspace-related modes
      if (!baseSchema?.properties?.mode?.enum) {
        return false;
      }

      // Check if any target modes are present in the schema
      const schemaModes = baseSchema.properties.mode.enum as string[];
      const hasTargetMode = this.targetModes.some(mode => schemaModes.includes(mode));
      
      logger.systemLog(`canEnhance(${toolName}): ${hasTargetMode}`, 'WorkspaceSchemaProvider');
      return hasTargetMode;

    } catch (error) {
      logger.systemError(error instanceof Error ? error : new Error(String(error)), 'WorkspaceSchemaProvider canEnhance');
      return false;
    }
  }

  /**
   * Enhance the given schema with workspace information
   * @param toolName Tool name
   * @param baseSchema Base schema to enhance
   * @returns Promise<any> The enhanced schema
   */
  async enhanceSchema(toolName: string, baseSchema: any): Promise<any> {
    try {
      // Get workspace data
      const workspaceData = await this.fetchEnhancementData();

      // Apply enhancements to schema
      const enhancedSchema = this.applyEnhancement(baseSchema, workspaceData);

      logger.systemLog(`Enhanced schema for ${toolName} with ${workspaceData.workspaceIds.length} workspaces`, 'WorkspaceSchemaProvider');
      return enhancedSchema;

    } catch (error) {
      logger.systemError(error instanceof Error ? error : new Error(String(error)), `WorkspaceSchemaProvider enhanceSchema for ${toolName}`);
      
      // Return original schema on error
      return baseSchema;
    }
  }

  /**
   * Get the priority of this provider
   * @returns Priority number (higher = higher priority)
   */
  getPriority(): number {
    return 100; // High priority for workspace information
  }

  /**
   * Fetch workspace enhancement data
   * @returns Workspace enhancement data
   */
  private async fetchEnhancementData(): Promise<WorkspaceEnhancementData> {
    const cacheKey = 'workspace_data';
    
    // Check cache first
    if (this.enableCaching && this.cache.has(cacheKey)) {
      const cachedData = this.cache.get(cacheKey)!;
      logger.systemLog(`Using cached workspace data (${cachedData.stats.totalCount} workspaces)`, 'WorkspaceSchemaProvider');
      return cachedData;
    }

    try {
      // Query all workspaces
      const workspaces = await this.workspaceService.getWorkspaces();

      logger.systemLog(`Fetched ${workspaces.length} workspaces for schema enhancement`, 'WorkspaceSchemaProvider');

      // Extract workspace IDs and details
      const workspaceIds = workspaces.map(ws => ws.id);
      const workspaceDetails = workspaces.map(ws => ({
        id: ws.id,
        name: ws.name || 'Unnamed Workspace',
        description: ws.description
      }));

      // Calculate statistics
      const stats = {
        totalCount: workspaces.length
      };

      const enhancementData = {
        workspaceIds,
        workspaces: workspaceDetails,
        stats
      };

      // Cache the data if caching is enabled
      if (this.enableCaching) {
        this.cache.set(cacheKey, enhancementData);
      }

      return enhancementData;

    } catch (error) {
      logger.systemError(error instanceof Error ? error : new Error(String(error)), 'WorkspaceSchemaProvider fetchEnhancementData');
      
      // Return minimal fallback data with global workspace
      const fallbackData = {
        workspaceIds: [GLOBAL_WORKSPACE_ID],
        workspaces: [{
          id: GLOBAL_WORKSPACE_ID,
          name: 'Global Workspace',
          description: 'Default workspace for general work'
        }],
        stats: {
          totalCount: 1
        }
      };

      // Cache fallback data too
      if (this.enableCaching) {
        this.cache.set(cacheKey, fallbackData);
      }

      return fallbackData;
    }
  }

  /**
   * Apply workspace enhancement to schema
   * @param originalSchema Original schema
   * @param enhancementData Workspace enhancement data
   * @returns Enhanced schema
   */
  private applyEnhancement(originalSchema: any, enhancementData: WorkspaceEnhancementData): any {
    // Deep clone the original schema
    const enhancedSchema = JSON.parse(JSON.stringify(originalSchema));

    // Ensure properties exist
    if (!enhancedSchema.properties) {
      enhancedSchema.properties = {};
    }

    // Check which modes are available in this schema and enhance them
    const schemaModes = enhancedSchema.properties?.mode?.enum as string[] || [];
    
    // Enhance loadWorkspace mode if it exists
    if (schemaModes.includes('loadWorkspace') && this.targetModes.includes('loadWorkspace')) {
      this.enhanceLoadWorkspaceSchema(enhancedSchema, enhancementData);
    }

    // Enhance listWorkspaces mode if it exists
    if (schemaModes.includes('listWorkspaces') && this.targetModes.includes('listWorkspaces')) {
      this.enhanceListWorkspacesSchema(enhancedSchema, enhancementData);
    }

    return enhancedSchema;
  }

  /**
   * Enhance loadWorkspace mode schema with workspace options
   * @param schema Schema to enhance
   * @param data Enhancement data
   */
  private enhanceLoadWorkspaceSchema(schema: any, data: WorkspaceEnhancementData): void {
    if (!schema.properties.id) {
      return; // Skip if 'id' parameter doesn't exist
    }

    // Add enum with available workspace IDs
    schema.properties.id.enum = data.workspaceIds;

    // Enhance description with available workspaces
    const workspaceList = data.workspaces
      .map(ws => `"${ws.id}": ${ws.name}${ws.description ? ` - ${ws.description}` : ''}`)
      .join(', ');

    schema.properties.id.description = 
      `Workspace ID to load (REQUIRED). Available workspaces (${data.stats.totalCount} total): ${workspaceList}`;

    // Add workspace count information to schema description
    if (!schema.description) {
      schema.description = 'Load a workspace by ID and restore context and state';
    }
    
    schema.description += ` | ${data.stats.totalCount} workspaces available`;

    logger.systemLog(`Enhanced loadWorkspace schema with ${data.workspaceIds.length} workspace options`, 'WorkspaceSchemaProvider');
  }

  /**
   * Enhance listWorkspaces mode schema with workspace statistics
   * @param schema Schema to enhance
   * @param data Enhancement data
   */
  private enhanceListWorkspacesSchema(schema: any, data: WorkspaceEnhancementData): void {
    // Enhance schema description with current workspace counts
    if (!schema.description) {
      schema.description = 'List available workspaces with filters and sorting';
    }

    schema.description += ` | Current workspace inventory: ${data.stats.totalCount} total`;

    logger.systemLog(`Enhanced listWorkspaces schema with workspace statistics`, 'WorkspaceSchemaProvider');
  }

  /**
   * Create a pre-configured instance for MemoryManager workspace modes
   * @param workspaceService WorkspaceService instance
   * @returns Configured WorkspaceSchemaProvider
   */
  static forMemoryManager(workspaceService: WorkspaceService): WorkspaceSchemaProvider {
    return new WorkspaceSchemaProvider(
      workspaceService,
      ['loadWorkspace', 'listWorkspaces'],
      true
    );
  }

  /**
   * Create a provider for specific workspace modes
   * @param workspaceService WorkspaceService instance
   * @param targetModes Specific modes to target
   * @returns Configured WorkspaceSchemaProvider
   */
  static forModes(workspaceService: WorkspaceService, targetModes: string[]): WorkspaceSchemaProvider {
    return new WorkspaceSchemaProvider(workspaceService, targetModes, true);
  }

  /**
   * Clear the cache (useful for testing or when workspace data changes)
   */
  public clearCache(): void {
    this.cache.clear();
  }

  /**
   * Get the current cache size
   * @returns Number of cached entries
   */
  public getCacheSize(): number {
    return this.cache.size;
  }
}
```

## handlers/strategies/IRequestStrategy.ts

```typescript
export interface IRequestStrategy<TRequest = any, TResponse = any> {
    canHandle(request: TRequest): boolean;
    handle(request: TRequest): Promise<TResponse>;
}

export interface IRequestStrategyContext {
    agentName?: string;
    mode?: string;
    requestType?: string;
}
```

## handlers/strategies/PromptsGetStrategy.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

interface PromptsGetRequest {
    method: string;
    params?: {
        name: string;
        arguments?: Record<string, any>;
    };
}

interface PromptsGetResponse {
    description?: string;
    messages: Array<{
        role: 'user' | 'assistant';
        content: {
            type: 'text';
            text: string;
        };
    }>;
}

/**
 * Strategy for handling prompts get requests
 * Follows Strategy Pattern for clean request handling
 */
export class PromptsGetStrategy implements IRequestStrategy<PromptsGetRequest, PromptsGetResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies
    ) {}

    canHandle(request: PromptsGetRequest): boolean {
        return request.method === 'prompts/get';
    }

    async handle(request: PromptsGetRequest): Promise<PromptsGetResponse> {
        try {
            logger.systemLog('PromptsGetStrategy: Handling prompts get request');
            
            const promptName = request.params?.name;
            if (!promptName) {
                throw new McpError(ErrorCode.InvalidParams, 'Prompt name is required');
            }
            
            // Get the prompt content
            const promptContent = await this.dependencies.promptsListService.getPrompt(promptName);
            
            if (!promptContent) {
                throw new McpError(ErrorCode.InvalidParams, `Prompt "${promptName}" not found`);
            }
            
            // Return the prompt as a user message in MCP format
            return {
                messages: [
                    {
                        role: 'user',
                        content: {
                            type: 'text',
                            text: promptContent
                        }
                    }
                ]
            };
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'PromptsGetStrategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to get prompt', error);
        }
    }
}
```

## handlers/strategies/PromptsListStrategy.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

interface PromptsListRequest {
    method: string;
    params?: {
        category?: string;
    };
}

interface PromptsListResponse {
    prompts: Array<{
        name: string;
        description?: string;
        arguments?: any[];
    }>;
}

/**
 * Strategy for handling prompts list requests
 * Follows Strategy Pattern for clean request handling
 */
export class PromptsListStrategy implements IRequestStrategy<PromptsListRequest, PromptsListResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies
    ) {}

    canHandle(request: PromptsListRequest): boolean {
        return request.method === 'prompts/list';
    }

    async handle(request: PromptsListRequest): Promise<PromptsListResponse> {
        try {
            
            const category = request.params?.category;
            
            if (category) {
                return await this.dependencies.promptsListService.listPromptsByCategory(category);
            } else {
                return await this.dependencies.promptsListService.listPrompts();
            }
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'PromptsListStrategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to list prompts', error);
        }
    }
}
```

## handlers/strategies/ResourceListStrategy.ts

```typescript
import { App } from 'obsidian';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

interface ResourceListRequest {
    method: string;
    params?: {
        pathPrefix?: string;
    };
}

interface ResourceListResponse {
    resources: Array<{
        uri: string;
        name: string;
        mimeType: string;
    }>;
}

/**
 * Strategy for handling resource list requests
 * Follows Strategy Pattern for clean request handling
 */
export class ResourceListStrategy implements IRequestStrategy<ResourceListRequest, ResourceListResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies,
        private app: App
    ) {}

    canHandle(request: ResourceListRequest): boolean {
        return request.method === 'resources/list';
    }

    async handle(request: ResourceListRequest): Promise<ResourceListResponse> {
        try {
            
            const pathPrefix = request.params?.pathPrefix;
            
            if (pathPrefix) {
                return await this.dependencies.resourceListService.listResourcesByPath(pathPrefix);
            } else {
                return await this.dependencies.resourceListService.listResources();
            }
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ResourceListStrategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to list resources', error);
        }
    }
}
```

## handlers/strategies/ResourceReadStrategy.ts

```typescript
import { App } from 'obsidian';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

interface ResourceReadRequest {
    method: string;
    params: {
        uri: string;
        uris?: string[];
    };
}

interface ResourceReadResponse {
    contents: Array<{
        uri: string;
        text: string;
        mimeType: string;
    }>;
}

/**
 * Strategy for handling resource read requests
 * Follows Strategy Pattern for clean request handling
 */
export class ResourceReadStrategy implements IRequestStrategy<ResourceReadRequest, ResourceReadResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies,
        private app: App
    ) {}

    canHandle(request: ResourceReadRequest): boolean {
        return request.method === 'resources/read';
    }

    async handle(request: ResourceReadRequest): Promise<ResourceReadResponse> {
        try {
            logger.systemLog('ResourceReadStrategy: Handling resource read request');
            
            const { uri, uris } = request.params;
            
            // Validate parameters
            if (!uri && (!uris || uris.length === 0)) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Either uri or uris parameter is required'
                );
            }
            
            // Handle multiple URIs if provided
            if (uris && uris.length > 0) {
                return await this.dependencies.resourceReadService.readMultipleResources(uris);
            }
            
            // Handle single URI
            if (uri) {
                return await this.dependencies.resourceReadService.readResource(uri);
            }
            
            throw new McpError(
                ErrorCode.InvalidParams,
                'No valid URI provided for resource read'
            );
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ResourceReadStrategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to read resource', error);
        }
    }
}
```

## handlers/strategies/ToolExecutionStrategy.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies, IRequestContext } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { SessionContextManager } from '../../services/SessionContextManager';
import { logger } from '../../utils/logger';
import { getErrorMessage } from '../../utils/errorUtils';

interface ToolExecutionRequest {
    params: {
        name: string;
        arguments: any;
    };
}

interface ToolExecutionResponse {
    content: Array<{
        type: string;
        text: string;
    }>;
}

export class ToolExecutionStrategy implements IRequestStrategy<ToolExecutionRequest, ToolExecutionResponse> {
    private readonly instanceId = `TES_V2_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    private readonly buildVersion = 'BUILD_20250803_1755'; // Force new instances
    
    constructor(
        private dependencies: IRequestHandlerDependencies,
        private getAgent: (name: string) => IAgent,
        private sessionContextManager?: SessionContextManager,
        private onToolResponse?: (toolName: string, params: any, response: any, success: boolean, executionTime: number) => Promise<void>
    ) {
        // ToolExecutionStrategy initialized with callback support
    }

    canHandle(request: ToolExecutionRequest): boolean {
        return !!(request.params && request.params.name && request.params.arguments);
    }

    async handle(request: ToolExecutionRequest): Promise<ToolExecutionResponse> {
        const startTime = Date.now();
        let context: any;
        let success = false;
        let result: any;
        
        try {
            context = await this.buildRequestContext(request);
            const processedParams = await this.processParameters(context);
            result = await this.executeTool(context, processedParams);
            success = true;
            
            // Trigger response capture callback if available
            if (this.onToolResponse) {
                try {
                    const executionTime = Date.now() - startTime;
                    await this.onToolResponse(
                        request.params.name,
                        context.params,
                        result,
                        success,
                        executionTime
                    );
                } catch (captureError) {
                    console.warn('[ToolExecutionStrategy] Response capture failed:', captureError);
                }
            }
            
            return this.dependencies.responseFormatter.formatToolExecutionResponse(
                result,
                context.sessionInfo
            );
        } catch (error) {
            // Trigger error response capture callback if available
            if (this.onToolResponse && context) {
                try {
                    const executionTime = Date.now() - startTime;
                    await this.onToolResponse(
                        request.params.name,
                        context.params,
                        { error: (error as Error).message },
                        false,
                        executionTime
                    );
                } catch (captureError) {
                    console.warn('[ToolExecutionStrategy] Error response capture failed:', captureError);
                }
            }
            
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'Tool Execution Strategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to execute tool', error);
        }
    }

    private async buildRequestContext(request: ToolExecutionRequest): Promise<IRequestContext & { sessionInfo: any }> {
        const { name: fullToolName, arguments: parsedArgs } = request.params;
        
        if (!parsedArgs) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `Missing arguments for tool ${fullToolName}`
            );
        }

        const agentName = this.extractAgentName(fullToolName);
        const { mode, ...params } = parsedArgs as { mode: string; [key: string]: any };
        
        if (!mode) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `Missing required parameter: mode for agent ${agentName}`
            );
        }

        // Use SessionContextManager for unified session handling instead of separate SessionService
        const sessionId = params.context?.sessionId || params.sessionId;
        
        let sessionInfo: any;
        if (this.sessionContextManager && sessionId) {
            try {
                const validationResult = await this.sessionContextManager.validateSessionId(sessionId);
                const isNonStandardId = validationResult.id !== sessionId;
                
                sessionInfo = {
                    sessionId: validationResult.id,
                    isNewSession: validationResult.created,
                    isNonStandardId: isNonStandardId,
                    originalSessionId: isNonStandardId ? sessionId : undefined
                };
                
                // Update params with validated session ID (both locations for compatibility)
                if (params.context) {
                    params.context.sessionId = validationResult.id;
                }
                params.sessionId = validationResult.id;
            } catch (error) {
                logger.systemWarn(`SessionContextManager validation failed: ${getErrorMessage(error)}. Falling back to SessionService`);
                // Fallback to original SessionService if SessionContextManager fails
                sessionInfo = await this.dependencies.sessionService.processSessionId(sessionId);
                if (params.context) {
                    params.context.sessionId = sessionInfo.sessionId;
                }
                params.sessionId = sessionInfo.sessionId;
            }
        } else {
            // Fallback to original SessionService if no SessionContextManager or sessionId
            sessionInfo = await this.dependencies.sessionService.processSessionId(sessionId);
            if (params.context) {
                params.context.sessionId = sessionInfo.sessionId;
            }
            params.sessionId = sessionInfo.sessionId;
        }
        
        const shouldInjectInstructions = this.dependencies.sessionService.shouldInjectInstructions(
            sessionInfo.sessionId, 
            this.sessionContextManager
        );

        return {
            agentName,
            mode,
            params,
            sessionId: sessionInfo.sessionId,
            fullToolName,
            sessionContextManager: this.sessionContextManager,
            sessionInfo: {
                ...sessionInfo,
                shouldInjectInstructions
            }
        };
    }

    private async processParameters(context: IRequestContext): Promise<any> {
        const agent = this.getAgent(context.agentName);
        const modeInstance = agent.getMode(context.mode);
        
        let paramSchema;
        try {
            if (modeInstance && typeof modeInstance.getParameterSchema === 'function') {
                paramSchema = modeInstance.getParameterSchema();
            }
        } catch (error) {
            logger.systemWarn(`Failed to get parameter schema for mode ${context.mode}: ${getErrorMessage(error)}`);
        }

        const enhancedParams = await this.dependencies.validationService.validateToolParams(
            context.params, 
            paramSchema,
            context.fullToolName
        );

        // Session validation is now handled in buildRequestContext() to avoid duplication
        // Only handle session description updates here if needed
        if (this.sessionContextManager && enhancedParams.context?.sessionId && enhancedParams.context?.sessionDescription) {
            try {
                await this.sessionContextManager.updateSessionDescription(enhancedParams.context.sessionId, enhancedParams.context.sessionDescription);
            } catch (error) {
                logger.systemWarn(`Session description update failed: ${getErrorMessage(error)}`);
            }
        }

        let processedParams = { ...enhancedParams };
        if (this.sessionContextManager && processedParams.context?.sessionId) {
            // Check if we need to apply workspace context from session manager
            // Skip if we already have workspaceId in context or workspaceContext
            const hasWorkspaceId = processedParams.context?.workspaceId || 
                                   (processedParams.workspaceContext && processedParams.workspaceContext.workspaceId);
            
            if (!hasWorkspaceId) {
                processedParams = this.sessionContextManager.applyWorkspaceContext(
                    processedParams.context.sessionId, 
                    processedParams
                );
            }
            
            // If we have workspaceId in context but no workspaceContext, create one for backward compatibility
            if (processedParams.context?.workspaceId && !processedParams.workspaceContext) {
                processedParams.workspaceContext = {
                    workspaceId: processedParams.context.workspaceId,
                    workspacePath: [],
                    contextDepth: 'standard'
                };
            }
        }

        return processedParams;
    }

    private async executeTool(context: IRequestContext, processedParams: any): Promise<any> {
        const agent = this.getAgent(context.agentName);
        const result = await this.dependencies.toolExecutionService.executeAgent(
            agent,
            context.mode,
            processedParams
        );

        if (this.sessionContextManager && processedParams.sessionId && result.workspaceContext) {
            this.sessionContextManager.updateFromResult(processedParams.sessionId, result);
        }


        return result;
    }

    private extractAgentName(toolName: string): string {
        const lastUnderscoreIndex = toolName.lastIndexOf('_');
        return lastUnderscoreIndex === -1 ? toolName : toolName.substring(0, lastUnderscoreIndex);
    }
}
```

## handlers/strategies/ToolHelpStrategy.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { logger } from '../../utils/logger';

interface ToolHelpRequest {
    method: string;
    params: {
        name: string;
        arguments: {
            mode: string;
        };
    };
}

interface ToolHelpResponse {
    content: Array<{
        type: string;
        text: string;
    }>;
}

/**
 * Strategy for handling tool help requests
 * Follows Strategy Pattern for clean request handling
 */
export class ToolHelpStrategy implements IRequestStrategy<ToolHelpRequest, ToolHelpResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies,
        private getAgent: (name: string) => IAgent
    ) {}

    canHandle(request: ToolHelpRequest): boolean {
        return request.method === 'tools/help';
    }

    async handle(request: ToolHelpRequest): Promise<ToolHelpResponse> {
        try {
            logger.systemLog('ToolHelpStrategy: Handling tool help request');
            
            const { name: toolName, arguments: args } = request.params;
            const { mode } = args;
            
            // Validate required parameters
            if (!toolName) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Tool name is required for help request'
                );
            }
            
            if (!mode) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Mode parameter is required for tool help'
                );
            }
            
            // Generate help using the service
            return await this.dependencies.toolHelpService.generateToolHelp(
                this.getAgent,
                toolName,
                mode
            );
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ToolHelpStrategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to get tool help', error);
        }
    }
}
```

## handlers/strategies/ToolListStrategy.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { logger } from '../../utils/logger';

interface ToolListRequest {
    method: string;
}

interface ToolListResponse {
    tools: any[];
}

export class ToolListStrategy implements IRequestStrategy<ToolListRequest, ToolListResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies,
        private agents: Map<string, IAgent>,
        private isVaultEnabled: boolean,
        private vaultName?: string
    ) {}

    canHandle(request: ToolListRequest): boolean {
        return request.method === 'tools/list';
    }

    async handle(request: ToolListRequest): Promise<ToolListResponse> {
        try {
            return await this.dependencies.toolListService.generateToolList(
                this.agents,
                this.isVaultEnabled,
                this.vaultName
            );
        } catch (error) {
            logger.systemError(error as Error, "Tool List Strategy");
            throw new McpError(ErrorCode.InternalError, 'Failed to list tools', error);
        }
    }
}
```

## main.ts

```typescript
import { Plugin, Notice } from 'obsidian';
import { MCPConnector } from './connector';
import { WorkspaceService } from './agents/memoryManager/services/WorkspaceService';
import { MemoryService } from './agents/memoryManager/services/MemoryService';
import { ConversationService } from './services/ConversationService';
import { DataMigrationService } from './services/migration/DataMigrationService';
import { SettingsTab } from './components/SettingsTab';
import { Settings } from './settings';

export default class ClaudesidianPlugin extends Plugin {
    private connector!: MCPConnector;
    private workspaceService!: WorkspaceService;
    private memoryService!: MemoryService;
    private conversationService!: ConversationService;
    private migrationService!: DataMigrationService;
    public settingsManager!: Settings;
    public settings: any;

    async onload() {
        try {
            // Load plugin settings first before creating any services
            this.settings = await this.loadData();
            this.settingsManager = new Settings(this);
            await this.settingsManager.loadSettings();

            // Initialize simplified services
            this.workspaceService = new WorkspaceService(this);
            this.memoryService = new MemoryService(this);
            this.conversationService = new ConversationService(this);
            this.migrationService = new DataMigrationService(this);

            // Check and perform migration if needed
            await this.checkAndPerformMigration();

            // Initialize MCP connector
            this.connector = new MCPConnector(this.app, this);
            await this.connector.start();

            // Add settings tab
            this.addSettingTab(new SettingsTab(
                this.app,
                this,
                this.settingsManager,
                {
                    workspaceService: this.workspaceService,
                    memoryService: this.memoryService
                }
            ));

        } catch (error) {
            console.error('Plugin loading failed:', error);
            throw error;
        }
    }

    async onunload() {
        if (this.connector) {
            await this.connector.stop();
        }
    }

    /**
     * Check and perform data migration if needed
     */
    private async checkAndPerformMigration(): Promise<void> {
        try {
            const migrationStatus = await this.migrationService.checkMigrationStatus();

            if (migrationStatus.isRequired) {
                new Notice('Claudesidian: Migrating data to new format...', 5000);
                const migrationResult = await this.migrationService.performMigration();

                if (migrationResult.success) {
                    new Notice('Claudesidian: Data migration completed successfully!', 8000);
                } else {
                    console.error('[Claudesidian] Migration failed:', migrationResult.errors);
                    new Notice(`Claudesidian: Migration failed. Check console for details.`, 10000);
                }
            }
        } catch (error) {
            console.error('[Claudesidian] Migration check error:', error);
            new Notice('Claudesidian: Error checking migration status', 5000);
        }
    }

    // Service accessors
    public get services() {
        return {
            workspaceService: this.workspaceService,
            memoryService: this.memoryService,
            conversationService: this.conversationService,
            migrationService: this.migrationService
        };
    }

    // Service getter method for compatibility
    public getService(serviceName: string) {
        const services = this.services;
        switch (serviceName) {
            case 'workspaceService':
                return services.workspaceService;
            case 'memoryService':
                return services.memoryService;
            case 'conversationService':
                return services.conversationService;
            case 'migrationService':
                return services.migrationService;
            default:
                return undefined;
        }
    }
}
```

## obsidian.d.ts

```typescript
import { App as ObsidianApp } from 'obsidian';

// Extend the Obsidian App interface to include the version property
declare module 'obsidian' {
  interface App extends ObsidianApp {
    version: string;
  }
}

declare global {
  interface Window {
    app: App;
    mcpProgressHandlers?: {
      updateProgress: (data: any) => void;
      completeProgress: (data: any) => void;
      cancelProgress: (data: any) => void;
    };
  }
}

export {};
```

## server.ts

```typescript
/**
 * server.ts - Refactored following SOLID principles
 * Main export for backward compatibility
 */

// Export the refactored MCPServer as the main MCPServer
export { MCPServer } from './server/MCPServer';

// Export specialized services for direct use if needed
export { ServerConfiguration } from './server/services/ServerConfiguration';
export { AgentRegistry } from './server/services/AgentRegistry';
export { StdioTransportManager } from './server/transport/StdioTransportManager';
export { IPCTransportManager } from './server/transport/IPCTransportManager';
export { RequestHandlerFactory } from './server/handlers/RequestHandlerFactory';
export { ServerLifecycleManager } from './server/lifecycle/ServerLifecycleManager';
export { AgentExecutionManager } from './server/execution/AgentExecutionManager';

// Export types if needed
export type { ServerConfigurationOptions } from './server/services/ServerConfiguration';
```

## server/MCPServer.ts

```typescript
/**
 * MCPServer - Refactored following SOLID principles
 * Main orchestrator for MCP server operations
 */

import { App, Plugin } from 'obsidian';
import { IMCPServer, ServerStatus } from '../types';
import { IAgent } from '../agents/interfaces/IAgent';
import { EventManager } from '../services/EventManager';
import { SessionContextManager } from '../services/SessionContextManager';
import { CustomPromptStorageService } from "../agents/agentManager/services/CustomPromptStorageService";
import { Server as MCPSDKServer } from '@modelcontextprotocol/sdk/server/index.js';
import { RequestRouter } from '../handlers/RequestRouter';
import { logger } from '../utils/logger';
import { getErrorMessage } from '../utils/errorUtils';

// Import specialized services
import { ServerConfiguration } from './services/ServerConfiguration';
import { AgentRegistry } from './services/AgentRegistry';
import { HttpTransportManager } from './transport/HttpTransportManager';
import { IPCTransportManager } from './transport/IPCTransportManager';
import { StdioTransportManager } from './transport/StdioTransportManager';
import { RequestHandlerFactory } from './handlers/RequestHandlerFactory';
import { ServerLifecycleManager } from './lifecycle/ServerLifecycleManager';
import { AgentExecutionManager } from './execution/AgentExecutionManager';

/**
 * Refactored MCP Server following SOLID principles
 * Orchestrates specialized services for server operations
 */
export class MCPServer implements IMCPServer {
    // Core SDK server
    private server: MCPSDKServer;
    
    // Specialized services following Dependency Injection principle
    private configuration: ServerConfiguration;
    private agentRegistry: AgentRegistry;
    private httpTransportManager: HttpTransportManager;
    private stdioTransportManager: StdioTransportManager;
    private ipcTransportManager: IPCTransportManager;
    private requestHandlerFactory: RequestHandlerFactory;
    private lifecycleManager: ServerLifecycleManager;
    private executionManager: AgentExecutionManager;
    
    // Request routing
    private requestRouter!: RequestRouter;

    constructor(
        private app: App,
        _plugin: Plugin,
        private eventManager: EventManager,
        private sessionContextManager?: SessionContextManager,
        serverName?: string,
        private customPromptStorage?: CustomPromptStorageService,
        private onToolCall?: (toolName: string, params: any) => Promise<void>,
        private onToolResponse?: (toolName: string, params: any, response: any, success: boolean, executionTime: number) => Promise<void>
    ) {
        // Initialize configuration service
        this.configuration = new ServerConfiguration(app, { serverName });
        
        // Initialize core SDK server
        this.server = this.createMCPSDKServer();
        
        // Initialize specialized services
        this.agentRegistry = new AgentRegistry();
        this.httpTransportManager = new HttpTransportManager(this.server, 3000, 'localhost');
        this.stdioTransportManager = new StdioTransportManager(this.server);
        this.ipcTransportManager = new IPCTransportManager(this.configuration, this.stdioTransportManager);
        this.executionManager = new AgentExecutionManager(this.agentRegistry, sessionContextManager);
        
        // Initialize request routing
        this.initializeRequestRouter();
        
        // Initialize request handlers
        this.requestHandlerFactory = new RequestHandlerFactory(
            this.server,
            this.requestRouter,
            this.onToolCall
        );
        
        // Initialize lifecycle manager
        this.lifecycleManager = new ServerLifecycleManager(
            this.agentRegistry,
            this.httpTransportManager as any,
            this.ipcTransportManager,
            this.eventManager
        );
        
        // Setup handlers
        this.requestHandlerFactory.initializeHandlers();
    }

    /**
     * Create the MCP SDK server instance
     */
    private createMCPSDKServer(): MCPSDKServer {
        try {
            return new MCPSDKServer(
                this.configuration.getServerInfo(),
                this.configuration.getServerOptions()
            );
        } catch (error) {
            logger.systemError(error as Error, 'MCP SDK Server Creation');
            throw error;
        }
    }

    /**
     * Initialize the request router
     */
    private initializeRequestRouter(): void {
        try {
            this.requestRouter = new RequestRouter(
                this.app,
                this.agentRegistry.getAgents(),
                true, // isVaultEnabled
                this.configuration.getSanitizedVaultName(),
                this.sessionContextManager,
                this.customPromptStorage,
                this.onToolResponse
            );
        } catch (error) {
            logger.systemError(error as Error, 'Request Router Initialization');
            throw error;
        }
    }

    /**
     * Start the MCP server
     */
    async start(): Promise<void> {
        await this.lifecycleManager.startServer();
    }

    /**
     * Stop the MCP server
     */
    async stop(): Promise<void> {
        await this.lifecycleManager.stopServer();
    }

    /**
     * Check if the server is running
     */
    isRunning(): boolean {
        return this.lifecycleManager.isRunning();
    }

    /**
     * Get the current server status
     */
    getStatus(): ServerStatus {
        return this.lifecycleManager.getStatus();
    }

    /**
     * Register an agent with the server
     */
    registerAgent(agent: IAgent): void {
        this.agentRegistry.registerAgent(agent);
    }

    /**
     * Get an agent by name
     */
    getAgent(name: string): IAgent {
        return this.agentRegistry.getAgent(name);
    }

    /**
     * Get all registered agents
     */
    getAgents(): Map<string, IAgent> {
        return this.agentRegistry.getAgents();
    }

    /**
     * Get detailed help for a specific mode
     */
    getModeHelp(agentName: string, modeName: string): string {
        return this.executionManager.getModeHelp(agentName, modeName);
    }

    /**
     * Execute a mode on an agent
     */
    async executeAgentMode(agentName: string, mode: string, params: any): Promise<any> {
        return await this.executionManager.executeAgentModeWithValidation(agentName, mode, params);
    }

    /**
     * Get server configuration summary
     */
    getConfigurationSummary(): any {
        return this.configuration.getConfigurationSummary();
    }

    /**
     * Get server diagnostics
     */
    async getDiagnostics(): Promise<any> {
        return await this.lifecycleManager.getDiagnostics();
    }

    /**
     * Perform health check
     */
    async performHealthCheck(): Promise<any> {
        return await this.lifecycleManager.performHealthCheck();
    }

    /**
     * Get execution statistics
     */
    getExecutionStatistics(): any {
        return this.executionManager.getExecutionStatistics();
    }

    /**
     * Get request handler statistics
     */
    getRequestHandlerStatistics(): any {
        return this.requestHandlerFactory.getHandlerStatistics();
    }

    /**
     * Restart the server
     */
    async restart(): Promise<void> {
        await this.lifecycleManager.restartServer();
    }

    /**
     * Force shutdown (emergency stop)
     */
    async forceShutdown(): Promise<void> {
        await this.lifecycleManager.forceShutdown();
    }

    /**
     * Get detailed server status
     */
    getDetailedStatus(): any {
        return this.lifecycleManager.getDetailedStatus();
    }

    /**
     * Get agent statistics
     */
    getAgentStatistics(): any {
        return this.agentRegistry.getAgentStatistics();
    }

    /**
     * Get transport status
     */
    getTransportStatus(): {
        http: any;
        ipc: any;
    } {
        return {
            http: this.httpTransportManager.getTransportStatus(),
            ipc: this.ipcTransportManager.getTransportStatus()
        };
    }

    /**
     * Get HTTP server URL for MCP integration
     */
    getServerUrl(): string {
        return this.httpTransportManager.getServerUrl();
    }

    /**
     * Validate execution parameters
     */
    validateExecutionParameters(agentName: string, mode: string, params: any): any {
        return this.executionManager.validateExecutionParameters(agentName, mode, params);
    }

    /**
     * Get execution context info
     */
    getExecutionContextInfo(sessionId?: string): any {
        return this.executionManager.getExecutionContextInfo(sessionId);
    }

    /**
     * Get agent mode schema
     */
    getAgentModeSchema(agentName: string, modeName: string): any {
        return this.executionManager.getAgentModeSchema(agentName, modeName);
    }

    /**
     * Update server configuration
     */
    updateConfiguration(updates: any): void {
        if (updates.capabilities) {
            this.configuration.updateCapabilities(updates.capabilities);
        }
    }

    /**
     * Reinitialize request router with current agents
     * Call this after agents have been registered
     */
    reinitializeRequestRouter(): void {
        try {
            this.requestRouter = new RequestRouter(
                this.app,
                this.agentRegistry.getAgents(),
                true, // isVaultEnabled
                this.configuration.getSanitizedVaultName(),
                this.sessionContextManager,
                this.customPromptStorage,
                this.onToolResponse // Callback should be available as class property
            );
            
            // Register WorkspaceSchemaProvider after RequestRouter is created with agents
            this.requestRouter.registerWorkspaceSchemaProvider().catch(error => {
                logger.systemError(error as Error, 'WorkspaceSchemaProvider Registration');
            });
            
            // Reinitialize request handlers with new router
            this.requestHandlerFactory = new RequestHandlerFactory(
                this.server,
                this.requestRouter,
                this.onToolCall
            );
            this.requestHandlerFactory.initializeHandlers();
        } catch (error) {
            logger.systemError(error as Error, 'Request Router Reinitialization');
            throw error;
        }
    }

    /**
     * Get server info
     */
    getServerInfo(): any {
        return {
            configuration: this.configuration.getConfigurationSummary(),
            status: this.getDetailedStatus(),
            agents: this.getAgentStatistics(),
            transports: this.getTransportStatus(),
            handlers: this.getRequestHandlerStatistics(),
            execution: this.getExecutionStatistics()
        };
    }
}
```

## server/execution/AgentExecutionManager.ts

```typescript
/**
 * AgentExecutionManager - Handles agent execution and session management
 * Follows Single Responsibility Principle by focusing only on agent execution
 */

import { AgentRegistry } from '../services/AgentRegistry';
import { SessionContextManager } from '../../services/SessionContextManager';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';
import { getErrorMessage } from '../../utils/errorUtils';
import { generateModeHelp, formatModeHelp } from '../../utils/parameterHintUtils';

/**
 * Service responsible for agent execution and session management
 * Follows SRP by focusing only on agent execution operations
 */
export class AgentExecutionManager {
    constructor(
        private agentRegistry: AgentRegistry,
        private sessionContextManager?: SessionContextManager
    ) {}

    /**
     * Execute a mode on an agent
     */
    async executeAgentMode(agentName: string, mode: string, params: any): Promise<any> {
        try {
            // Get the agent
            const agent = this.agentRegistry.validateAndGetAgent(agentName);

            // Process session context
            const processedParams = await this.processSessionContext(params);

            // Execute the mode
            const result = await agent.executeMode(mode, processedParams);

            // Update session context with result
            await this.updateSessionContext(processedParams, result);

            // Add session instructions if needed
            return this.addSessionInstructions(processedParams, result);
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            throw new McpError(
                ErrorCode.InternalError,
                `Failed to execute agent ${agentName} in mode ${mode}`,
                error
            );
        }
    }

    /**
     * Get detailed help for a specific mode
     */
    getModeHelp(agentName: string, modeName: string): string {
        try {
            // Get the agent
            const agent = this.agentRegistry.validateAndGetAgent(agentName);

            // Get the mode
            const mode = agent.getMode(modeName);

            if (!mode) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    `Mode ${modeName} not found in agent ${agentName}`
                );
            }

            // Get the mode's parameter schema
            const schema = mode.getParameterSchema();

            // Generate mode help
            const help = generateModeHelp(
                modeName,
                mode.description,
                schema
            );

            // Format and return the help
            return formatModeHelp(help);
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            throw new McpError(
                ErrorCode.InternalError,
                `Failed to get help for agent ${agentName} mode ${modeName}`,
                error
            );
        }
    }

    /**
     * Process session context for parameters
     */
    private async processSessionContext(params: any): Promise<any> {
        if (!this.sessionContextManager || !params.sessionId) {
            return params;
        }

        const originalSessionId = params.sessionId;

        try {
            // DIAGNOSTIC: Track session ID flow
            
            // Validate session ID - destructure the result to get the actual ID
            const {id: validatedSessionId, created} = await this.sessionContextManager.validateSessionId(params.sessionId);
            
            
            params.sessionId = validatedSessionId;
            

            // Apply workspace context
            params = this.sessionContextManager.applyWorkspaceContext(params.sessionId, params);

            return params;
        } catch (error) {
            logger.systemWarn(`Session validation failed: ${getErrorMessage(error)}. Using original ID`);
            return params;
        }
    }

    /**
     * Update session context with execution result
     */
    private async updateSessionContext(params: any, result: any): Promise<void> {
        if (!this.sessionContextManager || !params.sessionId || !result.workspaceContext) {
            return;
        }

        try {
            this.sessionContextManager.updateFromResult(params.sessionId, result);
        } catch (error) {
            logger.systemWarn(`Session context update failed: ${getErrorMessage(error)}`);
        }
    }

    /**
     * Add session instructions to result if needed
     */
    private addSessionInstructions(params: any, result: any): any {
        if (!this.sessionContextManager) {
            return result;
        }

        const needsInstructions = (params._isNewSession || params._isNonStandardId) && 
                               result && 
                               !this.sessionContextManager.hasReceivedInstructions(params.sessionId);

        if (!needsInstructions) {
            return result;
        }

        // Add session instructions
        if (params._isNonStandardId && params._originalSessionId) {
            result.sessionIdCorrection = {
                originalId: params._originalSessionId,
                correctedId: params.sessionId,
                message: "Your session ID has been standardized. Please use this corrected session ID for all future requests in this conversation."
            };
        } else if (params._isNewSession && !params._originalSessionId) {
            result.newSessionInfo = {
                sessionId: params.sessionId,
                message: "A new session has been created. This ID must be used for all future requests in this conversation."
            };
        }

        // Mark instructions as received
        this.sessionContextManager.markInstructionsReceived(params.sessionId);

        return result;
    }

    /**
     * Add auto-generated session info if needed
     */
    private addAutoGeneratedSessionInfo(params: any, result: any): any {
        if (!params._autoGeneratedSessionId || !result || params._originalSessionId) {
            return result;
        }

        result.newSessionId = params.sessionId;
        result.validSessionInfo = {
            originalId: null,
            newId: params.sessionId,
            message: "No session ID was provided. A new session has been created. Please use this session ID for future requests."
        };

        return result;
    }

    /**
     * Get execution statistics
     */
    getExecutionStatistics(): {
        totalAgents: number;
        totalModes: number;
        availableModes: Array<{
            agentName: string;
            modeName: string;
            description: string;
        }>;
        hasSessionManager: boolean;
    } {
        const agentStats = this.agentRegistry.getAgentStatistics();
        const availableModes = this.agentRegistry.getAllAvailableModes();

        return {
            totalAgents: agentStats.totalAgents,
            totalModes: availableModes.length,
            availableModes,
            hasSessionManager: !!this.sessionContextManager
        };
    }

    /**
     * Validate execution parameters
     */
    validateExecutionParameters(agentName: string, mode: string, params: any): {
        isValid: boolean;
        errors: string[];
        warnings: string[];
    } {
        const errors: string[] = [];
        const warnings: string[] = [];

        // Validate agent name
        if (!agentName || typeof agentName !== 'string') {
            errors.push('Agent name must be a non-empty string');
        } else if (!this.agentRegistry.hasAgent(agentName)) {
            errors.push(`Agent ${agentName} not found`);
        }

        // Validate mode
        if (!mode || typeof mode !== 'string') {
            errors.push('Mode must be a non-empty string');
        } else if (agentName && !this.agentRegistry.agentSupportsMode(agentName, mode)) {
            errors.push(`Agent ${agentName} does not support mode ${mode}`);
        }

        // Validate params
        if (params === null || params === undefined) {
            errors.push('Parameters cannot be null or undefined');
        } else if (typeof params !== 'object') {
            errors.push('Parameters must be an object');
        }

        // Session warnings
        if (params && params.sessionId && !this.sessionContextManager) {
            warnings.push('Session ID provided but no session context manager available');
        }

        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }

    /**
     * Execute agent mode with validation
     */
    async executeAgentModeWithValidation(agentName: string, mode: string, params: any): Promise<any> {
        // Validate parameters
        const validation = this.validateExecutionParameters(agentName, mode, params);
        
        if (!validation.isValid) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `Invalid execution parameters: ${validation.errors.join(', ')}`
            );
        }

        // Log warnings
        validation.warnings.forEach(warning => {
            logger.systemWarn(warning);
        });

        // Execute with validation passed
        return await this.executeAgentMode(agentName, mode, params);
    }

    /**
     * Get agent mode schema
     */
    getAgentModeSchema(agentName: string, modeName: string): any {
        const agent = this.agentRegistry.validateAndGetAgent(agentName);
        const mode = agent.getMode(modeName);

        if (!mode) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `Mode ${modeName} not found in agent ${agentName}`
            );
        }

        return mode.getParameterSchema();
    }

    /**
     * Get execution context info
     */
    getExecutionContextInfo(sessionId?: string): {
        hasSessionManager: boolean;
        sessionContext?: any;
        workspaceContext?: any;
    } {
        const info: any = {
            hasSessionManager: !!this.sessionContextManager
        };

        if (this.sessionContextManager && sessionId) {
            try {
                // Get session context if available
                const sessionContext = (this.sessionContextManager as any).getSessionContext?.(sessionId);
                if (sessionContext) {
                    info.sessionContext = sessionContext;
                }
                
                // Get workspace context if available
                const workspaceContext = (this.sessionContextManager as any).getWorkspaceContext?.(sessionId);
                if (workspaceContext) {
                    info.workspaceContext = workspaceContext;
                }
            } catch (error) {
                logger.systemWarn(`Failed to get execution context: ${getErrorMessage(error)}`);
            }
        }

        return info;
    }
}
```

## server/handlers/RequestHandlerFactory.ts

```typescript
/**
 * RequestHandlerFactory - Creates and configures request handlers
 * Follows Single Responsibility Principle by focusing only on handler setup
 */

import { Server as MCPSDKServer } from '@modelcontextprotocol/sdk/server/index.js';
import {
    ListResourcesRequestSchema,
    ReadResourceRequestSchema,
    ListToolsRequestSchema,
    CallToolRequestSchema,
    ListPromptsRequestSchema,
    GetPromptRequestSchema
} from '@modelcontextprotocol/sdk/types.js';
import { RequestRouter } from '../../handlers/RequestRouter';
import { parseJsonArrays } from '../../utils/jsonUtils';
import { logger } from '../../utils/logger';

/**
 * Service responsible for creating and configuring request handlers
 * Follows SRP by focusing only on handler setup operations
 */
export class RequestHandlerFactory {
    constructor(
        private server: MCPSDKServer,
        private requestRouter: RequestRouter,
        private onToolCall?: (toolName: string, params: any) => Promise<void>
    ) {}

    /**
     * Initialize all request handlers
     */
    initializeHandlers(): void {
        this.setupResourceHandlers();
        this.setupPromptHandlers();
        this.setupToolHandlers();
    }

    /**
     * Setup resource request handlers
     */
    private setupResourceHandlers(): void {
        // Handle resource listing
        this.server.setRequestHandler(ListResourcesRequestSchema, async (request) => {
            return await this.requestRouter.handleRequest('resources/list', request);
        });

        // Handle resource reading
        this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
            return await this.requestRouter.handleRequest('resources/read', request);
        });
    }

    /**
     * Setup prompt request handlers
     */
    private setupPromptHandlers(): void {
        // Handle prompts listing
        this.server.setRequestHandler(ListPromptsRequestSchema, async (request) => {
            return await this.requestRouter.handleRequest('prompts/list', request);
        });

        // Handle prompts get
        this.server.setRequestHandler(GetPromptRequestSchema, async (request) => {
            return await this.requestRouter.handleRequest('prompts/get', request);
        });
    }

    /**
     * Setup tool request handlers
     */
    private setupToolHandlers(): void {
        // Handle tool listing
        this.server.setRequestHandler(ListToolsRequestSchema, async (request) => {
            try {
                return await this.requestRouter.handleRequest('tools/list', request);
            } catch (error) {
                console.error("Error in tool list handler:", error);
                logger.systemError(error as Error, 'Tool List Handler');
                // Return empty list in case of error to avoid timeout
                return { tools: [] };
            }
        });

        // Handle tool execution
        this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
            return await this.handleToolCall(request);
        });
    }

    /**
     * Handle tool call with preprocessing
     */
    private async handleToolCall(request: any): Promise<any> {
        const parsedArgs = parseJsonArrays(request.params.arguments);
        
        // Trigger tool call hook for lazy loading
        await this.triggerToolCallHook(request.params.name, parsedArgs);
        
        // Check if this is a help request
        if (this.isHelpRequest(parsedArgs)) {
            return await this.handleHelpRequest(request, parsedArgs);
        }
        
        // Normal execution
        return await this.handleNormalExecution(request, parsedArgs);
    }

    /**
     * Trigger tool call hook if available
     */
    private async triggerToolCallHook(toolName: string, params: any): Promise<void> {
        if (!this.onToolCall) {
            return;
        }

        try {
            await this.onToolCall(toolName, params);
        } catch (error) {
            console.warn('[MCPServer] Tool call hook failed:', error);
        }
    }

    /**
     * Check if this is a help request
     */
    private isHelpRequest(parsedArgs: any): boolean {
        return parsedArgs && parsedArgs.help === true;
    }

    /**
     * Handle help request
     */
    private async handleHelpRequest(request: any, parsedArgs: any): Promise<any> {
        return await this.requestRouter.handleRequest('tools/help', {
            ...request,
            params: {
                ...request.params,
                arguments: parsedArgs
            }
        });
    }

    /**
     * Handle normal tool execution
     */
    private async handleNormalExecution(request: any, parsedArgs: any): Promise<any> {
        return await this.requestRouter.handleRequest('tools/call', {
            ...request,
            params: {
                ...request.params,
                arguments: parsedArgs
            }
        });
    }

    /**
     * Get handler statistics
     */
    getHandlerStatistics(): {
        totalHandlers: number;
        handlerTypes: string[];
        resourceHandlers: number;
        promptHandlers: number;
        toolHandlers: number;
    } {
        return {
            totalHandlers: 6,
            handlerTypes: ['resources', 'prompts', 'tools'],
            resourceHandlers: 2,
            promptHandlers: 2,
            toolHandlers: 2
        };
    }

    /**
     * Validate handler setup
     */
    validateHandlerSetup(): {
        isValid: boolean;
        errors: string[];
        warnings: string[];
    } {
        const errors: string[] = [];
        const warnings: string[] = [];

        if (!this.server) {
            errors.push('Server instance not provided');
        }

        if (!this.requestRouter) {
            errors.push('Request router not provided');
        }

        if (!this.onToolCall) {
            warnings.push('No tool call hook provided');
        }

        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }

    /**
     * Get request handler info
     */
    getRequestHandlerInfo(): Array<{
        schema: string;
        route: string;
        description: string;
        hasCustomLogic: boolean;
    }> {
        return [
            {
                schema: 'ListResourcesRequestSchema',
                route: 'resources/list',
                description: 'List available resources',
                hasCustomLogic: false
            },
            {
                schema: 'ReadResourceRequestSchema',
                route: 'resources/read',
                description: 'Read specific resource',
                hasCustomLogic: false
            },
            {
                schema: 'ListPromptsRequestSchema',
                route: 'prompts/list',
                description: 'List available prompts',
                hasCustomLogic: false
            },
            {
                schema: 'GetPromptRequestSchema',
                route: 'prompts/get',
                description: 'Get specific prompt',
                hasCustomLogic: false
            },
            {
                schema: 'ListToolsRequestSchema',
                route: 'tools/list',
                description: 'List available tools',
                hasCustomLogic: true
            },
            {
                schema: 'CallToolRequestSchema',
                route: 'tools/call',
                description: 'Execute tool',
                hasCustomLogic: true
            }
        ];
    }
}
```

## server/lifecycle/ServerLifecycleManager.ts

```typescript
/**
 * ServerLifecycleManager - Handles server lifecycle operations
 * Follows Single Responsibility Principle by focusing only on lifecycle management
 */

import { AgentRegistry } from '../services/AgentRegistry';
import { HttpTransportManager } from '../transport/HttpTransportManager';
import { IPCTransportManager } from '../transport/IPCTransportManager';
import { EventManager } from '../../services/EventManager';
import { ServerStatus } from '../../types';
import { logger } from '../../utils/logger';

/**
 * Service responsible for server lifecycle management
 * Follows SRP by focusing only on lifecycle operations
 */
export class ServerLifecycleManager {
    private status: ServerStatus = 'stopped';

    constructor(
        private agentRegistry: AgentRegistry,
        private httpTransportManager: HttpTransportManager,
        private ipcTransportManager: IPCTransportManager,
        private eventManager: EventManager
    ) {}

    /**
     * Start the server
     */
    async startServer(): Promise<void> {
        if (this.status === 'running') {
            logger.systemWarn('Server is already running');
            return;
        }

        try {
            this.status = 'starting';
            logger.systemLog('Starting server...');

            // Initialize agents
            await this.initializeAgents();

            // Start transports
            await this.startTransports();

            this.status = 'running';
            this.eventManager.emit('server:started', null);
            logger.systemLog('Server started successfully with IPC transport');
        } catch (error) {
            this.status = 'error';
            logger.systemError(error as Error, 'Server Start');
            throw error;
        }
    }

    /**
     * Stop the server
     */
    async stopServer(): Promise<void> {
        if (this.status === 'stopped') {
            logger.systemWarn('Server is already stopped');
            return;
        }

        try {
            this.status = 'stopping';
            logger.systemLog('Stopping server...');

            // Stop transports
            await this.stopTransports();

            this.status = 'stopped';
            this.eventManager.emit('server:stopped', null);
            logger.systemLog('Server stopped successfully');
        } catch (error) {
            this.status = 'error';
            logger.systemError(error as Error, 'Server Stop');
            throw error;
        }
    }

    /**
     * Restart the server
     */
    async restartServer(): Promise<void> {
        logger.systemLog('Restarting server...');
        await this.stopServer();
        await this.startServer();
    }

    /**
     * Initialize all registered agents
     */
    private async initializeAgents(): Promise<void> {
        try {
            await this.agentRegistry.initializeAgents();
            logger.systemLog('All agents initialized successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Agent Initialization');
            throw error;
        }
    }

    /**
     * Start both transports
     */
    private async startTransports(): Promise<void> {
        try {
            // Only start IPC transport for Obsidian plugin (no HTTP needed)
            const ipcResult = await this.ipcTransportManager.startTransport();

            logger.systemLog('IPC transport started successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Transport Start');
            throw error;
        }
    }

    /**
     * Stop both transports
     */
    private async stopTransports(): Promise<void> {
        try {
            // Only stop IPC transport (no HTTP to stop)
            await this.ipcTransportManager.stopTransport();

            logger.systemLog('IPC transport stopped successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Transport Stop');
            throw error;
        }
    }

    /**
     * Get current server status
     */
    getStatus(): ServerStatus {
        return this.status;
    }

    /**
     * Check if server is running
     */
    isRunning(): boolean {
        return this.status === 'running';
    }

    /**
     * Check if server is in error state
     */
    isInError(): boolean {
        return this.status === 'error';
    }

    /**
     * Get detailed server status
     */
    getDetailedStatus(): {
        status: ServerStatus;
        isRunning: boolean;
        agentCount: number;
        httpTransportStatus: any;
        ipcTransportStatus: any;
        uptime?: number;
    } {
        return {
            status: this.status,
            isRunning: this.isRunning(),
            agentCount: this.agentRegistry.getAgentCount(),
            ipcTransportStatus: this.ipcTransportManager.getTransportStatus(),
            httpTransportStatus: this.httpTransportManager.getTransportStatus()
        };
    }

    /**
     * Handle server error
     */
    handleServerError(error: Error): void {
        logger.systemError(error, 'Server Error');
        this.status = 'error';
        this.eventManager.emit('server:error', error);
    }

    /**
     * Perform health check
     */
    async performHealthCheck(): Promise<{
        isHealthy: boolean;
        status: ServerStatus;
        agentStatus: any;
        transportStatus: any;
        issues: string[];
    }> {
        const issues: string[] = [];

        // Check status
        if (this.status !== 'running') {
            issues.push(`Server status is ${this.status}, expected 'running'`);
        }

        // Check agents
        const agentStats = this.agentRegistry.getAgentStatistics();
        if (agentStats.totalAgents === 0) {
            issues.push('No agents registered');
        }

        // Check transports
        const httpStatus = this.httpTransportManager.getTransportStatus();
        const ipcStatus = this.ipcTransportManager.getTransportStatus();

        if (!httpStatus.isRunning) {
            issues.push('STDIO transport not connected');
        }

        if (!ipcStatus.isRunning) {
            issues.push('IPC transport not running');
        }

        return {
            isHealthy: issues.length === 0,
            status: this.status,
            agentStatus: agentStats,
            transportStatus: {
                http: httpStatus,
                ipc: ipcStatus
            },
            issues
        };
    }

    /**
     * Get server diagnostics
     */
    async getDiagnostics(): Promise<{
        lifecycle: any;
        agents: any;
        transports: any;
        events: any;
    }> {
        return {
            lifecycle: {
                status: this.status,
                isRunning: this.isRunning(),
                isInError: this.isInError()
            },
            agents: this.agentRegistry.getAgentStatistics(),
            transports: {
                http: this.httpTransportManager.getTransportStatus(),
                ipc: this.ipcTransportManager.getDiagnostics()
            },
            events: {
                hasEventManager: !!this.eventManager,
                // Could add event statistics here if EventManager supports it
            }
        };
    }

    /**
     * Force shutdown (emergency stop)
     */
    async forceShutdown(): Promise<void> {
        logger.systemWarn('Force shutdown initiated');
        
        try {
            // Try to stop transports gracefully first
            await Promise.race([
                this.stopTransports(),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Transport shutdown timeout')), 5000)
                )
            ]);
        } catch (error) {
            logger.systemError(error as Error, 'Force Shutdown - Transport Stop');
        }

        // Force cleanup
        try {
            await this.ipcTransportManager.forceCleanupSocket();
        } catch (error) {
            logger.systemError(error as Error, 'Force Shutdown - Socket Cleanup');
        }

        this.status = 'stopped';
        this.eventManager.emit('server:force-shutdown', null);
        logger.systemWarn('Force shutdown completed');
    }
}
```

## server/services/AgentRegistry.ts

```typescript
/**
 * AgentRegistry - Handles agent registration and management
 * Follows Single Responsibility Principle by focusing only on agent operations
 */

import { IAgent } from '../../agents/interfaces/IAgent';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';

/**
 * Service responsible for agent registration and management
 * Follows SRP by focusing only on agent operations
 */
export class AgentRegistry {
    private agents: Map<string, IAgent> = new Map();

    /**
     * Register an agent with the registry
     */
    registerAgent(agent: IAgent): void {
        if (this.agents.has(agent.name)) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `Agent ${agent.name} is already registered`
            );
        }

        this.agents.set(agent.name, agent);
        logger.systemLog(`Agent registered: ${agent.name}`);
    }

    /**
     * Get an agent by name
     */
    getAgent(name: string): IAgent {
        const agent = this.agents.get(name);
        
        if (!agent) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `Agent ${name} not found`
            );
        }

        return agent;
    }

    /**
     * Check if an agent is registered
     */
    hasAgent(name: string): boolean {
        return this.agents.has(name);
    }

    /**
     * Get all registered agents
     */
    getAgents(): Map<string, IAgent> {
        return new Map(this.agents);
    }

    /**
     * Get all agent names
     */
    getAgentNames(): string[] {
        return Array.from(this.agents.keys());
    }

    /**
     * Remove an agent from the registry
     */
    unregisterAgent(name: string): boolean {
        const removed = this.agents.delete(name);
        
        if (removed) {
            logger.systemLog(`Agent unregistered: ${name}`);
        }
        
        return removed;
    }

    /**
     * Initialize all registered agents
     */
    async initializeAgents(): Promise<void> {
        const initPromises = Array.from(this.agents.values()).map(async (agent) => {
            try {
                await agent.initialize();
                logger.systemLog(`Agent initialized: ${agent.name}`);
            } catch (error) {
                logger.systemError(error as Error, `Agent Initialization: ${agent.name}`);
                throw error;
            }
        });

        await Promise.all(initPromises);
    }

    /**
     * Get agent count
     */
    getAgentCount(): number {
        return this.agents.size;
    }

    /**
     * Clear all agents
     */
    clearAgents(): void {
        this.agents.clear();
    }

    /**
     * Get agent statistics
     */
    getAgentStatistics(): {
        totalAgents: number;
        agentNames: string[];
        agentInfo: Array<{
            name: string;
            description: string;
            modeCount: number;
        }>;
    } {
        const agentInfo = Array.from(this.agents.values()).map(agent => {
            try {
                const modes = agent.getModes();
                return {
                    name: agent.name,
                    description: agent.description,
                    modeCount: modes.length
                };
            } catch (error) {
                return {
                    name: agent.name,
                    description: agent.description,
                    modeCount: 0
                };
            }
        });

        return {
            totalAgents: this.agents.size,
            agentNames: this.getAgentNames(),
            agentInfo
        };
    }

    /**
     * Validate agent exists and get it
     */
    validateAndGetAgent(name: string): IAgent {
        if (!name || typeof name !== 'string') {
            throw new McpError(
                ErrorCode.InvalidParams,
                'Agent name must be a non-empty string'
            );
        }

        return this.getAgent(name);
    }

    /**
     * Get agent mode help
     */
    getAgentModeHelp(agentName: string, modeName: string): string {
        const agent = this.validateAndGetAgent(agentName);
        const mode = agent.getMode(modeName);

        if (!mode) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `Mode ${modeName} not found in agent ${agentName}`
            );
        }

        return (mode as any).getHelpText?.() || `Help for ${agentName}.${modeName}`;
    }

    /**
     * Check if agent supports a specific mode
     */
    agentSupportsMode(agentName: string, modeName: string): boolean {
        try {
            const agent = this.getAgent(agentName);
            return agent.getMode(modeName) !== null;
        } catch (error) {
            return false;
        }
    }

    /**
     * Get all available modes across all agents
     */
    getAllAvailableModes(): Array<{
        agentName: string;
        modeName: string;
        description: string;
    }> {
        const allModes: Array<{
            agentName: string;
            modeName: string;
            description: string;
        }> = [];

        for (const [agentName, agent] of this.agents) {
            try {
                const modes = agent.getModes();
                for (const mode of modes) {
                    allModes.push({
                        agentName,
                        modeName: mode.name,
                        description: mode.description
                    });
                }
            } catch (error) {
                logger.systemError(error as Error, `Mode Enumeration: ${agentName}`);
            }
        }

        return allModes;
    }
}
```

## server/services/ServerConfiguration.ts

```typescript
/**
 * ServerConfiguration - Handles server configuration and identification
 * Follows Single Responsibility Principle by focusing only on configuration
 */

import { App } from 'obsidian';
import { sanitizeVaultName } from '../../utils/vaultUtils';
import { logger } from '../../utils/logger';
import { platform } from 'os';

export interface ServerConfigurationOptions {
    serverName?: string;
    vaultName?: string;
    capabilities?: any;
}

/**
 * Service responsible for server configuration management
 * Follows SRP by focusing only on configuration operations
 */
export class ServerConfiguration {
    private serverName?: string;
    private vaultName: string;
    private sanitizedVaultName: string;
    private capabilities: any;

    constructor(
        private app: App,
        options: ServerConfigurationOptions = {}
    ) {
        this.serverName = options.serverName;
        this.vaultName = options.vaultName || this.getVaultName();
        this.sanitizedVaultName = sanitizeVaultName(this.vaultName);
        this.capabilities = options.capabilities || this.getDefaultCapabilities();
    }

    /**
     * Get the vault name from the app
     */
    private getVaultName(): string {
        try {
            return this.app.vault.getName();
        } catch (error) {
            logger.systemError(error as Error, 'Vault Name Retrieval');
            return 'default';
        }
    }

    /**
     * Get default server capabilities
     */
    private getDefaultCapabilities(): any {
        return {
            resources: {
                supportsUriTemplates: true,
                supportsContentWatch: false,
                supportsListWatch: false
            },
            tools: {
                supportsToolDescriptionMarkdown: true,
                supportsToolArgumentsMarkdown: true
            },
            prompts: {}
        };
    }

    /**
     * Get the server identifier
     */
    getServerIdentifier(): string {
        if (this.serverName) {
            return this.serverName;
        }
        
        return `claudesidian-mcp-${this.sanitizedVaultName}`;
    }

    /**
     * Get the server info for SDK initialization
     */
    getServerInfo(): { name: string; version: string } {
        return {
            name: this.getServerIdentifier(),
            version: "1.0.0"
        };
    }

    /**
     * Get server options for SDK initialization
     */
    getServerOptions(): { capabilities: any } {
        return {
            capabilities: this.capabilities
        };
    }

    /**
     * Get the IPC path for this server
     */
    getIPCPath(): string {
        return platform() === 'win32'
            ? `\\\\.\\pipe\\claudesidian_mcp_${this.sanitizedVaultName}`
            : `/tmp/claudesidian_mcp_${this.sanitizedVaultName}.sock`;
    }

    /**
     * Get the vault name
     */
    getVaultNameValue(): string {
        return this.vaultName;
    }

    /**
     * Get the sanitized vault name
     */
    getSanitizedVaultName(): string {
        return this.sanitizedVaultName;
    }

    /**
     * Get the server capabilities
     */
    getCapabilities(): any {
        return this.capabilities;
    }

    /**
     * Update server capabilities
     */
    updateCapabilities(capabilities: any): void {
        this.capabilities = { ...this.capabilities, ...capabilities };
    }

    /**
     * Check if this is a Windows platform
     */
    isWindows(): boolean {
        return platform() === 'win32';
    }

    /**
     * Get configuration summary
     */
    getConfigurationSummary(): {
        serverIdentifier: string;
        vaultName: string;
        sanitizedVaultName: string;
        ipcPath: string;
        isWindows: boolean;
        hasCustomName: boolean;
    } {
        return {
            serverIdentifier: this.getServerIdentifier(),
            vaultName: this.vaultName,
            sanitizedVaultName: this.sanitizedVaultName,
            ipcPath: this.getIPCPath(),
            isWindows: this.isWindows(),
            hasCustomName: !!this.serverName
        };
    }
}
```

## server/transport/HttpTransportManager.ts

```typescript
/**
 * HttpTransportManager - Modern HTTP transport using StreamableHTTPServerTransport
 * Based on MCP SDK examples and supports the latest protocol
 */

import { Server as MCPSDKServer } from '@modelcontextprotocol/sdk/server/index.js';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import { McpError, ErrorCode, isInitializeRequest } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';
import { randomUUID } from 'node:crypto';
import http from 'http';
import express from 'express';
import cors from 'cors';

/**
 * Modern HTTP transport manager using StreamableHTTP
 * Supports both JSON response mode and streaming
 */
export class HttpTransportManager {
    private httpServer: http.Server | null = null;
    private app: express.Application;
    private isRunning: boolean = false;
    private port: number;
    private host: string;
    private transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};

    constructor(
        private server: MCPSDKServer, 
        port: number = 3000, 
        host: string = 'localhost'
    ) {
        this.port = port;
        this.host = host;
        this.app = express();
        this.setupMiddleware();
        this.setupRoutes();
    }

    /**
     * Setup Express middleware
     */
    private setupMiddleware(): void {
        // Enable CORS for cross-origin requests
        this.app.use(cors({
            origin: '*',
            methods: ['GET', 'POST', 'OPTIONS'],
            allowedHeaders: ['Content-Type', 'Authorization']
        }));
        
        // Parse JSON bodies
        this.app.use(express.json());
        
        // Add request logging
        this.app.use((req, res, next) => {
            console.log(`[HTTP Transport] ${req.method} ${req.path} from ${req.ip}`);
            console.log(`[HTTP Transport] Headers:`, req.headers);
            logger.systemLog(`[HTTP Transport] ${req.method} ${req.path} from ${req.ip}`);
            next();
        });
    }

    /**
     * Setup Express routes for MCP
     */
    private setupRoutes(): void {
        // Health check endpoint
        this.app.get('/health', (req, res) => {
            res.json({ 
                status: 'healthy', 
                server: 'claudesidian-mcp',
                timestamp: new Date().toISOString() 
            });
        });

        // Main MCP endpoint (supports both initialization and regular requests)
        this.app.post('/sse', async (req, res) => {
            try {
                await this.handleMCPRequest(req, res);
            } catch (error) {
                logger.systemError(error as Error, 'MCP Request Handler');
                if (!res.headersSent) {
                    res.status(500).json({
                        jsonrpc: '2.0',
                        error: {
                            code: -32603,
                            message: 'Internal server error',
                        },
                        id: null,
                    });
                }
            }
        });

        // Alternative endpoint for compatibility
        this.app.post('/mcp', async (req, res) => {
            try {
                await this.handleMCPRequest(req, res);
            } catch (error) {
                logger.systemError(error as Error, 'MCP Request Handler');
                if (!res.headersSent) {
                    res.status(500).json({
                        jsonrpc: '2.0',
                        error: {
                            code: -32603,
                            message: 'Internal server error',
                        },
                        id: null,
                    });
                }
            }
        });
    }

    /**
     * Handle MCP requests (both initialization and regular requests)
     */
    private async handleMCPRequest(req: express.Request, res: express.Response): Promise<void> {
        const sessionId = req.headers['x-session-id'] as string;
        
        let transport: StreamableHTTPServerTransport;
        
        if (sessionId && this.transports[sessionId]) {
            // Reuse existing transport
            transport = this.transports[sessionId];
            logger.systemLog(`[HTTP Transport] Reusing session: ${sessionId}`);
        } else if (!sessionId && isInitializeRequest(req.body)) {
            // New initialization request - create new transport
            logger.systemLog(`[HTTP Transport] Creating new session for initialization`);
            
            transport = new StreamableHTTPServerTransport({
                sessionIdGenerator: () => randomUUID(),
                enableJsonResponse: true, // Enable JSON response mode for OpenAI MCP
                onsessioninitialized: (newSessionId: string) => {
                    logger.systemLog(`[HTTP Transport] Session initialized: ${newSessionId}`);
                    this.transports[newSessionId] = transport;
                }
            });
            
            // Connect the transport to the MCP server
            await this.server.connect(transport);
            
            // Handle the initialization request
            await transport.handleRequest(req, res, req.body);
            return;
        } else {
            // Invalid request - no session ID or not initialization request
            logger.systemWarn(`[HTTP Transport] Invalid request: sessionId=${sessionId}, isInit=${isInitializeRequest(req.body)}`);
            res.status(400).json({
                jsonrpc: '2.0',
                error: {
                    code: -32000,
                    message: 'Bad Request: No valid session ID provided or not initialization request',
                },
                id: null,
            });
            return;
        }
        
        // Handle regular request with existing transport
        await transport.handleRequest(req, res, req.body);
    }

    /**
     * Start the HTTP transport
     */
    async startTransport(): Promise<{ httpServer: http.Server; app: express.Application }> {
        if (this.httpServer) {
            return { httpServer: this.httpServer, app: this.app };
        }
        try {
            // Create HTTP server with Express app
            this.httpServer = http.createServer(this.app);
            
            // Start HTTP server
            await new Promise<void>((resolve, reject) => {
                this.httpServer!.listen(this.port, this.host, () => {
                    this.isRunning = true;
                    logger.systemLog(`HTTP MCP server started on ${this.host}:${this.port}`);
                    logger.systemLog(`MCP endpoint available at: http://${this.host}:${this.port}/sse`);
                    resolve();
                });
                
                this.httpServer!.on('error', (error: NodeJS.ErrnoException) => {
                    if (error.code === 'EADDRINUSE') {
                        logger.systemError(error, `Port ${this.port} is already in use`);
                    } else {
                        logger.systemError(error, 'HTTP Server Start');
                    }
                    reject(error);
                });
            });

            logger.systemLog('HTTP transport started successfully');
            
            return { httpServer: this.httpServer, app: this.app };
        } catch (error) {
            logger.systemError(error as Error, 'HTTP Transport Start');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to start HTTP transport',
                error
            );
        }
    }

    /**
     * Stop the HTTP transport
     */
    async stopTransport(): Promise<void> {
        if (!this.httpServer) {
            return; // Nothing to stop
        }

        try {
            // Close all active transports
            for (const sessionId in this.transports) {
                try {
                    logger.systemLog(`Closing transport for session ${sessionId}`);
                    await this.transports[sessionId].close();
                    delete this.transports[sessionId];
                } catch (error) {
                    logger.systemError(error as Error, `Error closing transport for session ${sessionId}`);
                }
            }

            // Close HTTP server
            await new Promise<void>((resolve, reject) => {
                this.httpServer!.close((error) => {
                    if (error) {
                        reject(error);
                    } else {
                        this.httpServer = null;
                        this.isRunning = false;
                        logger.systemLog('HTTP transport stopped successfully');
                        resolve();
                    }
                });
            });
        } catch (error) {
            logger.systemError(error as Error, 'HTTP Transport Stop');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to stop HTTP transport',
                error
            );
        }
    }

    /**
     * Get transport status
     */
    getTransportStatus(): {
        isRunning: boolean;
        endpoint?: string;
        port: number;
        host: string;
        activeSessions: number;
        sessions: string[];
    } {
        return {
            isRunning: this.isRunning,
            endpoint: this.isRunning ? `http://${this.host}:${this.port}/sse` : undefined,
            port: this.port,
            host: this.host,
            activeSessions: Object.keys(this.transports).length,
            sessions: Object.keys(this.transports)
        };
    }

    /**
     * Check if transport is running
     */
    isTransportRunning(): boolean {
        return this.isRunning;
    }

    /**
     * Get the server endpoint URL
     */
    getServerUrl(): string {
        if (!this.isRunning) {
            throw new McpError(
                ErrorCode.InternalError,
                'Cannot get server URL: transport not running'
            );
        }
        return `http://${this.host}:${this.port}/sse`;
    }

    /**
     * Update port configuration (only when stopped)
     */
    setPort(port: number): void {
        if (this.isRunning) {
            throw new McpError(
                ErrorCode.InvalidParams,
                'Cannot change port while transport is running'
            );
        }
        this.port = port;
    }

    /**
     * Update host configuration (only when stopped)
     */
    setHost(host: string): void {
        if (this.isRunning) {
            throw new McpError(
                ErrorCode.InvalidParams,
                'Cannot change host while transport is running'
            );
        }
        this.host = host;
    }

    /**
     * Get active session count
     */
    getActiveSessionCount(): number {
        return Object.keys(this.transports).length;
    }

    /**
     * Clean up a specific session
     */
    async cleanupSession(sessionId: string): Promise<void> {
        const transport = this.transports[sessionId];
        if (transport) {
            try {
                await transport.close();
                delete this.transports[sessionId];
                logger.systemLog(`Cleaned up session: ${sessionId}`);
            } catch (error) {
                logger.systemError(error as Error, `Error cleaning up session ${sessionId}`);
            }
        }
    }
}
```

## server/transport/IPCTransportManager.ts

```typescript
/**
 * IPCTransportManager - Handles IPC transport management
 * Follows Single Responsibility Principle by focusing only on IPC transport
 */

import { Server as NetServer, createServer } from 'net';
import { promises as fs } from 'fs';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { Server as MCPSDKServer } from '@modelcontextprotocol/sdk/server/index.js';
import { ServerConfiguration } from '../services/ServerConfiguration';
import { StdioTransportManager } from './StdioTransportManager';
import { logger } from '../../utils/logger';

/**
 * Service responsible for IPC transport management
 * Follows SRP by focusing only on IPC transport operations
 */
export class IPCTransportManager {
    private ipcServer: NetServer | null = null;
    private isRunning: boolean = false;

    constructor(
        private configuration: ServerConfiguration,
        private stdioTransportManager: StdioTransportManager
    ) {}

    /**
     * Start the IPC transport server
     */
    async startTransport(): Promise<NetServer> {
        if (this.ipcServer) {
            return this.ipcServer;
        }

        const isWindows = this.configuration.isWindows();
        const ipcPath = this.configuration.getIPCPath();

        if (!isWindows) {
            await this.cleanupSocket();
        }

        return new Promise((resolve, reject) => {
            try {
                const server = createServer((socket) => {
                    this.handleSocketConnection(socket);
                });

                this.setupServerErrorHandling(server, ipcPath, isWindows, reject);
                this.startListening(server, ipcPath, isWindows, resolve, reject);
            } catch (error) {
                logger.systemError(error as Error, 'IPC Server Creation');
                reject(error);
            }
        });
    }

    /**
     * Handle new socket connections
     */
    private handleSocketConnection(socket: NodeJS.ReadWriteStream): void {
        try {
            const transport = this.stdioTransportManager.createSocketTransport(socket, socket);
            
            this.stdioTransportManager.connectSocketTransport(transport)
                .then(() => {
                    logger.systemLog('IPC socket connected successfully');
                })
                .catch(error => {
                    logger.systemError(error as Error, 'IPC Socket Connection');
                });
        } catch (error) {
            logger.systemError(error as Error, 'IPC Socket Handling');
        }
    }

    /**
     * Setup server error handling
     */
    private setupServerErrorHandling(
        server: NetServer,
        ipcPath: string,
        isWindows: boolean,
        reject: (error: Error) => void
    ): void {
        server.on('error', (error) => {
            logger.systemError(error as Error, 'IPC Server');
            
            if (!isWindows && (error as NodeJS.ErrnoException).code === 'EADDRINUSE') {
                this.handleAddressInUse(server, ipcPath, reject);
            } else {
                reject(error);
            }
        });
    }

    /**
     * Handle address in use error
     */
    private handleAddressInUse(
        server: NetServer,
        ipcPath: string,
        reject: (error: Error) => void
    ): void {
        this.cleanupSocket()
            .then(() => {
                try {
                    server.listen(ipcPath);
                } catch (listenError) {
                    logger.systemError(listenError as Error, 'Server Listen Retry');
                    reject(listenError as Error);
                }
            })
            .catch(cleanupError => {
                logger.systemError(cleanupError as Error, 'Socket Cleanup');
                reject(cleanupError);
            });
    }

    /**
     * Start listening on the IPC path
     */
    private startListening(
        server: NetServer,
        ipcPath: string,
        isWindows: boolean,
        resolve: (server: NetServer) => void,
        reject: (error: Error) => void
    ): void {
        server.listen(ipcPath, () => {
            this.handleListeningStarted(server, ipcPath, isWindows, resolve, reject);
        });
    }

    /**
     * Handle successful listening start
     */
    private handleListeningStarted(
        server: NetServer,
        ipcPath: string,
        isWindows: boolean,
        resolve: (server: NetServer) => void,
        reject: (error: Error) => void
    ): void {
        if (!isWindows) {
            fs.chmod(ipcPath, 0o666).catch(error => {
                logger.systemError(error as Error, 'Socket Permissions');
            });
        }

        this.ipcServer = server;
        this.isRunning = true;
        
        logger.systemLog(`IPC server started on path: ${ipcPath}`);
        resolve(server);
    }

    /**
     * Stop the IPC transport server
     */
    async stopTransport(): Promise<void> {
        if (!this.ipcServer) {
            return;
        }

        try {
            this.ipcServer.close();
            this.ipcServer = null;
            this.isRunning = false;
            
            await this.cleanupSocket();
            
            logger.systemLog('IPC transport stopped successfully');
        } catch (error) {
            logger.systemError(error as Error, 'IPC Transport Stop');
            throw error;
        }
    }

    /**
     * Clean up the socket file
     */
    private async cleanupSocket(): Promise<void> {
        if (this.configuration.isWindows()) {
            return;
        }

        try {
            await fs.unlink(this.configuration.getIPCPath());
        } catch (error) {
            // Ignore if file doesn't exist
            if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
                logger.systemError(error as Error, 'Socket Cleanup');
            }
        }
    }

    /**
     * Check if the transport is running
     */
    isTransportRunning(): boolean {
        return this.isRunning && this.ipcServer !== null;
    }

    /**
     * Get the server instance
     */
    getServer(): NetServer | null {
        return this.ipcServer;
    }

    /**
     * Restart the transport
     */
    async restartTransport(): Promise<NetServer> {
        await this.stopTransport();
        return await this.startTransport();
    }

    /**
     * Get transport status
     */
    getTransportStatus(): {
        isRunning: boolean;
        hasServer: boolean;
        transportType: string;
        ipcPath: string;
        isWindows: boolean;
    } {
        return {
            isRunning: this.isRunning,
            hasServer: this.ipcServer !== null,
            transportType: 'ipc',
            ipcPath: this.configuration.getIPCPath(),
            isWindows: this.configuration.isWindows()
        };
    }

    /**
     * Get transport diagnostics
     */
    getDiagnostics(): {
        transportType: string;
        isRunning: boolean;
        hasServer: boolean;
        ipcPath: string;
        isWindows: boolean;
        socketExists?: boolean;
    } {
        const diagnostics = {
            transportType: 'ipc',
            isRunning: this.isRunning,
            hasServer: this.ipcServer !== null,
            ipcPath: this.configuration.getIPCPath(),
            isWindows: this.configuration.isWindows()
        };

        // Check if socket exists (for Unix systems)
        if (!this.configuration.isWindows()) {
            try {
                fs.access(this.configuration.getIPCPath())
                    .then(() => {
                        (diagnostics as any).socketExists = true;
                    })
                    .catch(() => {
                        (diagnostics as any).socketExists = false;
                    });
            } catch (error) {
                (diagnostics as any).socketExists = false;
            }
        }

        return diagnostics;
    }

    /**
     * Force cleanup socket (for emergency cleanup)
     */
    async forceCleanupSocket(): Promise<void> {
        if (this.configuration.isWindows()) {
            return;
        }

        try {
            await fs.unlink(this.configuration.getIPCPath());
            logger.systemLog('Socket force cleaned up successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Force Socket Cleanup');
        }
    }
}
```

## server/transport/StdioTransportManager.ts

```typescript
/**
 * StdioTransportManager - Handles STDIO transport management
 * Follows Single Responsibility Principle by focusing only on STDIO transport
 */

import { Server as MCPSDKServer } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';

/**
 * Service responsible for STDIO transport management
 * Follows SRP by focusing only on STDIO transport operations
 */
export class StdioTransportManager {
    private stdioTransport: StdioServerTransport | null = null;
    private isConnected: boolean = false;

    constructor(private server: MCPSDKServer) {}

    /**
     * Start the STDIO transport
     */
    async startTransport(): Promise<StdioServerTransport> {
        if (this.stdioTransport) {
            return this.stdioTransport;
        }

        try {
            const transport = new StdioServerTransport();
            
            await this.server.connect(transport);
            
            this.stdioTransport = transport;
            this.isConnected = true;
            
            logger.systemLog('STDIO transport started successfully');
            
            return transport;
        } catch (error) {
            logger.systemError(error as Error, 'STDIO Transport Start');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to start STDIO transport',
                error
            );
        }
    }

    /**
     * Stop the STDIO transport
     */
    async stopTransport(): Promise<void> {
        if (!this.stdioTransport) {
            return;
        }

        try {
            await this.stdioTransport.close();
            this.stdioTransport = null;
            this.isConnected = false;
            
            logger.systemLog('STDIO transport stopped successfully');
        } catch (error) {
            logger.systemError(error as Error, 'STDIO Transport Stop');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to stop STDIO transport',
                error
            );
        }
    }

    /**
     * Check if the transport is connected
     */
    isTransportConnected(): boolean {
        return this.isConnected && this.stdioTransport !== null;
    }

    /**
     * Get the transport instance
     */
    getTransport(): StdioServerTransport | null {
        return this.stdioTransport;
    }

    /**
     * Restart the transport
     */
    async restartTransport(): Promise<StdioServerTransport> {
        await this.stopTransport();
        return await this.startTransport();
    }

    /**
     * Get transport status
     */
    getTransportStatus(): {
        isConnected: boolean;
        hasTransport: boolean;
        transportType: string;
    } {
        return {
            isConnected: this.isConnected,
            hasTransport: this.stdioTransport !== null,
            transportType: 'stdio'
        };
    }

    /**
     * Create a new transport instance (for socket connections)
     */
    createSocketTransport(inputStream: any, outputStream: any): StdioServerTransport {
        return new StdioServerTransport(inputStream, outputStream);
    }

    /**
     * Connect a socket transport to the server
     */
    async connectSocketTransport(transport: StdioServerTransport): Promise<void> {
        try {
            await this.server.connect(transport);
            logger.systemLog('Socket transport connected successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Socket Transport Connection');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to connect socket transport',
                error
            );
        }
    }

    /**
     * Handle transport errors
     */
    handleTransportError(error: Error): void {
        logger.systemError(error, 'STDIO Transport Error');
        
        // Reset connection state
        this.isConnected = false;
        
        // Attempt to clean up
        if (this.stdioTransport) {
            try {
                this.stdioTransport.close().catch(closeError => {
                    logger.systemError(closeError as Error, 'Transport Error Cleanup');
                });
            } catch (cleanupError) {
                logger.systemError(cleanupError as Error, 'Transport Error Cleanup');
            }
        }
    }

    /**
     * Get transport diagnostics
     */
    getDiagnostics(): {
        transportType: string;
        isConnected: boolean;
        hasTransport: boolean;
        lastError?: string;
    } {
        return {
            transportType: 'stdio',
            isConnected: this.isConnected,
            hasTransport: this.stdioTransport !== null
        };
    }
}
```

## services/AgentManager.ts

```typescript
import { IAgent } from '../agents/interfaces/IAgent';
import { App } from 'obsidian';
import { EventManager } from './EventManager';

/**
 * Agent management service
 * Manages agent registration, initialization, and execution
 */
export class AgentManager {
  private agents: Map<string, IAgent> = new Map();
  
  /**
   * Create a new agent manager
   * @param app Obsidian app instance
   * @param plugin Plugin instance
   * @param eventManager Event manager instance
   */
  constructor(
    _app: App,
    _plugin: any,
    _eventManager: EventManager
  ) {
    // We're not currently using these parameters but they might be needed in the future
    // No need to store them as class properties for now
    // Using underscore prefix to indicate intentionally unused parameters
  }
  
  /**
   * Register an agent
   * @param agent Agent to register
   * @throws Error if agent with same name is already registered
   */
  registerAgent(agent: IAgent): void {
    if (this.agents.has(agent.name)) {
      throw new Error(`Agent ${agent.name} is already registered`);
    }
    
    this.agents.set(agent.name, agent);
    
    // Set the agent manager reference for inter-agent communication
    agent.setAgentManager(this);
  }
  
  /**
   * Get an agent by name
   * @param name Name of the agent
   * @returns Agent instance
   * @throws Error if agent not found
   */
  getAgent(name: string): IAgent {
    const agent = this.agents.get(name);
    if (!agent) {
      throw new Error(`Agent ${name} not found`);
    }
    
    return agent;
  }
  
  /**
   * Get all registered agents
   * @returns Array of agent instances
   */
  getAgents(): IAgent[] {
    return Array.from(this.agents.values());
  }
  
  /**
   * Execute a mode on an agent
   * @param agentName Name of the agent
   * @param mode Mode to execute
   * @param params Parameters to pass to the mode
   * @returns Promise that resolves with the mode's result
   */
  async executeAgentMode(agentName: string, mode: string, params: any): Promise<any> {
    const agent = this.getAgent(agentName);
    return await agent.executeMode(mode, params);
  }
  
  
  /**
   * Initialize all registered agents
   * @returns Promise that resolves when all agents are initialized
   */
  async initializeAgents(): Promise<void> {
    for (const agent of this.agents.values()) {
      await agent.initialize();
    }
  }
}
```

## services/ConversationService.ts

```typescript
import { Plugin } from 'obsidian';
import { FileSystemService } from './migration/FileSystemService';
import { ConversationDataStructure } from '../types/migration/MigrationTypes';

/**
 * Location: src/services/ConversationService.ts
 *
 * ConversationService for managing conversation data using the new JSON structure.
 * Handles conversations stored in .data/conversations.json with search capabilities.
 *
 * Used by: Chat-related agents and features for conversation management
 * Integrates with: FileSystemService for data persistence
 */
export class ConversationService {
  private plugin: Plugin;
  private fileSystem: FileSystemService;

  constructor(plugin: Plugin) {
    this.plugin = plugin;
    this.fileSystem = new FileSystemService(plugin);
  }

  async getAllConversations(): Promise<any[]> {
    const data = await this.loadConversationData();
    return Object.values(data.conversations);
  }

  async getConversation(id: string): Promise<any | undefined> {
    const data = await this.loadConversationData();
    return data.conversations[id];
  }

  async createConversation(conversation: any): Promise<any> {
    const data = await this.loadConversationData();

    const convId = conversation.id || Date.now().toString();
    data.conversations[convId] = {
      ...conversation,
      id: convId,
      created: Date.now(),
      updated: Date.now()
    };

    await this.saveConversationData(data);
    return data.conversations[convId];
  }

  async updateConversation(id: string, updates: any): Promise<void> {
    const data = await this.loadConversationData();

    if (!data.conversations[id]) {
      throw new Error(`Conversation ${id} not found`);
    }

    data.conversations[id] = {
      ...data.conversations[id],
      ...updates,
      updated: Date.now()
    };

    await this.saveConversationData(data);
  }

  async deleteConversation(id: string): Promise<void> {
    const data = await this.loadConversationData();

    if (!data.conversations[id]) {
      throw new Error(`Conversation ${id} not found`);
    }

    delete data.conversations[id];
    await this.saveConversationData(data);
  }

  async addMessage(conversationId: string, message: any): Promise<void> {
    const data = await this.loadConversationData();

    if (!data.conversations[conversationId]) {
      throw new Error(`Conversation ${conversationId} not found`);
    }

    const conversation = data.conversations[conversationId];

    if (!conversation.messages) {
      conversation.messages = [];
    }

    const messageWithId = {
      ...message,
      id: message.id || Date.now().toString() + Math.random().toString(36).substr(2, 9),
      timestamp: message.timestamp || Date.now()
    };

    conversation.messages.push(messageWithId);
    conversation.message_count = conversation.messages.length;
    conversation.updated = Date.now();

    await this.saveConversationData(data);
  }

  async getConversationsByVault(vaultName: string): Promise<any[]> {
    const conversations = await this.getAllConversations();
    return conversations.filter(conv => conv.vault_name === vaultName);
  }

  async searchConversations(query: string, limit?: number): Promise<any[]> {
    const conversations = await this.getAllConversations();

    if (!query) {
      return limit ? conversations.slice(0, limit) : conversations;
    }

    const filtered = conversations.filter(conv =>
      conv.title.toLowerCase().includes(query.toLowerCase()) ||
      conv.messages.some((msg: any) =>
        msg.content.toLowerCase().includes(query.toLowerCase())
      )
    );

    return limit ? filtered.slice(0, limit) : filtered;
  }

  async searchConversationsByDateRange(startDate: number, endDate: number): Promise<any[]> {
    const conversations = await this.getAllConversations();

    return conversations.filter(conv =>
      conv.created >= startDate && conv.created <= endDate
    );
  }

  async getRecentConversations(limit: number = 10): Promise<any[]> {
    const conversations = await this.getAllConversations();

    return conversations
      .sort((a, b) => b.updated - a.updated)
      .slice(0, limit);
  }

  async listConversations(vaultName?: string, limit?: number): Promise<any[]> {
    const conversations = await this.getAllConversations();

    let filtered = conversations;

    // Filter by vault if specified
    if (vaultName) {
      filtered = conversations.filter(conv => conv.vault_name === vaultName);
    }

    // Sort by last updated (most recent first)
    filtered.sort((a, b) => (b.updated || 0) - (a.updated || 0));

    // Apply limit if specified
    if (limit) {
      filtered = filtered.slice(0, limit);
    }

    return filtered;
  }

  async getConversationStats(): Promise<{
    totalConversations: number;
    totalMessages: number;
    vaultCounts: Record<string, number>;
    oldestConversation?: number;
    newestConversation?: number;
  }> {
    const conversations = await this.getAllConversations();

    const stats = {
      totalConversations: conversations.length,
      totalMessages: 0,
      vaultCounts: {} as Record<string, number>,
      oldestConversation: undefined as number | undefined,
      newestConversation: undefined as number | undefined
    };

    if (conversations.length === 0) {
      return stats;
    }

    let oldest = Infinity;
    let newest = 0;

    for (const conv of conversations) {
      stats.totalMessages += conv.message_count || 0;

      // Count by vault
      const vault = conv.vault_name || 'Unknown';
      stats.vaultCounts[vault] = (stats.vaultCounts[vault] || 0) + 1;

      // Track date range
      if (conv.created < oldest) oldest = conv.created;
      if (conv.created > newest) newest = conv.created;
    }

    stats.oldestConversation = oldest === Infinity ? undefined : oldest;
    stats.newestConversation = newest === 0 ? undefined : newest;

    return stats;
  }

  private async loadConversationData(): Promise<ConversationDataStructure> {
    const data = await this.fileSystem.readJSON('conversations.json');

    if (!data) {
      return {
        conversations: {},
        metadata: {
          version: '2.0.0',
          lastUpdated: Date.now(),
          totalConversations: 0
        }
      };
    }

    return data;
  }

  private async saveConversationData(data: ConversationDataStructure): Promise<void> {
    data.metadata.lastUpdated = Date.now();
    data.metadata.totalConversations = Object.keys(data.conversations).length;
    await this.fileSystem.writeJSON('conversations.json', data);
  }
}
```

## services/EventManager.ts

```typescript
/**
 * Event management service
 * Provides a simple event system for communication between components
 */
export class EventManager {
  private eventListeners: Map<string, Array<(data: any) => void>> = new Map();
  
  /**
   * Register an event listener
   * @param event Event name
   * @param callback Callback function to execute when event is emitted
   */
  on(event: string, callback: (data: any) => void): void {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    
    this.eventListeners.get(event)?.push(callback);
  }
  
  /**
   * Remove an event listener
   * @param event Event name
   * @param callback Callback function to remove
   */
  off(event: string, callback: (data: any) => void): void {
    if (!this.eventListeners.has(event)) {
      return;
    }
    
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
    }
  }
  
  /**
   * Emit an event
   * @param event Event name
   * @param data Data to pass to listeners
   */
  emit(event: string, data: any): void {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      for (const listener of listeners) {
        listener(data);
      }
    }
  }
  
  /**
   * Alias for emit to make compatible with Obsidian Events API
   * @param event Event name
   * @param data Data to pass to listeners
   */
  trigger(event: string, data: any): void {
    this.emit(event, data);
  }
}
```

## services/SessionContextManager.ts

```typescript
import { CommonResult } from '../types';
import { logger } from '../utils/logger';
import { parseWorkspaceContext } from '../utils/contextUtils';
import { generateSessionId, isStandardSessionId } from '../utils/sessionUtils';

/**
 * Interface for workspace context
 */
export interface WorkspaceContext {
  workspaceId: string;
  workspacePath?: string[];
  activeWorkspace?: boolean;
}

/**
 * SessionContextManager
 * 
 * Provides a centralized service for managing and persisting workspace context
 * across tool calls within sessions. This helps maintain context continuity
 * without requiring explicit context passing between every operation.
 */
export class SessionContextManager {
  // Reference to session service for database validation
  private sessionService: any = null;
  
  // Map of sessionId -> workspace context
  private sessionContextMap: Map<string, WorkspaceContext> = new Map();
  
  // Default workspace context for new sessions (global)
  private defaultWorkspaceContext: WorkspaceContext | null = null;
  
  // Set of session IDs that have already received instructions
  private instructedSessions: Set<string> = new Set();
  
  /**
   * Set the session service for database validation
   * This is called during plugin initialization
   */
  setSessionService(sessionService: any): void {
    this.sessionService = sessionService;
  }
  
  /**
   * Get workspace context for a specific session
   * 
   * @param sessionId The session ID to retrieve context for
   * @returns The workspace context for the session, or null if not found
   */
  getWorkspaceContext(sessionId: string): WorkspaceContext | null {
    return this.sessionContextMap.get(sessionId) || this.defaultWorkspaceContext;
  }
  
  /**
   * Set workspace context for a specific session
   * 
   * @param sessionId The session ID to set context for
   * @param context The workspace context to associate with the session
   */
  setWorkspaceContext(sessionId: string, context: WorkspaceContext): void {
    if (!sessionId) {
      logger.systemWarn('Attempted to set workspace context with empty sessionId');
      return;
    }
    
    if (!context.workspaceId) {
      logger.systemWarn('Attempted to set workspace context with empty workspaceId');
      return;
    }
    
    this.sessionContextMap.set(sessionId, context);
    logger.systemLog(`Set workspace context for session ${sessionId}: ${context.workspaceId}`);
  }
  
  /**
   * Set the default workspace context used for new sessions
   * 
   * @param context The default workspace context or null to clear
   */
  setDefaultWorkspaceContext(context: WorkspaceContext | null): void {
    this.defaultWorkspaceContext = context;
    if (context) {
      logger.systemLog(`Set default workspace context: ${context.workspaceId}`);
    } else {
      logger.systemLog('Cleared default workspace context');
    }
  }
  
  /**
   * Clear workspace context for a specific session
   * 
   * @param sessionId The session ID to clear context for
   */
  clearWorkspaceContext(sessionId: string): void {
    this.sessionContextMap.delete(sessionId);
  }
  
  /**
   * Update workspace context from a result
   * Extracts and saves workspace context from mode execution results
   * 
   * @param sessionId The session ID to update context for
   * @param result The result containing workspace context
   */
  updateFromResult(sessionId: string, result: CommonResult): void {
    if (!result.workspaceContext || !result.workspaceContext.workspaceId) {
      return;
    }
    
    this.setWorkspaceContext(sessionId, result.workspaceContext);
  }
  
  /**
   * Apply workspace context to parameters if not already specified
   * 
   * @param sessionId The session ID to get context for
   * @param params The parameters to apply context to
   * @returns The parameters with workspace context applied
   */
  applyWorkspaceContext<T extends { workspaceContext?: WorkspaceContext }>(
    sessionId: string, 
    params: T
  ): T {
    // Don't override existing context if specified
    const parsedContext = parseWorkspaceContext(params.workspaceContext);
  if (parsedContext?.workspaceId) {
      return params;
    }
    
    const context = this.getWorkspaceContext(sessionId);
    if (!context) {
      return params;
    }
    
    // Create new params object to avoid mutation
    return {
      ...params,
      workspaceContext: context
    };
  }
  
  /**
   * Check if workspace context exists for a session
   * 
   * @param sessionId The session ID to check
   * @returns True if context exists for the session
   */
  hasWorkspaceContext(sessionId: string): boolean {
    return this.sessionContextMap.has(sessionId);
  }
  
  /**
   * Get all active sessions with their workspace contexts
   * 
   * @returns Map of all session IDs to their workspace contexts
   */
  getAllSessionContexts(): Map<string, WorkspaceContext> {
    return new Map(this.sessionContextMap);
  }
  
  /**
   * Clear all session contexts
   */
  clearAll(): void {
    this.sessionContextMap.clear();
    this.defaultWorkspaceContext = null;
  }
  
  /**
   * Set the memory service for session validation
   * 
   * @param memoryService The memory service instance
   */
  setMemoryService(_memoryService: any): void {
    // Placeholder for future implementation
    // Memory service will be used for session validation in future releases
  }
  
  /**
   * Validate a session ID and auto-create session if needed
   * 
   * @param sessionId The session ID to validate (can be friendly name or standard ID)
   * @param sessionDescription Optional session description for auto-creation
   * @returns Object with validated session ID and creation status
   */
  async validateSessionId(sessionId: string, sessionDescription?: string): Promise<{id: string, created: boolean}> {
    
    // If no session ID is provided, generate a new one in our standard format
    if (!sessionId) {
      logger.systemWarn('Empty sessionId provided for validation, generating a new one');
      const newId = generateSessionId();
      await this.createAutoSession(newId, 'Default Session', sessionDescription);
      return {id: newId, created: true};
    }
    
    // If the session ID doesn't match our standard format, it's a friendly name - create session
    if (!isStandardSessionId(sessionId)) {
      const newId = generateSessionId();
      await this.createAutoSession(newId, sessionId, sessionDescription);
      return {id: newId, created: true};
    }
    
    // Session ID is in standard format - check if it exists in database
    console.log(`üö® SessionService available: ${!!this.sessionService}`);
    if (this.sessionService) {
      try {
        const existingSession = await this.sessionService.getSession(sessionId);
        if (existingSession) {
          return {id: sessionId, created: false};
        } else {
          await this.createAutoSession(sessionId, `Session ${sessionId}`, sessionDescription);
          return {id: sessionId, created: true};
        }
      } catch (error) {
        logger.systemWarn(`Error checking session existence: ${error instanceof Error ? error.message : String(error)}`);
        // Fallback to returning the session ID without verification
        return {id: sessionId, created: false};
      }
    } else {
      logger.systemWarn('SessionService not available - cannot validate session existence');
      // Return the original sessionId if it's already in our standard format
      return {id: sessionId, created: false};
    }
  }

  /**
   * Auto-create a session with given parameters
   * 
   * @param sessionId Generated standard session ID
   * @param sessionName Friendly name provided by LLM
   * @param sessionDescription Optional session description
   */
  private async createAutoSession(sessionId: string, sessionName: string, sessionDescription?: string): Promise<void> {
    logger.systemLog(`Auto-created session: ${sessionId} with name "${sessionName}" and description "${sessionDescription || 'No description'}"`);
    
    // Create session using the injected session service
    if (this.sessionService) {
      try {
        const sessionData = {
          name: sessionName,
          description: sessionDescription || '',
          workspaceId: 'default-workspace',
          id: sessionId
        };
        
        const createdSession = await this.sessionService.createSession(sessionData);
        logger.systemLog(`Session ${sessionId} successfully created in database`);
      } catch (error) {
        logger.systemError(error as Error, `Failed to create session ${sessionId}`);
      }
    } else {
      logger.systemWarn(`SessionService not available - session ${sessionId} not saved to database`);
    }
  }
  
  /**
   * Update session description if it has changed
   * 
   * @param sessionId Standard session ID
   * @param sessionDescription New session description
   */
  async updateSessionDescription(sessionId: string, sessionDescription: string): Promise<void> {
    logger.systemLog(`Updating session description for ${sessionId}: "${sessionDescription}"`);
    
    // Update session using the injected session service
    if (this.sessionService) {
      try {
        // Note: This assumes the session service has an updateSession method
        // If not, we may need to use a different method
        await this.sessionService.updateSession?.(sessionId, { description: sessionDescription });
        logger.systemLog(`Session ${sessionId} description updated in database`);
      } catch (error) {
        logger.systemError(error as Error, `Failed to update session ${sessionId} description`);
      }
    } else {
      logger.systemWarn(`SessionService not available - session ${sessionId} description update not saved`);
    }
  }

  /**
   * Check if a session ID appears to be generated by Claude or not in our standard format
   * 
   * @param sessionId The session ID to check
   * @returns Boolean indicating if this appears to be a non-standard ID
   */
  isNonStandardSessionId(sessionId: string): boolean {
    return !isStandardSessionId(sessionId);
  }
  
  /**
   * Check if a session has already received instructions
   * 
   * @param sessionId The session ID to check
   * @returns Whether instructions have been sent for this session
   */
  hasReceivedInstructions(sessionId: string): boolean {
    return this.instructedSessions.has(sessionId);
  }
  
  /**
   * Mark a session as having received instructions
   * 
   * @param sessionId The session ID to mark
   */
  markInstructionsReceived(sessionId: string): void {
    this.instructedSessions.add(sessionId);
    logger.systemLog(`Marked session ${sessionId} as having received instructions`);
  }
}
```

## services/StaticModelsService.ts

```typescript
/**
 * Static Models Service
 * Loads model information from static adapter files instead of making API calls
 */

import { ModelSpec } from './llm/adapters/modelTypes';
import { OPENAI_MODELS } from './llm/adapters/openai/OpenAIModels';
import { ANTHROPIC_MODELS } from './llm/adapters/anthropic/AnthropicModels';
import { GOOGLE_MODELS } from './llm/adapters/google/GoogleModels';
import { MISTRAL_MODELS } from './llm/adapters/mistral/MistralModels';
import { GROQ_MODELS } from './llm/adapters/groq/GroqModels';
import { OPENROUTER_MODELS } from './llm/adapters/openrouter/OpenRouterModels';
import { REQUESTY_MODELS } from './llm/adapters/requesty/RequestyModels';
import { PERPLEXITY_MODELS } from './llm/adapters/perplexity/PerplexityModels';

export interface ModelWithProvider {
  provider: string;
  id: string;
  name: string;
  contextWindow: number;
  maxTokens: number;
  pricing: {
    inputPerMillion: number;
    outputPerMillion: number;
    currency: string;
  };
  capabilities: {
    supportsJSON: boolean;
    supportsImages: boolean;
    supportsFunctions: boolean;
    supportsStreaming: boolean;
    supportsThinking: boolean;
  };
  userDescription?: string; // User-defined description
  isDefault?: boolean;
}

export class StaticModelsService {
  private static instance: StaticModelsService;
  private modelCache: Map<string, ModelWithProvider[]> = new Map();

  /**
   * Get singleton instance
   */
  static getInstance(): StaticModelsService {
    if (!StaticModelsService.instance) {
      StaticModelsService.instance = new StaticModelsService();
    }
    return StaticModelsService.instance;
  }

  /**
   * Get all models for all providers
   */
  getAllModels(): ModelWithProvider[] {
    const allModels: ModelWithProvider[] = [];
    
    const providerModels = [
      { provider: 'openai', models: OPENAI_MODELS },
      { provider: 'anthropic', models: ANTHROPIC_MODELS },
      { provider: 'google', models: GOOGLE_MODELS },
      { provider: 'mistral', models: MISTRAL_MODELS },
      { provider: 'groq', models: GROQ_MODELS },
      { provider: 'openrouter', models: OPENROUTER_MODELS },
      { provider: 'requesty', models: REQUESTY_MODELS },
      { provider: 'perplexity', models: PERPLEXITY_MODELS }
    ];

    providerModels.forEach(({ provider, models }) => {
      models.forEach(model => {
        allModels.push(this.convertModelSpec(model));
      });
    });

    return allModels;
  }

  /**
   * Get models for a specific provider
   */
  getModelsForProvider(providerId: string): ModelWithProvider[] {
    if (this.modelCache.has(providerId)) {
      return this.modelCache.get(providerId)!;
    }

    let providerModels: ModelSpec[] = [];
    
    switch (providerId) {
      case 'openai':
        providerModels = OPENAI_MODELS;
        break;
      case 'anthropic':
        providerModels = ANTHROPIC_MODELS;
        break;
      case 'google':
        providerModels = GOOGLE_MODELS;
        break;
      case 'mistral':
        providerModels = MISTRAL_MODELS;
        break;
      case 'groq':
        providerModels = GROQ_MODELS;
        break;
      case 'openrouter':
        providerModels = OPENROUTER_MODELS;
        break;
      case 'requesty':
        providerModels = REQUESTY_MODELS;
        break;
      case 'perplexity':
        providerModels = PERPLEXITY_MODELS;
        break;
      default:
        return [];
    }

    const convertedModels = providerModels.map(model => this.convertModelSpec(model));
    this.modelCache.set(providerId, convertedModels);
    
    return convertedModels;
  }

  /**
   * Convert ModelSpec to ModelWithProvider format
   */
  private convertModelSpec(model: ModelSpec): ModelWithProvider {
    return {
      provider: model.provider,
      id: model.apiName,
      name: model.name,
      contextWindow: model.contextWindow,
      maxTokens: model.maxTokens,
      pricing: {
        inputPerMillion: model.inputCostPerMillion,
        outputPerMillion: model.outputCostPerMillion,
        currency: 'USD'
      },
      capabilities: {
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: model.capabilities.supportsThinking
      }
    };
  }

  /**
   * Get provider information
   */
  getAvailableProviders(): string[] {
    return ['openai', 'anthropic', 'google', 'mistral', 'groq', 'openrouter', 'requesty', 'perplexity'];
  }

  /**
   * Check if a provider has models available
   */
  hasModelsForProvider(providerId: string): boolean {
    const models = this.getModelsForProvider(providerId);
    return models.length > 0;
  }

  /**
   * Find a specific model by provider and model ID
   * For OpenRouter, supports :online suffix (e.g., "gpt-4:online")
   */
  findModel(provider: string, modelId: string): ModelWithProvider | undefined {
    const providerModels = this.getModelsForProvider(provider);
    
    // For OpenRouter models, check if modelId has :online suffix
    if (provider === 'openrouter' && modelId.endsWith(':online')) {
      const baseModelId = modelId.replace(':online', '');
      return providerModels.find(model => model.id === baseModelId);
    }
    
    return providerModels.find(model => model.id === modelId);
  }

  /**
   * Get models suitable for specific tasks
   */
  getModelsForTask(taskType: 'coding' | 'writing' | 'analysis' | 'creative' | 'fast'): ModelWithProvider[] {
    const allModels = this.getAllModels();

    switch (taskType) {
      case 'coding':
        return allModels.filter(model => 
          model.capabilities.supportsFunctions || 
          model.id.includes('code') || 
          model.provider === 'mistral' ||
          model.id.includes('gpt-4')
        );
      
      case 'writing':
        return allModels.filter(model => 
          model.provider === 'anthropic' || 
          model.id.includes('gpt-4') ||
          model.contextWindow > 32000
        );
      
      case 'analysis':
        return allModels.filter(model => 
          model.provider === 'anthropic' ||
          model.id.includes('gpt-4') ||
          model.contextWindow > 100000
        );
      
      case 'creative':
        return allModels.filter(model => 
          model.provider === 'openai' ||
          model.provider === 'anthropic' ||
          model.provider === 'google'
        );
      
      case 'fast':
        return allModels.filter(model => 
          model.provider === 'groq' ||
          model.id.includes('turbo') ||
          model.id.includes('fast') ||
          model.id.includes('mini')
        );
      
      default:
        return allModels;
    }
  }

  /**
   * Get model statistics
   */
  getModelStatistics(): {
    totalModels: number;
    providerCount: number;
    averageContextWindow: number;
    maxContextWindow: number;
    minCostPerMillion: number;
    maxCostPerMillion: number;
  } {
    const allModels = this.getAllModels();
    
    if (allModels.length === 0) {
      return {
        totalModels: 0,
        providerCount: 0,
        averageContextWindow: 0,
        maxContextWindow: 0,
        minCostPerMillion: 0,
        maxCostPerMillion: 0
      };
    }

    const providers = new Set(allModels.map(m => m.provider));
    const contextWindows = allModels.map(m => m.contextWindow);
    const costs = allModels.map(m => m.pricing.inputPerMillion);

    return {
      totalModels: allModels.length,
      providerCount: providers.size,
      averageContextWindow: Math.round(contextWindows.reduce((a, b) => a + b, 0) / allModels.length),
      maxContextWindow: Math.max(...contextWindows),
      minCostPerMillion: Math.min(...costs),
      maxCostPerMillion: Math.max(...costs)
    };
  }
}
```

## services/UsageTracker.ts

```typescript
/**
 * Shared Usage Tracking Service
 * Handles cost tracking for LLM usage with provider-level breakdown
 */

export type UsageType = 'llm';

export interface ProviderUsage {
    [provider: string]: number; // Cost in USD
}

export interface UsageData {
    monthly: ProviderUsage;
    allTime: ProviderUsage;
    monthlyTotal: number;
    allTimeTotal: number;
    currentMonth: string;
    lastUpdated: string;
}

export interface BudgetStatus {
    monthlyBudget: number;
    currentSpending: number;
    percentageUsed: number;
    budgetExceeded: boolean;
    remainingBudget: number;
}

export interface UsageResponse {
    provider: string;
    cost: number;
    budgetStatus: BudgetStatus;
}

/**
 * Shared service for tracking usage costs by provider
 * Supports tracking for LLM usage
 */
export class UsageTracker {
    private readonly storageKeyPrefix: string;
    private readonly budgetKey: string;
    
    constructor(
        private usageType: UsageType,
        private settings: any
    ) {
        this.storageKeyPrefix = `claudesidian-usage-${usageType}`;
        this.budgetKey = `claudesidian-budget-${usageType}`;
    }

    /**
     * Track usage for a specific provider
     */
    async trackUsage(provider: string, cost: number): Promise<UsageResponse> {
        const usage = await this.loadUsageData();
        const currentMonth = this.getCurrentMonthKey();
        
        // Reset monthly stats if new month
        if (usage.currentMonth !== currentMonth) {
            usage.monthly = {};
            usage.monthlyTotal = 0;
            usage.currentMonth = currentMonth;
        }
        
        // Update monthly usage
        usage.monthly[provider] = (usage.monthly[provider] || 0) + cost;
        usage.monthlyTotal += cost;
        
        // Update all-time usage
        usage.allTime[provider] = (usage.allTime[provider] || 0) + cost;
        usage.allTimeTotal += cost;
        
        usage.lastUpdated = new Date().toISOString();
        
        await this.saveUsageData(usage);
        
        const budgetStatus = this.getBudgetStatus(usage.monthlyTotal);
        
        return {
            provider,
            cost,
            budgetStatus
        };
    }

    /**
     * Check if budget allows for a specific cost
     */
    async canAfford(cost: number): Promise<boolean> {
        const usage = await this.loadUsageData();
        const budget = this.getMonthlyBudget();
        
        if (budget <= 0) return true; // No budget set
        
        return (usage.monthlyTotal + cost) <= budget;
    }

    /**
     * Get current budget status
     */
    async getBudgetStatusAsync(): Promise<BudgetStatus> {
        const usage = await this.loadUsageData();
        return this.getBudgetStatus(usage.monthlyTotal);
    }

    /**
     * Get usage data for display
     */
    async getUsageData(): Promise<UsageData> {
        return await this.loadUsageData();
    }

    /**
     * Reset monthly usage
     */
    async resetMonthlyUsage(): Promise<void> {
        const usage = await this.loadUsageData();
        usage.monthly = {};
        usage.monthlyTotal = 0;
        usage.currentMonth = this.getCurrentMonthKey();
        usage.lastUpdated = new Date().toISOString();
        
        await this.saveUsageData(usage);
    }

    /**
     * Set monthly budget
     */
    setMonthlyBudget(budget: number): void {
        if (typeof localStorage === 'undefined') return;
        
        try {
            localStorage.setItem(this.budgetKey, budget.toString());
        } catch (error) {
            console.warn(`Failed to save ${this.usageType} budget:`, error);
        }
    }

    /**
     * Get monthly budget
     */
    getMonthlyBudget(): number {
        if (typeof localStorage === 'undefined') return 0;
        
        try {
            const budget = localStorage.getItem(this.budgetKey);
            return budget ? parseFloat(budget) : 0;
        } catch (error) {
            console.warn(`Failed to load ${this.usageType} budget:`, error);
            return 0;
        }
    }

    /**
     * Load usage data from storage
     */
    private async loadUsageData(): Promise<UsageData> {
        const defaultData: UsageData = {
            monthly: {},
            allTime: {},
            monthlyTotal: 0,
            allTimeTotal: 0,
            currentMonth: this.getCurrentMonthKey(),
            lastUpdated: new Date().toISOString()
        };

        if (typeof localStorage === 'undefined') {
            return defaultData;
        }

        try {
            const stored = localStorage.getItem(this.storageKeyPrefix);
            if (!stored) return defaultData;

            const parsed = JSON.parse(stored) as UsageData;
            
            // Ensure all required fields exist
            return {
                monthly: parsed.monthly || {},
                allTime: parsed.allTime || {},
                monthlyTotal: parsed.monthlyTotal || 0,
                allTimeTotal: parsed.allTimeTotal || 0,
                currentMonth: parsed.currentMonth || this.getCurrentMonthKey(),
                lastUpdated: parsed.lastUpdated || new Date().toISOString()
            };
        } catch (error) {
            console.warn(`Failed to load ${this.usageType} usage data:`, error);
            return defaultData;
        }
    }

    /**
     * Save usage data to storage
     */
    private async saveUsageData(data: UsageData): Promise<void> {
        if (typeof localStorage === 'undefined') return;

        try {
            localStorage.setItem(this.storageKeyPrefix, JSON.stringify(data));
        } catch (error) {
            console.warn(`Failed to save ${this.usageType} usage data:`, error);
        }
    }

    /**
     * Get budget status for current spending
     */
    private getBudgetStatus(currentSpending: number): BudgetStatus {
        const monthlyBudget = this.getMonthlyBudget();
        const percentageUsed = monthlyBudget > 0 ? (currentSpending / monthlyBudget) * 100 : 0;
        const budgetExceeded = monthlyBudget > 0 && currentSpending >= monthlyBudget;
        const remainingBudget = Math.max(0, monthlyBudget - currentSpending);

        return {
            monthlyBudget,
            currentSpending,
            percentageUsed: Math.round(percentageUsed * 100) / 100, // Round to 2 decimal places
            budgetExceeded,
            remainingBudget
        };
    }

    /**
     * Get current month key (YYYY-MM format)
     */
    private getCurrentMonthKey(): string {
        const now = new Date();
        return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
    }
}
```

## services/agent/AgentRegistrationService.ts

```typescript
import { App, Plugin } from 'obsidian';
import ClaudesidianPlugin from '../../main';
import { AgentManager } from '../AgentManager';
import { EventManager } from '../EventManager';
import type { ServiceManager } from '../../core/ServiceManager';
import {
    ContentManagerAgent,
    CommandManagerAgent,
    VaultManagerAgent,
    VaultLibrarianAgent,
    MemoryManagerAgent,
    AgentManagerAgent
} from '../../agents';
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';
import { CustomPromptStorageService } from "../../agents/agentManager/services/CustomPromptStorageService";
import { LLMProviderManager } from '../llm/providers/ProviderManager';
import { DEFAULT_LLM_PROVIDER_SETTINGS } from '../../types';
import { LLMValidationService } from '../llm/validation/ValidationService';

/**
 * Location: src/services/agent/AgentRegistrationService.ts
 * 
 * This service handles agent initialization and registration, including:
 * - Agent creation and configuration
 * - API key validation for agent capabilities
 * - Agent lifecycle management
 * - Service dependency injection
 * 
 * Used by: MCPConnector
 * Dependencies: All agent implementations, ServiceContainer, validation services
 */

export interface AgentRegistrationServiceInterface {
    /**
     * Initializes all configured agents
     * @returns Promise resolving to map of initialized agents
     * @throws InitializationError when agent initialization fails
     */
    initializeAllAgents(): Promise<Map<string, any>>;

    /**
     * Gets registered agent by name
     * @param name Agent name
     * @returns Agent instance or null if not found
     */
    getAgent(name: string): any | null;

    /**
     * Gets all registered agents
     * @returns Map of all registered agents
     */
    getAllAgents(): Map<string, any>;

    /**
     * Registers agents with server
     * @param registerFunction Function to register agents with server
     */
    registerAgentsWithServer(registerFunction: (agent: any) => void): void;

    /**
     * Gets agent registration status
     * @returns Registration status information
     */
    getRegistrationStatus(): AgentRegistrationStatus;
}

export interface AgentRegistrationStatus {
    /** Total number of registered agents */
    totalAgents: number;
    
    /** Number of successfully initialized agents */
    initializedAgents: number;
    
    /** Number of failed agent initializations */
    failedAgents: number;
    
    /** Agent initialization errors */
    initializationErrors: Record<string, Error>;
    
    /** Registration timestamp */
    registrationTime: Date;
    
    /** Time taken for registration in milliseconds */
    registrationDuration: number;
}

export class AgentRegistrationService implements AgentRegistrationServiceInterface {
    private agentManager: AgentManager;
    private registrationStatus: AgentRegistrationStatus;
    private initializationErrors: Record<string, Error> = {};

    constructor(
        private app: App,
        private plugin: Plugin | ClaudesidianPlugin,
        private eventManager: EventManager,
        private serviceManager?: ServiceManager,
        private customPromptStorage?: CustomPromptStorageService
    ) {
        this.agentManager = new AgentManager(app, plugin, eventManager);
        this.registrationStatus = {
            totalAgents: 0,
            initializedAgents: 0,
            failedAgents: 0,
            initializationErrors: {},
            registrationTime: new Date(),
            registrationDuration: 0
        };
    }

    /**
     * Initializes all configured agents
     */
    async initializeAllAgents(): Promise<Map<string, any>> {
        const startTime = Date.now();
        this.registrationStatus.registrationTime = new Date();
        this.initializationErrors = {};

        try {
            // Get memory settings to determine what to enable
            const memorySettings = this.plugin && (this.plugin as any).settings?.settings?.memory;
            const isMemoryEnabled = memorySettings?.enabled;
            
            // Validate API keys
            const hasValidLLMKeys = await this.validateLLMApiKeys();

            // Search modes disabled
            const enableSearchModes = false;
            
            // Enable LLM-dependent modes only if valid LLM API keys exist
            const enableLLMModes = hasValidLLMKeys;
            
            logger.systemLog(`Agent initialization started - Search modes: ${enableSearchModes}, LLM modes: ${enableLLMModes}`);
            
            // Log additional debugging info for AgentManager
            if (!hasValidLLMKeys) {
                const pluginSettings = (this.plugin as any)?.settings?.settings;
                const llmProviderSettings = pluginSettings?.llmProviders || DEFAULT_LLM_PROVIDER_SETTINGS;
                logger.systemLog(`LLM validation failed - Default provider: ${llmProviderSettings.defaultModel?.provider || 'none'}, Provider config exists: ${!!llmProviderSettings.providers}`);
            }

            // Initialize agents in order
            await this.initializeContentManager();
            await this.initializeCommandManager();
            await this.initializeVaultManager();
            await this.initializeAgentManager(enableLLMModes);
            await this.initializeVaultLibrarian(enableSearchModes, memorySettings);
            await this.initializeMemoryManager();
            // ChatAgent removed - native chatbot UI handles chat functionality
            logger.systemLog('Using native chatbot UI instead of ChatAgent');

            // Calculate final statistics
            const agents = this.agentManager.getAgents();
            this.registrationStatus = {
                totalAgents: agents.length,
                initializedAgents: agents.length - Object.keys(this.initializationErrors).length,
                failedAgents: Object.keys(this.initializationErrors).length,
                initializationErrors: this.initializationErrors,
                registrationTime: this.registrationStatus.registrationTime,
                registrationDuration: Date.now() - startTime
            };

            // Log conditional mode availability status
            if (!enableSearchModes && !enableLLMModes) {
                logger.systemLog("No valid API keys found - modes requiring API keys will be disabled");
            } else {
                if (!enableSearchModes) {
                    logger.systemLog("Search modes disabled");
                }
                if (!enableLLMModes) {
                    logger.systemLog("LLM modes disabled - no valid LLM API keys configured");
                }
            }

            logger.systemLog(`Agent initialization completed - ${this.registrationStatus.initializedAgents}/${this.registrationStatus.totalAgents} agents initialized`);

            return new Map(agents.map(agent => [agent.name, agent]));

        } catch (error) {
            this.registrationStatus.registrationDuration = Date.now() - startTime;
            
            logger.systemError(error as Error, 'Agent Registration');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to initialize agents',
                error
            );
        }
    }

    /**
     * Gets registered agent by name
     */
    getAgent(name: string): any | null {
        try {
            return this.agentManager.getAgent(name);
        } catch (error) {
            return null;
        }
    }

    /**
     * Gets all registered agents
     */
    getAllAgents(): Map<string, any> {
        const agents = this.agentManager.getAgents();
        return new Map(agents.map(agent => [agent.name, agent]));
    }

    /**
     * Registers agents with server
     */
    registerAgentsWithServer(registerFunction: (agent: any) => void): void {
        try {
            const agents = this.agentManager.getAgents();
            
            for (const agent of agents) {
                registerFunction(agent);
            }
            
            logger.systemLog(`Registered ${agents.length} agents with server`);
        } catch (error) {
            logger.systemError(error as Error, 'Agent Server Registration');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to register agents with server',
                error
            );
        }
    }

    /**
     * Gets agent registration status
     */
    getRegistrationStatus(): AgentRegistrationStatus {
        return { ...this.registrationStatus };
    }

    /**
     * Initialize ContentManager agent
     * @private
     */
    private async initializeContentManager(): Promise<void> {
        try {
            const contentManagerAgent = new ContentManagerAgent(
                this.app, 
                this.plugin as ClaudesidianPlugin
            );
            
            this.agentManager.registerAgent(contentManagerAgent);
            logger.systemLog('ContentManager agent initialized successfully');
        } catch (error) {
            this.initializationErrors['contentManager'] = error as Error;
            logger.systemError(error as Error, 'ContentManager Agent Initialization');
        }
    }

    /**
     * Initialize CommandManager agent
     * @private
     */
    private async initializeCommandManager(): Promise<void> {
        try {
            // CommandManager with lazy memory service - NON-BLOCKING
            const memoryService = this.serviceManager ? 
                this.serviceManager.getServiceIfReady('memoryService') : null;
            
            const commandManagerAgent = new CommandManagerAgent(
                this.app, 
                memoryService as any
            );
            
            this.agentManager.registerAgent(commandManagerAgent);
            logger.systemLog('CommandManager agent initialized successfully');
        } catch (error) {
            this.initializationErrors['commandManager'] = error as Error;
            logger.systemError(error as Error, 'CommandManager Agent Initialization');
        }
    }

    /**
     * Initialize VaultManager agent
     * @private
     */
    private async initializeVaultManager(): Promise<void> {
        try {
            const vaultManagerAgent = new VaultManagerAgent(this.app);
            
            this.agentManager.registerAgent(vaultManagerAgent);
            logger.systemLog('VaultManager agent initialized successfully');
        } catch (error) {
            this.initializationErrors['vaultManager'] = error as Error;
            logger.systemError(error as Error, 'VaultManager Agent Initialization');
        }
    }

    /**
     * Initialize AgentManager agent
     * @private
     */
    private async initializeAgentManager(enableLLMModes: boolean): Promise<void> {
        try {
            if (!this.customPromptStorage) {
                logger.systemWarn('AgentManager agent - no custom prompt storage available from constructor');
                // Try to create custom prompt storage directly if settings are available
                const pluginSettings = this.plugin && (this.plugin as any).settings;
                if (pluginSettings) {
                    try {
                        this.customPromptStorage = new CustomPromptStorageService(pluginSettings);
                        logger.systemLog('AgentManager - created custom prompt storage during initialization');
                    } catch (error) {
                        logger.systemError(error as Error, 'AgentManager - Failed to create custom prompt storage');
                        return;
                    }
                } else {
                    logger.systemError(new Error('Plugin settings not available'), 'AgentManager agent initialization');
                    return;
                }
            }

            const agentManagerAgent = new AgentManagerAgent((this.plugin as any).settings);
            logger.systemLog(`AgentManager agent created - LLM modes enabled: ${enableLLMModes}`);

            // Initialize LLM Provider Manager if LLM modes are enabled
            if (enableLLMModes) {
                try {
                    // Get LLM provider settings from plugin settings or use defaults
                    const pluginSettings = (this.plugin as any)?.settings?.settings;
                    const llmProviderSettings = pluginSettings?.llmProviders || DEFAULT_LLM_PROVIDER_SETTINGS;
                    
                    // Create LLM Provider Manager
                    const llmProviderManager = new LLMProviderManager(llmProviderSettings);
                    
                    // Set up the provider manager on the agent
                    agentManagerAgent.setProviderManager(llmProviderManager);
                    
                    // Set the vault adapter for file reading
                    llmProviderManager.setVaultAdapter(this.app.vault.adapter);
                    
                    agentManagerAgent.setParentAgentManager(this.agentManager);
                    
                    // Create and inject LLM usage tracker (non-blocking)
                    import('../UsageTracker').then(({ UsageTracker }) => {
                        const llmUsageTracker = new UsageTracker('llm', pluginSettings);
                        agentManagerAgent.setUsageTracker(llmUsageTracker);
                    }).catch(error => {
                        logger.systemError(error as Error, 'LLM Usage Tracker Initialization');
                    });
                    
                } catch (error) {
                    logger.systemError(error as Error, 'LLM Provider Manager Initialization');
                    // Continue without LLM modes - basic prompt management will still work
                }
            } else {
                logger.systemLog('LLM modes disabled - AgentManager will function with prompt management only');
            }
            
            // Always set the parent agent manager for basic functionality
            agentManagerAgent.setParentAgentManager(this.agentManager);
            
            // Set the vault for image generation functionality
            agentManagerAgent.setVault(this.app.vault);
            
            // Set LLM settings for image generation
            const pluginSettings = (this.plugin as any)?.settings?.settings;
            if (pluginSettings) {
                agentManagerAgent.setLLMSettings(pluginSettings);
            }
            
            this.agentManager.registerAgent(agentManagerAgent);
            logger.systemLog('AgentManager agent initialized successfully');
        } catch (error) {
            this.initializationErrors['agentManager'] = error as Error;
            logger.systemError(error as Error, 'AgentManager Agent Initialization');
        }
    }

    /**
     * Initialize VaultLibrarian agent
     * @private
     */
    private async initializeVaultLibrarian(enableSearchModes: boolean, memorySettings: any): Promise<void> {
        try {
            const vaultLibrarianAgent = new VaultLibrarianAgent(
                this.app,
                enableSearchModes  // Pass search modes enabled status
            );
            
            // Update VaultLibrarian with memory settings
            if (memorySettings) {
                vaultLibrarianAgent.updateSettings(memorySettings);
            }
            
            this.agentManager.registerAgent(vaultLibrarianAgent);
            logger.systemLog('VaultLibrarian agent initialized successfully');
        } catch (error) {
            this.initializationErrors['vaultLibrarian'] = error as Error;
            logger.systemError(error as Error, 'VaultLibrarian Agent Initialization');
        }
    }

    /**
     * Initialize MemoryManager agent
     * @private
     */
    private async initializeMemoryManager(): Promise<void> {
        try {
            const memoryManagerAgent = new MemoryManagerAgent(
                this.app,
                this.plugin
            );
            
            this.agentManager.registerAgent(memoryManagerAgent);
            logger.systemLog('MemoryManager agent initialized successfully');
        } catch (error) {
            this.initializationErrors['memoryManager'] = error as Error;
            logger.systemError(error as Error, 'MemoryManager Agent Initialization');
        }
    }


    /**
     * Validate API keys for LLM providers used in agent modes
     * @private
     */
    private async validateLLMApiKeys(): Promise<boolean> {
        try {
            const pluginSettings = (this.plugin as any)?.settings?.settings;
            const llmProviderSettings = pluginSettings?.llmProviders || DEFAULT_LLM_PROVIDER_SETTINGS;
            
            const defaultProvider = llmProviderSettings.defaultModel?.provider;
            if (!defaultProvider) {
                return false;
            }

            const providerConfig = llmProviderSettings.providers?.[defaultProvider];
            if (!providerConfig?.apiKey) {
                return false;
            }

            // Validate the API key
            const validation = await LLMValidationService.validateApiKey(defaultProvider, providerConfig.apiKey);
            return validation.success;
        } catch (error) {
            logger.systemError(error as Error, 'LLM API Key Validation');
            return false;
        }
    }
}
```

## services/chat/ChatService.ts

```typescript
/**
 * ChatService - Native chatbot with MCP client integration
 * 
 * Acts as an internal MCP client to our own MCP server, allowing the chatbot
 * to use all existing agents and tools through the MCP protocol.
 * 
 * Flow: User message ‚Üí LLM ‚Üí Tool calls ‚Üí MCP client ‚Üí Our agents ‚Üí Results ‚Üí LLM ‚Üí Response
 */

// import { ConversationRepository } from '../../database/services/chat/ConversationRepository';
import { ConversationData, ConversationMessage, ToolCall, CreateConversationParams } from '../../types/chat/ChatTypes';
import { documentToConversationData } from '../../types/chat/ChatTypes';
import { getErrorMessage } from '../../utils/errorUtils';
import { MCPChatIntegration, MCPChatOptions } from './MCPChatIntegration';
import { MCPConfigurationManager } from '../mcp/MCPConfigurationManager';
import { ConversationContextBuilder } from './ConversationContextBuilder';

export interface ChatServiceOptions {
  maxToolIterations?: number;
  toolTimeout?: number;
  enableToolChaining?: boolean;
  mcpServerPath?: string;
}

export interface ChatServiceDependencies {
  conversationService: any;
  llmService: any;
  vaultName: string;
  mcpConnector?: any;
  mcpServerUrl?: string;
}

export class ChatService {
  private availableTools: any[] = [];
  private toolCallHistory = new Map<string, ToolCall[]>();
  private mcpIntegration: MCPChatIntegration;
  private mcpConfig: MCPConfigurationManager;
  private toolEventCallback?: (messageId: string, event: 'started' | 'completed', data: any) => void;
  private currentProvider?: string; // Track current provider for context building
  
  constructor(
    private dependencies: ChatServiceDependencies,
    private options: ChatServiceOptions = {}
  ) {
    this.options = {
      maxToolIterations: 10,
      toolTimeout: 30000,
      enableToolChaining: true,
      ...options
    };
    
    // Initialize MCP integration
    this.mcpConfig = new MCPConfigurationManager();
    this.mcpIntegration = new MCPChatIntegration(this.mcpConfig);
  }

  /**
   * Set tool event callback for live UI updates
   */
  setToolEventCallback(callback: (messageId: string, event: 'started' | 'completed', data: any) => void): void {
    this.toolEventCallback = callback;
  }

  /**
   * Initialize the HTTP MCP integration
   */
  async initialize(): Promise<void> {
    try {
      
      // Initialize with MCP server URL if provided
      if (this.dependencies.mcpServerUrl) {
        this.mcpIntegration.initialize(this.dependencies.mcpServerUrl);
      }
      
      // Get real tools from MCP connector if available
      if (this.dependencies.mcpConnector && typeof this.dependencies.mcpConnector.getAvailableTools === 'function') {
        this.availableTools = this.dependencies.mcpConnector.getAvailableTools();
      } else {
        // Fallback: use static tool manifest for MVP
        console.warn('[ChatService] MCP connector not available, using static tool manifest');
        this.availableTools = this.getStaticToolManifest();
      }
      
      // Auto-configure MCP for supported providers
      if (this.dependencies.llmService) {
        this.mcpIntegration.autoConfigureProviders(this.dependencies.llmService);
      }
      
      // Log available tool count for debugging
      console.log(`[ChatService] Initialized with ${this.availableTools.length} tools available`);
      
    } catch (error) {
      console.error('[ChatService] Failed to initialize MCP integration:', error);
      // Continue without MCP connection - chatbot will work without tools
      this.availableTools = [];
    }
  }

  /**
   * Create a new conversation
   */
  async createConversation(
    title: string, 
    initialMessage?: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
    }
  ): Promise<{
    success: boolean;
    conversationId?: string;
    error?: string;
  }> {
    try {
      const conversation: ConversationData = {
        id: `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        title,
        created: Date.now(),
        updated: Date.now(),
        messages: []
      };

      const createParams: CreateConversationParams = {
        title: conversation.title,
        initialMessage: initialMessage?.trim() || undefined
      };
      
      // Create the base conversation with initial message if provided
      await this.dependencies.conversationService.createConversation(createParams);

      // If there's an initial message, get AI response
      if (initialMessage?.trim()) {
        // Get AI response with potential tool calls
        // Use streaming method and collect complete response  
        let completeResponse = '';
        for await (const chunk of this.generateResponseStreaming(conversation.id, initialMessage, undefined, options)) {
          completeResponse += chunk.chunk;
        }
        // Note: AI response is automatically saved by the streaming method
      }

      return {
        success: true,
        conversationId: conversation.id
      };
    } catch (error) {
      console.error('[ChatService] Failed to create conversation:', error);
      return {
        success: false,
        error: getErrorMessage(error)
      };
    }
  }

  /**
   * Add a message to a conversation
   */
  async addMessage(params: {
    conversationId: string;
    role: 'user' | 'assistant';
    content: string;
    toolCalls?: any[];
  }): Promise<{ success: boolean; messageId?: string; error?: string }> {
    try {
      const result = await this.dependencies.conversationService.addMessage({
        conversationId: params.conversationId,
        role: params.role,
        content: params.content,
        toolCalls: params.toolCalls
      });

      return {
        success: result.success,
        messageId: result.messageId,
        error: result.error
      };
    } catch (error) {
      console.error('[ChatService] Failed to add message:', error);
      return {
        success: false,
        error: getErrorMessage(error)
      };
    }
  }

  /**
   * Send a message and get AI response with iterative tool execution
   */
  async sendMessage(
    conversationId: string, 
    message: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
    }
  ): Promise<{
    success: boolean;
    messageId?: string;
    error?: string;
  }> {
    try {
      // Get existing conversation
      const conversation = await this.dependencies.conversationService.getConversation(conversationId);
      if (!conversation) {
        return { success: false, error: 'Conversation not found' };
      }

      // Add user message to repository
      const userMessage = await this.dependencies.conversationService.addMessage({
        conversationId,
        role: 'user',
        content: message
      });

      // Generate AI response with tool execution
      // Use streaming method and collect complete response  
      let completeResponse = '';
      const conversationData = documentToConversationData(conversation);
      for await (const chunk of this.generateResponseStreaming(conversationId, message, conversationData, options)) {
        completeResponse += chunk.chunk;
      }
      // Note: AI response is automatically saved by the streaming method

      return {
        success: true,
        messageId: userMessage.success ? userMessage.messageId : undefined
      };
    } catch (error) {
      console.error('[ChatService] Failed to send message:', error);
      return {
        success: false,
        error: getErrorMessage(error)
      };
    }
  }

  /**
   * Generate AI response with streaming support
   * Yields chunks of the response as they're generated
   */
  async* generateResponseStreaming(
    conversationId: string,
    userMessage: string,
    conversation?: ConversationData,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      messageId?: string; // Allow passing existing messageId for UI consistency
    }
  ): AsyncGenerator<{ chunk: string; complete: boolean; messageId: string; toolCalls?: any[] }, void, unknown> {
    try {
      const messageId = options?.messageId || `msg_${Date.now()}_ai`;
      let accumulatedContent = '';

      // Get defaults from LLMService if user didn't select provider/model
      const defaultModel = this.dependencies.llmService.getDefaultModel();
      
      // Get provider for context building
      const provider = options?.provider || defaultModel.provider;
      this.currentProvider = provider; // Store for context building
      
      console.log(`[ChatService] Using provider: ${provider} for conversation context`);

      // Build conversation context for LLM with provider-specific formatting
      const messages = conversation ? 
        this.buildLLMMessages(conversation, provider, options?.systemPrompt) : [];
      
      // Add system prompt if provided and not already added by buildLLMMessages
      if (options?.systemPrompt && !messages.some(m => m.role === 'system')) {
        messages.unshift({ role: 'system', content: options.systemPrompt });
      }
      
      messages.push({ role: 'user', content: userMessage });
      
      console.log(`[ChatService] Final message context has ${messages.length} messages for LLM`);
      
      // Prepare MCP-enabled LLM options - use user selection or fallback to configured defaults
      const mcpOptions: MCPChatOptions = {
        providerId: options?.provider || defaultModel.provider,
        model: options?.model || defaultModel.model,  
        systemPrompt: options?.systemPrompt,
        enableMCP: this.availableTools.length > 0
      };
      
      const llmOptions = await this.mcpIntegration.prepareLLMOptions(
        {
          toolChoice: 'auto'
        },
        mcpOptions,
        this.availableTools
      );
      
      // Add tool event callback for live UI updates
      if (this.toolEventCallback) {
        llmOptions.onToolEvent = (event: 'started' | 'completed', data: any) => {
          this.toolEventCallback!(messageId, event, data);
        };
        console.log('[ChatService] Added tool event callback to llmOptions');
      }

      // Stream the response from LLM service with MCP tools
      let toolCalls: any[] | undefined = undefined;
      
      for await (const chunk of this.dependencies.llmService.generateResponseStream(messages, llmOptions)) {
        accumulatedContent += chunk.chunk;
        
        // Extract tool calls when available (typically on completion)
        if (chunk.toolCalls) {
          toolCalls = chunk.toolCalls;
          console.log('[ChatService] Tool calls received in stream:', {
            toolCallCount: toolCalls?.length || 0,
            toolNames: toolCalls?.map(tc => tc.name || tc.function?.name).filter(Boolean) || [],
            toolCallsStructure: toolCalls?.map(tc => ({
              id: tc.id,
              name: tc.name || tc.function?.name,
              hasParameters: !!(tc.parameters || tc.arguments)
            })) || []
          });
        }
        
        // Save to database BEFORE yielding final chunk to ensure persistence
        if (chunk.complete) {
          console.log('[ChatService] Saving chronological messages to repository:', {
            conversationId,
            hasToolCalls: !!(toolCalls && toolCalls.length > 0),
            toolCallCount: toolCalls?.length || 0,
            assistantContentLength: accumulatedContent.length,
            toolCallsPreview: toolCalls?.slice(0, 2).map(tc => ({
              id: tc.id,
              name: tc.name || tc.function?.name,
              hasResult: !!tc.result
            })) || []
          });
          
          // Save separate tool and assistant messages
          if (toolCalls && toolCalls.length > 0) {
            // First: Save tool message with complete tool calls (including results)
            await this.dependencies.conversationService.addMessage({
              conversationId,
              role: 'tool',
              content: `Executed ${toolCalls.length} tool${toolCalls.length > 1 ? 's' : ''}: ${toolCalls.map(tc => tc.name || tc.function?.name).join(', ')}`,
              toolCalls: toolCalls
            });
          }
          
          // Second: Save assistant response message (clean text only)
          await this.dependencies.conversationService.addMessage({
            conversationId,
            role: 'assistant',
            content: accumulatedContent
            // No toolCalls here - they're in the separate tool message above
          });
        }

        yield {
          chunk: chunk.chunk,
          complete: chunk.complete,
          messageId,
          toolCalls: toolCalls
        };

        if (chunk.complete) {
          break;
        }
      }

    } catch (error) {
      console.error('[ChatService] Error in generateResponseStreaming:', error);
      throw error;
    }
  }


  /**
   * Execute tool calls via MCP client
   */
  private async executeToolCallsViaMCP(toolCalls: any[]): Promise<ToolCall[]> {
    const results: ToolCall[] = [];

    for (const toolCall of toolCalls) {
      try {

        let result: any;

        // Use MCP connector for tool execution (fallback mode)
        if (this.dependencies.mcpConnector) {
          result = await this.dependencies.mcpConnector.callTool({
            agent: toolCall.name.split('.')[0] || toolCall.name.split('_')[0],
            mode: toolCall.name.split('.')[1] || toolCall.name.split('_')[1],
            params: toolCall.arguments || toolCall.parameters
          });
        } else {
          // Fallback: direct execution (for MVP)
          result = await this.executeToolDirectly(toolCall);
        }

        results.push({
          id: toolCall.id,
          type: 'function',
          name: toolCall.name,
          function: {
            name: toolCall.name,
            arguments: JSON.stringify(toolCall.arguments || toolCall.parameters || {})
          },
          parameters: toolCall.arguments || toolCall.parameters,
          result: result,
          success: !result.error,
          error: result.error
        });

      } catch (error) {
        console.error(`[ChatService] Tool execution failed for ${toolCall.name}:`, error);
        results.push({
          id: toolCall.id,
          type: 'function',
          name: toolCall.name,
          function: {
            name: toolCall.name,
            arguments: JSON.stringify(toolCall.arguments || toolCall.parameters || {})
          },
          parameters: toolCall.arguments || toolCall.parameters,
          success: false,
          error: getErrorMessage(error)
        });
      }
    }

    return results;
  }

  /**
   * Execute tool directly through MCP connector
   */
  private async executeToolDirectly(toolCall: any): Promise<any> {
    if (!this.dependencies.mcpConnector) {
      console.warn('[ChatService] No MCP connector available, using fallback');
      return {
        success: true,
        result: `Mock result for ${toolCall.name}`,
        message: 'This is a mock response - MCP connector not available'
      };
    }

    try {
      // Convert tool call to AgentModeParams format
      const agentModeParams = this.convertToolCallToAgentParams(toolCall);
      
      // Call the tool through the MCP connector
      const result = await this.dependencies.mcpConnector.callTool(agentModeParams);
      
      return {
        success: true,
        result: result,
        message: 'Executed via MCP connector'
      };
    } catch (error) {
      console.error(`[ChatService] Tool execution failed for ${toolCall.name}:`, error);
      return {
        success: false,
        error: getErrorMessage(error),
        result: null
      };
    }
  }

  /**
   * Convert LLM tool call format to AgentModeParams format
   */
  private convertToolCallToAgentParams(toolCall: any): any {
    // Parse the tool name to extract agent and mode
    // Tool names should be in format: "agentName.modeName"
    const [agent, mode] = toolCall.name.split('.');
    
    return {
      agent,
      mode,
      params: toolCall.arguments || toolCall.parameters || {}
    };
  }

  /**
   * Get static tool manifest for MVP
   * TODO: Replace with dynamic tool list from MCP client
   */
  private getStaticToolManifest(): any[] {
    return [
      {
        name: 'contentManager.read',
        description: 'Read content from a note',
        inputSchema: {
          type: 'object',
          properties: {
            path: { type: 'string', description: 'Path to the note' }
          },
          required: ['path']
        }
      },
      {
        name: 'contentManager.create',
        description: 'Create a new note',
        inputSchema: {
          type: 'object',
          properties: {
            path: { type: 'string', description: 'Path for new note' },
            content: { type: 'string', description: 'Content for the note' }
          },
          required: ['path', 'content']
        }
      },
      {
        name: 'contentManager.replace',
        description: 'Replace content in a note',
        inputSchema: {
          type: 'object',
          properties: {
            path: { type: 'string', description: 'Path to the note' },
            content: { type: 'string', description: 'New content' }
          },
          required: ['path', 'content']
        }
      },
      {
        name: 'vaultManager.list',
        description: 'List files in a directory',
        inputSchema: {
          type: 'object',
          properties: {
            path: { type: 'string', description: 'Directory path' }
          },
          required: ['path']
        }
      },
      {
        name: 'vaultLibrarian.search',
        description: 'Search for notes',
        inputSchema: {
          type: 'object',
          properties: {
            query: { type: 'string', description: 'Search query' },
            limit: { type: 'number', description: 'Max results' }
          },
          required: ['query']
        }
      }
    ];
  }

  /**
   * Build message history for LLM context using provider-specific formatting
   * 
   * This method now uses ConversationContextBuilder to properly reconstruct
   * conversation history with tool calls in the correct format for each provider.
   */
  private buildLLMMessages(conversation: ConversationData, provider?: string, systemPrompt?: string): any[] {
    const currentProvider = provider || this.getCurrentProvider();
    
    console.log(`[ChatService] Building LLM context for provider: ${currentProvider}`);
    console.log(`[ChatService] Conversation has ${conversation.messages.length} messages`);
    
    // Count tool calls for debugging
    const totalToolCalls = conversation.messages.reduce((count, msg) => 
      count + (msg.toolCalls?.length || 0), 0);
    console.log(`[ChatService] Total tool calls in conversation: ${totalToolCalls}`);
    
    return ConversationContextBuilder.buildContextForProvider(
      conversation, 
      currentProvider, 
      systemPrompt
    );
  }

  /**
   * Get current provider for context building
   */
  private getCurrentProvider(): string {
    return this.currentProvider || this.dependencies.llmService.getDefaultModel().provider;
  }

  /**
   * Update conversation with new data
   */
  async updateConversation(conversation: ConversationData): Promise<{ success: boolean; error?: string }> {
    try {
      const result = await this.dependencies.conversationService.updateConversation(
        conversation.id,
        { 
          title: conversation.title,
          messages: conversation.messages
        }
      );

      return {
        success: result.success,
        error: result.error
      };
    } catch (error) {
      console.error('[ChatService] Failed to update conversation:', error);
      return {
        success: false,
        error: getErrorMessage(error)
      };
    }
  }

  /**
   * Get conversation by ID
   */
  async getConversation(id: string): Promise<ConversationData | null> {
    const document = await this.dependencies.conversationService.getConversation(id);
    return document ? documentToConversationData(document) : null;
  }

  /**
   * List conversations
   */
  async listConversations(options?: { limit?: number; offset?: number }): Promise<ConversationData[]> {
    const searchResults = await this.dependencies.conversationService.listConversations(
      this.dependencies.vaultName,
      options?.limit || 50
    );

    // Convert ConversationDocument[] to ConversationData[]
    return searchResults.map((document: any) => ({
      id: document.id,
      title: document.metadata.title,
      created: document.metadata.created,
      updated: document.metadata.updated,
      messages: [] // Messages not loaded in list view for performance
    }));
  }

  /**
   * Delete conversation
   */
  async deleteConversation(id: string): Promise<boolean> {
    try {
      await this.dependencies.conversationService.deleteConversation(id);
      this.toolCallHistory.delete(id);
      return true;
    } catch (error) {
      console.error('[ChatService] Failed to delete conversation:', error);
      return false;
    }
  }

  /**
   * Search conversations
   */
  async searchConversations(query: string, limit = 10): Promise<any[]> {
    // This would use the conversation search service when available
    try {
      const conversations = await this.listConversations({ limit: 50 });
      return conversations
        .filter(conv => 
          conv.title.toLowerCase().includes(query.toLowerCase()) ||
          conv.messages.some(msg => msg.content.toLowerCase().includes(query.toLowerCase()))
        )
        .slice(0, limit)
        .map(conv => ({
          id: conv.id,
          title: conv.title,
          summary: conv.messages[0]?.content.substring(0, 100) + '...',
          relevanceScore: 0.8, // Mock score
          lastUpdated: conv.updated
        }));
    } catch (error) {
      console.error('[ChatService] Search failed:', error);
      return [];
    }
  }

  /**
   * Get conversation repository for branch management
   */
  getConversationRepository(): any {
    return this.dependencies.conversationService;
  }

  /**
   * Cleanup resources
   */
  async dispose(): Promise<void> {
    // Clean up MCP integration resources
    try {
      this.mcpConfig.removeAllListeners();
    } catch (error) {
      console.error('[ChatService] Error disposing MCP integration:', error);
    }
  }
}
```

## services/chat/ConversationContextBuilder.ts

```typescript
/**
 * ConversationContextBuilder - Builds LLM-ready conversation context from stored conversation data
 * 
 * Handles provider-specific conversation formatting to ensure proper tool call context
 * and conversation continuity across different LLM providers.
 * 
 * Follows Single Responsibility Principle - only handles conversation context formatting.
 */

import { ConversationData } from '../../types/chat/ChatTypes';

export class ConversationContextBuilder {
  
  /**
   * Build LLM-ready conversation context from stored conversation data
   * 
   * @param conversation - The stored conversation data with tool calls
   * @param provider - LLM provider (determines format)
   * @param systemPrompt - Optional system prompt to prepend
   * @returns Properly formatted conversation messages for the LLM provider
   */
  static buildContextForProvider(
    conversation: ConversationData, 
    provider: string,
    systemPrompt?: string
  ): any[] {
    const messages: any[] = [];
    
    // Add system prompt if provided
    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }
    
    // Build conversation based on provider format
    switch (provider.toLowerCase()) {
      case 'anthropic':
        return this.buildAnthropicContext(conversation, messages);
      case 'google':
        return this.buildGoogleContext(conversation, messages);
      default:
        // OpenAI format (used by: openai, openrouter, groq, mistral, requesty, perplexity)
        return this.buildOpenAIContext(conversation, messages);
    }
  }
  
  /**
   * OpenAI format: separate assistant + tool result messages
   * This format is used by most providers (OpenAI, OpenRouter, Groq, Mistral, Requesty, Perplexity)
   * 
   * Pattern:
   * 1. Assistant message with tool_calls array
   * 2. Tool result messages with role: "tool"
   * 3. Final assistant message with response content
   */
  private static buildOpenAIContext(conversation: ConversationData, messages: any[]): any[] {
    conversation.messages.forEach((msg, index) => {
      if (msg.role === 'user') {
        messages.push({ role: 'user', content: msg.content });
      }
      else if (msg.role === 'assistant') {
        if (msg.toolCalls && msg.toolCalls.length > 0) {

          // 1. Assistant message with original tool calls format
          const assistantMessage: any = {
            role: 'assistant',
            content: msg.content || null // OpenAI allows null content when tool calls are present
          };

          // Convert our stored tool calls to OpenAI format
          assistantMessage.toolCalls = msg.toolCalls.map(tc => ({
            id: tc.id,
            type: 'function',
            function: {
              name: tc.name,
              arguments: JSON.stringify(tc.parameters || {})
            }
          }));

          messages.push(assistantMessage);

          // 2. Tool result messages for each tool call
          msg.toolCalls.forEach(toolCall => {
            const toolMessage = {
              role: 'tool',
              tool_call_id: toolCall.id,
              content: toolCall.success
                ? JSON.stringify(toolCall.result || {})
                : `Error: ${toolCall.error || 'Tool execution failed'}`
            };

            messages.push(toolMessage);
          });

          // 3. If there's final content after tool execution, add another assistant message
          if (msg.content && msg.content.trim()) {
            messages.push({
              role: 'assistant',
              content: msg.content
            });
          }
        } else {
          // Regular assistant message without tools
          messages.push({ role: 'assistant', content: msg.content });
        }
      }
      else if (msg.role === 'tool') {
        // Handle stored tool messages - convert tool_calls to individual tool result messages
        if (msg.toolCalls && msg.toolCalls.length > 0) {
          msg.toolCalls.forEach(toolCall => {
            const toolMessage = {
              role: 'tool',
              tool_call_id: toolCall.id,
              content: toolCall.success
                ? JSON.stringify(toolCall.result || {})
                : `Error: ${toolCall.error || 'Tool execution failed'}`
            };

            messages.push(toolMessage);
          });
        }
      }
    });
    
    return messages;
  }
  
  /**
   * Anthropic format: tool_use blocks within messages
   * Anthropic uses tool_result blocks in user messages, not separate tool role messages
   */
  private static buildAnthropicContext(conversation: ConversationData, messages: any[]): any[] {
    conversation.messages.forEach((msg, index) => {
      if (msg.role === 'user') {
        messages.push({ role: 'user', content: msg.content });
      }
      else if (msg.role === 'assistant') {
        if (msg.toolCalls && msg.toolCalls.length > 0) {
          // For Anthropic, assistant message contains both text AND tool_use blocks
          const content: any[] = [];

          // Add text content if present
          if (msg.content && msg.content.trim()) {
            content.push({
              type: 'text',
              text: msg.content
            });
          }

          // Add tool_use blocks
          msg.toolCalls.forEach(toolCall => {
            content.push({
              type: 'tool_use',
              id: toolCall.id,
              name: toolCall.name,
              input: toolCall.parameters || {}
            });
          });

          messages.push({
            role: 'assistant',
            content: content
          });

          // Add tool results as user message with tool_result blocks
          const toolResultContent: any[] = [];
          msg.toolCalls.forEach(toolCall => {
            toolResultContent.push({
              type: 'tool_result',
              tool_use_id: toolCall.id,
              content: toolCall.success
                ? JSON.stringify(toolCall.result || {})
                : `Error: ${toolCall.error || 'Tool execution failed'}`
            });
          });

          if (toolResultContent.length > 0) {
            messages.push({
              role: 'user',
              content: toolResultContent
            });
          }
        } else {
          // Regular assistant message without tools
          messages.push({ role: 'assistant', content: msg.content });
        }
      }
      else if (msg.role === 'tool') {
        // Handle stored tool messages - convert to tool_result blocks in user messages
        if (msg.toolCalls && msg.toolCalls.length > 0) {
          const toolResultContent: any[] = [];
          msg.toolCalls.forEach(toolCall => {
            toolResultContent.push({
              type: 'tool_result',
              tool_use_id: toolCall.id,
              content: toolCall.success
                ? JSON.stringify(toolCall.result || {})
                : `Error: ${toolCall.error || 'Tool execution failed'}`
            });
          });

          if (toolResultContent.length > 0) {
            messages.push({
              role: 'user',
              content: toolResultContent
            });
          }
        }
      }
    });

    return messages;
  }
  
  /**
   * Google format: function_call/function_response
   * TODO: Implement Google-specific format when needed  
   */
  private static buildGoogleContext(conversation: ConversationData, messages: any[]): any[] {
    return this.buildOpenAIContext(conversation, messages);
  }
  
  /**
   * Get provider categories for debugging
   */
  static getProviderCategory(provider: string): string {
    switch (provider.toLowerCase()) {
      case 'anthropic':
        return 'anthropic';
      case 'google':
        return 'google';
      case 'openai':
      case 'openrouter': 
      case 'groq':
      case 'mistral':
      case 'requesty':
      case 'perplexity':
        return 'openai-compatible';
      default:
        return 'openai-compatible';
    }
  }
}
```

## services/chat/MCPChatIntegration.ts

```typescript
/**
 * MCP Chat Integration - Bridges ChatService with HTTP MCP functionality
 * 
 * Provides a clean interface for ChatService to use MCP-enabled LLM providers
 * without changing the core ChatService architecture.
 */

import { MCPConfigurationManager } from '../mcp/MCPConfigurationManager';
import { logger } from '../../utils/logger';

export interface MCPChatOptions {
  /** Provider ID (openai, anthropic, etc.) */
  providerId: string;
  
  /** Model to use */
  model: string;
  
  /** System prompt */
  systemPrompt?: string;
  
  /** Enable MCP tool integration */
  enableMCP?: boolean;
}

export interface MCPChatResponse {
  /** Generated text content */
  content: string;
  
  /** Token usage information */
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  
  /** Tool calls executed via MCP */
  toolCalls?: Array<{
    id: string;
    name: string;
    parameters: any;
    result: any;
    success: boolean;
    error?: string;
    server_label?: string;
  }>;
  
  /** MCP-specific metadata */
  mcpMetadata?: {
    serverUrl: string;
    serverLabel: string;
    hasToolExecution: boolean;
    toolCallCount: number;
  };
}

export class MCPChatIntegration {
  private mcpConfig: MCPConfigurationManager;
  private serverUrl: string | null = null;

  constructor(mcpConfig: MCPConfigurationManager) {
    this.mcpConfig = mcpConfig;
    
    // Listen for server URL updates
    this.mcpConfig.on('configUpdated', (config) => {
      this.serverUrl = config.server.url;
    });
  }

  /**
   * Initialize with MCP server URL
   */
  initialize(serverUrl: string): void {
    this.serverUrl = serverUrl;
    this.mcpConfig.initialize(serverUrl);
    
    logger.systemLog(`[MCP Chat Integration] Initialized with server: ${serverUrl}`);
  }

  /**
   * Check if MCP tools are available (provider-agnostic)
   */
  isMCPAvailable(providerId: string): boolean {
    // MCP is available if we have a server URL and tools
    // Provider doesn't matter - we use bridge system for all providers
    const available = this.serverUrl !== null;
    return available;
  }

  /**
   * Prepare LLM service options for MCP-enabled generation
   */
  async prepareLLMOptions(
    baseOptions: any,
    mcpOptions: MCPChatOptions,
    availableTools: any[]
  ): Promise<any> {
    // If MCP is not available or disabled, return base options
    const mcpAvailable = this.isMCPAvailable(mcpOptions.providerId);
    
    if (!mcpAvailable || !mcpOptions.enableMCP) {
      return baseOptions;
    }

    // Convert MCP tools to provider-specific format using bridge system
    let convertedTools: any[] = [];
    try {
      // Lazy import to avoid circular dependencies
      const { MCPFunctionBridge } = await import('../mcp-bridge/core/MCPFunctionBridge');
      const { OpenAIToolConverter } = await import('../mcp-bridge/providers/openai/OpenAIToolConverter');
      
      if (mcpOptions.providerId === 'openai' || mcpOptions.providerId === 'openrouter') {
        const converter = new OpenAIToolConverter();
        convertedTools = availableTools.map(mcpTool => {
          try {
            const providerTool = converter.convertMCPTool(mcpTool);
            return providerTool.tool; // Extract the OpenAI-formatted tool
          } catch (error) {
            return null;
          }
        }).filter(tool => tool !== null);
        
      } else {
        convertedTools = []; // No tools for unsupported providers
      }
    } catch (error) {
      convertedTools = []; // Fallback to no tools
    }

    // Enhance options with MCP configuration
    const enhancedOptions = {
      ...baseOptions,
      provider: mcpOptions.providerId,
      model: mcpOptions.model,
      systemPrompt: mcpOptions.systemPrompt,
      tools: convertedTools, // Use converted tools in provider-specific format
      mcpEnabled: true,
      mcpServerUrl: this.serverUrl
    };

    logger.systemLog(`[MCP Chat Integration] Enhanced LLM options for ${mcpOptions.providerId} with MCP`);
    return enhancedOptions;
  }

  /**
   * Process LLM response and extract MCP-specific information
   */
  processLLMResponse(response: any, originalTools: any[]): MCPChatResponse {
    const chatResponse: MCPChatResponse = {
      content: response.text || response.content || '',
      usage: response.usage,
      toolCalls: response.toolCalls,
      mcpMetadata: response.metadata?.mcpEnabled ? {
        serverUrl: response.metadata.serverUrl || this.serverUrl || 'unknown',
        serverLabel: response.metadata.serverLabel || 'claudesidian',
        hasToolExecution: response.metadata.hasToolExecution || false,
        toolCallCount: response.metadata.toolCallCount || 0
      } : undefined
    };

    // Log MCP tool execution if it occurred
    if (chatResponse.mcpMetadata?.hasToolExecution) {
      logger.systemLog(
        `[MCP Chat Integration] Executed ${chatResponse.mcpMetadata.toolCallCount} tools via MCP server`
      );
    }

    return chatResponse;
  }

  /**
   * Get MCP-aware tool manifest for ChatService
   */
  getMCPToolManifest(providerId: string, availableTools: any[]): any[] {
    if (!this.isMCPAvailable(providerId)) {
      return availableTools;
    }

    // Return tools with MCP-specific metadata
    return availableTools.map(tool => ({
      ...tool,
      mcpEnabled: true,
      serverUrl: this.serverUrl,
      serverLabel: this.mcpConfig.getConfiguration().server.label
    }));
  }

  /**
   * Configure MCP for a specific provider
   */
  configureProvider(
    providerId: string, 
    options: {
      enabled?: boolean;
      supported?: boolean;
      config?: Record<string, any>;
    }
  ): void {
    if (options.supported !== undefined) {
      this.mcpConfig.setProviderSupported(providerId, options.supported);
    }
    
    if (options.enabled !== undefined) {
      this.mcpConfig.setProviderEnabled(providerId, options.enabled);
    }

    logger.systemLog(`[MCP Chat Integration] Configured ${providerId}: ${JSON.stringify(options)}`);
  }

  /**
   * Get configuration summary for debugging
   */
  getConfigSummary(): any {
    return {
      serverUrl: this.serverUrl,
      mcpConfig: this.mcpConfig.getConfigSummary(),
      initialized: !!this.serverUrl
    };
  }

  /**
   * Enable MCP for supported providers automatically
   */
  autoConfigureProviders(llmService: any): void {
    // Simplified: since we use bridge system, all function-calling providers support MCP
    
    // No need to configure individual adapters - bridge handles all providers
    logger.systemLog('[MCP Integration] Bridge system ready for all function-calling providers');
  }

  /**
   * Update server URL and reconfigure providers
   */
  updateServerUrl(serverUrl: string): void {
    this.serverUrl = serverUrl;
    this.mcpConfig.updateServerConfig({ url: serverUrl });
    
    // TODO: Update all configured adapters with new server URL
    
    logger.systemLog(`[MCP Chat Integration] Updated server URL: ${serverUrl}`);
  }
}
```

## services/chat/index.ts

```typescript
/**
 * Chat Services Index - Export all chat-related services
 * 
 * Provides centralized access to the complete chat infrastructure:
 * - Repository layer for CRUD operations (database services)
 * - Business logic services for chat operations
 * - Tool execution and message processing services
 * - MCP protocol integration services
 */

// Database layer services (from database/services/chat/)
// Note: Chat database services removed in simplify-search-architecture
// Chat data now stored in simplified JSON format

// Business logic services (from services/chat/)
export * from './ChatService';
```

## services/llm/ImageFileManager.ts

```typescript
/**
 * Image File Manager
 * Handles saving generated images to the Obsidian vault with proper security and metadata
 */

import { Vault, TFile, TFolder } from 'obsidian';
import * as path from 'path';
import { 
  ImageGenerationParams,
  ImageGenerationResponse,
  ImageSaveResult,
  ImageBuffer
} from './types/ImageTypes';

export class ImageFileManager {
  private vault: Vault;

  constructor(vault: Vault) {
    this.vault = vault;
  }

  /**
   * Save generated image to vault with metadata
   */
  async saveImage(
    imageResponse: ImageGenerationResponse,
    params: ImageGenerationParams
  ): Promise<ImageSaveResult> {
    try {
      // Validate and sanitize the save path
      const sanitizedPath = this.sanitizePath(params.savePath);
      const finalPath = await this.ensureUniqueFileName(sanitizedPath, imageResponse.format);

      // Ensure directory exists
      await this.ensureDirectoryExists(path.dirname(finalPath));

      // Save the image file
      const arrayBuffer = new ArrayBuffer(imageResponse.imageData.length);
      const uint8Array = new Uint8Array(arrayBuffer);
      uint8Array.set(imageResponse.imageData);
      const file = await this.vault.createBinary(finalPath, arrayBuffer);

      return {
        success: true,
        filePath: finalPath,
        fileName: path.basename(finalPath),
        fileSize: imageResponse.imageData.length,
        dimensions: imageResponse.dimensions,
        format: imageResponse.format
      };
    } catch (error) {
      return {
        success: false,
        filePath: params.savePath,
        fileName: path.basename(params.savePath),
        fileSize: 0,
        dimensions: { width: 0, height: 0 },
        format: imageResponse.format,
        error: error instanceof Error ? error.message : 'Unknown error saving image'
      };
    }
  }

  /**
   * Save multiple images from a batch generation
   */
  async saveImages(
    imageResponses: ImageGenerationResponse[],
    params: ImageGenerationParams
  ): Promise<ImageSaveResult[]> {
    const results: ImageSaveResult[] = [];

    for (let i = 0; i < imageResponses.length; i++) {
      const imageResponse = imageResponses[i];
      
      // Create unique save path for each image
      const basePath = this.removeExtension(params.savePath);
      const extension = this.getFileExtension(imageResponse.format);
      const indexedPath = imageResponses.length > 1 
        ? `${basePath}-${i + 1}.${extension}`
        : `${basePath}.${extension}`;

      const indexedParams = { ...params, savePath: indexedPath };
      const result = await this.saveImage(imageResponse, indexedParams);
      results.push(result);
    }

    return results;
  }

  /**
   * Check if a file path is safe (within vault, no directory traversal)
   */
  private validatePath(filePath: string): boolean {
    // Normalize the path
    const normalizedPath = path.normalize(filePath);
    
    // Check for directory traversal attempts
    if (normalizedPath.includes('..') || normalizedPath.startsWith('/')) {
      return false;
    }

    // Check for invalid characters
    const invalidChars = /[<>:"|?*]/;
    if (invalidChars.test(normalizedPath)) {
      return false;
    }

    return true;
  }

  /**
   * Sanitize file path for vault storage
   */
  private sanitizePath(filePath: string): string {
    if (!this.validatePath(filePath)) {
      throw new Error('Invalid file path: contains directory traversal or invalid characters');
    }

    // Remove leading/trailing whitespace and normalize separators
    let sanitized = filePath.trim().replace(/\\/g, '/');
    
    // Remove leading slash if present
    if (sanitized.startsWith('/')) {
      sanitized = sanitized.substring(1);
    }

    // Ensure the path has a valid image extension
    const validExtensions = ['png', 'jpg', 'jpeg', 'webp'];
    const ext = path.extname(sanitized).toLowerCase().substring(1);
    
    if (!ext || !validExtensions.includes(ext)) {
      sanitized = this.removeExtension(sanitized) + '.png';
    }

    return sanitized;
  }

  /**
   * Ensure directory exists, create if necessary
   */
  private async ensureDirectoryExists(dirPath: string): Promise<void> {
    if (!dirPath || dirPath === '.') {
      return; // Root directory
    }

    const folderPath = path.normalize(dirPath);
    
    // Check if folder already exists
    const existingFolder = this.vault.getAbstractFileByPath(folderPath);
    if (existingFolder instanceof TFolder) {
      return; // Folder already exists
    }

    // Create the folder (this will create parent directories as needed)
    try {
      await this.vault.createFolder(folderPath);
    } catch (error) {
      // Folder might already exist due to race condition
      const folder = this.vault.getAbstractFileByPath(folderPath);
      if (!(folder instanceof TFolder)) {
        throw error;
      }
    }
  }

  /**
   * Ensure filename is unique, append number if needed
   */
  private async ensureUniqueFileName(filePath: string, format: string): Promise<string> {
    let finalPath = filePath;
    let counter = 1;

    // Ensure the file has the correct extension
    const basePath = this.removeExtension(filePath);
    const extension = this.getFileExtension(format);
    finalPath = `${basePath}.${extension}`;

    while (this.vault.getAbstractFileByPath(finalPath)) {
      finalPath = `${basePath}-${counter}.${extension}`;
      counter++;
    }

    return finalPath;
  }


  /**
   * Get file extension for format
   */
  private getFileExtension(format: string): string {
    const extensions = {
      'png': 'png',
      'jpeg': 'jpg',
      'jpg': 'jpg',
      'webp': 'webp'
    };
    return extensions[format.toLowerCase() as keyof typeof extensions] || 'png';
  }

  /**
   * Remove file extension from path
   */
  private removeExtension(filePath: string): string {
    const ext = path.extname(filePath);
    return ext ? filePath.substring(0, filePath.length - ext.length) : filePath;
  }

  /**
   * Check if file exists in vault
   */
  async fileExists(filePath: string): Promise<boolean> {
    const file = this.vault.getAbstractFileByPath(filePath);
    return file instanceof TFile;
  }

  /**
   * Get available disk space (estimate)
   */
  getAvailableSpace(): number {
    // This is a rough estimate as there's no direct API for disk space in Obsidian
    // Return a conservative estimate
    return 100 * 1024 * 1024; // 100MB
  }

  /**
   * Validate image buffer and extract metadata
   */
  validateImageBuffer(buffer: Buffer): ImageBuffer | null {
    if (!buffer || buffer.length === 0) {
      return null;
    }

    try {
      // Basic PNG validation (check PNG signature)
      const isPNG = buffer.subarray(0, 8).equals(Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]));
      
      // Basic JPEG validation (check JPEG signature)
      const isJPEG = buffer.subarray(0, 2).equals(Buffer.from([0xFF, 0xD8]));

      // Basic WebP validation (check WebP signature)
      const isWebP = buffer.subarray(0, 4).equals(Buffer.from('RIFF', 'ascii')) && 
                     buffer.subarray(8, 12).equals(Buffer.from('WEBP', 'ascii'));

      let format: 'png' | 'jpeg' | 'webp';
      if (isPNG) format = 'png';
      else if (isJPEG) format = 'jpeg';
      else if (isWebP) format = 'webp';
      else return null; // Unsupported format

      return {
        data: buffer,
        format,
        dimensions: { width: 0, height: 0 }, // Would need image parsing library for actual dimensions
        metadata: {
          prompt: '',
          model: '',
          provider: '',
          generatedAt: new Date().toISOString(),
          fileSize: buffer.length
        }
      };
    } catch (error) {
      console.warn('Failed to validate image buffer:', error);
      return null;
    }
  }
}
```

## services/llm/ImageGenerationService.ts

```typescript
/**
 * Image Generation Service
 * Central orchestration service for image generation workflow
 * Coordinates between adapters, file management, and cost tracking
 */

import { Vault } from 'obsidian';
import { OpenAIImageAdapter } from './adapters/openai/OpenAIImageAdapter'; // Available but not used
import { GeminiImageAdapter } from './adapters/google/GeminiImageAdapter';
import { ImageFileManager } from './ImageFileManager';
import { 
  ImageGenerationParams, 
  ImageGenerationResult,
  ImageProvider,
  ImageValidationResult,
  ImageGenerationError
} from './types/ImageTypes';
import { BaseImageAdapter } from './adapters/BaseImageAdapter';
import { LLMProviderSettings } from '../../types/llm/ProviderTypes';

export class ImageGenerationService {
  private adapters: Map<ImageProvider, BaseImageAdapter>;
  private fileManager: ImageFileManager;
  private vault: Vault;
  private llmSettings: LLMProviderSettings | null = null;

  constructor(vault: Vault, llmSettings?: LLMProviderSettings) {
    this.vault = vault;
    this.fileManager = new ImageFileManager(vault);
    this.adapters = new Map();
    this.llmSettings = llmSettings || null;
    
    this.initializeAdapters();
  }

  /**
   * Initialize image generation adapters
   */
  private initializeAdapters(): void {
    try {
      if (!this.llmSettings) {
        console.warn('No LLM settings provided to ImageGenerationService - image generation will be unavailable');
        return;
      }

      // Initialize OpenAI adapter (DISABLED - available but not active)
      // Uncomment the block below to enable OpenAI image generation
      /*
      const openaiConfig = this.llmSettings.providers?.openai;
      if (openaiConfig?.apiKey && openaiConfig?.enabled) {
        const openaiAdapter = new OpenAIImageAdapter({
          apiKey: openaiConfig.apiKey
        });
        this.adapters.set('openai', openaiAdapter);
        console.log('OpenAI image adapter initialized with plugin settings');
      }
      */

      // Initialize Google adapter if API key is available and enabled
      const googleConfig = this.llmSettings.providers?.google;
      if (googleConfig?.apiKey && googleConfig?.enabled) {
        const googleAdapter = new GeminiImageAdapter({
          apiKey: googleConfig.apiKey
        });
        this.adapters.set('google', googleAdapter);
      }

      if (this.adapters.size === 0) {
        console.warn('No image generation providers configured. Please configure Google API keys in plugin settings and enable the providers.');
      } else {
      }
    } catch (error) {
      console.error('Failed to initialize image generation adapters:', error);
    }
  }

  /**
   * Generate image with full workflow orchestration
   */
  async generateImage(params: ImageGenerationParams): Promise<ImageGenerationResult> {
    try {
      // Validate provider
      const adapter = this.getAdapter(params.provider);
      if (!adapter) {
        return {
          success: false,
          error: `Provider ${params.provider} not available. Please configure the appropriate API key.`
        };
      }

      // Check if adapter is available for image generation
      const isAvailable = await adapter.isImageGenerationAvailable();
      if (!isAvailable) {
        return {
          success: false,
          error: `Image generation not available for provider ${params.provider}. Please check API key configuration.`
        };
      }

      // Generate the image using the adapter
      const result = await adapter.generateImageSafely(params);
      
      if (!result.success || !result.data) {
        return result;
      }

      // Generate the image response for file saving
      const imageResponse = await adapter.generateImage(params);

      // Save the image to vault
      const saveResult = await this.fileManager.saveImage(imageResponse, params);
      
      if (!saveResult.success) {
        return {
          success: false,
          error: `Image generation succeeded but file save failed: ${saveResult.error}`
        };
      }

      // Update the result with the actual saved path
      return {
        success: true,
        data: {
          ...result.data,
          imagePath: saveResult.filePath,
          fileSize: saveResult.fileSize
        }
      };

    } catch (error) {
      console.error('Image generation service error:', error);
      
      if (error instanceof ImageGenerationError) {
        return {
          success: false,
          error: error.message
        };
      }

      return {
        success: false,
        error: `Image generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Validate image generation parameters across all providers
   */
  async validateParams(params: ImageGenerationParams): Promise<ImageValidationResult> {
    try {
      const adapter = this.getAdapter(params.provider);
      if (!adapter) {
        return {
          isValid: false,
          errors: [`Provider ${params.provider} not available`]
        };
      }

      return adapter.validateImageParams(params);
    } catch (error) {
      return {
        isValid: false,
        errors: [`Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`]
      };
    }
  }

  /**
   * Get available providers with their status
   */
  async getAvailableProviders(): Promise<Array<{
    provider: ImageProvider;
    available: boolean;
    models: string[];
    error?: string;
  }>> {
    const providers: Array<{
      provider: ImageProvider;
      available: boolean;
      models: string[];
      error?: string;
    }> = [];

    for (const [providerName, adapter] of this.adapters) {
      try {
        const available = await adapter.isImageGenerationAvailable();
        const models = available ? adapter.supportedModels : [];
        
        providers.push({
          provider: providerName,
          available,
          models,
          error: available ? undefined : 'API key not configured or invalid'
        });
      } catch (error) {
        providers.push({
          provider: providerName,
          available: false,
          models: [],
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    // Add unavailable providers if no API keys are configured
    const allProviders: ImageProvider[] = ['openai', 'google']; // OpenAI available but disabled
    for (const provider of allProviders) {
      if (!providers.find(p => p.provider === provider)) {
        providers.push({
          provider,
          available: false,
          models: [],
          error: provider === 'openai' ? 'Provider disabled (available in code)' : 'API key not configured'
        });
      }
    }

    return providers;
  }

  /**
   * Get supported models for a provider
   */
  async getSupportedModels(provider: ImageProvider): Promise<string[]> {
    const adapter = this.getAdapter(provider);
    if (!adapter) {
      return [];
    }

    try {
      const available = await adapter.isImageGenerationAvailable();
      return available ? adapter.supportedModels : [];
    } catch (error) {
      console.warn(`Failed to get models for ${provider}:`, error);
      return [];
    }
  }

  /**
   * Get supported sizes for a provider
   */
  getSupportedSizes(provider: ImageProvider): string[] {
    const adapter = this.getAdapter(provider);
    return adapter ? adapter.getSupportedImageSizes() : [];
  }

  /**
   * Get provider capabilities
   */
  async getProviderCapabilities(provider: ImageProvider) {
    const adapter = this.getAdapter(provider);
    if (!adapter) {
      return null;
    }

    try {
      return adapter.getImageCapabilities();
    } catch (error) {
      console.warn(`Failed to get capabilities for ${provider}:`, error);
      return null;
    }
  }

  /**
   * Estimate cost for image generation
   */
  async estimateCost(params: ImageGenerationParams): Promise<{
    estimatedCost: number;
    currency: string;
    breakdown: string;
  } | null> {
    const adapter = this.getAdapter(params.provider);
    if (!adapter) {
      return null;
    }

    try {
      const model = params.model || adapter.supportedModels[0];
      const pricing = await adapter.getImageModelPricing(model);
      
      if (!pricing) {
        return null;
      }

      return {
        estimatedCost: pricing.totalCost,
        currency: pricing.currency,
        breakdown: `1 image using ${model}: ${pricing.totalCost} ${pricing.currency}`
      };
    } catch (error) {
      console.warn(`Failed to estimate cost for ${params.provider}:`, error);
      return null;
    }
  }

  /**
   * Check if any image generation providers are available
   */
  hasAvailableProviders(): boolean {
    return this.adapters.size > 0;
  }

  /**
   * Get file manager instance
   */
  getFileManager(): ImageFileManager {
    return this.fileManager;
  }

  /**
   * Update LLM settings and refresh adapters
   */
  updateSettings(llmSettings: LLMProviderSettings): void {
    this.llmSettings = llmSettings;
    this.refreshAdapters();
  }

  /**
   * Refresh adapter configurations (useful after API key changes)
   */
  refreshAdapters(): void {
    this.adapters.clear();
    this.initializeAdapters();
  }

  // Private helper methods

  private getAdapter(provider: ImageProvider): BaseImageAdapter | undefined {
    return this.adapters.get(provider);
  }

  /**
   * Validate common parameters before generation
   */
  private validateCommonParams(params: ImageGenerationParams): string[] {
    const errors: string[] = [];

    if (!params.prompt || params.prompt.trim().length === 0) {
      errors.push('Prompt is required');
    }

    if (!params.savePath || params.savePath.trim().length === 0) {
      errors.push('Save path is required');
    }

    if (!params.provider) {
      errors.push('Provider is required');
    }

    if (params.savePath && (params.savePath.includes('..') || params.savePath.startsWith('/'))) {
      errors.push('Save path must be relative to vault root');
    }

    return errors;
  }
}
```

## services/llm/adapters/BaseAdapter.ts

```typescript
/**
 * Base LLM Adapter
 * Abstract class that all provider adapters extend
 * Based on patterns from services/llm/BaseLLMProvider.ts
 */

import { 
  GenerateOptions, 
  StreamChunk, 
  LLMResponse, 
  ModelInfo, 
  LLMProviderError,
  ProviderConfig,
  ProviderCapabilities,
  TokenUsage,
  CostDetails,
  ModelPricing
} from './types';
import { BaseCache, CacheManager } from '../utils/CacheManager';
import { createHash } from 'crypto';
import { createParser, type ParsedEvent, type ParseEvent } from 'eventsource-parser';

export abstract class BaseAdapter {
  abstract readonly name: string;
  abstract readonly baseUrl: string;
  
  protected apiKey: string;
  protected currentModel: string;
  protected config: ProviderConfig;
  protected cache!: BaseCache<LLMResponse>;

  constructor(apiKey: string, defaultModel: string, baseUrl?: string, requiresApiKey: boolean = true) {
    this.apiKey = apiKey || '';
    this.currentModel = defaultModel;

    this.config = {
      apiKey: this.apiKey,
      baseUrl: baseUrl || ''
    };

    if (!this.apiKey && requiresApiKey) {
      console.warn(`‚ö†Ô∏è API key not provided for adapter`);
    }
  }

  protected initializeCache(cacheConfig?: any): void {
    const cacheName = `${this.name}-responses`;
    this.cache = CacheManager.getCache<LLMResponse>(cacheName) || 
                 CacheManager.createLRUCache<LLMResponse>(cacheName, {
                   maxSize: cacheConfig?.maxSize || 1000,
                   defaultTTL: cacheConfig?.defaultTTL || 3600000, // 1 hour
                   ...cacheConfig
                 });
  }

  // Abstract methods that each provider must implement
  abstract generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse>;
  abstract generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown>;
  abstract listModels(): Promise<ModelInfo[]>;
  abstract getCapabilities(): ProviderCapabilities;
  abstract getModelPricing(modelId: string): Promise<ModelPricing | null>;

  /**
   * Centralized SSE streaming processor using eventsource-parser
   * Handles all the complex buffering, parsing, and error recovery
   * Each adapter provides extraction functions for their specific format
   */
  protected async* processSSEStream(
    response: Response,
    options: {
      extractContent: (parsed: any) => string | null;
      extractToolCalls: (parsed: any) => any[] | null;
      extractFinishReason: (parsed: any) => string | null;
      extractUsage?: (parsed: any) => any;
      onParseError?: (error: Error, rawData: string) => void;
      debugLabel?: string;
      // Tool call accumulation settings
      accumulateToolCalls?: boolean;
      toolCallThrottling?: {
        initialYield: boolean;
        progressInterval: number; // Yield every N characters of arguments
      };
    }
  ): AsyncGenerator<StreamChunk, void, unknown> {
    if (!response.body) {
      throw new Error('Response body is not readable');
    }

    const debugLabel = options.debugLabel || 'SSE';
    let tokenCount = 0;
    let usage: any = undefined;
    
    // Tool call accumulation system
    const toolCallsAccumulator: Map<number, any> = new Map();
    let accumulatedContent = '';
    
    // Event queue for handling async events in sync generator
    const eventQueue: StreamChunk[] = [];
    let isCompleted = false;
    let completionError: Error | null = null;

    const reader = response.body.getReader();
    const decoder = new TextDecoder();

    const parser = createParser((event: ParseEvent) => {
      if (isCompleted) return;

      // Handle reconnect intervals
      if (event.type === 'reconnect-interval') {
        return;
      }

      // Handle [DONE] event
      if (event.data === '[DONE]') {
        
        const finalUsage = usage ? { 
          promptTokens: usage.prompt_tokens || 0,
          completionTokens: usage.completion_tokens || 0,
          totalTokens: usage.total_tokens || 0 
        } : undefined;

        const finalToolCalls = options.accumulateToolCalls && toolCallsAccumulator.size > 0 
          ? Array.from(toolCallsAccumulator.values()) 
          : undefined;

        eventQueue.push({
          content: '',
          complete: true,
          usage: finalUsage,
          toolCalls: finalToolCalls
        });
        
        isCompleted = true;
        return;
      }

      try {
        const parsed = JSON.parse(event.data);
          
          // Extract content using adapter-specific logic
          const content = options.extractContent(parsed);
          if (content) {
            tokenCount++;
            accumulatedContent += content;
            
            eventQueue.push({ 
              content, 
              complete: false 
            });
          }

          // Extract tool calls using adapter-specific logic
          const toolCalls = options.extractToolCalls(parsed);
          if (toolCalls && options.accumulateToolCalls) {
            
            let shouldYieldToolCalls = false;
            
            for (const toolCall of toolCalls) {
              const index = toolCall.index || 0;
              
              if (!toolCallsAccumulator.has(index)) {
                // Initialize new tool call
                toolCallsAccumulator.set(index, {
                  id: toolCall.id || '',
                  type: toolCall.type || 'function',
                  function: {
                    name: toolCall.function?.name || '',
                    arguments: toolCall.function?.arguments || ''
                  }
                });
                shouldYieldToolCalls = options.toolCallThrottling?.initialYield !== false;
              } else {
                // Accumulate existing tool call
                const existing = toolCallsAccumulator.get(index);
                if (toolCall.id) existing.id = toolCall.id;
                if (toolCall.function?.name) existing.function.name = toolCall.function.name;
                if (toolCall.function?.arguments) {
                  existing.function.arguments += toolCall.function.arguments;
                  
                  // Check throttling conditions
                  const argLength = existing.function.arguments.length;
                  const interval = options.toolCallThrottling?.progressInterval || 50;
                  shouldYieldToolCalls = argLength > 0 && argLength % interval === 0;
                }
              }
            }
            
            if (shouldYieldToolCalls) {
              const currentToolCalls = Array.from(toolCallsAccumulator.values());
              
              eventQueue.push({
                content: '',
                complete: false,
                toolCalls: currentToolCalls
              });
            }
          }

          // Extract usage information
          if (options.extractUsage) {
            const extractedUsage = options.extractUsage(parsed);
            if (extractedUsage) {
              usage = extractedUsage;
            }
          }

          // Handle completion
          const finishReason = options.extractFinishReason(parsed);
          if (finishReason === 'stop' || finishReason === 'length') {
            
            eventQueue.push({
              content: '',
              complete: true
            });
            
            isCompleted = true;
          }

        } catch (parseError) {
          if (options.onParseError) {
            options.onParseError(parseError as Error, event.data);
          }
          // Continue processing other events
        }
      });

    try {
      // Process the stream
      while (!isCompleted && !completionError) {
        const { done, value } = await reader.read();
        
        if (done) {
          isCompleted = true;
          break;
        }

        // Feed chunk to parser
        const chunk = decoder.decode(value, { stream: true });
        parser.feed(chunk);

        // Yield any queued events
        while (eventQueue.length > 0) {
          const event = eventQueue.shift()!;
          yield event;
          
          // If this was a completion event, we're done
          if (event.complete) {
            isCompleted = true;
            break;
          }
        }
      }

      // Yield any remaining queued events
      while (eventQueue.length > 0) {
        const event = eventQueue.shift()!;
        yield event;
      }

      // If we completed without a completion event, yield one
      if (!isCompleted || (!eventQueue.length && !completionError)) {
        yield {
          content: '',
          complete: true,
          usage: usage ? {
            promptTokens: usage.prompt_tokens || 0,
            completionTokens: usage.completion_tokens || 0,
            totalTokens: usage.total_tokens || 0
          } : undefined
        };
      }

    } catch (error) {
      throw error;
    } finally {
      try {
        reader.cancel();
      } catch (error) {
      }
    }

    if (completionError) {
      throw completionError;
    }
  }

  // Cached generate method
  async generate(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    // Skip cache if explicitly disabled or for streaming
    if (options?.disableCache) {
      return this.generateUncached(prompt, options);
    }

    const cacheKey = this.generateCacheKey(prompt, options);
    
    // Try cache first
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return {
        ...cached,
        metadata: {
          ...cached.metadata,
          cached: true,
          cacheHit: true
        }
      };
    }

    // Generate new response
    const response = await this.generateUncached(prompt, options);
    
    // Cache the response
    await this.cache.set(cacheKey, response, options?.cacheTTL);
    
    return {
      ...response,
      metadata: {
        ...response.metadata,
        cached: false,
        cacheHit: false
      }
    };
  }

  // Common implementations
  async generateJSON(prompt: string, schema?: any, options?: GenerateOptions): Promise<any> {
    try {
      const response = await this.generate(prompt, { 
        ...options, 
        jsonMode: true 
      });
      
      const parsed = JSON.parse(response.text);
      
      // Basic schema validation if provided
      if (schema && !this.validateSchema(parsed, schema)) {
        throw new LLMProviderError(
          'Response does not match expected schema',
          this.name,
          'SCHEMA_VALIDATION_ERROR'
        );
      }
      
      return parsed;
    } catch (error) {
      if (error instanceof SyntaxError) {
        throw new LLMProviderError(
          `Invalid JSON response: ${error.message}`,
          this.name,
          'JSON_PARSE_ERROR',
          error
        );
      }
      throw error;
    }
  }

  // Cache management methods
  protected generateCacheKey(prompt: string, options?: GenerateOptions): string {
    const cacheData = {
      prompt,
      model: options?.model || this.currentModel,
      temperature: options?.temperature || 0.7,
      maxTokens: options?.maxTokens || 2000,
      topP: options?.topP,
      frequencyPenalty: options?.frequencyPenalty,
      presencePenalty: options?.presencePenalty,
      stopSequences: options?.stopSequences,
      systemPrompt: options?.systemPrompt,
      jsonMode: options?.jsonMode
    };
    
    const serialized = JSON.stringify(cacheData);
    return createHash('sha256').update(serialized).digest('hex');
  }

  async clearCache(): Promise<void> {
    await this.cache.clear();
  }

  getCacheMetrics() {
    return this.cache.getMetrics();
  }

  async isAvailable(): Promise<boolean> {
    if (!this.apiKey) {
      return false;
    }
    
    try {
      await this.listModels();
      return true;
    } catch (error) {
      console.warn(`Provider ${this.name} unavailable:`, error);
      return false;
    }
  }

  setModel(model: string): void {
    this.currentModel = model;
  }

  getCurrentModel(): string {
    return this.currentModel;
  }

  getApiKey(): string {
    return this.apiKey ? '***' + this.apiKey.slice(-4) : 'NOT_SET';
  }

  // Helper methods
  protected validateConfiguration(): void {
    if (!this.apiKey) {
      throw new LLMProviderError(
        `API key not configured for ${this.name}`,
        this.name,
        'MISSING_API_KEY'
      );
    }
  }

  protected buildHeaders(additionalHeaders?: Record<string, string>): Record<string, string> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'User-Agent': 'Synaptic-Lab-Kit/1.0.0',
      ...additionalHeaders
    };

    return headers;
  }

  protected handleError(error: any, operation: string): never {
    if (error instanceof LLMProviderError) {
      throw error;
    }

    if (error.response) {
      // HTTP error
      const status = error.response.status;
      const message = error.response.data?.error?.message || error.message;
      
      let errorCode = 'HTTP_ERROR';
      if (status === 401) errorCode = 'AUTHENTICATION_ERROR';
      if (status === 403) errorCode = 'PERMISSION_ERROR';
      if (status === 429) errorCode = 'RATE_LIMIT_ERROR';
      if (status >= 500) errorCode = 'SERVER_ERROR';

      throw new LLMProviderError(
        `${operation} failed: ${message}`,
        this.name,
        errorCode,
        error
      );
    }

    throw new LLMProviderError(
      `${operation} failed: ${error.message}`,
      this.name,
      'UNKNOWN_ERROR',
      error
    );
  }

  protected validateSchema(data: any, schema: any): boolean {
    // Basic schema validation - could be enhanced with a proper validator
    if (typeof schema !== 'object' || schema === null) {
      return true;
    }

    if (schema.type) {
      const expectedType = schema.type;
      const actualType = Array.isArray(data) ? 'array' : typeof data;
      
      if (expectedType !== actualType) {
        return false;
      }
    }

    if (schema.properties && typeof data === 'object') {
      for (const [key, propSchema] of Object.entries(schema.properties)) {
        if (schema.required?.includes(key) && !(key in data)) {
          return false;
        }
        
        if (key in data && !this.validateSchema(data[key], propSchema)) {
          return false;
        }
      }
    }

    return true;
  }

  protected buildMessages(prompt: string, systemPrompt?: string): any[] {
    const messages: any[] = [];
    
    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }
    
    messages.push({ role: 'user', content: prompt });
    
    return messages;
  }

  protected extractUsage(response: any): TokenUsage | undefined {
    // Default implementation - override in specific adapters
    if (response.usage) {
      return {
        promptTokens: response.usage.prompt_tokens || response.usage.input_tokens || 0,
        completionTokens: response.usage.completion_tokens || response.usage.output_tokens || 0,
        totalTokens: response.usage.total_tokens || 0
      };
    }
    return undefined;
  }

  // Cost calculation methods
  protected async calculateCost(usage: TokenUsage, model: string): Promise<CostDetails | null> {
    
    const modelPricing = await this.getModelPricing(model);
    
    if (!modelPricing) {
      return null;
    }
    
    // Calculate actual costs based on token usage and pricing rates
    const inputCost = (usage.promptTokens / 1_000_000) * modelPricing.rateInputPerMillion;
    const outputCost = (usage.completionTokens / 1_000_000) * modelPricing.rateOutputPerMillion;
    const totalCost = inputCost + outputCost;

    const costDetails: CostDetails = {
      inputCost,
      outputCost,
      totalCost,
      currency: modelPricing.currency || 'USD',
      rateInputPerMillion: modelPricing.rateInputPerMillion,
      rateOutputPerMillion: modelPricing.rateOutputPerMillion
    };
    
    console.log('BaseAdapter: calculated cost successfully', {
      provider: this.name,
      model,
      usage,
      rates: {
        input: modelPricing.rateInputPerMillion,
        output: modelPricing.rateOutputPerMillion
      },
      calculatedCosts: costDetails
    });
    return costDetails;
  }

  protected async buildLLMResponse(
    content: string,
    model: string,
    usage?: TokenUsage,
    metadata?: Record<string, any>,
    finishReason?: 'stop' | 'length' | 'tool_calls' | 'content_filter',
    toolCalls?: any[]
  ): Promise<LLMResponse> {
    const response: LLMResponse = {
      text: content,
      model,
      provider: this.name,
      usage: usage || { promptTokens: 0, completionTokens: 0, totalTokens: 0 },
      metadata: metadata || {},
      finishReason: finishReason || 'stop',
      toolCalls: toolCalls || []
    };

    // Extract webSearchResults from metadata if present
    if (metadata?.webSearchResults) {
      response.webSearchResults = metadata.webSearchResults;
    }

    // Calculate cost if usage is available
    if (usage) {
      const cost = await this.calculateCost(usage, model);
      if (cost) {
        response.cost = cost;
      } else {
      }
    } else {
    }

    return response;
  }

  // Rate limiting and retry logic
  protected async withRetry<T>(
    operation: () => Promise<T>,
    maxRetries = 3,
    baseDelay = 1000
  ): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        
        // Don't retry on certain errors
        if (error instanceof LLMProviderError) {
          if (['AUTHENTICATION_ERROR', 'PERMISSION_ERROR', 'MISSING_API_KEY'].includes(error.code || '')) {
            throw error;
          }
        }
        
        if (attempt < maxRetries) {
          const delay = baseDelay * Math.pow(2, attempt);
          console.warn(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw lastError!;
  }
}
```

## services/llm/adapters/BaseImageAdapter.ts

```typescript
/**
 * Base Image Generation Adapter
 * Abstract class that image generation adapters extend
 * Provides common functionality for image generation while extending BaseAdapter
 */

import { BaseAdapter } from './BaseAdapter';
import { 
  ImageGenerationParams, 
  ImageGenerationResponse, 
  ImageGenerationResult,
  ImageValidationResult,
  ImageCostDetails,
  ImageGenerationError,
  ImageProvider,
  ImageModel,
  ImageUsage
} from '../types/ImageTypes';
import { ProviderCapabilities, ModelInfo, CostDetails } from './types';

export abstract class BaseImageAdapter extends BaseAdapter {
  abstract readonly supportedModels: ImageModel[];
  abstract readonly supportedSizes: string[];
  abstract readonly supportedFormats: string[];

  constructor(
    apiKey: string, 
    defaultModel: string, 
    baseUrl?: string
  ) {
    super(
      apiKey,
      defaultModel,
      baseUrl,
      true // requiresApiKey
    );
  }

  // Abstract methods that each image provider must implement
  abstract generateImage(params: ImageGenerationParams): Promise<ImageGenerationResponse>;
  abstract validateImageParams(params: ImageGenerationParams): ImageValidationResult;
  abstract getImageCapabilities(): ProviderCapabilities;
  abstract getSupportedImageSizes(): string[];
  abstract getImageModelPricing(model: string): Promise<CostDetails | null>;

  /**
   * Generate image with comprehensive validation and error handling
   */
  async generateImageSafely(params: ImageGenerationParams): Promise<ImageGenerationResult> {
    const startTime = Date.now();
    
    try {
      console.log(`[${this.name}] Starting image generation for prompt: "${params.prompt.substring(0, 50)}..."`);
      
      // Validate parameters first
      const validation = this.validateImageParams(params);
      if (!validation.isValid) {
        return {
          success: false,
          error: `Parameter validation failed: ${validation.errors.join(', ')}`,
          validationErrors: validation.errors
        };
      }

      // Use adjusted parameters if provided
      const finalParams = { ...params, ...validation.adjustedParams };

      // Generate the image with timeout
      const response = await Promise.race([
        this.generateImage(finalParams),
        this.createTimeoutPromise(120000) // 2 minute timeout
      ]);

      const generationTime = Date.now() - startTime;
      console.log(`[${this.name}] Image generation completed in ${generationTime}ms`);

      // Calculate costs
      const cost = await this.calculateImageCost(response, finalParams.model || this.currentModel);

      return {
        success: true,
        data: {
          imagePath: finalParams.savePath,
          prompt: finalParams.prompt,
          revisedPrompt: response.revisedPrompt,
          model: finalParams.model || this.currentModel,
          provider: this.name as ImageProvider,
          dimensions: response.dimensions,
          fileSize: response.imageData.length,
          format: response.format,
          cost: cost || undefined,
          usage: response.usage,
          metadata: {
            ...response.metadata,
            generationTimeMs: generationTime
          }
        }
      };
    } catch (error) {
      const generationTime = Date.now() - startTime;
      console.error(`[${this.name}] Image generation failed after ${generationTime}ms:`, error);
      
      if (error instanceof ImageGenerationError) {
        return {
          success: false,
          error: error.message
        };
      }

      // Handle timeout specifically
      if (error instanceof Error && error.message === 'Image generation timed out') {
        return {
          success: false,
          error: `Image generation timed out after ${Math.round(generationTime / 1000)}s. This can happen with complex prompts or high server load. Please try again with a simpler prompt.`
        };
      }

      return {
        success: false,
        error: `Image generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Create a timeout promise that rejects after specified milliseconds
   */
  private createTimeoutPromise(timeoutMs: number): Promise<never> {
    return new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error('Image generation timed out'));
      }, timeoutMs);
    });
  }

  /**
   * Check if the adapter is available for image generation
   */
  async isImageGenerationAvailable(): Promise<boolean> {
    if (!this.apiKey) {
      return false;
    }

    try {
      const capabilities = this.getImageCapabilities();
      return capabilities.supportsImageGeneration || false;
    } catch (error) {
      console.warn(`Image generation unavailable for ${this.name}:`, error);
      return false;
    }
  }

  /**
   * Get all supported models with their capabilities
   */
  async getImageModels(): Promise<ModelInfo[]> {
    const models = await this.listModels();
    return models.filter(model => model.supportsImageGeneration);
  }

  /**
   * Calculate image generation cost
   */
  protected async calculateImageCost(
    response: ImageGenerationResponse, 
    model: string
  ): Promise<ImageCostDetails | null> {
    try {
      const pricing = await this.getImageModelPricing(model);
      if (!pricing) {
        return null;
      }

      const usage = response.usage;
      if (!usage) {
        return null;
      }

      // For image generation, we typically have a per-image cost
      const totalCost = pricing.totalCost * usage.imagesGenerated;

      return {
        inputCost: 0, // Images don't have input tokens in the traditional sense
        outputCost: totalCost,
        totalCost,
        currency: pricing.currency,
        ratePerImage: pricing.totalCost,
        resolution: usage.resolution,
        imagesGenerated: usage.imagesGenerated
      };
    } catch (error) {
      console.warn(`Failed to calculate image cost for ${model}:`, error);
      return null;
    }
  }

  /**
   * Validate common image parameters
   */
  protected validateCommonParams(params: ImageGenerationParams): ImageValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Validate prompt
    if (!params.prompt || params.prompt.trim().length === 0) {
      errors.push('Prompt is required');
    }

    // Validate save path
    if (!params.savePath || params.savePath.trim().length === 0) {
      errors.push('Save path is required');
    }

    // Check if path is trying to escape vault
    if (params.savePath?.includes('..') || params.savePath?.startsWith('/')) {
      errors.push('Save path must be relative to vault root');
    }

    // Validate model if specified
    if (params.model && !this.supportedModels.includes(params.model as ImageModel)) {
      errors.push(`Model ${params.model} not supported. Supported models: ${this.supportedModels.join(', ')}`);
    }

    // Validate size if specified
    if (params.size && !this.supportedSizes.includes(params.size)) {
      errors.push(`Size ${params.size} not supported. Supported sizes: ${this.supportedSizes.join(', ')}`);
    }

    // Format validation removed - Google Imagen only outputs PNG

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Build image usage tracking object
   */
  protected buildImageUsage(
    imagesGenerated: number, 
    resolution: string, 
    model: string
  ): ImageUsage {
    return {
      imagesGenerated,
      resolution,
      model,
      provider: this.name
    };
  }

  /**
   * Handle image-specific errors
   */
  protected handleImageError(error: any, operation: string, params?: ImageGenerationParams): never {
    if (error instanceof ImageGenerationError) {
      throw error;
    }

    if (error.response) {
      const status = error.response.status;
      const message = error.response.data?.error?.message || error.message;
      
      let errorCode = 'HTTP_ERROR';
      if (status === 401) errorCode = 'AUTHENTICATION_ERROR';
      if (status === 403) errorCode = 'CONTENT_FILTER_ERROR';
      if (status === 429) errorCode = 'RATE_LIMIT_ERROR';
      if (status === 400) errorCode = 'INVALID_REQUEST';

      throw new ImageGenerationError(
        `${operation} failed: ${message}`,
        this.name,
        errorCode,
        error,
        params
      );
    }

    throw new ImageGenerationError(
      `${operation} failed: ${error.message || 'Unknown error'}`,
      this.name,
      'UNKNOWN_ERROR',
      error,
      params
    );
  }

  // Required BaseAdapter methods (stub implementations for image-only adapters)
  async generateUncached(): Promise<any> {
    throw new Error('Use generateImage() for image generation. This adapter only supports image generation.');
  }

  async generateStream(): Promise<any> {
    throw new Error('Streaming not supported for image generation');
  }

  getCapabilities(): ProviderCapabilities {
    return this.getImageCapabilities();
  }

  async getModelPricing(modelId: string): Promise<CostDetails | null> {
    return await this.getImageModelPricing(modelId);
  }
}
```

## services/llm/adapters/CostCalculator.ts

```typescript
/**
 * Cost Calculation and Token Counting System
 * 
 * This module provides comprehensive cost calculation with proper token counting
 * using provider APIs when available, with fallback tokenization for accuracy.
 * 
 * Features:
 * - Provider-specific token counting APIs
 * - Fallback tokenization for all providers
 * - Detailed cost breakdown and tracking
 * - Usage analytics and reporting
 */

import { ModelRegistry } from './ModelRegistry';

/**
 * Detailed token usage information from provider APIs or fallback tokenization
 */
export interface DetailedTokenUsage {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  inputTokensDetails?: {
    cachedTokens?: number;
    audioTokens?: number;
    textTokens?: number;
  };
  outputTokensDetails?: {
    reasoningTokens?: number;
    audioTokens?: number;
    textTokens?: number;
  };
  source: 'provider_api' | 'fallback_tokenizer';
}

/**
 * Detailed cost breakdown
 */
export interface CostBreakdown {
  inputCost: number;
  outputCost: number;
  totalCost: number;
  currency: string;
  model: string;
  provider: string;
  tokenUsage: DetailedTokenUsage;
  costPerInputToken: number;
  costPerOutputToken: number;
  timestamp: string;
}

/**
 * Cost tracking for analytics
 */
export interface CostTracker {
  totalRequests: number;
  totalInputTokens: number;
  totalOutputTokens: number;
  totalCost: number;
  costByProvider: Record<string, number>;
  costByModel: Record<string, number>;
  averageCostPerRequest: number;
  currency: string;
  lastUpdated: string;
}

/**
 * Provider-specific token counting functions
 */
export class TokenCounter {
  /**
   * Count tokens using OpenAI's token counting API
   */
  static async countTokensOpenAI(text: string, model: string): Promise<number> {
    try {
      // Use OpenAI's token counting endpoint if available
      const response = await fetch('https://api.openai.com/v1/tokenize', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: model,
          text: text
        })
      });

      if (response.ok) {
        const data = await response.json() as any;
        return data.token_count || 0;
      }
    } catch (error) {
      console.warn('OpenAI token counting failed, using fallback:', error);
    }

    return this.fallbackTokenCount(text);
  }

  /**
   * Count tokens using Google's token counting API
   */
  static async countTokensGoogle(text: string, model: string): Promise<number> {
    try {
      // Google's countTokens API
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:countTokens?key=${process.env.GOOGLE_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: text }]
          }]
        })
      });

      if (response.ok) {
        const data = await response.json() as any;
        return data.totalTokens || 0;
      }
    } catch (error) {
      console.warn('Google token counting failed, using fallback:', error);
    }

    return this.fallbackTokenCount(text);
  }

  /**
   * Count tokens using Anthropic's token counting API
   */
  static async countTokensAnthropic(text: string, model: string): Promise<number> {
    try {
      // Anthropic's count tokens endpoint
      const response = await fetch('https://api.anthropic.com/v1/messages/count_tokens', {
        method: 'POST',
        headers: {
          'x-api-key': process.env.ANTHROPIC_API_KEY!,
          'Content-Type': 'application/json',
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: model,
          messages: [{ role: 'user', content: text }]
        })
      });

      if (response.ok) {
        const data = await response.json() as any;
        return data.input_tokens || 0;
      }
    } catch (error) {
      console.warn('Anthropic token counting failed, using fallback:', error);
    }

    return this.fallbackTokenCount(text);
  }

  /**
   * Fallback token counting using simple heuristics
   * Based on OpenAI's general rule: ~4 characters per token for English text
   */
  static fallbackTokenCount(text: string): number {
    if (!text) return 0;
    
    // More sophisticated estimation
    const words = text.split(/\s+/).length;
    const chars = text.length;
    
    // Estimate based on multiple factors
    const charBasedEstimate = Math.ceil(chars / 4);
    const wordBasedEstimate = Math.ceil(words * 1.3); // ~1.3 tokens per word on average
    
    // Use the more conservative (higher) estimate
    return Math.max(charBasedEstimate, wordBasedEstimate);
  }

  /**
   * Count tokens for any provider with fallback
   */
  static async countTokens(text: string, provider: string, model: string): Promise<DetailedTokenUsage> {
    let tokenCount = 0;
    let source: 'provider_api' | 'fallback_tokenizer' = 'fallback_tokenizer';

    try {
      switch (provider) {
        case 'openai':
          tokenCount = await this.countTokensOpenAI(text, model);
          source = 'provider_api';
          break;
        case 'google':
          tokenCount = await this.countTokensGoogle(text, model);
          source = 'provider_api';
          break;
        case 'anthropic':
          tokenCount = await this.countTokensAnthropic(text, model);
          source = 'provider_api';
          break;
        default:
          tokenCount = this.fallbackTokenCount(text);
          break;
      }
    } catch (error) {
      console.warn(`Token counting failed for ${provider}, using fallback:`, error);
      tokenCount = this.fallbackTokenCount(text);
    }

    return {
      inputTokens: tokenCount,
      outputTokens: 0,
      totalTokens: tokenCount,
      source
    };
  }
}

/**
 * Main cost calculation engine
 */
export class CostCalculator {
  /**
   * Calculate cost from token usage and model pricing
   */
  static calculateCost(
    provider: string,
    model: string,
    tokenUsage: DetailedTokenUsage
  ): CostBreakdown | null {
    const modelSpec = ModelRegistry.findModel(provider, model);
    if (!modelSpec) {
      console.warn(`Model not found in registry: ${provider}/${model}`);
      return null;
    }

    const costPerInputToken = modelSpec.inputCostPerMillion / 1_000_000;
    const costPerOutputToken = modelSpec.outputCostPerMillion / 1_000_000;

    const inputCost = tokenUsage.inputTokens * costPerInputToken;
    const outputCost = tokenUsage.outputTokens * costPerOutputToken;
    const totalCost = inputCost + outputCost;

    return {
      inputCost,
      outputCost,
      totalCost,
      currency: 'USD',
      model,
      provider,
      tokenUsage,
      costPerInputToken,
      costPerOutputToken,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Extract token usage from provider response objects
   */
  static extractTokenUsage(response: any, provider: string): DetailedTokenUsage | null {
    try {
      switch (provider) {
        case 'openai':
          // OpenAI Responses API and Chat Completions format
          if (response.usage) {
            return {
              inputTokens: response.usage.input_tokens || response.usage.prompt_tokens || 0,
              outputTokens: response.usage.output_tokens || response.usage.completion_tokens || 0,
              totalTokens: response.usage.total_tokens || 0,
              inputTokensDetails: response.usage.input_tokens_details,
              outputTokensDetails: response.usage.output_tokens_details,
              source: 'provider_api'
            };
          }
          break;

        case 'google':
          // Google Gemini format
          if (response.usageMetadata) {
            return {
              inputTokens: response.usageMetadata.promptTokenCount || 0,
              outputTokens: response.usageMetadata.candidatesTokenCount || 0,
              totalTokens: response.usageMetadata.totalTokenCount || 0,
              source: 'provider_api'
            };
          }
          break;

        case 'anthropic':
          // Anthropic Claude format
          if (response.usage) {
            return {
              inputTokens: response.usage.input_tokens || 0,
              outputTokens: response.usage.output_tokens || 0,
              totalTokens: (response.usage.input_tokens || 0) + (response.usage.output_tokens || 0),
              source: 'provider_api'
            };
          }
          break;

        case 'openrouter':
        case 'requesty':
          // OpenRouter/Requesty typically pass through OpenAI format
          if (response.usage) {
            return {
              inputTokens: response.usage.prompt_tokens || 0,
              outputTokens: response.usage.completion_tokens || 0,
              totalTokens: response.usage.total_tokens || 0,
              source: 'provider_api'
            };
          }
          break;
      }
    } catch (error) {
      console.warn(`Failed to extract token usage from ${provider} response:`, error);
    }

    return null;
  }

  /**
   * Calculate cost with automatic token counting if usage not provided
   */
  static async calculateCostWithTokenCounting(
    provider: string,
    model: string,
    inputText: string,
    outputText: string,
    providedUsage?: DetailedTokenUsage
  ): Promise<CostBreakdown | null> {
    let tokenUsage: DetailedTokenUsage;

    if (providedUsage) {
      tokenUsage = providedUsage;
    } else {
      // Count tokens for input and output
      const inputUsage = await TokenCounter.countTokens(inputText, provider, model);
      const outputUsage = await TokenCounter.countTokens(outputText, provider, model);
      
      tokenUsage = {
        inputTokens: inputUsage.inputTokens,
        outputTokens: outputUsage.inputTokens, // Output counting uses same method
        totalTokens: inputUsage.inputTokens + outputUsage.inputTokens,
        source: inputUsage.source
      };
    }

    return this.calculateCost(provider, model, tokenUsage);
  }

  /**
   * Compare costs across multiple providers/models
   */
  static compareCosts(
    providers: Array<{ provider: string; model: string }>,
    tokenUsage: DetailedTokenUsage
  ): Array<CostBreakdown> {
    return providers
      .map(({ provider, model }) => this.calculateCost(provider, model, tokenUsage))
      .filter(Boolean)
      .sort((a, b) => a!.totalCost - b!.totalCost) as Array<CostBreakdown>;
  }
}

/**
 * Cost tracking and analytics
 */
export class CostAnalyzer {
  private tracker: CostTracker = {
    totalRequests: 0,
    totalInputTokens: 0,
    totalOutputTokens: 0,
    totalCost: 0,
    costByProvider: {},
    costByModel: {},
    averageCostPerRequest: 0,
    currency: 'USD',
    lastUpdated: new Date().toISOString()
  };

  addUsage(costBreakdown: CostBreakdown): void {
    this.tracker.totalRequests++;
    this.tracker.totalInputTokens += costBreakdown.tokenUsage.inputTokens;
    this.tracker.totalOutputTokens += costBreakdown.tokenUsage.outputTokens;
    this.tracker.totalCost += costBreakdown.totalCost;
    
    this.tracker.costByProvider[costBreakdown.provider] = 
      (this.tracker.costByProvider[costBreakdown.provider] || 0) + costBreakdown.totalCost;
    
    const modelKey = `${costBreakdown.provider}/${costBreakdown.model}`;
    this.tracker.costByModel[modelKey] = 
      (this.tracker.costByModel[modelKey] || 0) + costBreakdown.totalCost;
    
    this.tracker.averageCostPerRequest = this.tracker.totalCost / this.tracker.totalRequests;
    this.tracker.lastUpdated = new Date().toISOString();
  }

  getReport(): CostTracker {
    return { ...this.tracker };
  }

  getMostExpensive(): { provider: string; model: string; cost: number } | null {
    const entries = Object.entries(this.tracker.costByModel);
    if (entries.length === 0) return null;

    const [model, cost] = entries.reduce((max, entry) => 
      entry[1] > max[1] ? entry : max
    );

    const [provider, modelName] = model.split('/');
    return { provider: provider || 'unknown', model: modelName || model, cost };
  }

  getCheapest(): { provider: string; model: string; cost: number } | null {
    const entries = Object.entries(this.tracker.costByModel);
    if (entries.length === 0) return null;

    const [model, cost] = entries.reduce((min, entry) => 
      entry[1] < min[1] ? entry : min
    );

    const [provider, modelName] = model.split('/');
    return { provider: provider || 'unknown', model: modelName || model, cost };
  }

  getCostByProvider(): Record<string, { cost: number; percentage: number }> {
    const result: Record<string, { cost: number; percentage: number }> = {};
    
    for (const [provider, cost] of Object.entries(this.tracker.costByProvider)) {
      result[provider] = {
        cost,
        percentage: this.tracker.totalCost > 0 ? (cost / this.tracker.totalCost) * 100 : 0
      };
    }
    
    return result;
  }

  reset(): void {
    this.tracker = {
      totalRequests: 0,
      totalInputTokens: 0,
      totalOutputTokens: 0,
      totalCost: 0,
      costByProvider: {},
      costByModel: {},
      averageCostPerRequest: 0,
      currency: 'USD',
      lastUpdated: new Date().toISOString()
    };
  }

  exportData(): string {
    return JSON.stringify(this.tracker, null, 2);
  }

  importData(data: string): void {
    try {
      const imported = JSON.parse(data);
      this.tracker = { ...this.tracker, ...imported };
    } catch (error) {
      console.error('Failed to import cost tracking data:', error);
    }
  }
}

/**
 * Global cost analyzer instance for easy access
 */
export const globalCostAnalyzer = new CostAnalyzer();
```

## services/llm/adapters/ModelRegistry.ts

```typescript
/**
 * Centralized AI Model Registry
 * 
 * This file imports all provider-specific model definitions and provides
 * a unified interface for working with models across all providers.
 * 
 * Updated June 17, 2025 with modular provider structure
 */

import { ModelSpec } from './modelTypes';
import { OPENAI_MODELS, OPENAI_DEFAULT_MODEL } from './openai/OpenAIModels';
import { GOOGLE_MODELS, GOOGLE_DEFAULT_MODEL } from './google/GoogleModels';
import { ANTHROPIC_MODELS, ANTHROPIC_DEFAULT_MODEL } from './anthropic/AnthropicModels';
import { MISTRAL_MODELS, MISTRAL_DEFAULT_MODEL } from './mistral/MistralModels';
import { OPENROUTER_MODELS, OPENROUTER_DEFAULT_MODEL } from './openrouter/OpenRouterModels';
import { REQUESTY_MODELS, REQUESTY_DEFAULT_MODEL } from './requesty/RequestyModels';
import { GROQ_MODELS, GROQ_DEFAULT_MODEL } from './groq/GroqModels';
import { OLLAMA_MODELS } from './ollama/OllamaModels';

// Re-export ModelSpec for convenience
export type { ModelSpec };

/**
 * Complete model registry organized by provider
 * Reconstructed from individual provider model definitions
 */
export const AI_MODELS: Record<string, ModelSpec[]> = {
  openai: OPENAI_MODELS,
  google: GOOGLE_MODELS,
  anthropic: ANTHROPIC_MODELS,
  mistral: MISTRAL_MODELS,
  openrouter: OPENROUTER_MODELS,
  requesty: REQUESTY_MODELS,
  groq: GROQ_MODELS,
  ollama: OLLAMA_MODELS
};

/**
 * Helper functions for working with the model registry
 */
export class ModelRegistry {
  /**
   * Get all models for a specific provider
   */
  static getProviderModels(provider: string): ModelSpec[] {
    return AI_MODELS[provider] || [];
  }

  /**
   * Find a specific model by provider and API name
   * For OpenRouter, supports :online suffix (e.g., "gpt-4:online")
   */
  static findModel(provider: string, apiName: string): ModelSpec | undefined {
    const providerModels = this.getProviderModels(provider);
    
    // For OpenRouter models, check if apiName has :online suffix
    if (provider === 'openrouter' && apiName.endsWith(':online')) {
      const baseModelName = apiName.replace(':online', '');
      return providerModels.find(model => model.apiName === baseModelName);
    }
    
    return providerModels.find(model => model.apiName === apiName);
  }

  /**
   * Get all available providers
   */
  static getProviders(): string[] {
    return Object.keys(AI_MODELS);
  }

  /**
   * Get models with specific capabilities
   */
  static getModelsByCapability(capability: keyof ModelSpec['capabilities'], value = true): ModelSpec[] {
    const allModels = Object.values(AI_MODELS).flat();
    return allModels.filter(model => model.capabilities[capability] === value);
  }

  /**
   * Get models within a cost range (input cost per million tokens)
   */
  static getModelsByCostRange(maxInputCost: number, maxOutputCost?: number): ModelSpec[] {
    const allModels = Object.values(AI_MODELS).flat();
    return allModels.filter(model => {
      const withinInputCost = model.inputCostPerMillion <= maxInputCost;
      const withinOutputCost = maxOutputCost ? model.outputCostPerMillion <= maxOutputCost : true;
      return withinInputCost && withinOutputCost;
    });
  }

  /**
   * Get the latest models (all current models)
   */
  static getLatestModels(): ModelSpec[] {
    return Object.values(AI_MODELS).flat();
  }

  /**
   * Check if a model name is valid for OpenRouter with :online suffix
   */
  static isValidOpenRouterModel(apiName: string): boolean {
    if (!apiName.endsWith(':online')) {
      return this.findModel('openrouter', apiName) !== undefined;
    }
    
    const baseModelName = apiName.replace(':online', '');
    return this.findModel('openrouter', baseModelName) !== undefined;
  }

  /**
   * Convert ModelSpec to the legacy ModelInfo format
   */
  static toModelInfo(modelSpec: ModelSpec): any {
    return {
      id: modelSpec.apiName,
      name: modelSpec.name,
      contextWindow: modelSpec.contextWindow,
      maxOutputTokens: modelSpec.maxTokens,
      supportsJSON: modelSpec.capabilities.supportsJSON,
      supportsImages: modelSpec.capabilities.supportsImages,
      supportsFunctions: modelSpec.capabilities.supportsFunctions,
      supportsStreaming: modelSpec.capabilities.supportsStreaming,
      supportsThinking: modelSpec.capabilities.supportsThinking,
      costPer1kTokens: {
        input: modelSpec.inputCostPerMillion / 1000,
        output: modelSpec.outputCostPerMillion / 1000
      },
      pricing: {
        inputPerMillion: modelSpec.inputCostPerMillion,
        outputPerMillion: modelSpec.outputCostPerMillion,
        currency: 'USD',
        lastUpdated: new Date().toISOString()
      }
    };
  }
}

/**
 * Export default models for each provider (recommended models)
 */
export const DEFAULT_MODELS: Record<string, string> = {
  openai: OPENAI_DEFAULT_MODEL,
  google: GOOGLE_DEFAULT_MODEL,
  anthropic: ANTHROPIC_DEFAULT_MODEL,
  mistral: MISTRAL_DEFAULT_MODEL,
  openrouter: OPENROUTER_DEFAULT_MODEL,
  requesty: REQUESTY_DEFAULT_MODEL,
  groq: GROQ_DEFAULT_MODEL
};
```

## services/llm/adapters/anthropic/AnthropicAdapter.ts

```typescript
/**
 * Anthropic Claude Adapter with true streaming support
 * Implements Anthropic's SSE streaming protocol
 * Based on official Anthropic streaming documentation
 */

import Anthropic from '@anthropic-ai/sdk';
import { BaseAdapter } from '../BaseAdapter';
import { 
  GenerateOptions, 
  StreamChunk, 
  LLMResponse, 
  ModelInfo, 
  ProviderCapabilities,
  ModelPricing
} from '../types';
import { ANTHROPIC_MODELS, ANTHROPIC_DEFAULT_MODEL } from './AnthropicModels';
import { MCPToolExecution, MCPCapableAdapter } from '../shared/MCPToolExecution';

export class AnthropicAdapter extends BaseAdapter implements MCPCapableAdapter {
  readonly name = 'anthropic';
  readonly baseUrl = 'https://api.anthropic.com';
  
  private client: Anthropic;
  mcpConnector?: any;

  constructor(apiKey: string, mcpConnector?: any, model?: string) {
    super(apiKey, model || ANTHROPIC_DEFAULT_MODEL);
    
    this.client = new Anthropic({
      apiKey: this.apiKey,
      baseURL: this.baseUrl,
      dangerouslyAllowBrowser: true
    });
    
    this.mcpConnector = mcpConnector;
    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    return this.withRetry(async () => {
      try {
        // If tools are provided (pre-converted by ChatService), use tool-enabled generation
        if (options?.tools && options.tools.length > 0) {
          console.log('[Anthropic Adapter] Using tool-enabled generation', {
            toolCount: options.tools.length
          });
          return await this.generateWithProvidedTools(prompt, options);
        }
        
        // Otherwise use basic message generation
        console.log('[Anthropic Adapter] Using basic message generation (no tools)');
        return await this.generateWithBasicMessages(prompt, options);
      } catch (error) {
        this.handleError(error, 'generation');
      }
    });
  }

  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      console.log('[AnthropicAdapter] Starting streaming response');
      
      const messages = this.buildMessages(prompt, options?.systemPrompt);
      
      const requestParams: any = {
        model: options?.model || this.currentModel,
        max_tokens: options?.maxTokens || 4096,
        messages: messages.filter(msg => msg.role !== 'system'),
        temperature: options?.temperature,
        stream: true
      };

      // Add system message if provided
      const systemMessage = messages.find(msg => msg.role === 'system');
      if (systemMessage) {
        requestParams.system = systemMessage.content;
      }

      // Extended thinking mode for Claude 4 models
      if (options?.enableThinking && this.supportsThinking(options?.model || this.currentModel)) {
        requestParams.thinking = {
          type: 'enabled',
          budget_tokens: 16000
        };
      }

      // Add tools if provided
      if (options?.tools && options.tools.length > 0) {
        requestParams.tools = this.convertTools(options.tools);
      }

      const stream = this.client.messages.stream(requestParams);
      
      let usage: any = undefined;

      for await (const event of stream) {
        console.log('[AnthropicAdapter] Stream event type:', event.type);
        
        if ('type' in event) {
          switch (event.type) {
            case 'message_start':
              usage = (event as any).message.usage;
              break;
              
            case 'content_block_delta':
              const delta = (event as any).delta;
              if (delta.type === 'text_delta' && delta.text) {
                yield { 
                  content: delta.text, 
                  complete: false 
                };
              } else if (delta.type === 'thinking_delta' && delta.thinking) {
                // Stream thinking content if enabled
                if (options?.enableThinking) {
                  yield { 
                    content: delta.thinking, 
                    complete: false 
                  };
                }
              }
              break;
              
            case 'message_delta':
              if ((event as any).usage) {
                usage = (event as any).usage;
              }
              break;
              
            case 'message_stop':
              yield { 
                content: '', 
                complete: true, 
                usage: this.extractUsage({ usage }) 
              };
              break;
              
            default:
              // Handle ping, error, and other events
              if ((event as any).type === 'ping') {
                // Ignore ping events
              } else if ((event as any).type === 'error') {
                console.error('[AnthropicAdapter] Stream error:', (event as any).error);
                throw new Error(`Anthropic stream error: ${(event as any).error.message}`);
              } else {
                console.log('[AnthropicAdapter] Unknown event type:', (event as any).type);
              }
              break;
          }
        }
      }
      
      console.log('[AnthropicAdapter] Streaming completed');
    } catch (error) {
      console.error('[AnthropicAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return ANTHROPIC_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: model.capabilities.supportsThinking,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: true,
      maxContextWindow: 200000,
      supportedFeatures: [
        'messages',
        'extended_thinking',
        'function_calling',
        'web_search',
        'computer_use',
        'vision',
        'streaming'
      ]
    };
  }

  /**
   * Generate with pre-converted tools (from ChatService) using centralized execution
   */
  private async generateWithProvidedTools(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    // Use centralized tool execution wrapper to eliminate code duplication
    const model = options?.model || this.currentModel;
    let systemMessage: string | undefined;

    return MCPToolExecution.executeWithToolSupport(
      this,
      'anthropic',
      {
        model,
        tools: options?.tools || [],
        prompt,
        systemPrompt: options?.systemPrompt
      },
      {
        buildMessages: (prompt: string, systemPrompt?: string) => {
          const messages = this.buildMessages(prompt, systemPrompt);
          systemMessage = messages.find(msg => msg.role === 'system')?.content;
          return messages.filter(msg => msg.role !== 'system');
        },
        
        buildRequestBody: (messages: any[], isInitial: boolean) => {
          const requestParams: any = {
            model,
            max_tokens: options?.maxTokens || 4096,
            messages,
            temperature: options?.temperature,
            stop_sequences: options?.stopSequences,
            tools: this.convertTools(options?.tools || [])
          };

          // Add system message if available
          if (systemMessage) {
            requestParams.system = systemMessage;
          }

          // Extended thinking mode for Claude 4 models
          if (options?.enableThinking && this.supportsThinking(model)) {
            requestParams.thinking = {
              type: 'enabled',
              budget_tokens: 16000
            };
          }

          return requestParams;
        },
        
        makeApiCall: async (requestBody: any) => {
          return await this.client.messages.create(requestBody);
        },
        
        extractResponse: async (response: any) => {
          const toolCalls = this.extractToolCalls(response.content);
          
          return {
            content: this.extractTextFromContent(response.content),
            usage: this.extractUsage(response),
            finishReason: this.mapStopReason(response.stop_reason),
            toolCalls: toolCalls,
            choice: {
              message: {
                content: response.content,
                toolCalls: toolCalls.length > 0 ? toolCalls : undefined
              }
            }
          };
        },
        
        buildLLMResponse: async (
          content: string,
          model: string,
          usage?: any,
          metadata?: any,
          finishReason?: any,
          toolCalls?: any[]
        ) => {
          // Find latest response to extract metadata
          const finalMetadata = {
            ...metadata,
            thinking: this.extractThinking({ content: [] }), // Will be properly extracted during execution
            stopSequence: undefined // Will be properly extracted during execution
          };
          
          return this.buildLLMResponse(content, model, usage, finalMetadata, finishReason, toolCalls);
        }
      }
    );
  }

  /**
   * Generate using basic message API without tools
   */
  private async generateWithBasicMessages(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const messages = this.buildMessages(prompt, options?.systemPrompt);
    
    const requestParams: any = {
      model: options?.model || this.currentModel,
      max_tokens: options?.maxTokens || 4096,
      messages: messages.filter(msg => msg.role !== 'system'),
      temperature: options?.temperature,
      stop_sequences: options?.stopSequences
    };

    // Add system message if provided
    const systemMessage = messages.find(msg => msg.role === 'system');
    if (systemMessage) {
      requestParams.system = systemMessage.content;
    }

    // Extended thinking mode for Claude 4 models
    if (options?.enableThinking && this.supportsThinking(options?.model || this.currentModel)) {
      requestParams.thinking = {
        type: 'enabled',
        budget_tokens: 16000
      };
    }

    // Add tools if provided
    if (options?.tools && options.tools.length > 0) {
      requestParams.tools = this.convertTools(options.tools);
    }

    // Special tools
    if (options?.webSearch) {
      requestParams.tools = requestParams.tools || [];
      requestParams.tools.push({
        type: 'web_search_20250305',
        name: 'web_search',
        max_uses: 5
      });
    }

    const response = await this.client.messages.create(requestParams);
    
    const extractedUsage = this.extractUsage(response);
    const finishReason = this.mapStopReason(response.stop_reason);
    const toolCalls = this.extractToolCalls(response.content);
    const metadata = {
      thinking: this.extractThinking(response),
      stopSequence: response.stop_sequence
    };

    return await this.buildLLMResponse(
      this.extractTextFromContent(response.content),
      response.model,
      extractedUsage,
      metadata,
      finishReason,
      toolCalls
    );
  }

  // Private methods
  private supportsThinking(modelId: string): boolean {
    const model = ANTHROPIC_MODELS.find(m => m.apiName === modelId);
    return model?.capabilities.supportsThinking || false;
  }

  private convertTools(tools: any[]): any[] {
    return tools.map(tool => {
      if (tool.type === 'function') {
        return {
          name: tool.function.name,
          description: tool.function.description,
          input_schema: tool.function.parameters
        };
      }
      return tool;
    });
  }

  private extractTextFromContent(content: any[]): string {
    return content
      .filter(block => block.type === 'text')
      .map(block => block.text)
      .join('');
  }

  private extractToolCalls(content: any[]): any[] {
    return content
      .filter(block => block.type === 'tool_use')
      .map(block => ({
        id: block.id,
        type: 'function',
        function: {
          name: block.name,
          arguments: JSON.stringify(block.input)
        }
      }));
  }

  private extractThinking(response: any): string | undefined {
    // Extract thinking process from response if available
    const thinkingBlocks = response.content?.filter((block: any) => block.type === 'thinking') || [];
    if (thinkingBlocks.length > 0) {
      return thinkingBlocks.map((block: any) => block.thinking).join('\n');
    }
    return undefined;
  }

  private mapStopReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'end_turn': 'stop',
      'max_tokens': 'length',
      'tool_use': 'tool_calls',
      'stop_sequence': 'stop'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): any {
    if (response.usage) {
      return {
        promptTokens: response.usage.input_tokens || 0,
        completionTokens: response.usage.output_tokens || 0,
        totalTokens: (response.usage.input_tokens || 0) + (response.usage.output_tokens || 0)
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = ANTHROPIC_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/anthropic/AnthropicModels.ts

```typescript
/**
 * Anthropic Model Specifications
 * Updated June 17, 2025 with latest Claude releases
 */

import { ModelSpec } from '../modelTypes';

export const ANTHROPIC_MODELS: ModelSpec[] = [
  // Claude models
  {
    provider: 'anthropic',
    name: 'Claude 3.5 Haiku',
    apiName: 'claude-3-5-haiku-latest',
    contextWindow: 200000,
    maxTokens: 8192,
    inputCostPerMillion: 0.80,
    outputCostPerMillion: 4.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Claude 4 models
  {
    provider: 'anthropic',
    name: 'Claude 4 Opus',
    apiName: 'claude-opus-4-0',
    contextWindow: 200000,
    maxTokens: 32000,
    inputCostPerMillion: 15.00,
    outputCostPerMillion: 75.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'anthropic',
    name: 'Claude 4.1 Opus',
    apiName: 'claude-opus-4-1-20250805',
    contextWindow: 200000,
    maxTokens: 32000,
    inputCostPerMillion: 15.00,
    outputCostPerMillion: 75.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'anthropic',
    name: 'Claude 4 Sonnet',
    apiName: 'claude-sonnet-4-0',
    contextWindow: 200000,
    maxTokens: 64000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  }
];

export const ANTHROPIC_DEFAULT_MODEL = 'claude-3-5-haiku-latest';
```

## services/llm/adapters/google/GeminiImageAdapter.ts

```typescript
/**
 * Google Gemini Image Generation Adapter
 * Supports Google's Imagen 4 models for image generation
 * Based on 2025 API documentation using @google/genai SDK
 */

import { GoogleGenAI } from '@google/genai';
import { BaseImageAdapter } from '../BaseImageAdapter';
import { 
  ImageGenerationParams, 
  ImageGenerationResponse, 
  ImageValidationResult,
  ImageModel,
  ImageUsage,
  AspectRatio
} from '../../types/ImageTypes';
import { 
  ProviderConfig,
  ProviderCapabilities,
  ModelInfo,
  CostDetails
} from '../types';

export class GeminiImageAdapter extends BaseImageAdapter {
  
  // Image adapters don't support streaming in the same way as text
  async* generateStreamAsync(): AsyncGenerator<never, void, unknown> {
    // Image generation is not streamable - it's a single result
    // This method should not be called for image adapters
    throw new Error('Image generation does not support streaming');
  }
  readonly name = 'gemini-image';
  readonly baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  readonly supportedModels: ImageModel[] = ['imagen-4', 'imagen-4-ultra', 'imagen-4-fast'];
  readonly supportedSizes: string[] = ['1024x1024', '1536x1024', '1024x1536', '1792x1024', '1024x1792'];
  readonly supportedFormats: string[] = ['png'];
  
  private client: GoogleGenAI;
  private readonly modelMap = {
    'imagen-4': 'imagen-4.0-generate-001',
    'imagen-4-ultra': 'imagen-4.0-ultra-generate-001',
    'imagen-4-fast': 'imagen-4.0-fast-generate-001'
  };
  private readonly defaultModel = 'imagen-4';
  private readonly aspectRatioMap = {
    '1024x1024': '1:1',
    '1536x1024': '3:4',
    '1024x1536': '4:3', 
    '1792x1024': '16:9',
    '1024x1792': '9:16'
  };

  constructor(config?: ProviderConfig) {
    const apiKey = config?.apiKey || '';
    super(apiKey, 'imagen-4', config?.baseUrl);
    
    this.client = new GoogleGenAI({
      apiKey: apiKey
    });

    this.initializeCache();
  }

  /**
   * Generate images using Google's Imagen 4 models
   */
  async generateImage(params: ImageGenerationParams): Promise<ImageGenerationResponse> {
    try {
      this.validateConfiguration();
      
      const modelId = this.modelMap[params.model as keyof typeof this.modelMap] || 
                     this.modelMap[this.defaultModel as keyof typeof this.modelMap];

      const response = await this.withRetry(async () => {
        const config: any = {
          numberOfImages: params.numberOfImages || 1,
        };

        // Add aspect ratio directly from params (preferred) or convert from size (legacy)
        if (params.aspectRatio) {
          config.aspectRatio = params.aspectRatio;
        } else if (params.size) {
          config.aspectRatio = this.getAspectRatio(params.size);
        } else {
          config.aspectRatio = '1:1'; // Default aspect ratio
        }

        // Add sample image size if specified (only for imagen-4 and imagen-4-ultra)
        if (params.sampleImageSize && (params.model === 'imagen-4' || params.model === 'imagen-4-ultra')) {
          config.sampleImageSize = params.sampleImageSize;
        }

        const result = await (this.client as any).models.generateImages({
          model: modelId,
          prompt: params.prompt,
          config
        });

        return result;
      }, 2); // Reduced retry count for faster failure detection

      return this.buildImageResponse(response, params);
    } catch (error) {
      this.handleImageError(error, 'image generation', params);
    }
  }

  /**
   * Validate Google-specific image generation parameters
   */
  validateImageParams(params: ImageGenerationParams): ImageValidationResult {
    // Start with common validation
    const baseValidation = this.validateCommonParams(params);
    if (!baseValidation.isValid) {
      return baseValidation;
    }

    const errors: string[] = [...baseValidation.errors];
    const warnings: string[] = [...(baseValidation.warnings || [])];
    const adjustedParams: Partial<ImageGenerationParams> = {};

    // Validate prompt length (Imagen 4 has a 480 token limit)
    if (params.prompt.length > 2000) { // Rough approximation of 480 tokens
      errors.push('Prompt too long (approximately 480 tokens max for Imagen 4)');
    }

    // Validate model
    if (params.model && !this.supportedModels.includes(params.model as ImageModel)) {
      errors.push(`Invalid model. Supported models: ${this.supportedModels.join(', ')}`);
    }

    // Size validation - convert to aspect ratios (legacy support)
    if (params.size) {
      if (!this.supportedSizes.includes(params.size)) {
        errors.push(`Invalid size. Supported sizes: ${this.supportedSizes.join(', ')}`);
      }
    }

    // Number of images validation
    if (params.numberOfImages && (params.numberOfImages < 1 || params.numberOfImages > 4)) {
      errors.push('numberOfImages must be between 1 and 4');
    }

    // Sample image size validation (only for imagen-4 and imagen-4-ultra)
    if (params.sampleImageSize) {
      if (!['1K', '2K'].includes(params.sampleImageSize)) {
        errors.push('sampleImageSize must be "1K" or "2K"');
      }
      if (params.sampleImageSize === '2K' && params.model === 'imagen-4-fast') {
        errors.push('2K resolution is not supported for imagen-4-fast model');
      }
    }

    // Set default model if not specified
    if (!params.model) {
      adjustedParams.model = this.defaultModel;
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      adjustedParams
    };
  }

  /**
   * Get Google Imagen capabilities
   */
  getImageCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: false,
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsThinking: false,
      supportsImageGeneration: true,
      maxContextWindow: 480, // Token limit for prompts
      supportedFeatures: [
        'text_to_image',
        'multi_image_generation',
        'aspect_ratio_control',
        'high_quality_output',
        'enhanced_text_rendering'
      ]
    };
  }

  /**
   * Get supported aspect ratios (converted from sizes)
   */
  getSupportedImageSizes(): string[] {
    return [...this.supportedSizes];
  }

  /**
   * Get supported aspect ratios
   */
  getSupportedAspectRatios(): AspectRatio[] {
    return [AspectRatio.SQUARE, AspectRatio.PORTRAIT_3_4, AspectRatio.LANDSCAPE_4_3, AspectRatio.PORTRAIT_9_16, AspectRatio.LANDSCAPE_16_9];
  }

  /**
   * Get pricing for Imagen models (2025 pricing)
   */
  async getImageModelPricing(model: string = 'imagen-4'): Promise<CostDetails> {
    const pricing = {
      'imagen-4': 0.04,      // Standard
      'imagen-4-ultra': 0.06, // Ultra
      'imagen-4-fast': 0.02   // Fast
    };

    const basePrice = pricing[model as keyof typeof pricing] || 0.04;

    return {
      inputCost: 0,
      outputCost: basePrice,
      totalCost: basePrice,
      currency: 'USD',
      rateInputPerMillion: 0,
      rateOutputPerMillion: basePrice * 1_000_000
    };
  }

  /**
   * List available Google image models
   */
  async listModels(): Promise<ModelInfo[]> {
    return [
      {
        id: 'imagen-4',
        name: 'Imagen 4',
        contextWindow: 480,
        maxOutputTokens: 0,
        supportsJSON: false,
        supportsImages: false,
        supportsFunctions: false,
        supportsStreaming: false,
        supportsThinking: false,
        supportsImageGeneration: true,
        pricing: {
          inputPerMillion: 0,
          outputPerMillion: 0,
          imageGeneration: 0.04,
          currency: 'USD',
          lastUpdated: '2025-08-22'
        }
      },
      {
        id: 'imagen-4-ultra',
        name: 'Imagen 4 Ultra',
        contextWindow: 480,
        maxOutputTokens: 0,
        supportsJSON: false,
        supportsImages: false,
        supportsFunctions: false,
        supportsStreaming: false,
        supportsThinking: false,
        supportsImageGeneration: true,
        pricing: {
          inputPerMillion: 0,
          outputPerMillion: 0,
          imageGeneration: 0.06,
          currency: 'USD',
          lastUpdated: '2025-08-22'
        }
      },
      {
        id: 'imagen-4-fast',
        name: 'Imagen 4 Fast',
        contextWindow: 480,
        maxOutputTokens: 0,
        supportsJSON: false,
        supportsImages: false,
        supportsFunctions: false,
        supportsStreaming: false,
        supportsThinking: false,
        supportsImageGeneration: true,
        pricing: {
          inputPerMillion: 0,
          outputPerMillion: 0,
          imageGeneration: 0.02,
          currency: 'USD',
          lastUpdated: '2025-08-22'
        }
      }
    ];
  }

  // Private helper methods

  private buildImageResponse(
    response: any, 
    params: ImageGenerationParams
  ): ImageGenerationResponse {
    // Handle Google GenAI SDK response format
    if (!response.generatedImages || response.generatedImages.length === 0) {
      throw new Error('No image data received from Google');
    }

    const generatedImage = response.generatedImages[0];
    if (!generatedImage.image || !generatedImage.image.imageBytes) {
      throw new Error('No image bytes found in Google response');
    }

    // Convert base64 to buffer
    const buffer = Buffer.from(generatedImage.image.imageBytes, 'base64');

    // Extract dimensions from aspectRatio or size parameter
    let width = 1024, height = 1024; // Default square
    let aspectRatio: AspectRatio = params.aspectRatio || AspectRatio.SQUARE;
    let size = '1024x1024';
    
    if (params.aspectRatio) {
      // Use aspect ratio to calculate dimensions
      const aspectRatioToDimensions: Record<AspectRatio, [number, number]> = {
        [AspectRatio.SQUARE]: [1024, 1024],
        [AspectRatio.PORTRAIT_3_4]: [1152, 896], // Google's typical dimensions for 3:4
        [AspectRatio.LANDSCAPE_4_3]: [896, 1152], // Google's typical dimensions for 4:3  
        [AspectRatio.PORTRAIT_9_16]: [576, 1024], // Google's typical dimensions for 9:16
        [AspectRatio.LANDSCAPE_16_9]: [1024, 576]  // Google's typical dimensions for 16:9
      };
      [width, height] = aspectRatioToDimensions[params.aspectRatio] || [1024, 1024];
      size = `${width}x${height}`;
    } else if (params.size) {
      // Legacy: extract from size parameter
      const [w, h] = params.size.split('x').map(Number);
      width = w;
      height = h;
      size = params.size;
      const mappedRatio = this.aspectRatioMap[size as keyof typeof this.aspectRatioMap];
      aspectRatio = (mappedRatio as AspectRatio) || AspectRatio.SQUARE;
    }

    const usage: ImageUsage = this.buildImageUsage(1, size, params.model || this.defaultModel);

    return {
      imageData: buffer,
      format: 'png', // Google Imagen typically returns PNG
      dimensions: { width, height },
      metadata: {
        aspectRatio,
        model: params.model || this.defaultModel,
        provider: this.name,
        generatedAt: new Date().toISOString(),
        originalPrompt: params.prompt,
        synthidWatermarking: true // Google adds SynthID watermarking
      },
      usage
    };
  }

  /**
   * Convert size to aspect ratio for Google API
   */
  private getAspectRatio(size: string): string {
    return this.aspectRatioMap[size as keyof typeof this.aspectRatioMap] || '1:1';
  }

}
```

## services/llm/adapters/google/GoogleAdapter.ts

```typescript
/**
 * Google Gemini Adapter with true streaming support
 * Implements Google Gemini streaming protocol using generateContentStream
 * Based on official Google Gemini JavaScript SDK documentation
 */

import { GoogleGenAI } from '@google/genai';
import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  SearchResult
} from '../types';
import { GOOGLE_MODELS, GOOGLE_DEFAULT_MODEL } from './GoogleModels';
import { WebSearchUtils } from '../../utils/WebSearchUtils';

export class GoogleAdapter extends BaseAdapter {
  readonly name = 'google';
  readonly baseUrl = 'https://generativelanguage.googleapis.com/v1';
  
  private client: GoogleGenAI;

  constructor(apiKey: string, model?: string) {
    super(apiKey, model || GOOGLE_DEFAULT_MODEL);
    
    this.client = new GoogleGenAI({ apiKey: this.apiKey });
    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    return this.withRetry(async () => {
      try {
        // Validate web search support
        if (options?.webSearch) {
          WebSearchUtils.validateWebSearchRequest('google', options.webSearch);
        }

        const request: any = {
          model: options?.model || this.currentModel,
          contents: [{
            role: 'user',
            parts: [{ text: prompt }]
          }],
          generationConfig: {
            temperature: options?.temperature,
            maxOutputTokens: options?.maxTokens,
            topK: 40,
            topP: 0.95
          }
        };

        // Add system instruction if provided
        if (options?.systemPrompt) {
          request.systemInstruction = {
            role: 'system',
            parts: [{ text: options.systemPrompt }]
          };
        }

        // Add tools if provided
        const tools = [...(options?.tools || [])];

        // Add web search tool if requested
        if (options?.webSearch) {
          tools.push({
            type: 'function',
            function: {
              name: 'google_search',
              description: 'Search the web for current information',
              parameters: {
                type: 'object',
                properties: {
                  query: { type: 'string', description: 'Search query' }
                },
                required: ['query']
              }
            }
          });
        }

        if (tools.length > 0) {
          request.tools = this.convertTools(tools);
        }

        const response = await this.client.models.generateContent(request);

        const extractedUsage = this.extractUsage(response);
        const finishReason = this.mapFinishReason(response.finishReason);
        const toolCalls = this.extractToolCalls(response);

        // Extract web search results if web search was enabled
        const webSearchResults = options?.webSearch
          ? this.extractGoogleSources(response)
          : undefined;

        return await this.buildLLMResponse(
          response.text || '',
          options?.model || this.currentModel,
          extractedUsage,
          { webSearchResults },
          finishReason,
          toolCalls
        );
      } catch (error) {
        this.handleError(error, 'generation');
      }
    });
  }

  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      console.log('[GoogleAdapter] Starting streaming response');
      
      const request: any = {
        model: options?.model || this.currentModel,
        contents: [{
          role: 'user',
          parts: [{ text: prompt }]
        }],
        generationConfig: {
          temperature: options?.temperature,
          maxOutputTokens: options?.maxTokens,
          topK: 40,
          topP: 0.95
        }
      };

      // Add system instruction if provided
      if (options?.systemPrompt) {
        request.systemInstruction = {
          role: 'system',
          parts: [{ text: options.systemPrompt }]
        };
      }

      // Add tools if provided
      if (options?.tools && options.tools.length > 0) {
        request.tools = this.convertTools(options.tools);
      }

      const response = await this.client.models.generateContentStream(request);
      
      let usage: any = undefined;

      for await (const chunk of response) {
        console.log('[GoogleAdapter] Stream chunk received');
        
        if (chunk.text) {
          yield { 
            content: chunk.text, 
            complete: false 
          };
        }
        
        // Extract usage information if available
        if (chunk.usageMetadata) {
          usage = chunk.usageMetadata;
        }
      }
      
      // Final chunk with usage information
      yield { 
        content: '', 
        complete: true, 
        usage: this.extractUsage({ usageMetadata: usage }) 
      };
      
      console.log('[GoogleAdapter] Streaming completed');
    } catch (error) {
      console.error('[GoogleAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return GOOGLE_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: model.capabilities.supportsThinking,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: true,
      maxContextWindow: 2097152,
      supportedFeatures: [
        'messages',
        'function_calling',
        'vision',
        'streaming',
        'json_mode',
        'thinking_mode'
      ]
    };
  }

  // Private methods
  private convertTools(tools: any[]): any[] {
    return tools.map(tool => {
      if (tool.type === 'function') {
        return {
          function_declarations: [{
            name: tool.function.name,
            description: tool.function.description,
            parameters: tool.function.parameters
          }]
        };
      }
      return tool;
    });
  }

  private extractToolCalls(response: any): any[] {
    if (!response.functionCalls) return [];

    return response.functionCalls.map((call: any) => ({
      id: call.name + '_' + Date.now(),
      type: 'function',
      function: {
        name: call.name,
        arguments: JSON.stringify(call.args || {})
      }
    }));
  }

  /**
   * Extract search results from Google response
   * Google may include sources in grounding chunks or tool results
   */
  private extractGoogleSources(response: any): SearchResult[] {
    try {
      const sources: SearchResult[] = [];

      // Check for grounding metadata (Google's web search citations)
      if (response.groundingMetadata?.webSearchQueries) {
        const groundingChunks = response.groundingMetadata.groundingChunks || [];
        for (const chunk of groundingChunks) {
          const result = WebSearchUtils.validateSearchResult({
            title: chunk.title || 'Unknown Source',
            url: chunk.web?.uri || chunk.uri,
            date: chunk.publishedDate
          });
          if (result) sources.push(result);
        }
      }

      // Check for function call results (if google_search tool was used)
      const functionCalls = response.functionCalls || [];
      for (const call of functionCalls) {
        if (call.name === 'google_search' && call.response) {
          try {
            const searchData = call.response;
            if (searchData.results && Array.isArray(searchData.results)) {
              const extractedSources = WebSearchUtils.extractSearchResults(searchData.results);
              sources.push(...extractedSources);
            }
          } catch (error) {
            console.warn('[Google] Failed to parse search tool response:', error);
          }
        }
      }

      return sources;
    } catch (error) {
      console.warn('[Google] Failed to extract search sources:', error);
      return [];
    }
  }

  private mapFinishReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'STOP': 'stop',
      'MAX_TOKENS': 'length',
      'SAFETY': 'content_filter',
      'RECITATION': 'content_filter',
      'OTHER': 'stop'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): any {
    const usage = response.usageMetadata || response.usage;
    if (usage) {
      return {
        promptTokens: usage.promptTokenCount || usage.inputTokens || 0,
        completionTokens: usage.candidatesTokenCount || usage.outputTokens || 0,
        totalTokens: usage.totalTokenCount || usage.totalTokens || 0
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = GOOGLE_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/google/GoogleModels.ts

```typescript
/**
 * Google Model Specifications
 * Updated June 17, 2025 with latest Gemini releases
 */

import { ModelSpec } from '../modelTypes';

export const GOOGLE_MODELS: ModelSpec[] = [
  // Gemini 2.5 models (latest)
  {
    provider: 'google',
    name: 'Gemini 2.5 Pro',
    apiName: 'gemini-2.5-pro',
    contextWindow: 2000000,
    maxTokens: 8192,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'google',
    name: 'Gemini 2.5 Flash',
    apiName: 'gemini-2.5-flash',
    contextWindow: 1048576,
    maxTokens: 65536,
    inputCostPerMillion: 0.15,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  }
];

export const GOOGLE_DEFAULT_MODEL = 'gemini-2.5-flash';
```

## services/llm/adapters/groq/GroqAdapter.ts

```typescript
/**
 * Groq Adapter with true streaming support and Ultra-Fast Inference
 * Leverages Groq's high-performance LLM serving infrastructure
 * Uses OpenAI-compatible streaming API with extended usage metrics
 * Based on official Groq SDK streaming documentation
 */

import Groq from 'groq-sdk';
import { BaseAdapter } from '../BaseAdapter';
import { 
  GenerateOptions, 
  StreamChunk, 
  LLMResponse, 
  ModelInfo, 
  ProviderCapabilities,
  ModelPricing
} from '../types';
import { GROQ_MODELS, GROQ_DEFAULT_MODEL } from './GroqModels';
import { MCPToolExecution, MCPCapableAdapter } from '../shared/MCPToolExecution';

export class GroqAdapter extends BaseAdapter implements MCPCapableAdapter {
  readonly name = 'groq';
  readonly baseUrl = 'https://api.groq.com/openai/v1';
  
  private client: Groq;
  mcpConnector?: any;

  constructor(apiKey: string, mcpConnector?: any, model?: string) {
    super(apiKey, model || GROQ_DEFAULT_MODEL);
    
    this.client = new Groq({ 
      apiKey: this.apiKey,
      dangerouslyAllowBrowser: true 
    });
    this.mcpConnector = mcpConnector;
    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || this.currentModel;
      
      // If tools are provided (pre-converted by ChatService), use tool-enabled generation
      if (options?.tools && options.tools.length > 0) {
        console.log('[Groq Adapter] Using tool-enabled generation', {
          toolCount: options.tools.length
        });
        return await this.generateWithProvidedTools(prompt, options);
      }
      
      // Otherwise use basic chat completions
      console.log('[Groq Adapter] Using basic chat completions (no tools)');
      return await this.generateWithChatCompletions(prompt, options);
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      console.log('[GroqAdapter] Starting streaming response');
      
      const stream = await this.client.chat.completions.create({
        model: options?.model || this.currentModel,
        messages: this.buildMessages(prompt, options?.systemPrompt),
        temperature: options?.temperature,
        max_completion_tokens: options?.maxTokens,
        top_p: options?.topP,
        stop: options?.stopSequences,
        tools: options?.tools ? this.convertTools(options.tools) : undefined,
        response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
        stream: true
      });

      let usage: any = undefined;

      for await (const chunk of stream) {
        const content = chunk.choices[0]?.delta?.content;
        
        if (content) {
          yield { content, complete: false };
        }
        
        // Extract usage information if available (typically in the last chunk)
        if ((chunk as any).usage || (chunk as any).x_groq) {
          usage = {
            usage: (chunk as any).usage,
            x_groq: (chunk as any).x_groq
          };
        }
      }

      // Final chunk with usage information
      yield { 
        content: '', 
        complete: true, 
        usage: this.extractUsage(usage) 
      };
      
      console.log('[GroqAdapter] Streaming completed');
    } catch (error) {
      console.error('[GroqAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return GROQ_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: false,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    const baseCapabilities = {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: false,
      maxContextWindow: 128000,
      supportedFeatures: [
        'messages',
        'function_calling',
        'vision',
        'streaming',
        'json_mode',
        'ultra_fast_inference',
        'extended_metrics'
      ]
    };

    // Add MCP support if available
    if (this.supportsMCP()) {
      baseCapabilities.supportedFeatures.push('mcp_integration');
    }

    return baseCapabilities;
  }

  /**
   * Check if MCP is available via connector
   */
  supportsMCP(): boolean {
    return MCPToolExecution.supportsMCP(this);
  }

  /**
   * Generate with pre-converted tools (from ChatService) using centralized execution
   */
  private async generateWithProvidedTools(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    // Use centralized tool execution wrapper to eliminate code duplication
    const model = options?.model || this.currentModel;

    return MCPToolExecution.executeWithToolSupport(
      this,
      'groq',
      {
        model,
        tools: options?.tools || [],
        prompt,
        systemPrompt: options?.systemPrompt
      },
      {
        buildMessages: (prompt: string, systemPrompt?: string) => 
          this.buildMessages(prompt, systemPrompt),
        
        buildRequestBody: (messages: any[], isInitial: boolean) => ({
          model,
          messages,
          tools: options?.tools,
          tool_choice: 'auto',
          temperature: options?.temperature,
          max_completion_tokens: options?.maxTokens,
          top_p: options?.topP,
          stop: options?.stopSequences,
          response_format: options?.jsonMode ? { type: 'json_object' } : undefined
        }),
        
        makeApiCall: async (requestBody: any) => {
          return await this.client.chat.completions.create(requestBody);
        },
        
        extractResponse: async (response: any) => {
          const choice = response.choices[0];
          
          return {
            content: choice?.message?.content || '',
            usage: this.extractUsage(response),
            finishReason: choice?.finish_reason || 'stop',
            toolCalls: choice?.message?.toolCalls,
            choice: choice
          };
        },
        
        buildLLMResponse: async (
          content: string,
          model: string,
          usage?: any,
          metadata?: any,
          finishReason?: any,
          toolCalls?: any[]
        ) => {
          return this.buildLLMResponse(content, model, usage, metadata, finishReason, toolCalls);
        }
      }
    );
  }

  /**
   * Generate using standard chat completions
   */
  private async generateWithChatCompletions(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;
    
    const chatParams: any = {
      model,
      messages: this.buildMessages(prompt, options?.systemPrompt),
      temperature: options?.temperature,
      max_completion_tokens: options?.maxTokens,
      top_p: options?.topP,
      stop: options?.stopSequences,
      response_format: options?.jsonMode ? { type: 'json_object' } : undefined
    };

    // Add tools if provided
    if (options?.tools) {
      chatParams.tools = this.convertTools(options.tools);
    }

    const response = await this.client.chat.completions.create(chatParams);
    const choice = response.choices[0];
    
    if (!choice) {
      throw new Error('No response from Groq');
    }
    
    let text = choice.message?.content || '';
    const usage = this.extractUsage(response);
    let finishReason = choice.finish_reason || 'stop';

    // If tools were provided and we got tool calls, we need to handle them
    // For now, just return the response as-is since tool execution is complex
    if (options?.tools && choice.message?.tool_calls && choice.message.tool_calls.length > 0) {
      console.log(`[Groq Adapter] Received ${choice.message.tool_calls.length} tool calls, but tool execution not implemented in basic mode`);
      text = text || '[AI requested tool calls but tool execution not available]';
    }

    return this.buildLLMResponse(
      text,
      model,
      usage,
      undefined,
      finishReason as any
    );
  }

  // Private methods
  private convertTools(tools: any[]): any[] {
    return tools.map(tool => {
      if (tool.type === 'function' && tool.function) {
        return {
          type: 'function',
          function: {
            name: tool.function.name,
            description: tool.function.description,
            parameters: tool.function.parameters
          }
        };
      }
      return tool;
    });
  }

  private extractToolCalls(message: any): any[] {
    return message?.toolCalls || [];
  }

  private mapFinishReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'stop': 'stop',
      'length': 'length',
      'tool_calls': 'tool_calls',
      'content_filter': 'content_filter'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): any {
    const usage = response?.usage;
    if (usage) {
      return {
        promptTokens: usage.prompt_tokens || 0,
        completionTokens: usage.completion_tokens || 0,
        totalTokens: usage.total_tokens || 0,
        // Groq-specific extended metrics
        queueTime: response?.x_groq?.queue_time,
        promptTime: response?.x_groq?.prompt_time,
        completionTime: response?.x_groq?.completion_time
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = GROQ_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/groq/GroqModels.ts

```typescript
/**
 * Groq Model Specifications
 * Updated June 17, 2025 with latest Groq model releases
 * 
 * Groq provides ultra-fast inference with OpenAI-compatible API
 * Specializes in high-performance LLM serving with extended usage metrics
 */

import { ModelSpec } from '../modelTypes';

export const GROQ_MODELS: ModelSpec[] = [
  // Current Production Models (January 2025)
  
  // Llama 3.1 models - Text generation
  {
    provider: 'groq',
    name: 'Llama 3.1 70B Versatile',
    apiName: 'llama-3.1-70b-versatile',
    contextWindow: 131072,
    maxTokens: 8192,
    inputCostPerMillion: 0.59,
    outputCostPerMillion: 0.79,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'groq',
    name: 'Llama 3.1 8B Instant',
    apiName: 'llama-3.1-8b-instant',
    contextWindow: 131072,
    maxTokens: 8192,
    inputCostPerMillion: 0.05,
    outputCostPerMillion: 0.08,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Llama 3.3 models
  {
    provider: 'groq',
    name: 'Llama 3.3 70B Versatile',
    apiName: 'llama-3.3-70b-versatile',
    contextWindow: 128000,
    maxTokens: 32768,
    inputCostPerMillion: 0.59,
    outputCostPerMillion: 0.79,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Gemma models
  {
    provider: 'groq',
    name: 'Gemma 2 9B IT',
    apiName: 'gemma2-9b-it',
    contextWindow: 8192,
    maxTokens: 8192,
    inputCostPerMillion: 0.20,
    outputCostPerMillion: 0.20,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // New Llama 4 models
  {
    provider: 'groq',
    name: 'Llama 4 Scout',
    apiName: 'llama-4-scout-17bx16e',
    contextWindow: 128000,
    maxTokens: 8192,
    inputCostPerMillion: 0.11,
    outputCostPerMillion: 0.34,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'groq',
    name: 'Llama 4 Maverick',
    apiName: 'llama-4-maverick-17bx128e',
    contextWindow: 128000,
    maxTokens: 8192,
    inputCostPerMillion: 0.20,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Content moderation model
  {
    provider: 'groq',
    name: 'Llama Guard 4 12B',
    apiName: 'meta-llama/llama-guard-4-12b',
    contextWindow: 131072,
    maxTokens: 128,
    inputCostPerMillion: 0.20,
    outputCostPerMillion: 0.20,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // OpenAI models on Groq
  {
    provider: 'groq',
    name: 'GPT OSS 20B',
    apiName: 'openai/gpt-oss-20b',
    contextWindow: 131072,
    maxTokens: 32768,
    inputCostPerMillion: 0.10,
    outputCostPerMillion: 0.50,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'groq',
    name: 'GPT OSS 120B',
    apiName: 'openai/gpt-oss-120b',
    contextWindow: 131072,
    maxTokens: 32766,
    inputCostPerMillion: 0.149,
    outputCostPerMillion: 0.769,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  // Preview models
  {
    provider: 'groq',
    name: 'DeepSeek R1 Distill Llama 70B',
    apiName: 'deepseek-r1-distill-llama-70b',
    contextWindow: 128000,
    maxTokens: 8192,
    inputCostPerMillion: 0.75,
    outputCostPerMillion: 0.99,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'groq',
    name: 'Qwen 3 32B',
    apiName: 'qwen/qwen3-32b',
    contextWindow: 128000,
    maxTokens: 16384,
    inputCostPerMillion: 0.29,
    outputCostPerMillion: 0.59,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  }
];

export const GROQ_DEFAULT_MODEL = 'llama-3.1-70b-versatile';

/**
 * Groq-specific model categories for easier selection
 */
export const GROQ_MODEL_CATEGORIES = {
  // Ultra-fast text generation
  FAST_TEXT: [
    'llama-3.1-8b-instant',
    'gemma2-9b-it'
  ],
  
  // High-quality text generation
  QUALITY_TEXT: [
    'llama-3.1-70b-versatile',
    'llama-3.3-70b-versatile',
    'llama-4-maverick-17bx128e'
  ],
  
  // New Llama 4 models
  LLAMA_4: [
    'llama-4-scout-17bx16e',
    'llama-4-maverick-17bx128e'
  ],
  
  // Reasoning-optimized
  REASONING: [
    'deepseek-r1-distill-llama-70b'
  ],
  
  // Content moderation
  MODERATION: [
    'meta-llama/llama-guard-4-12b'
  ],
  
  // Preview/experimental models
  PREVIEW: [
    'deepseek-r1-distill-llama-70b',
    'qwen/qwen3-32b'
  ]
};

/**
 * Get models by category
 */
export function getGroqModelsByCategory(category: keyof typeof GROQ_MODEL_CATEGORIES): ModelSpec[] {
  const modelNames = GROQ_MODEL_CATEGORIES[category];
  return GROQ_MODELS.filter(model => modelNames.includes(model.apiName));
}

/**
 * Check if a model supports specific capabilities
 */
export function getGroqModelCapabilities(modelName: string): ModelSpec['capabilities'] | null {
  const model = GROQ_MODELS.find(m => m.apiName === modelName);
  return model?.capabilities || null;
}
```

## services/llm/adapters/index.ts

```typescript
/**
 * Adapter exports and factory functions
 * Provides unified access to all LLM providers
 */

export { BaseAdapter } from './BaseAdapter';
export * from './types';

// Provider implementations
export { OpenAIAdapter } from './openai/OpenAIAdapter';
export { GoogleAdapter } from './google/GoogleAdapter';
export { AnthropicAdapter } from './anthropic/AnthropicAdapter';
export { MistralAdapter } from './mistral/MistralAdapter';
export { OpenRouterAdapter } from './openrouter/OpenRouterAdapter';
export { RequestyAdapter } from './requesty/RequestyAdapter';
export { GroqAdapter } from './groq/GroqAdapter';
export { PerplexityAdapter } from './perplexity/PerplexityAdapter';
export { OllamaAdapter } from './ollama/OllamaAdapter';

// Model registry and cost calculation
export * from './modelTypes';
export * from './ModelRegistry';
export * from './CostCalculator';

import { BaseAdapter } from './BaseAdapter';
import { OpenAIAdapter } from './openai/OpenAIAdapter';
import { GoogleAdapter } from './google/GoogleAdapter';
import { AnthropicAdapter } from './anthropic/AnthropicAdapter';
import { MistralAdapter } from './mistral/MistralAdapter';
import { OpenRouterAdapter } from './openrouter/OpenRouterAdapter';
import { RequestyAdapter } from './requesty/RequestyAdapter';
import { GroqAdapter } from './groq/GroqAdapter';
import { PerplexityAdapter } from './perplexity/PerplexityAdapter';
import { OllamaAdapter } from './ollama/OllamaAdapter';
import { SupportedProvider, LLMProviderError } from './types';

/**
 * Factory function to create adapter instances
 * Note: This factory requires environment variables to be set for API keys
 * For direct API key injection, instantiate adapters directly
 */
export function createAdapter(provider: SupportedProvider, model?: string): BaseAdapter {
  switch (provider.toLowerCase()) {
    case 'openai':
      return new OpenAIAdapter(process.env.OPENAI_API_KEY || '');
    case 'google':
    case 'gemini':
      return new GoogleAdapter(process.env.GOOGLE_API_KEY || '', model);
    case 'anthropic':
    case 'claude':
      return new AnthropicAdapter(process.env.ANTHROPIC_API_KEY || '', model);
    case 'mistral':
      return new MistralAdapter(process.env.MISTRAL_API_KEY || '', model);
    case 'openrouter':
      return new OpenRouterAdapter(process.env.OPENROUTER_API_KEY || '', model);
    case 'requesty':
      return new RequestyAdapter(process.env.REQUESTY_API_KEY || '', model);
    case 'groq':
      return new GroqAdapter(process.env.GROQ_API_KEY || '', model);
    case 'perplexity':
      return new PerplexityAdapter(process.env.PERPLEXITY_API_KEY || '', model);
    case 'ollama':
      return new OllamaAdapter(process.env.OLLAMA_URL || 'http://127.0.0.1:11434', model);
    default:
      throw new LLMProviderError(
        `Unsupported provider: ${provider}`,
        'factory',
        'UNSUPPORTED_PROVIDER'
      );
  }
}

/**
 * Get all available providers
 */
export function getAvailableProviders(): SupportedProvider[] {
  return ['openai', 'google', 'anthropic', 'mistral', 'openrouter', 'requesty', 'groq', 'perplexity', 'ollama'];
}

/**
 * Check which providers are available (have API keys)
 */
export async function getAvailableProvidersWithKeys(): Promise<Array<{
  provider: SupportedProvider;
  available: boolean;
  error?: string;
}>> {
  const providers = getAvailableProviders();
  const providerResults: Array<{
    provider: SupportedProvider;
    available: boolean;
    error?: string;
  }> = [];

  for (const provider of providers) {
    try {
      const adapter = createAdapter(provider);
      const available = await adapter.isAvailable();
      providerResults.push({ provider, available });
    } catch (error) {
      providerResults.push({
        provider,
        available: false,
        error: (error as Error).message
      });
    }
  }

  return providerResults;
}

/**
 * Auto-select best available provider based on criteria
 */
export async function selectBestProvider(criteria?: {
  requiresThinking?: boolean;
  requiresImages?: boolean;
  requiresFunctions?: boolean;
  prefersCost?: boolean;
  prefersSpeed?: boolean;
}): Promise<BaseAdapter | null> {
  const availableProviders = await getAvailableProvidersWithKeys();
  const available = availableProviders.filter(p => p.available);

  if (available.length === 0) {
    console.warn('No LLM providers available. Please check your API keys.');
    return null;
  }

  // Score providers based on criteria
  const providerScores = available.map(({ provider }) => {
    const adapter = createAdapter(provider);
    const capabilities = adapter.getCapabilities();
    let score = 1;

    if (criteria?.requiresThinking && capabilities.supportsThinking) score += 3;
    if (criteria?.requiresImages && capabilities.supportsImages) score += 2;
    if (criteria?.requiresFunctions && capabilities.supportsFunctions) score += 1;

    // Performance preferences (subjective weights based on 2025 performance)
    const performanceScores: Record<string, number> = {
      'groq': 6,      // Ultra-fast inference
      'google': 5,    // Gemini 2.5 Flash - best performance/cost
      'anthropic': 4, // Claude 4 - best reasoning
      'openai': 3,    // GPT-4 Turbo - reliable
      'ollama': 3,    // Local models - good performance, no cost
      'mistral': 2,   // Good specialized models
      'openrouter': 1, // Good for variety
      'requesty': 1   // Good for cost optimization
    };

    score += performanceScores[provider] || 0;

    if (criteria?.prefersCost) {
      // Adjust for cost (lower cost = higher score)
      const costScores: Record<string, number> = {
        'ollama': 5,    // Free local models
        'groq': 3,      // Very competitive pricing
        'google': 3,    // Gemini Flash - best value
        'mistral': 2,   // Good pricing
        'requesty': 2,  // Cost optimization
        'openrouter': 1,
        'anthropic': 0, // More expensive
        'openai': 0     // More expensive
      };
      score += costScores[provider] || 0;
    }

    if (criteria?.prefersSpeed) {
      // Adjust for speed
      const speedScores: Record<string, number> = {
        'groq': 5,      // Ultra-fast inference (up to 750 tokens/sec)
        'ollama': 4,    // Local inference - very fast, no network latency
        'google': 3,    // Gemini Flash
        'openai': 2,    // GPT-4 Turbo
        'openrouter': 2,
        'requesty': 2,
        'anthropic': 1, // Slower but higher quality
        'mistral': 1
      };
      score += speedScores[provider] || 0;
    }

    return { provider, score };
  });

  // Sort by score and return the best
  providerScores.sort((a, b) => b.score - a.score);
  const bestResult = providerScores[0];

  if (bestResult?.provider) {
    console.log(`üéØ Auto-selected provider: ${bestResult.provider} (score: ${bestResult.score})`);
    return createAdapter(bestResult.provider);
  }

  return null;
}

/**
 * Provider comparison utility
 */
export interface ProviderComparison {
  provider: SupportedProvider;
  capabilities: ReturnType<BaseAdapter['getCapabilities']>;
  available: boolean;
  models: number;
  maxContext: number;
}

export async function compareProviders(): Promise<ProviderComparison[]> {
  const providers = getAvailableProviders();
  const comparisons: ProviderComparison[] = [];

  for (const provider of providers) {
    try {
      const adapter = createAdapter(provider);
      const available = await adapter.isAvailable();
      const capabilities = adapter.getCapabilities();
      const models = available ? (await adapter.listModels()).length : 0;

      comparisons.push({
        provider,
        capabilities,
        available,
        models,
        maxContext: capabilities.maxContextWindow
      });
    } catch (error) {
      comparisons.push({
        provider,
        capabilities: {
          supportsStreaming: false,
          supportsJSON: false,
          supportsImages: false,
          supportsFunctions: false,
          supportsThinking: false,
          maxContextWindow: 0,
          supportedFeatures: []
        },
        available: false,
        models: 0,
        maxContext: 0
      });
    }
  }

  return comparisons;
}
```

## services/llm/adapters/mistral/MistralAdapter.ts

```typescript
/**
 * Mistral AI Adapter with true streaming support
 * Implements Mistral's native streaming using client.chat.stream()
 * Based on official Mistral TypeScript SDK documentation
 */

import { Mistral } from '@mistralai/mistralai';
import { BaseAdapter } from '../BaseAdapter';
import { 
  GenerateOptions, 
  StreamChunk, 
  LLMResponse, 
  ModelInfo, 
  ProviderCapabilities,
  ModelPricing
} from '../types';
import { MISTRAL_MODELS, MISTRAL_DEFAULT_MODEL } from './MistralModels';
import { MCPToolExecution, MCPCapableAdapter } from '../shared/MCPToolExecution';

export class MistralAdapter extends BaseAdapter implements MCPCapableAdapter {
  readonly name = 'mistral';
  readonly baseUrl = 'https://api.mistral.ai';
  
  private client: Mistral;
  mcpConnector?: any;

  constructor(apiKey: string, mcpConnector?: any, model?: string) {
    super(apiKey, model || MISTRAL_DEFAULT_MODEL);
    
    this.client = new Mistral({ apiKey: this.apiKey });
    this.mcpConnector = mcpConnector;
    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || this.currentModel;
      
      // If tools are provided (pre-converted by ChatService), use tool-enabled generation
      if (options?.tools && options.tools.length > 0) {
        console.log('[Mistral Adapter] Using tool-enabled generation', {
          toolCount: options.tools.length
        });
        return await this.generateWithProvidedTools(prompt, options);
      }
      
      // Otherwise use basic chat completions
      console.log('[Mistral Adapter] Using basic chat completions (no tools)');
      return await this.generateWithChatCompletions(prompt, options);
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      console.log('[MistralAdapter] Starting streaming response');
      
      const result = await this.client.chat.stream({
        model: options?.model || this.currentModel,
        messages: this.buildMessages(prompt, options?.systemPrompt),
        temperature: options?.temperature,
        maxTokens: options?.maxTokens,
        topP: options?.topP,
        stop: options?.stopSequences,
        tools: options?.tools ? this.convertTools(options.tools) : undefined
      });

      let usage: any = undefined;

      for await (const chunk of result) {
        const streamText = chunk.data.choices[0]?.delta?.content;
        
        if (typeof streamText === "string" && streamText) {
          yield { content: streamText, complete: false };
        }

        // Extract usage information if available
        if (chunk.data.usage) {
          usage = chunk.data.usage;
        }
      }

      // Final chunk with usage information
      yield { 
        content: '', 
        complete: true, 
        usage: this.extractUsage({ usage }) 
      };
      
      console.log('[MistralAdapter] Streaming completed');
    } catch (error) {
      console.error('[MistralAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return MISTRAL_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: false,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    const baseCapabilities = {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsThinking: false,
      maxContextWindow: 128000,
      supportedFeatures: [
        'messages',
        'function_calling',
        'streaming',
        'json_mode'
      ]
    };

    // Add MCP support if available
    if (this.supportsMCP()) {
      baseCapabilities.supportedFeatures.push('mcp_integration');
    }

    return baseCapabilities;
  }

  /**
   * Check if MCP is available via connector
   */
  supportsMCP(): boolean {
    return MCPToolExecution.supportsMCP(this);
  }

  /**
   * Generate with pre-converted tools (from ChatService) using centralized execution
   */
  private async generateWithProvidedTools(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    // Use centralized tool execution wrapper to eliminate code duplication
    const model = options?.model || this.currentModel;

    return MCPToolExecution.executeWithToolSupport(
      this,
      'mistral',
      {
        model,
        tools: options?.tools || [],
        prompt,
        systemPrompt: options?.systemPrompt
      },
      {
        buildMessages: (prompt: string, systemPrompt?: string) => 
          this.buildMessages(prompt, systemPrompt),
        
        buildRequestBody: (messages: any[], isInitial: boolean) => ({
          model,
          messages,
          tools: options?.tools ? this.convertTools(options.tools) : undefined,
          toolChoice: 'auto',
          temperature: options?.temperature,
          maxTokens: options?.maxTokens,
          topP: options?.topP,
          stop: options?.stopSequences
        }),
        
        makeApiCall: async (requestBody: any) => {
          return await this.client.chat.complete(requestBody);
        },
        
        extractResponse: async (response: any) => {
          const choice = response.choices[0];
          
          return {
            content: this.extractMessageContent(choice?.message?.content) || '',
            usage: this.extractUsage(response),
            finishReason: choice?.finishReason || 'stop',
            toolCalls: choice?.message?.toolCalls,
            choice: choice
          };
        },
        
        buildLLMResponse: async (
          content: string,
          model: string,
          usage?: any,
          metadata?: any,
          finishReason?: any,
          toolCalls?: any[]
        ) => {
          return this.buildLLMResponse(content, model, usage, metadata, finishReason, toolCalls);
        }
      }
    );
  }

  /**
   * Generate using standard chat completions
   */
  private async generateWithChatCompletions(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;
    
    const chatParams: any = {
      model,
      messages: this.buildMessages(prompt, options?.systemPrompt),
      temperature: options?.temperature,
      maxTokens: options?.maxTokens,
      topP: options?.topP,
      stop: options?.stopSequences
    };

    // Add tools if provided
    if (options?.tools) {
      chatParams.tools = this.convertTools(options.tools);
    }

    const response = await this.client.chat.complete(chatParams);
    const choice = response.choices[0];
    
    if (!choice) {
      throw new Error('No response from Mistral');
    }
    
    let text = this.extractMessageContent(choice.message?.content) || '';
    const usage = this.extractUsage(response);
    let finishReason = choice.finishReason || 'stop';

    // If tools were provided and we got tool calls, we need to handle them
    // For now, just return the response as-is since tool execution is complex
    if (options?.tools && choice.message?.toolCalls && choice.message.toolCalls.length > 0) {
      console.log(`[Mistral Adapter] Received ${choice.message.toolCalls.length} tool calls, but tool execution not implemented in basic mode`);
      text = text || '[AI requested tool calls but tool execution not available]';
    }

    return this.buildLLMResponse(
      text,
      model,
      usage,
      undefined,
      finishReason as any
    );
  }

  // Private methods
  private convertTools(tools: any[]): any[] {
    return tools.map(tool => {
      if (tool.type === 'function' && tool.function) {
        return {
          type: 'function',
          function: {
            name: tool.function.name,
            description: tool.function.description,
            parameters: tool.function.parameters
          }
        };
      }
      return tool;
    });
  }

  private extractToolCalls(message: any): any[] {
    return message?.toolCalls || [];
  }

  private extractMessageContent(content: any): string {
    if (typeof content === 'string') {
      return content;
    }
    if (Array.isArray(content)) {
      return content
        .filter(chunk => chunk.type === 'text')
        .map(chunk => chunk.text || '')
        .join('');
    }
    return '';
  }

  private mapFinishReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'stop': 'stop',
      'length': 'length',
      'tool_calls': 'tool_calls',
      'model_length': 'length',
      'content_filter': 'content_filter'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): any {
    const usage = response.usage;
    if (usage) {
      return {
        promptTokens: usage.prompt_tokens || 0,
        completionTokens: usage.completion_tokens || 0,
        totalTokens: usage.total_tokens || 0
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = MISTRAL_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/mistral/MistralModels.ts

```typescript
/**
 * Mistral Model Specifications
 * Updated June 17, 2025 with latest Mistral releases
 */

import { ModelSpec } from '../modelTypes';

export const MISTRAL_MODELS: ModelSpec[] = [
  {
    provider: 'mistral',
    name: 'Mistral Large Latest',
    apiName: 'mistral-large-latest',
    contextWindow: 128000,
    maxTokens: 8192,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 6.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'mistral',
    name: 'Mistral Medium Latest',
    apiName: 'mistral-medium-latest',
    contextWindow: 128000,
    maxTokens: 8192,
    inputCostPerMillion: 0.40,
    outputCostPerMillion: 2.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'mistral',
    name: 'Mistral Saba',
    apiName: 'mistral-saba-latest',
    contextWindow: 128000,
    maxTokens: 4096,
    inputCostPerMillion: 0.20,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: false,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'mistral',
    name: 'Magistral Medium',
    apiName: 'magistral-medium-latest',
    contextWindow: 40000,
    maxTokens: 40000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 5.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: true
    }
  }
];

export const MISTRAL_DEFAULT_MODEL = 'mistral-large-latest';
```

## services/llm/adapters/modelTypes.ts

```typescript
/**
 * Shared model type definitions
 * Updated June 17, 2025
 */

export interface ModelSpec {
  /** Provider name (openai, google, anthropic, etc.) */
  provider: string;
  /** Human-readable model name */
  name: string;
  /** API identifier used in requests */
  apiName: string;
  /** Context window size in tokens */
  contextWindow: number;
  /** Maximum output tokens */
  maxTokens: number;
  /** Input cost per million tokens in USD */
  inputCostPerMillion: number;
  /** Output cost per million tokens in USD */
  outputCostPerMillion: number;
  /** Model capabilities */
  capabilities: {
    supportsJSON: boolean;
    supportsImages: boolean;
    supportsFunctions: boolean;
    supportsStreaming: boolean;
    supportsThinking: boolean;
  };
}
```

## services/llm/adapters/ollama/OllamaAdapter.ts

```typescript
/**
 * Ollama LLM Adapter
 * Provides local, privacy-focused LLM models via Ollama
 * Local LLM provider for text generation
 */

import { BaseAdapter } from '../BaseAdapter';
import { 
  GenerateOptions, 
  StreamChunk, 
  LLMResponse, 
  ModelInfo, 
  ProviderCapabilities,
  ModelPricing,
  TokenUsage,
  LLMProviderError
} from '../types';

export class OllamaAdapter extends BaseAdapter {
  readonly name = 'ollama';
  readonly baseUrl: string;
  
  private ollamaUrl: string;

  constructor(ollamaUrl = 'http://127.0.0.1:11434', defaultModel = 'llama3.1') {
    // Ollama doesn't need an API key - set requiresApiKey to false
    super('', defaultModel, ollamaUrl, false);
    
    this.ollamaUrl = ollamaUrl;
    this.baseUrl = ollamaUrl;
    
    this.initializeCache();
  }

  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    // Non-streaming fallback - call regular generate() and yield as single chunk
    const result = await this.generate(prompt, options);
    yield { content: result.text || '', complete: true, usage: result.usage };
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || this.currentModel;
      
      const requestBody: any = {
        model: model,
        prompt: prompt,
        stream: false,
        options: {
          temperature: options?.temperature,
          num_predict: options?.maxTokens,
          stop: options?.stopSequences,
          top_p: options?.topP,
          frequency_penalty: options?.frequencyPenalty,
          presence_penalty: options?.presencePenalty
        }
      };

      // Remove undefined values
      Object.keys(requestBody.options).forEach(key => {
        if (requestBody.options[key] === undefined) {
          delete requestBody.options[key];
        }
      });

      const response = await fetch(`${this.ollamaUrl}/api/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new LLMProviderError(
          `Ollama API error: ${response.status} ${response.statusText} - ${errorText}`,
          'generation',
          'API_ERROR'
        );
      }

      const data = await response.json();

      if (!data.response) {
        throw new LLMProviderError(
          'Invalid response format from Ollama API: missing response field',
          'generation',
          'INVALID_RESPONSE'
        );
      }

      // Extract usage information
      const usage: TokenUsage = {
        promptTokens: data.prompt_eval_count || 0,
        completionTokens: data.eval_count || 0,
        totalTokens: (data.prompt_eval_count || 0) + (data.eval_count || 0)
      };

      const finishReason = data.done ? 'stop' : 'length';
      const metadata = {
        cached: false,
        modelDetails: data.model,
        totalDuration: data.total_duration,
        loadDuration: data.load_duration,
        promptEvalDuration: data.prompt_eval_duration,
        evalDuration: data.eval_duration
      };

      return await this.buildLLMResponse(
        data.response,
        model,
        usage,
        metadata,
        finishReason
      );
    } catch (error) {
      if (error instanceof LLMProviderError) {
        throw error;
      }
      throw new LLMProviderError(
        `Ollama generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'generation',
        'NETWORK_ERROR'
      );
    }
  }

  async generateStream(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || this.currentModel;
      
      const requestBody: any = {
        model: model,
        prompt: prompt,
        stream: true,
        options: {
          temperature: options?.temperature,
          num_predict: options?.maxTokens,
          stop: options?.stopSequences,
          top_p: options?.topP
        }
      };

      // Remove undefined values
      Object.keys(requestBody.options).forEach(key => {
        if (requestBody.options[key] === undefined) {
          delete requestBody.options[key];
        }
      });

      const response = await fetch(`${this.ollamaUrl}/api/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new LLMProviderError(
          `Ollama API error: ${response.status} ${response.statusText} - ${errorText}`,
          'streaming',
          'API_ERROR'
        );
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new LLMProviderError(
          'No response body available for streaming',
          'streaming',
          'NO_RESPONSE_BODY'
        );
      }

      let fullText = '';
      let usage: TokenUsage = {
        promptTokens: 0,
        completionTokens: 0,
        totalTokens: 0
      };
      let finishReason: 'stop' | 'length' = 'stop';
      let metadata: Record<string, any> = {};

      try {
        const decoder = new TextDecoder();
        
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) break;
          
          const chunk = decoder.decode(value);
          const lines = chunk.split('\n').filter(line => line.trim());
          
          for (const line of lines) {
            try {
              const data = JSON.parse(line);
              
              if (data.response) {
                fullText += data.response;
                // Token callback removed - use generateStreamAsync for streaming
              }
              
              if (data.done) {
                usage = {
                  promptTokens: data.prompt_eval_count || 0,
                  completionTokens: data.eval_count || 0,
                  totalTokens: (data.prompt_eval_count || 0) + (data.eval_count || 0)
                };
                
                metadata = {
                  modelDetails: data.model,
                  totalDuration: data.total_duration,
                  loadDuration: data.load_duration,
                  promptEvalDuration: data.prompt_eval_duration,
                  evalDuration: data.eval_duration
                };
                
                finishReason = 'stop';
                break;
              }
            } catch (parseError) {
              // Skip invalid JSON lines
              continue;
            }
          }
        }
      } finally {
        reader.releaseLock();
      }

      const result: LLMResponse = {
        text: fullText,
        model: model,
        provider: this.name,
        usage: usage,
        cost: {
          inputCost: 0, // Local models are free
          outputCost: 0,
          totalCost: 0,
          currency: 'USD',
          rateInputPerMillion: 0,
          rateOutputPerMillion: 0
        },
        finishReason: finishReason,
        metadata: {
          ...metadata,
          cached: false,
          streamed: true
        }
      };

      // Completion callback removed - use generateStreamAsync for streaming
      return result;
    } catch (error) {
      const errorObj = error instanceof Error ? error : new Error('Unknown streaming error');
      // Error callback removed - use generateStreamAsync for streaming
      
      if (error instanceof LLMProviderError) {
        throw error;
      }
      throw new LLMProviderError(
        `Ollama streaming failed: ${errorObj.message}`,
        'streaming',
        'NETWORK_ERROR'
      );
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    // Only return the configured model, not all available models
    // This ensures the UI only shows the model the user specifically configured
    return [{
      id: this.currentModel,
      name: this.currentModel,
      contextWindow: this.estimateContextWindow(this.currentModel),
      supportsStreaming: true,
      supportsJSON: false, // Ollama doesn't have built-in JSON mode
      supportsImages: this.currentModel.includes('vision') || this.currentModel.includes('llava'),
      supportsFunctions: false,
      supportsThinking: false,
      pricing: {
        inputPerMillion: 0, // Local models are free
        outputPerMillion: 0,
        currency: 'USD',
        lastUpdated: new Date().toISOString()
      }
    }];
  }

  getCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: true,
      supportsJSON: false, // Ollama doesn't have built-in JSON mode
      supportsImages: false, // Depends on specific model
      supportsFunctions: false,
      supportsThinking: false,
      maxContextWindow: 128000, // Varies by model, this is a reasonable default
      supportedFeatures: ['streaming', 'local', 'privacy']
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    console.log('OllamaAdapter: getModelPricing called for model:', modelId);
    
    // Local models are free - zero rates
    const pricing: ModelPricing = {
      rateInputPerMillion: 0,
      rateOutputPerMillion: 0,
      currency: 'USD'
    };
    
    console.log('OllamaAdapter: returning free pricing:', pricing);
    return pricing;
  }

  async isAvailable(): Promise<boolean> {
    try {
      const response = await fetch(`${this.ollamaUrl}/api/tags`, {
        method: 'GET'
      });
      return response.ok;
    } catch (error) {
      return false;
    }
  }

  // Utility methods
  private formatSize(bytes: number): string {
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    if (bytes === 0) return '0 B';
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
  }

  private estimateContextWindow(modelName: string): number {
    // Rough estimates based on common Ollama models
    if (modelName.includes('llama3.1')) return 128000;
    if (modelName.includes('llama3')) return 8192;
    if (modelName.includes('llama2')) return 4096;
    if (modelName.includes('mistral')) return 32768;
    if (modelName.includes('codellama')) return 16384;
    if (modelName.includes('gemma')) return 8192;
    if (modelName.includes('qwen')) return 32768;
    if (modelName.includes('phi')) return 4096;
    
    // Default reasonable estimate
    return 8192;
  }

  protected buildMessages(prompt: string, systemPrompt?: string): any[] {
    const messages = [];
    
    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }
    
    messages.push({ role: 'user', content: prompt });
    
    return messages;
  }

  protected handleError(error: any, operation: string): never {
    if (error instanceof LLMProviderError) {
      throw error;
    }

    let message = `Ollama ${operation} failed`;
    let code = 'UNKNOWN_ERROR';

    if (error?.message) {
      message += `: ${error.message}`;
    }

    if (error?.code === 'ECONNREFUSED') {
      message = 'Cannot connect to Ollama server. Make sure Ollama is running.';
      code = 'CONNECTION_REFUSED';
    } else if (error?.code === 'ENOTFOUND') {
      message = 'Ollama server not found. Check the URL configuration.';
      code = 'SERVER_NOT_FOUND';
    }

    throw new LLMProviderError(message, this.name, code, error);
  }
}
```

## services/llm/adapters/ollama/OllamaModels.ts

```typescript
/**
 * Ollama Model Definitions
 * Common models available through Ollama
 * Models are pulled on-demand, so this is a reference list
 */

import { ModelSpec } from '../modelTypes';

export const OLLAMA_MODELS: ModelSpec[] = [
  // Popular Llama models
  {
    provider: 'ollama',
    name: 'Llama 3.1 8B',
    apiName: 'llama3.1:8b',
    contextWindow: 128000,
    maxTokens: 4096,
    inputCostPerMillion: 0,
    outputCostPerMillion: 0,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'ollama',
    name: 'Llama 3.1 70B',
    apiName: 'llama3.1:70b',
    contextWindow: 128000,
    maxTokens: 4096,
    inputCostPerMillion: 0,
    outputCostPerMillion: 0,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'ollama',
    name: 'Llama 3 8B',
    apiName: 'llama3:8b',
    contextWindow: 8192,
    maxTokens: 4096,
    inputCostPerMillion: 0,
    outputCostPerMillion: 0,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  // Mistral models
  {
    provider: 'ollama',
    name: 'Mistral 7B',
    apiName: 'mistral:7b',
    contextWindow: 32768,
    maxTokens: 4096,
    inputCostPerMillion: 0,
    outputCostPerMillion: 0,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'ollama',
    name: 'Mixtral 8x7B',
    apiName: 'mixtral:8x7b',
    contextWindow: 32768,
    maxTokens: 4096,
    inputCostPerMillion: 0,
    outputCostPerMillion: 0,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  // Code models
  {
    provider: 'ollama',
    name: 'Code Llama 7B',
    apiName: 'codellama:7b',
    contextWindow: 16384,
    maxTokens: 4096,
    inputCostPerMillion: 0,
    outputCostPerMillion: 0,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  // Vision models
  {
    provider: 'ollama',
    name: 'LLaVA 7B',
    apiName: 'llava:7b',
    contextWindow: 4096,
    maxTokens: 4096,
    inputCostPerMillion: 0,
    outputCostPerMillion: 0,
    capabilities: {
      supportsJSON: false,
      supportsImages: true,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  // Other popular models
  {
    provider: 'ollama',
    name: 'Gemma 7B',
    apiName: 'gemma:7b',
    contextWindow: 8192,
    maxTokens: 4096,
    inputCostPerMillion: 0,
    outputCostPerMillion: 0,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'ollama',
    name: 'Phi-3 Mini',
    apiName: 'phi3:3.8b',
    contextWindow: 128000,
    maxTokens: 4096,
    inputCostPerMillion: 0,
    outputCostPerMillion: 0,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  }
];

// Default model for Ollama
export const OLLAMA_DEFAULT_MODEL = 'llama3.1:8b';

// Get recommended models
export function getRecommendedOllamaModels(): ModelSpec[] {
  return OLLAMA_MODELS.filter(model => 
    ['llama3.1:8b', 'mistral:7b', 'codellama:7b', 'gemma:7b', 'phi3:3.8b'].includes(model.apiName)
  );
}

// Get models with vision capabilities
export function getVisionOllamaModels(): ModelSpec[] {
  return OLLAMA_MODELS.filter(model => model.capabilities.supportsImages);
}

// Get code-specialized models
export function getCodeOllamaModels(): ModelSpec[] {
  return OLLAMA_MODELS.filter(model => 
    model.apiName.includes('codellama') || model.apiName.includes('code')
  );
}
```

## services/llm/adapters/openai/DeepResearchHandler.ts

```typescript
/**
 * OpenAI Deep Research Handler
 * Handles deep research models that use the Responses API
 * Separate from streaming chat functionality
 */

import OpenAI from 'openai';
import { GenerateOptions, LLMResponse, TokenUsage } from '../types';
import { LLMProviderError } from '../types';

export class DeepResearchHandler {
  constructor(private client: OpenAI) {}

  /**
   * Check if a model is a deep research model
   */
  isDeepResearchModel(model: string): boolean {
    return model.includes('deep-research');
  }

  /**
   * Generate response using deep research model
   */
  async generate(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || 'sonar-deep-research';
    
    console.log(`[DeepResearchHandler] Starting deep research for model: ${model}`);
    
    // Build input format for Deep Research API
    const input: any[] = [];
    
    // Add system message if provided
    if (options?.systemPrompt) {
      input.push({
        role: 'developer',
        content: [{ type: 'input_text', text: options.systemPrompt }]
      });
    }
    
    // Add user message
    input.push({
      role: 'user', 
      content: [{ type: 'input_text', text: prompt }]
    });

    const requestParams: any = {
      model,
      input,
      reasoning: { summary: 'auto' },
      tools: [{ type: 'web_search_preview' }], // Default tool for deep research
      background: true // Enable async processing
    };

    // Add optional tools if specified
    if (options?.tools && options.tools.length > 0) {
      // Convert tools to Deep Research API format
      const drTools = options.tools.map(tool => {
        if (tool.type === 'function') {
          return { type: 'code_interpreter', container: { type: 'auto', file_ids: [] } };
        }
        return { type: tool.type };
      });
      requestParams.tools = [...requestParams.tools, ...drTools];
    }

    try {
      // Submit the deep research request
      const response = await (this.client as any).responses.create(requestParams);
      
      // Poll for completion if response is not immediately ready
      let finalResponse = response;
      if (response.status === 'in_progress' || !this.isComplete(response)) {
        finalResponse = await this.pollForCompletion(response.id, model);
      }

      // Extract the final report from the output array
      return this.parseResponse(finalResponse, model);
    } catch (error) {
      console.error(`[DeepResearchHandler] Deep research failed for ${model}:`, error);
      throw new LLMProviderError(
        `Deep research generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'openai',
        'DEEP_RESEARCH_ERROR',
        error instanceof Error ? error : undefined
      );
    }
  }

  /**
   * Check if deep research response is complete
   */
  private isComplete(response: any): boolean {
    return response.output && 
           response.output.length > 0 && 
           response.output.some((item: any) => 
             item.type === 'message' && 
             item.content && 
             item.content.length > 0 &&
             item.content[0].text
           );
  }

  /**
   * Poll for deep research completion
   */
  private async pollForCompletion(responseId: string, model: string, maxWaitTime = 300000): Promise<any> {
    const startTime = Date.now();
    const pollInterval = model.includes('o4-mini') ? 2000 : 5000; // Faster polling for mini model
    
    console.log(`[DeepResearchHandler] Polling for completion of ${responseId} with ${pollInterval}ms intervals`);
    
    while (Date.now() - startTime < maxWaitTime) {
      try {
        const response = await (this.client as any).responses.retrieve(responseId);
        
        if (response.status === 'completed' || this.isComplete(response)) {
          console.log(`[DeepResearchHandler] Deep research completed after ${Date.now() - startTime}ms`);
          return response;
        }
        
        if (response.status === 'failed' || response.status === 'expired') {
          throw new Error(`Deep research ${response.status}: ${response.error || 'Unknown error'}`);
        }
        
        console.log(`[DeepResearchHandler] Deep research in progress... (${response.status})`);
        await new Promise(resolve => setTimeout(resolve, pollInterval));
        
      } catch (error) {
        if (error instanceof Error && error.message.includes('Deep research')) {
          throw error; // Re-throw deep research specific errors
        }
        console.warn(`[DeepResearchHandler] Polling error:`, error);
        await new Promise(resolve => setTimeout(resolve, pollInterval));
      }
    }
    
    throw new Error(`Deep research timed out after ${maxWaitTime}ms`);
  }

  /**
   * Parse deep research response structure
   */
  private parseResponse(response: any, model: string): LLMResponse {
    if (!response.output || response.output.length === 0) {
      throw new Error('No output received from deep research');
    }

    // Find the final message in the output array
    const finalOutput = response.output[response.output.length - 1];
    
    if (finalOutput.type !== 'message' || !finalOutput.content || finalOutput.content.length === 0) {
      throw new Error('Invalid deep research response structure');
    }

    const content = finalOutput.content[0];
    const text = content.text || '';
    const annotations = content.annotations || [];

    // Extract usage information if available
    let usage: TokenUsage | undefined;
    const usageOutput = response.output.find((item: any) => item.usage);
    if (usageOutput) {
      usage = {
        promptTokens: usageOutput.usage.prompt_tokens || usageOutput.usage.input_tokens || 0,
        completionTokens: usageOutput.usage.completion_tokens || usageOutput.usage.output_tokens || 0,
        totalTokens: usageOutput.usage.total_tokens || 0
      };
    }

    // Build metadata with citations
    const metadata: Record<string, any> = {
      deepResearch: true,
      citations: annotations.map((annotation: any) => ({
        title: annotation.title,
        url: annotation.url,
        startIndex: annotation.start_index,
        endIndex: annotation.end_index
      })),
      intermediateSteps: response.output.length - 1, // Number of intermediate processing steps
      processingTime: response.metadata?.processing_time_ms
    };

    return {
      text,
      model,
      provider: 'openai',
      usage,
      metadata,
      finishReason: 'stop' // Deep research always completes normally
    };
  }
}
```

## services/llm/adapters/openai/OpenAIAdapter.ts

```typescript
/**
 * OpenAI Adapter - Clean implementation focused on streaming
 * Supports both regular chat completions and deep research models
 */

import OpenAI from 'openai';
import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  SearchResult
} from '../types';
import { ModelRegistry } from '../ModelRegistry';
import { DeepResearchHandler } from './DeepResearchHandler';
import { MCPToolExecution, MCPCapableAdapter } from '../shared/MCPToolExecution';
import { WebSearchUtils } from '../../utils/WebSearchUtils';

export class OpenAIAdapter extends BaseAdapter implements MCPCapableAdapter {
  readonly name = 'openai';
  readonly baseUrl = 'https://api.openai.com/v1';
  
  private client: OpenAI;
  private deepResearch: DeepResearchHandler;
  mcpConnector?: any;

  constructor(apiKey: string, mcpConnector?: any) {
    super(apiKey, 'gpt-5');
    
    this.client = new OpenAI({
      apiKey: this.apiKey,
      dangerouslyAllowBrowser: true, // Required for Obsidian plugin environment
    });
    
    this.deepResearch = new DeepResearchHandler(this.client);
    this.mcpConnector = mcpConnector;
    this.initializeCache();
    
    // MCP connector will be provided via constructor
  }

  /**
   * Generate response without caching
   */
  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      // Validate web search support
      if (options?.webSearch) {
        WebSearchUtils.validateWebSearchRequest('openai', options.webSearch);
      }

      const model = options?.model || this.currentModel;

      // Route deep research models to specialized handler
      if (this.deepResearch.isDeepResearchModel(model)) {
        return await this.deepResearch.generate(prompt, options);
      }

      // If web search is requested, add web search tool
      if (options?.webSearch) {
        const webSearchTool = {
          type: 'web_search' as const
        };
        const toolsWithWebSearch = [...(options.tools || []), webSearchTool];
        return await this.generateWithProvidedTools(prompt, { ...options, tools: toolsWithWebSearch });
      }

      // If tools are provided (pre-converted by ChatService), use tool-enabled generation
      if (options?.tools && options.tools.length > 0) {
        console.log('[OpenAI Adapter] Using tool-enabled generation', {
          toolCount: options.tools.length
        });
        return await this.generateWithProvidedTools(prompt, options);
      }

      // Otherwise use basic chat completions
      console.log('[OpenAI Adapter] Using basic chat completions (no tools)');
      return await this.generateWithChatCompletions(prompt, options);
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  /**
   * Generate streaming response using async generator
   */
  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      const model = options?.model || this.currentModel;
      

      // Deep research models cannot be used in streaming chat
      if (this.deepResearch.isDeepResearchModel(model)) {
        throw new Error(`Deep research models (${model}) cannot be used in streaming chat. Please select a different model for real-time conversations.`);
      }

      // Build streaming parameters
      const streamParams: any = {
        model,
        messages: this.buildMessages(prompt, options?.systemPrompt),
        stream: true
      };

      // Add optional parameters
      if (options?.temperature !== undefined) streamParams.temperature = options.temperature;
      if (options?.maxTokens !== undefined) streamParams.max_tokens = options.maxTokens;
      if (options?.jsonMode) streamParams.response_format = { type: 'json_object' };
      if (options?.stopSequences) streamParams.stop = options.stopSequences;
      if (options?.tools) streamParams.tools = options.tools;
      if (options?.topP !== undefined) streamParams.top_p = options.topP;
      if (options?.frequencyPenalty !== undefined) streamParams.frequency_penalty = options.frequencyPenalty;
      if (options?.presencePenalty !== undefined) streamParams.presence_penalty = options.presencePenalty;

      console.log(`[OpenAIAdapter] Creating stream with params:`, { ...streamParams, messages: '[hidden]' });
      
      // Create OpenAI stream  
      const stream = await this.client.chat.completions.create(streamParams) as any;

      let tokenCount = 0;
      let usage: any = undefined;
      let finishReason: 'stop' | 'length' | 'tool_calls' | 'content_filter' = 'stop';

      // Stream tokens as they arrive
      for await (const chunk of stream) {
        const delta = chunk.choices[0]?.delta?.content || '';
        
        if (delta) {
          tokenCount++;
          
          // Yield each token immediately
          yield { 
            content: delta, 
            complete: false
          };
        }
        
        // Capture usage info when available
        if (chunk.usage) {
          usage = chunk.usage;
        }

        // Capture finish reason
        if (chunk.choices[0]?.finish_reason) {
          const reason = chunk.choices[0].finish_reason;
          if (reason === 'stop' || reason === 'length' || reason === 'tool_calls' || reason === 'content_filter') {
            finishReason = reason;
          }
        }
      }

      
      // Yield final completion with usage info
      const extractedUsage = this.extractUsage({ usage });
      yield { 
        content: '', 
        complete: true, 
        usage: extractedUsage 
      };

    } catch (error) {
      console.error('[OpenAIAdapter] Streaming error:', error);
      throw this.handleError(error, 'streaming generation');
    }
  }

  /**
   * Generate with pre-converted tools (from ChatService) using centralized execution
   */
  private async generateWithProvidedTools(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    // Use centralized tool execution wrapper to eliminate code duplication
    const model = options?.model || this.currentModel;

    return MCPToolExecution.executeWithToolSupport(
      this,
      'openai',
      {
        model,
        tools: options?.tools || [],
        prompt,
        systemPrompt: options?.systemPrompt
      },
      {
        buildMessages: (prompt: string, systemPrompt?: string) => 
          this.buildMessages(prompt, systemPrompt),
        
        buildRequestBody: (messages: any[], isInitial: boolean) => {
          const chatParams: any = {
            model,
            messages,
            tools: options?.tools,
            tool_choice: 'auto'
          };

          // Add optional parameters
          if (options?.temperature !== undefined) chatParams.temperature = options.temperature;
          if (options?.maxTokens !== undefined) chatParams.max_tokens = options.maxTokens;
          if (options?.jsonMode) chatParams.response_format = { type: 'json_object' };
          if (options?.stopSequences) chatParams.stop = options.stopSequences;
          if (options?.topP !== undefined) chatParams.top_p = options.topP;
          if (options?.frequencyPenalty !== undefined) chatParams.frequency_penalty = options.frequencyPenalty;
          if (options?.presencePenalty !== undefined) chatParams.presence_penalty = options.presencePenalty;

          return chatParams;
        },
        
        makeApiCall: async (requestBody: any) => {
          return await this.client.chat.completions.create(requestBody);
        },
        
        extractResponse: async (response: any) => {
          const choice = response.choices[0];
          
          return {
            content: choice?.message?.content || '',
            usage: this.extractUsage({ usage: response.usage }),
            finishReason: choice?.finish_reason || 'stop',
            toolCalls: choice?.message?.toolCalls,
            choice: choice
          };
        },
        
        buildLLMResponse: async (
          content: string,
          model: string,
          usage?: any,
          metadata?: any,
          finishReason?: any,
          toolCalls?: any[]
        ) => {
          return this.buildLLMResponse(content, model, usage, metadata, finishReason, toolCalls);
        }
      }
    );
  }

  /**
   * Generate using standard chat completions
   */
  private async generateWithChatCompletions(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;
    
    const chatParams: any = {
      model,
      messages: this.buildMessages(prompt, options?.systemPrompt)
    };

    // Add optional parameters
    if (options?.temperature !== undefined) chatParams.temperature = options.temperature;
    if (options?.maxTokens !== undefined) chatParams.max_tokens = options.maxTokens;
    if (options?.jsonMode) chatParams.response_format = { type: 'json_object' };
    if (options?.stopSequences) chatParams.stop = options.stopSequences;
    if (options?.tools) chatParams.tools = options.tools;
    if (options?.topP !== undefined) chatParams.top_p = options.topP;
    if (options?.frequencyPenalty !== undefined) chatParams.frequency_penalty = options.frequencyPenalty;
    if (options?.presencePenalty !== undefined) chatParams.presence_penalty = options.presencePenalty;

    const response = await this.client.chat.completions.create(chatParams);
    const choice = response.choices[0];
    
    if (!choice) {
      throw new Error('No response from OpenAI');
    }
    
    let text = choice.message?.content || '';
    const usage = this.extractUsage({ usage: response.usage });
    let finishReason = choice.finish_reason || 'stop';

    // If tools were provided and we got tool calls, we need to handle them
    // For now, just return the response as-is since tool execution is complex
    // TODO: Implement proper tool call execution if needed
    if (options?.tools && choice.message?.tool_calls && choice.message.tool_calls.length > 0) {
      console.log(`[OpenAI Adapter] Received ${choice.message.tool_calls.length} tool calls, but tool execution not implemented in basic mode`);
      text = text || '[AI requested tool calls but tool execution not available]';
    }

    return this.buildLLMResponse(
      text,
      model,
      usage,
      undefined,
      finishReason as any
    );
  }

  /**
   * Extract search results from OpenAI response
   * OpenAI may include sources in annotations or tool results
   */
  private extractOpenAISources(response: any): SearchResult[] {
    try {
      const sources: SearchResult[] = [];

      // Check for annotations (if OpenAI includes web sources)
      const annotations = response.choices?.[0]?.message?.annotations || [];
      for (const annotation of annotations) {
        if (annotation.type === 'url_citation' || annotation.type === 'citation') {
          const result = WebSearchUtils.validateSearchResult({
            title: annotation.title || annotation.text || 'Unknown Source',
            url: annotation.url,
            date: annotation.date || annotation.timestamp
          });
          if (result) sources.push(result);
        }
      }

      // Check for tool calls with web search results
      const toolCalls = response.choices?.[0]?.message?.toolCalls || [];
      for (const toolCall of toolCalls) {
        if (toolCall.function?.name === 'web_search' && toolCall.result) {
          try {
            const searchResult = JSON.parse(toolCall.result);
            if (searchResult.sources && Array.isArray(searchResult.sources)) {
              const extractedSources = WebSearchUtils.extractSearchResults(searchResult.sources);
              sources.push(...extractedSources);
            }
          } catch (error) {
            console.warn('[OpenAI] Failed to parse web search tool result:', error);
          }
        }
      }

      return sources;
    } catch (error) {
      console.warn('[OpenAI] Failed to extract search sources:', error);
      return [];
    }
  }

  /**
   * List available models
   */
  async listModels(): Promise<ModelInfo[]> {
    try {
      // Use centralized model registry instead of API call
      const openaiModels = ModelRegistry.getProviderModels('openai');
      return openaiModels.map(model => ModelRegistry.toModelInfo(model));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }


  /**
   * Check if MCP is available via connector
   */
  supportsMCP(): boolean {
    return MCPToolExecution.supportsMCP(this);
  }


  /**
   * Get provider capabilities
   */
  getCapabilities(): ProviderCapabilities {
    const baseCapabilities = {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: true,
      supportsImageGeneration: true,
      maxContextWindow: 2000000, // GPT-5 context window
      supportedFeatures: [
        'streaming',
        'json_mode',
        'function_calling',
        'image_input',
        'image_generation',
        'thinking_models',
        'deep_research'
      ]
    };

    // Add MCP support if available
    if (this.supportsMCP()) {
      baseCapabilities.supportedFeatures.push('mcp_integration');
    }

    return baseCapabilities;
  }

  /**
   * Get model pricing
   */
  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    try {
      const models = ModelRegistry.getProviderModels('openai');
      const model = models.find(m => m.apiName === modelId);
      if (!model) {
        return null;
      }

      return {
        rateInputPerMillion: model.inputCostPerMillion,
        rateOutputPerMillion: model.outputCostPerMillion,
        currency: 'USD'
      };
    } catch (error) {
      console.warn(`Failed to get pricing for model ${modelId}:`, error);
      return null;
    }
  }
}
```

## services/llm/adapters/openai/OpenAIImageAdapter.ts

```typescript
/**
 * OpenAI Image Generation Adapter
 * Supports OpenAI's gpt-image-1 model via Responses API for image generation
 * Based on 2025 API documentation
 */

import OpenAI from 'openai';
import { BaseImageAdapter } from '../BaseImageAdapter';
import { 
  ImageGenerationParams, 
  ImageGenerationResponse, 
  ImageValidationResult,
  ImageModel,
  ImageUsage
} from '../../types/ImageTypes';
import { 
  ProviderConfig,
  ProviderCapabilities,
  ModelInfo,
  CostDetails
} from '../types';

export class OpenAIImageAdapter extends BaseImageAdapter {
  
  // Image adapters don't support streaming in the same way as text
  async* generateStreamAsync(): AsyncGenerator<never, void, unknown> {
    // Image generation is not streamable - it's a single result
    // This method should not be called for image adapters
    throw new Error('Image generation does not support streaming');
  }
  
  readonly name = 'openai-image';
  readonly baseUrl = 'https://api.openai.com/v1';
  readonly supportedModels: ImageModel[] = ['gpt-image-1'];
  readonly supportedSizes: string[] = ['1024x1024', '1536x1024', '1024x1536', 'auto'];
  readonly supportedFormats: string[] = ['png'];
  
  private client: OpenAI;
  private readonly imageModel = 'gpt-image-1'; // Use gpt-image-1 via Responses API

  constructor(config?: ProviderConfig) {
    const apiKey = config?.apiKey || '';
    super(apiKey, 'gpt-image-1', config?.baseUrl);
    
    this.client = new OpenAI({
      apiKey: apiKey,
      organization: process.env.OPENAI_ORG_ID,
      project: process.env.OPENAI_PROJECT_ID,
      baseURL: config?.baseUrl || this.baseUrl,
      dangerouslyAllowBrowser: true // Required for Obsidian plugin environment
    });

    this.initializeCache();
  }

  /**
   * Generate images using OpenAI's gpt-image-1 model via Responses API
   */
  async generateImage(params: ImageGenerationParams): Promise<ImageGenerationResponse> {
    try {
      this.validateConfiguration();
      
      console.log(`[OpenAI] Generating image with model: ${this.imageModel}, size: ${params.size || '1024x1024'}`);
      
      const response = await this.withRetry(async () => {
        // Use a supported model for Responses API (gpt-4.1 supports image_generation tool)
        const requestParams = {
          model: 'gpt-4.1', // Model that supports image_generation tool
          input: params.prompt,
          tools: [{
            type: 'image_generation' as const,
            size: params.size as 'auto' | '1024x1024' | '1536x1024' | '1024x1536' || '1024x1024'
            // quality and background removed - not in new interface
          }]
        };

        console.log(`[OpenAI] Sending request to OpenAI Responses API with gpt-image-1...`);
        const startTime = Date.now();
        
        const result = await this.client.responses.create(requestParams);
        
        const requestTime = Date.now() - startTime;
        console.log(`[OpenAI] Responses API request completed in ${requestTime}ms`);
        
        return result;
      }, 2); // Reduced retry count for faster failure detection

      return await this.buildImageResponse(response, params);
    } catch (error) {
      this.handleImageError(error, 'image generation', params);
    }
  }

  /**
   * Validate OpenAI-specific image generation parameters
   */
  validateImageParams(params: ImageGenerationParams): ImageValidationResult {
    // Start with common validation
    const baseValidation = this.validateCommonParams(params);
    if (!baseValidation.isValid) {
      return baseValidation;
    }

    const errors: string[] = [...baseValidation.errors];
    const warnings: string[] = [...(baseValidation.warnings || [])];
    const adjustedParams: Partial<ImageGenerationParams> = {};

    // Validate prompt length (gpt-image-1 has a 32,000 character limit)
    if (params.prompt.length > 32000) {
      errors.push('Prompt too long (max 32,000 characters for gpt-image-1)');
    }

    // Validate model - only gpt-image-1 supported
    if (params.model && params.model !== 'gpt-image-1') {
      errors.push('Only gpt-image-1 model is supported for OpenAI');
    }

    // Size validation for gpt-image-1
    if (params.size) {
      const validSizes = ['1024x1024', '1536x1024', '1024x1536', 'auto'];
      if (!validSizes.includes(params.size)) {
        errors.push(`Invalid size for gpt-image-1. Supported sizes: ${validSizes.join(', ')}`);
      }
    }

    // Quality and format validation removed - properties no longer in interface

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      adjustedParams
    };
  }

  /**
   * Get OpenAI image generation capabilities
   */
  getImageCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: false,
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsThinking: false,
      supportsImageGeneration: true,
      maxContextWindow: 32000, // Character limit for prompts
      supportedFeatures: [
        'text_to_image',
        'quality_control',
        'size_variants',
        'style_control',
        'high_resolution'
      ]
    };
  }

  /**
   * Get supported image sizes for gpt-image-1
   */
  getSupportedImageSizes(): string[] {
    return [...this.supportedSizes];
  }

  /**
   * Get pricing for gpt-image-1 image generation
   */
  async getImageModelPricing(model: string = 'gpt-image-1'): Promise<CostDetails> {
    // gpt-image-1 pricing is token-based, approximate base price
    const basePrice = 0.015; // Approximate cost per image

    return {
      inputCost: 0,
      outputCost: basePrice,
      totalCost: basePrice,
      currency: 'USD',
      rateInputPerMillion: 0,
      rateOutputPerMillion: basePrice * 1_000_000
    };
  }

  /**
   * List available OpenAI image models
   */
  async listModels(): Promise<ModelInfo[]> {
    return [{
      id: this.imageModel,
      name: 'GPT Image 1',
      contextWindow: 32000,
      maxOutputTokens: 0,
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: false,
      supportsImageGeneration: true,
      pricing: {
        inputPerMillion: 0,
        outputPerMillion: 0,
        imageGeneration: 0.015,
        currency: 'USD',
        lastUpdated: '2025-01-01'
      }
    }];
  }

  // Private helper methods

  private async buildImageResponse(
    response: any, // Responses API response format
    params: ImageGenerationParams
  ): Promise<ImageGenerationResponse> {
    // Extract image data from Responses API format
    const imageData = response.output
      .filter((output: any) => output.type === "image_generation_call")
      .map((output: any) => output.result);

    if (!imageData || imageData.length === 0) {
      throw new Error('No image data received from OpenAI Responses API');
    }

    const imageBase64 = imageData[0];
    if (!imageBase64) {
      throw new Error('No base64 image data received from OpenAI');
    }

    // Convert base64 to buffer
    const buffer = Buffer.from(imageBase64, 'base64');
    console.log(`[OpenAI] Received base64 image data (${buffer.length} bytes)`);

    // Extract dimensions from size parameter or use default
    const size = params.size || '1024x1024';
    const [width, height] = size === 'auto' ? [1024, 1024] : size.split('x').map(Number);

    const usage: ImageUsage = this.buildImageUsage(1, size, this.imageModel);

    // Extract revised prompt from image generation call
    const imageGenerationCall = response.output.find((output: any) => output.type === "image_generation_call");
    const revisedPrompt = imageGenerationCall?.revised_prompt;

    return {
      imageData: buffer,
      format: 'png', // Default format for Responses API
      dimensions: { width, height },
      metadata: {
        size: params.size || '1024x1024',
        responseFormat: 'responses_api',
        model: this.imageModel,
        provider: this.name,
        generatedAt: new Date().toISOString(),
        originalPrompt: params.prompt,
        responseId: response.id,
        apiResponse: {
          outputCount: response.output.length,
          imageOutputCount: imageData.length
        }
      },
      usage,
      revisedPrompt: revisedPrompt
    };
  }
}
```

## services/llm/adapters/openai/OpenAIMCPHandler.ts

```typescript
/**
 * OpenAI MCP Handler - Uses responses API with MCP support
 * Handles communication with local MCP server via HTTP
 */

import OpenAI from 'openai';
import { GenerateOptions, LLMResponse, TokenUsage } from '../types';
import { LLMProviderError } from '../types';
import { logger } from '../../../../utils/logger';

export interface MCPToolConfig {
  type: 'mcp';
  server_label: string;
  server_description?: string;
  command: string;
  args: string[];
  env?: Record<string, string>;
  require_approval: 'always' | 'never' | { never: { tool_names: string[] } };
  allowed_tools?: string[];
}

export interface MCPResponse {
  output_text?: string;
  output?: Array<{
    id: string;
    type: string;
    content?: any;
    tools?: any[];
    server_label?: string;
    name?: string;
    arguments?: string;
    result?: any;
    error?: any;
  }>;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

export class OpenAIMCPHandler {
  private serverUrl: string;
  private serverLabel: string;
  
  constructor(
    private client: OpenAI,
    serverUrl: string,
    serverLabel: string = 'claudesidian'
  ) {
    this.serverUrl = serverUrl;
    this.serverLabel = serverLabel;
  }

  /**
   * Generate response using OpenAI responses API with MCP integration
   */
  async generateWithMCP(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || 'gpt-5';
      
      // Build MCP tool configuration following OpenRouter documentation format
      console.log('[OpenAI MCP] Building tool config with connector script');
      const mcpTool: MCPToolConfig = {
        type: 'mcp',
        server_label: 'claudesidian',
        server_description: 'Claudesidian MCP server providing vault operations and AI agents',
        command: 'node',
        args: ['connector.js'], // Relative path - OpenRouter will resolve from plugin directory
        env: {
          NODE_ENV: 'production'
        },
        require_approval: 'never', // Trust our own server
        // Don't specify allowed_tools to get all available tools
      };

      // Build request for responses API  
      const requestParams: any = {
        model,
        input: this.buildInput(prompt, options?.systemPrompt),
        tools: [mcpTool]
      };
      
      // Add system prompt as instructions if provided
      if (options?.systemPrompt) {
        requestParams.instructions = options.systemPrompt;
      }

      // Add optional parameters
      if (options?.temperature !== undefined) requestParams.temperature = options.temperature;
      if (options?.maxTokens !== undefined) requestParams.max_tokens = options.maxTokens;
      if (options?.topP !== undefined) requestParams.top_p = options.topP;
      if (options?.frequencyPenalty !== undefined) requestParams.frequency_penalty = options.frequencyPenalty;
      if (options?.presencePenalty !== undefined) requestParams.presence_penalty = options.presencePenalty;

      logger.systemLog(`[OpenAI MCP] Calling responses API with MCP server: ${this.serverUrl}`);
      
      // Call OpenAI responses API with MCP
      const response = await this.client.responses.create(requestParams) as MCPResponse;
      
      return this.processResponse(response, model);
    } catch (error) {
      logger.systemError(error as Error, 'OpenAI MCP Generation');
      
      // Check if this is a server connectivity issue
      if ((error as any).message?.includes('ECONNREFUSED') || 
          (error as any).code === 'ECONNREFUSED') {
        throw new LLMProviderError(
          'MCP server not reachable. Please ensure the Claudesidian MCP server is running.',
          'openai',
          'MCP_SERVER_UNREACHABLE',
          error as Error
        );
      }
      
      throw new LLMProviderError(
        `OpenAI MCP generation failed: ${(error as Error).message}`,
        'openai',
        'MCP_GENERATION_ERROR',
        error as Error
      );
    }
  }

  /**
   * Process the MCP response and extract results
   */
  private processResponse(response: MCPResponse, model: string): LLMResponse {
    let finalText = response.output_text || '';
    let toolCalls: any[] = [];
    let hasToolExecution = false;

    // Process output array for tool calls and results
    if (response.output && Array.isArray(response.output)) {
      const mcpListTools = response.output.find(item => item.type === 'mcp_list_tools');
      const mcpCalls = response.output.filter(item => item.type === 'mcp_call');
      
      if (mcpListTools) {
        logger.systemLog(`[OpenAI MCP] Tools available from ${mcpListTools.server_label}: ${mcpListTools.tools?.length || 0} tools`);
      }

      // Process tool calls
      mcpCalls.forEach(call => {
        hasToolExecution = true;
        
        const toolCall = {
          id: call.id,
          name: call.name,
          parameters: call.arguments ? JSON.parse(call.arguments) : {},
          result: call.result,
          success: !call.error,
          error: call.error,
          server_label: call.server_label
        };

        toolCalls.push(toolCall);
        
        // Add tool execution info to response text if not already present
        if (!finalText.includes(call.name || '')) {
          finalText += `\n\n[Tool executed: ${call.name || 'unknown'}]`;
          if (call.result) {
            finalText += `\nResult: ${typeof call.result === 'string' ? call.result : JSON.stringify(call.result || '')}`;
          }
        }
      });
    }

    // Extract usage information
    const usage: TokenUsage = {
      promptTokens: response.usage?.prompt_tokens || 0,
      completionTokens: response.usage?.completion_tokens || 0,
      totalTokens: response.usage?.total_tokens || 0
    };

    const llmResponse: LLMResponse = {
      text: finalText,
      model,
      provider: 'openai',
      usage,
      metadata: {
        mcpEnabled: true,
        serverUrl: this.serverUrl,
        serverLabel: this.serverLabel,
        hasToolExecution,
        toolCallCount: toolCalls.length
      },
      finishReason: 'stop',
      toolCalls: toolCalls.length > 0 ? toolCalls : undefined
    };

    return llmResponse;
  }

  /**
   * Build input format for responses API
   * Based on actual OpenAI SDK: input can be string or ResponseInput array
   */
  private buildInput(prompt: string, systemPrompt?: string): string {
    // For MCP testing, start with the simplest approach - just the user prompt
    // System prompts can be handled via the instructions parameter instead
    return prompt;
  }

  /**
   * Check if responses API is available
   */
  isResponsesAPIAvailable(): boolean {
    return typeof this.client.responses?.create === 'function';
  }

  /**
   * Update server configuration
   */
  updateServerConfig(serverUrl: string, serverLabel?: string): void {
    this.serverUrl = serverUrl;
    if (serverLabel) {
      this.serverLabel = serverLabel;
    }
  }

  /**
   * Get current server configuration
   */
  getServerConfig(): { serverUrl: string; serverLabel: string } {
    return {
      serverUrl: this.serverUrl,
      serverLabel: this.serverLabel
    };
  }
}
```

## services/llm/adapters/openai/OpenAIModels.ts

```typescript
/**
 * OpenAI Model Specifications
 * Updated August 10, 2025 with GPT-5 model family
 */

import { ModelSpec } from '../modelTypes';

export const OPENAI_MODELS: ModelSpec[] = [
  // GPT-5 model family (latest flagship models)
  {
    provider: 'openai',
    name: 'GPT-5',
    apiName: 'gpt-5',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openai',
    name: 'GPT-5 Mini',
    apiName: 'gpt-5-mini',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 0.25,
    outputCostPerMillion: 2.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openai',
    name: 'GPT-5 Nano',
    apiName: 'gpt-5-nano',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 0.05,
    outputCostPerMillion: 0.40,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  {
    provider: 'openai',
    name: 'GPT-4o',
    apiName: 'gpt-4o-2024-11-20',
    contextWindow: 128000,
    maxTokens: 16384,
    inputCostPerMillion: 2.50,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // GPT-4.1 models
  {
    provider: 'openai',
    name: 'GPT-4.1',
    apiName: 'gpt-4.1-2025-04-14',
    contextWindow: 1047576,
    maxTokens: 32768,
    inputCostPerMillion: 8.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openai',
    name: 'GPT-4.1 Mini',
    apiName: 'gpt-4.1-mini-2025-04-14',
    contextWindow: 1047576,
    maxTokens: 32768,
    inputCostPerMillion: 0.10,
    outputCostPerMillion: 1.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openai',
    name: 'GPT-4.1 Nano',
    apiName: 'gpt-4.1-nano-2025-04-14',
    contextWindow: 1047576,
    maxTokens: 32768,
    inputCostPerMillion: 0.10,
    outputCostPerMillion: 0.40,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // o3 models (reasoning)
  {
    provider: 'openai',
    name: 'o3',
    apiName: 'o3-2025-04-16',
    contextWindow: 200000,
    maxTokens: 100000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: true
    }
  },
  {
    provider: 'openai',
    name: 'o3 Pro',
    apiName: 'o3-pro-2025-06-10',
    contextWindow: 200000,
    maxTokens: 100000,
    inputCostPerMillion: 20.00,
    outputCostPerMillion: 80.00,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: true
    }
  },

  // o3 deep research models
  // {
  //   provider: 'openai',
  //   name: 'o3 Deep Research',
  //   apiName: 'o3-deep-research-2025-06-26',
  //   contextWindow: 200000,
  //   maxTokens: 100000,
  //   inputCostPerMillion: 10.00,
  //   outputCostPerMillion: 40.00,
  //   capabilities: {
  //     supportsJSON: false,
  //     supportsImages: true,
  //     supportsFunctions: false,
  //     supportsStreaming: true,
  //     supportsThinking: true
  //   }
  // },

  // o4 models (reasoning)
  {
    provider: 'openai',
    name: 'o4 Mini',
    apiName: 'o4-mini-2025-04-16',
    contextWindow: 200000,
    maxTokens: 100000,
    inputCostPerMillion: 1.10,
    outputCostPerMillion: 4.40,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: true
    }
  },
  // {
  //   provider: 'openai',
  //   name: 'o4 Mini Deep Research',
  //   apiName: 'o4-mini-deep-research-2025-06-26',
  //   contextWindow: 200000,
  //   maxTokens: 100000,
  //   inputCostPerMillion: 2.00,
  //   outputCostPerMillion: 8.00,
  //   capabilities: {
  //     supportsJSON: false,
  //     supportsImages: true,
  //     supportsFunctions: false,
  //     supportsStreaming: true,
  //     supportsThinking: true
  //   }
  // }
];

export const OPENAI_DEFAULT_MODEL = 'gpt-5';
```

## services/llm/adapters/openrouter/OpenRouterAdapter.ts

```typescript
/**
 * OpenRouter Adapter - Clean implementation with centralized SSE streaming
 * Supports 400+ models through OpenRouter's unified API
 * Uses BaseAdapter's processSSEStream for reliable streaming
 */

import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  SearchResult
} from '../types';
import { ModelRegistry } from '../ModelRegistry';
import { MCPToolExecution, MCPCapableAdapter } from '../shared/MCPToolExecution';
import { WebSearchUtils } from '../../utils/WebSearchUtils';

export class OpenRouterAdapter extends BaseAdapter implements MCPCapableAdapter {
  readonly name = 'openrouter';
  readonly baseUrl = 'https://openrouter.ai/api/v1';
  
  mcpConnector?: any;

  constructor(apiKey: string, mcpConnector?: any) {
    super(apiKey, 'anthropic/claude-3.5-sonnet');
    this.mcpConnector = mcpConnector;
    this.initializeCache();
  }

  /**
   * Generate response without caching
   */
  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      // Validate web search support
      if (options?.webSearch) {
        WebSearchUtils.validateWebSearchRequest('openrouter', options.webSearch);
      }

      const baseModel = options?.model || this.currentModel;

      // Add :online suffix for web search
      const model = options?.webSearch ? `${baseModel}:online` : baseModel;

      // Handle post-stream tool execution: if detectedToolCalls are provided, execute only tools
      if (options?.detectedToolCalls && options.detectedToolCalls.length > 0) {
        return await this.executeDetectedToolCalls(options.detectedToolCalls, model, prompt, options);
      }

      // If tools are provided (pre-converted by ChatService), use tool-enabled generation
      if (options?.tools && options.tools.length > 0) {
        return await this.generateWithProvidedTools(prompt, options);
      }

      const requestBody = {
        model,
        messages: this.buildMessages(prompt, options?.systemPrompt),
        temperature: options?.temperature,
        max_tokens: options?.maxTokens,
        top_p: options?.topP,
        frequency_penalty: options?.frequencyPenalty,
        presence_penalty: options?.presencePenalty,
        response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
        stop: options?.stopSequences,
        tools: options?.tools
      };

      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          ...this.buildHeaders(),
          'Authorization': `Bearer ${this.apiKey}`,
          'HTTP-Referer': 'https://synaptic-lab-kit.com',
          'X-Title': 'Synaptic Lab Kit'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      const text = data.choices[0]?.message?.content || '';
      const usage = this.extractUsage(data);
      const finishReason = data.choices[0]?.finish_reason || 'stop';

      // Extract web search results if web search was enabled
      const webSearchResults = options?.webSearch
        ? this.extractOpenRouterSources(data)
        : undefined;

      return this.buildLLMResponse(
        text,
        baseModel, // Use base model name, not :online version
        usage,
        { webSearchResults },
        finishReason as any
      );
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  /**
   * Generate streaming response using centralized SSE processing
   */
  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      // Validate web search support
      if (options?.webSearch) {
        WebSearchUtils.validateWebSearchRequest('openrouter', options.webSearch);
      }

      const baseModel = options?.model || this.currentModel;

      // Add :online suffix for web search
      const model = options?.webSearch ? `${baseModel}:online` : baseModel;
      
      const requestBody = {
        model,
        messages: options?.conversationHistory || this.buildMessages(prompt, options?.systemPrompt),
        temperature: options?.temperature,
        max_tokens: options?.maxTokens,
        top_p: options?.topP,
        frequency_penalty: options?.frequencyPenalty,
        presence_penalty: options?.presencePenalty,
        response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
        stop: options?.stopSequences,
        tools: options?.tools,
        stream: true // Enable streaming
      };

      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          ...this.buildHeaders(),
          'Authorization': `Bearer ${this.apiKey}`,
          'HTTP-Referer': 'https://synaptic-lab-kit.com',
          'X-Title': 'Synaptic Lab Kit'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      // Use centralized SSE streaming with OpenRouter-specific extraction
      yield* this.processSSEStream(response, {
        debugLabel: 'OpenRouter',
        accumulateToolCalls: true,
        toolCallThrottling: {
          initialYield: true,
          progressInterval: 50
        },

        extractContent: (parsed: any) => {
          // Process all available choices - reasoning models may use multiple choices
          // Choice 0 might be reasoning, Choice 1 might be actual response
          for (const choice of parsed.choices || []) {
            const delta = choice?.delta;
            const content = delta?.content || delta?.text || choice?.text;
            if (content) {
              return content;
            }
          }
          return null;
        },

        extractToolCalls: (parsed: any) => {
          // Extract tool calls from any choice that has them
          for (const choice of parsed.choices || []) {
            const toolCalls = choice?.delta?.toolCalls;
            if (toolCalls) {
              return toolCalls;
            }
          }
          return null;
        },

        extractFinishReason: (parsed: any) => {
          // Extract finish reason from any choice
          for (const choice of parsed.choices || []) {
            if (choice?.finish_reason) {
              return choice.finish_reason;
            }
          }
          return null;
        },

        extractUsage: (parsed: any) => {
          return parsed.usage || null;
        },

        onParseError: (error: Error, rawData: string) => {
          // Failed to parse SSE data
        }
      });

    } catch (error) {
      throw this.handleError(error, 'streaming generation');
    }
  }

  /**
   * List available models
   */
  async listModels(): Promise<ModelInfo[]> {
    try {
      // Use centralized model registry
      const openrouterModels = ModelRegistry.getProviderModels('openrouter');
      return openrouterModels.map(model => ModelRegistry.toModelInfo(model));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  /**
   * Get provider capabilities
   */
  getCapabilities(): ProviderCapabilities {
    const baseCapabilities = {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: false,
      maxContextWindow: 2000000, // Varies by model
      supportedFeatures: [
        'streaming',
        'json_mode',
        'function_calling',
        'image_input',
        '400+ models'
      ]
    };

    // Add MCP support if available
    if (this.supportsMCP()) {
      baseCapabilities.supportedFeatures.push('mcp_integration');
    }

    return baseCapabilities;
  }

  /**
   * Check if MCP is available via connector
   */
  supportsMCP(): boolean {
    return MCPToolExecution.supportsMCP(this);
  }

  /**
   * Generate with pre-converted tools (from ChatService) using iterative execution
   */
  private async generateWithProvidedTools(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    // Use centralized tool execution wrapper to eliminate code duplication
    const model = options?.model || this.currentModel;

    
    return MCPToolExecution.executeWithToolSupport(
      this,
      'openrouter',
      {
        model,
        tools: options?.tools || [],
        prompt,
        systemPrompt: options?.systemPrompt,
        onToolEvent: options?.onToolEvent
      },
      {
        buildMessages: (prompt: string, systemPrompt?: string) => 
          this.buildMessages(prompt, systemPrompt),
        
        buildRequestBody: (messages: any[], isInitial: boolean) => ({
          model,
          messages,
          tools: options?.tools,
          tool_choice: 'auto',
          temperature: options?.temperature,
          max_tokens: options?.maxTokens,
          top_p: options?.topP,
          frequency_penalty: options?.frequencyPenalty,
          presence_penalty: options?.presencePenalty,
          response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
          stop: options?.stopSequences
        }),
        
        makeApiCall: async (requestBody: any) => {
          return await fetch(`${this.baseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
              ...this.buildHeaders(),
              'Authorization': `Bearer ${this.apiKey}`,
              'HTTP-Referer': 'https://synaptic-lab-kit.com',
              'X-Title': 'Synaptic Lab Kit'
            },
            body: JSON.stringify(requestBody)
          });
        },
        
        extractResponse: async (response: Response) => {
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          const data = await response.json();
          const choice = data.choices[0];
          
          return {
            content: choice?.message?.content || '',
            usage: this.extractUsage(data),
            finishReason: choice?.finish_reason || 'stop',
            toolCalls: choice?.message?.toolCalls,
            choice: choice
          };
        },
        
        buildLLMResponse: async (
          content: string,
          model: string,
          usage?: any,
          metadata?: any,
          finishReason?: any,
          toolCalls?: any[]
        ) => {
          return this.buildLLMResponse(content, model, usage, metadata, finishReason, toolCalls);
        }
      }
    );
  }

  /**
   * Execute detected tool calls from streaming and get AI response
   * Used for post-stream tool execution - implements pingpong pattern
   */
  private async executeDetectedToolCalls(detectedToolCalls: any[], model: string, prompt: string, options?: GenerateOptions): Promise<LLMResponse> {

    try {
      // Convert to MCP format
      const mcpToolCalls: any[] = detectedToolCalls.map((tc: any) => ({
        id: tc.id,
        function: {
          name: tc.function?.name || tc.name,
          arguments: tc.function?.arguments || JSON.stringify(tc.parameters || {})
        }
      }));

      // Execute tool calls directly using MCPToolExecution
      const toolResults = await MCPToolExecution.executeToolCalls(
        this, 
        mcpToolCalls, 
        'openrouter',
        options?.onToolEvent
      );


      // Now do the "pingpong" - send the conversation with tool results back to the LLM
      const messages = this.buildMessages(prompt, options?.systemPrompt);
      
      // Add the assistant message with tool calls
      messages.push({
        role: 'assistant' as const,
        content: '', // Empty content since this was a tool call
        toolCalls: detectedToolCalls
      });

      // Add tool result messages
      const toolMessages = MCPToolExecution.buildToolMessages(toolResults);
      messages.push(...toolMessages);


      // Make API call to get AI's response to the tool results  
      const requestBody = {
        model,
        messages,
        temperature: options?.temperature,
        max_tokens: options?.maxTokens,
        top_p: options?.topP,
        frequency_penalty: options?.frequencyPenalty,
        presence_penalty: options?.presencePenalty,
        response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
        stop: options?.stopSequences
      };
      
      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          ...this.buildHeaders(),
          'Authorization': `Bearer ${this.apiKey}`,
          'HTTP-Referer': 'https://synaptic-lab-kit.com',
          'X-Title': 'Synaptic Lab Kit'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      const choice = data.choices[0];
      const finalContent = choice?.message?.content || 'No response from AI after tool execution';
      const usage = this.extractUsage(data);


      // Combine original tool calls with their execution results
      const completeToolCalls = detectedToolCalls.map(originalCall => {
        const result = toolResults.find(r => r.id === originalCall.id);
        return {
          id: originalCall.id,
          name: originalCall.function?.name || originalCall.name,
          parameters: JSON.parse(originalCall.function?.arguments || '{}'),
          result: result?.result,
          success: result?.success || false,
          error: result?.error,
          executionTime: result?.executionTime
        };
      });

      // Return LLMResponse with AI's natural language response to tool results
      return this.buildLLMResponse(
        finalContent,
        model,
        usage,
        MCPToolExecution.buildToolMetadata(toolResults),
        choice?.finish_reason || 'stop',
        completeToolCalls
      );

    } catch (error) {
      console.error('[OpenRouter Adapter] Post-stream tool execution failed:', error);
      throw this.handleError(error, 'post-stream tool execution');
    }
  }

  /**
   * Extract search results from OpenRouter response annotations
   */
  private extractOpenRouterSources(response: any): SearchResult[] {
    try {
      const annotations = response.choices?.[0]?.message?.annotations || [];
      const sources = annotations
        .filter((ann: any) => ann.type === 'url_citation')
        .map((ann: any) => {
          const citation = ann.url_citation;
          return WebSearchUtils.validateSearchResult({
            title: citation?.title || citation?.text || 'Unknown Source',
            url: citation?.url,
            date: citation?.date || citation?.timestamp
          });
        })
        .filter((result: SearchResult | null): result is SearchResult => result !== null);

      return sources;
    } catch (error) {
      console.warn('[OpenRouter] Failed to extract search sources:', error);
      return [];
    }
  }

  /**
   * Get model pricing
   */
  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    try {
      const models = ModelRegistry.getProviderModels('openrouter');
      const model = models.find(m => m.apiName === modelId);
      if (!model) {
        return null;
      }

      return {
        rateInputPerMillion: model.inputCostPerMillion,
        rateOutputPerMillion: model.outputCostPerMillion,
        currency: 'USD'
      };
    } catch (error) {
      console.warn(`Failed to get pricing for model ${modelId}:`, error);
      return null;
    }
  }
}
```

## services/llm/adapters/openrouter/OpenRouterModels.ts

```typescript
/**
 * OpenRouter Model Specifications
 * OpenRouter provides access to multiple providers through a unified API
 * Updated August 10, 2025 with GPT-5 models
 */

import { ModelSpec } from '../modelTypes';

// OpenRouter provides access to models from other providers
// Each model has its own specific API name in OpenRouter
export const OPENROUTER_MODELS: ModelSpec[] = [
  // OpenAI GPT-5 models via OpenRouter
  {
    provider: 'openrouter',
    name: 'GPT-5',
    apiName: 'openai/gpt-5',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'GPT-5 Mini',
    apiName: 'openai/gpt-5-mini',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 0.25,
    outputCostPerMillion: 2.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'GPT-5 Nano',
    apiName: 'openai/gpt-5-nano',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 0.05,
    outputCostPerMillion: 0.40,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  // OpenAI GPT-4 models via OpenRouter
  {
    provider: 'openrouter',
    name: 'GPT-4o',
    apiName: 'openai/gpt-4o-2024-11-20',
    contextWindow: 128000,
    maxTokens: 16384,
    inputCostPerMillion: 2.50,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openrouter',
    name: 'GPT-4.1',
    apiName: 'openai/gpt-4.1',
    contextWindow: 1047576,
    maxTokens: 32768,
    inputCostPerMillion: 8.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openrouter',
    name: 'GPT-4.1 Mini',
    apiName: 'openai/gpt-4.1-mini',
    contextWindow: 1047576,
    maxTokens: 32768,
    inputCostPerMillion: 0.10,
    outputCostPerMillion: 1.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openrouter',
    name: 'GPT-4.1 Nano',
    apiName: 'openai/gpt-4.1-nano',
    contextWindow: 1047576,
    maxTokens: 32768,
    inputCostPerMillion: 0.10,
    outputCostPerMillion: 0.40,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openrouter',
    name: 'o4 Mini',
    apiName: 'openai/o4-mini',
    contextWindow: 200000,
    maxTokens: 100000,
    inputCostPerMillion: 1.10,
    outputCostPerMillion: 4.40,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: true
    }
  },

  // Google models via OpenRouter
  {
    provider: 'openrouter',
    name: 'Gemini 2.5 Pro Experimental',
    apiName: 'google/gemini-2.5-pro-preview-06-05',
    contextWindow: 1048576,
    maxTokens: 66000,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'Gemini 2.5 Flash',
    apiName: 'google/gemini-2.5-flash',
    contextWindow: 1048576,
    maxTokens: 65536,
    inputCostPerMillion: 0.15,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Anthropic models via OpenRouter
  {
    provider: 'openrouter',
    name: 'Claude 3.5 Haiku',
    apiName: 'anthropic/claude-3-5-haiku',
    contextWindow: 200000,
    maxTokens: 8192,
    inputCostPerMillion: 0.80,
    outputCostPerMillion: 4.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openrouter',
    name: 'Claude 4.1 Opus',
    apiName: 'anthropic/claude-opus-4.1',
    contextWindow: 200000,
    maxTokens: 32000,
    inputCostPerMillion: 15.00,
    outputCostPerMillion: 75.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openrouter',
    name: 'Claude 4 Sonnet',
    apiName: 'anthropic/claude-sonnet-4',
    contextWindow: 200000,
    maxTokens: 64000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Mistral models via OpenRouter
  {
    provider: 'openrouter',
    name: 'Mistral Large',
    apiName: 'mistralai/mistral-large-2411',
    contextWindow: 131072,
    maxTokens: 131072,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 6.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openrouter',
    name: 'Mistral Medium',
    apiName: 'mistralai/magistral-medium-2506',
    contextWindow: 40960,
    maxTokens: 40000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 5.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openrouter',
    name: 'Mistral Saba',
    apiName: 'mistralai/mistral-saba',
    contextWindow: 32768,
    maxTokens: 32768,
    inputCostPerMillion: 0.20,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: false,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openrouter',
    name: 'Magistral Medium',
    apiName: 'mistralai/magistral-medium-2506',
    contextWindow: 40960,
    maxTokens: 40000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 5.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: true
    }
  }
];

export const OPENROUTER_DEFAULT_MODEL = 'openai/gpt-5';
```

## services/llm/adapters/perplexity/PerplexityAdapter.ts

```typescript
/**
 * Perplexity AI Adapter with true streaming support
 * Supports Perplexity's Sonar models with web search and reasoning capabilities
 * Based on official Perplexity streaming documentation with SSE parsing
 */

import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  TokenUsage,
  SearchResult
} from '../types';
import { PERPLEXITY_MODELS, PERPLEXITY_DEFAULT_MODEL } from './PerplexityModels';
import { MCPToolExecution, MCPCapableAdapter } from '../shared/MCPToolExecution';
import { WebSearchUtils } from '../../utils/WebSearchUtils';

export interface PerplexityOptions extends GenerateOptions {
  webSearch?: boolean;
  searchMode?: 'web' | 'academic';
  reasoningEffort?: 'low' | 'medium' | 'high';
  searchContextSize?: 'low' | 'medium' | 'high';
}

export class PerplexityAdapter extends BaseAdapter implements MCPCapableAdapter {
  readonly name = 'perplexity';
  readonly baseUrl = 'https://api.perplexity.ai';
  
  mcpConnector?: any;

  constructor(apiKey: string, mcpConnector?: any, model?: string) {
    super(apiKey, model || PERPLEXITY_DEFAULT_MODEL);
    this.mcpConnector = mcpConnector;
    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: PerplexityOptions): Promise<LLMResponse> {
    try {
      // Validate web search support (Perplexity always supports web search)
      if (options?.webSearch) {
        WebSearchUtils.validateWebSearchRequest('perplexity', options.webSearch);
      }

      const model = options?.model || this.currentModel;

      // Perplexity does not support native function calling
      // If tools are requested, inform user and proceed without tools
      if (options?.tools && options.tools.length > 0) {
        console.warn('[Perplexity Adapter] Tools requested but Perplexity API does not support function calling. Proceeding without tools.');
      }

      // Use standard chat completions (Perplexity's strength is web search, not tool calling)
      console.log('[Perplexity Adapter] Using chat completions with web search capabilities');
      return await this.generateWithChatCompletions(prompt, options);
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  async* generateStreamAsync(prompt: string, options?: PerplexityOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      console.log('[PerplexityAdapter] Starting streaming response');
      
      const requestBody = {
        model: options?.model || this.currentModel,
        messages: this.buildMessages(prompt, options?.systemPrompt),
        temperature: options?.temperature,
        max_tokens: options?.maxTokens,
        top_p: options?.topP,
        presence_penalty: options?.presencePenalty,
        frequency_penalty: options?.frequencyPenalty,
        tools: options?.tools,
        stream: true,
        extra: {
          search_mode: options?.searchMode || 'web',
          reasoning_effort: options?.reasoningEffort || 'medium',
          web_search_options: {
            search_context_size: options?.searchContextSize || 'low'
          }
        }
      };

      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No response body reader available');
      }

      const decoder = new TextDecoder();
      let buffer = '';
      let usage: any = undefined;
      let searchResults: any[] = [];
      let metadata: any = {};

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          
          // Process complete lines from buffer
          while (true) {
            const lineEnd = buffer.indexOf('\n');
            if (lineEnd === -1) break;
            
            const line = buffer.slice(0, lineEnd).trim();
            buffer = buffer.slice(lineEnd + 1);
            
            // Skip empty lines
            if (!line) continue;
            
            if (line.startsWith('data: ')) {
              const data = line.slice(6).trim();
              if (data === '[DONE]') break;
              
              try {
                const chunk = JSON.parse(data);
                
                // Process content chunks
                const content = chunk.choices?.[0]?.delta?.content;
                if (content) {
                  yield { content, complete: false };
                }
                
                // Collect metadata (arrives in final chunks)
                if (chunk.search_results) {
                  searchResults = chunk.search_results;
                }
                
                if (chunk.usage) {
                  usage = chunk.usage;
                }
                
                // Collect other metadata
                for (const key of ['reasoning_effort', 'search_mode']) {
                  if (chunk[key]) {
                    metadata[key] = chunk[key];
                  }
                }
                
              } catch (error) {
                console.warn('[PerplexityAdapter] Failed to parse streaming chunk:', error);
              }
            }
          }
        }
      } finally {
        reader.releaseLock();
      }

      // Final chunk with usage information (search results stored in metadata)
      yield { 
        content: '', 
        complete: true, 
        usage: this.extractUsage({ usage })
      };
      
      console.log('[PerplexityAdapter] Streaming completed');
    } catch (error) {
      console.error('[PerplexityAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return PERPLEXITY_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: false,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false, // Perplexity does not support function calling
      supportsThinking: false,
      maxContextWindow: 127072,
      supportedFeatures: [
        'messages',
        'streaming',
        'web_search', // This is Perplexity's main strength
        'reasoning',
        'sonar_models',
        'academic_search',
        'real_time_information',
        'citations'
      ]
    };
  }

  /**
   * Check if MCP is available via connector
   */
  supportsMCP(): boolean {
    return MCPToolExecution.supportsMCP(this);
  }

  /**
   * Generate with pre-converted tools (from ChatService) using centralized execution
   */
  private async generateWithProvidedTools(prompt: string, options?: PerplexityOptions): Promise<LLMResponse> {
    // Use centralized tool execution wrapper to eliminate code duplication
    const model = options?.model || this.currentModel;

    return MCPToolExecution.executeWithToolSupport(
      this,
      'perplexity',
      {
        model,
        tools: options?.tools || [],
        prompt,
        systemPrompt: options?.systemPrompt
      },
      {
        buildMessages: (prompt: string, systemPrompt?: string) => 
          this.buildMessages(prompt, systemPrompt),
        
        buildRequestBody: (messages: any[], isInitial: boolean) => ({
          model,
          messages,
          tools: options?.tools,
          tool_choice: 'auto',
          temperature: options?.temperature,
          max_tokens: options?.maxTokens,
          top_p: options?.topP,
          presence_penalty: options?.presencePenalty,
          frequency_penalty: options?.frequencyPenalty,
          extra: {
            search_mode: options?.searchMode || 'web',
            reasoning_effort: options?.reasoningEffort || 'medium',
            web_search_options: {
              search_context_size: options?.searchContextSize || 'low'
            }
          }
        }),
        
        makeApiCall: async (requestBody: any) => {
          return await fetch(`${this.baseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${this.apiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
          });
        },
        
        extractResponse: async (response: Response) => {
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          const data = await response.json();
          const choice = data.choices[0];
          
          return {
            content: choice?.message?.content || '',
            usage: this.extractUsage(data),
            finishReason: choice?.finish_reason || 'stop',
            toolCalls: choice?.message?.toolCalls,
            choice: choice
          };
        },
        
        buildLLMResponse: async (
          content: string,
          model: string,
          usage?: any,
          metadata?: any,
          finishReason?: any,
          toolCalls?: any[]
        ) => {
          return this.buildLLMResponse(content, model, usage, metadata, finishReason, toolCalls);
        }
      }
    );
  }

  /**
   * Generate using standard chat completions
   */
  private async generateWithChatCompletions(prompt: string, options?: PerplexityOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;
    
    const requestBody: any = {
      model,
      messages: this.buildMessages(prompt, options?.systemPrompt),
      temperature: options?.temperature,
      max_tokens: options?.maxTokens,
      top_p: options?.topP,
      presence_penalty: options?.presencePenalty,
      frequency_penalty: options?.frequencyPenalty,
      extra: {
        search_mode: options?.searchMode || 'web',
        reasoning_effort: options?.reasoningEffort || 'medium',
        web_search_options: {
          search_context_size: options?.searchContextSize || 'low'
        }
      }
    };

    // Add tools if provided
    if (options?.tools) {
      requestBody.tools = options.tools;
    }

    const response = await fetch(`${this.baseUrl}/chat/completions`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }

    const data = await response.json() as any;
    const choice = data.choices[0];
    
    if (!choice) {
      throw new Error('No response from Perplexity');
    }
    
    let text = choice.message?.content || '';
    const usage = this.extractUsage(data);
    let finishReason = choice.finish_reason || 'stop';

    // If tools were provided and we got tool calls, we need to handle them
    // For now, just return the response as-is since tool execution is complex
    if (options?.tools && choice.message?.toolCalls && choice.message.toolCalls.length > 0) {
      console.log(`[Perplexity Adapter] Received ${choice.message.toolCalls.length} tool calls, but tool execution not implemented in basic mode`);
      text = text || '[AI requested tool calls but tool execution not available]';
    }

    // Extract and format web search results
    const webSearchResults = options?.webSearch || data.search_results
      ? this.extractPerplexitySources(data.search_results || [])
      : undefined;

    return this.buildLLMResponse(
      text,
      model,
      usage,
      {
        provider: 'perplexity',
        searchResults: data.search_results, // Keep raw data for debugging
        searchMode: options?.searchMode,
        webSearchResults
      },
      finishReason as any
    );
  }

  // Private methods

  /**
   * Extract search results from Perplexity response
   */
  private extractPerplexitySources(searchResults: any[]): SearchResult[] {
    try {
      if (!Array.isArray(searchResults)) {
        return [];
      }

      return searchResults
        .map(result => WebSearchUtils.validateSearchResult({
          title: result.title || result.name || 'Unknown Source',
          url: result.url,
          date: result.date || result.timestamp
        }))
        .filter((result: SearchResult | null): result is SearchResult => result !== null);
    } catch (error) {
      console.warn('[Perplexity] Failed to extract search sources:', error);
      return [];
    }
  }

  private extractToolCalls(message: any): any[] {
    return message?.toolCalls || [];
  }

  private mapFinishReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'stop': 'stop',
      'length': 'length',
      'tool_calls': 'tool_calls',
      'content_filter': 'content_filter'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): TokenUsage | undefined {
    const usage = response?.usage;
    if (usage) {
      return {
        promptTokens: usage.prompt_tokens || 0,
        completionTokens: usage.completion_tokens || 0,
        totalTokens: usage.total_tokens || 0
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = PERPLEXITY_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/perplexity/PerplexityModels.ts

```typescript
/**
 * Perplexity AI Model Definitions
 * Based on 2025 Perplexity API specifications
 */

import { ModelSpec } from '../modelTypes';

export const PERPLEXITY_MODELS: ModelSpec[] = [
  // Search Models (Online)
  {
    provider: 'perplexity',
    name: 'Sonar',
    apiName: 'sonar',
    contextWindow: 128000,
    maxTokens: 8000,
    inputCostPerMillion: 1.00,
    outputCostPerMillion: 1.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'perplexity',
    name: 'Sonar Pro',
    apiName: 'sonar-pro',
    contextWindow: 200000,
    maxTokens: 8000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Reasoning Models
  {
    provider: 'perplexity',
    name: 'Sonar Reasoning',
    apiName: 'sonar-reasoning',
    contextWindow: 128000,
    maxTokens: 8000,
    inputCostPerMillion: 1.00,
    outputCostPerMillion: 5.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'perplexity',
    name: 'Sonar Reasoning Pro',
    apiName: 'sonar-reasoning-pro',
    contextWindow: 200000,
    maxTokens: 8000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  // Research Models
  {
    provider: 'perplexity',
    name: 'Sonar Deep Research',
    apiName: 'sonar-deep-research',
    contextWindow: 200000,
    maxTokens: 8000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Offline Model
  {
    provider: 'perplexity',
    name: 'r1-1776',
    apiName: 'r1-1776',
    contextWindow: 128000,
    maxTokens: 8000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  }
];

export const PERPLEXITY_DEFAULT_MODEL = 'sonar-pro';

export const PERPLEXITY_SEARCH_MODELS = PERPLEXITY_MODELS.filter(m => 
  m.apiName !== 'r1-1776' // All models except r1-1776 have web search
);
export const PERPLEXITY_REASONING_MODELS = PERPLEXITY_MODELS.filter(m => 
  m.capabilities.supportsThinking
);
export const PERPLEXITY_OFFLINE_MODELS = PERPLEXITY_MODELS.filter(m => 
  m.apiName === 'r1-1776' // Only r1-1776 is offline
);
```

## services/llm/adapters/requesty/RequestyAdapter.ts

```typescript
/**
 * Requesty AI Adapter with true streaming support
 * OpenAI-compatible streaming interface for 150+ models via router
 * Based on Requesty streaming documentation
 */

import { BaseAdapter } from '../BaseAdapter';
import { 
  GenerateOptions, 
  StreamChunk, 
  LLMResponse, 
  ModelInfo, 
  ProviderCapabilities, 
  ModelPricing 
} from '../types';
import { REQUESTY_MODELS, REQUESTY_DEFAULT_MODEL } from './RequestyModels';
import { MCPToolExecution, MCPCapableAdapter } from '../shared/MCPToolExecution';

export class RequestyAdapter extends BaseAdapter implements MCPCapableAdapter {
  readonly name = 'requesty';
  readonly baseUrl = 'https://router.requesty.ai/v1';
  
  mcpConnector?: any;

  constructor(apiKey: string, mcpConnector?: any, model?: string) {
    super(apiKey, model || REQUESTY_DEFAULT_MODEL);
    this.mcpConnector = mcpConnector;
    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || this.currentModel;
      
      // If tools are provided (pre-converted by ChatService), use tool-enabled generation
      if (options?.tools && options.tools.length > 0) {
        console.log('[Requesty Adapter] Using tool-enabled generation', {
          toolCount: options.tools.length
        });
        return await this.generateWithProvidedTools(prompt, options);
      }
      
      // Otherwise use basic chat completions
      console.log('[Requesty Adapter] Using basic chat completions (no tools)');
      return await this.generateWithChatCompletions(prompt, options);
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      console.log('[RequestyAdapter] Starting streaming response');
      
      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          ...this.buildHeaders(),
          'Authorization': `Bearer ${this.apiKey}`,
          'HTTP-Referer': 'https://synaptic-lab-kit.com',
          'X-Title': 'Synaptic Lab Kit',
          'User-Agent': 'Synaptic-Lab-Kit/1.0.0'
        },
        body: JSON.stringify({
          model: options?.model || this.currentModel,
          messages: this.buildMessages(prompt, options?.systemPrompt),
          temperature: options?.temperature,
          max_tokens: options?.maxTokens,
          response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
          stop: options?.stopSequences,
          tools: options?.tools,
          stream: true
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No response body reader available');
      }

      const decoder = new TextDecoder();
      let buffer = '';
      let usage: any = undefined;

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          
          // Process complete lines from buffer
          while (true) {
            const lineEnd = buffer.indexOf('\n');
            if (lineEnd === -1) break;
            
            const line = buffer.slice(0, lineEnd).trim();
            buffer = buffer.slice(lineEnd + 1);
            
            // Skip empty lines and comments
            if (!line || line.startsWith(':')) continue;
            
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data === '[DONE]') break;
              
              try {
                const parsed = JSON.parse(data);
                const content = parsed.choices[0]?.delta?.content;
                
                if (content) {
                  yield { content, complete: false };
                }
                
                // Extract usage information
                if (parsed.usage) {
                  usage = parsed.usage;
                }
              } catch (error) {
                console.warn('[RequestyAdapter] Failed to parse streaming chunk:', error);
              }
            }
          }
        }
      } finally {
        reader.releaseLock();
      }

      // Final chunk with usage information
      yield { 
        content: '', 
        complete: true, 
        usage: this.extractUsage({ usage }) 
      };
      
      console.log('[RequestyAdapter] Streaming completed');
    } catch (error) {
      console.error('[RequestyAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return REQUESTY_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: false,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    const baseCapabilities = {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: false,
      maxContextWindow: 200000,
      supportedFeatures: [
        'messages',
        'function_calling',
        'vision',
        'streaming',
        'json_mode',
        'router_fallback'
      ]
    };

    // Add MCP support if available
    if (this.supportsMCP()) {
      baseCapabilities.supportedFeatures.push('mcp_integration');
    }

    return baseCapabilities;
  }

  /**
   * Check if MCP is available via connector
   */
  supportsMCP(): boolean {
    return MCPToolExecution.supportsMCP(this);
  }

  /**
   * Generate with pre-converted tools (from ChatService) using centralized execution
   */
  private async generateWithProvidedTools(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    // Use centralized tool execution wrapper to eliminate code duplication
    const model = options?.model || this.currentModel;

    return MCPToolExecution.executeWithToolSupport(
      this,
      'requesty',
      {
        model,
        tools: options?.tools || [],
        prompt,
        systemPrompt: options?.systemPrompt
      },
      {
        buildMessages: (prompt: string, systemPrompt?: string) => 
          this.buildMessages(prompt, systemPrompt),
        
        buildRequestBody: (messages: any[], isInitial: boolean) => ({
          model,
          messages,
          tools: options?.tools,
          tool_choice: 'auto',
          temperature: options?.temperature,
          max_tokens: options?.maxTokens,
          response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
          stop: options?.stopSequences
        }),
        
        makeApiCall: async (requestBody: any) => {
          return await fetch(`${this.baseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
              ...this.buildHeaders(),
              'Authorization': `Bearer ${this.apiKey}`,
              'HTTP-Referer': 'https://synaptic-lab-kit.com',
              'X-Title': 'Synaptic Lab Kit',
              'User-Agent': 'Synaptic-Lab-Kit/1.0.0'
            },
            body: JSON.stringify(requestBody)
          });
        },
        
        extractResponse: async (response: Response) => {
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          const data = await response.json();
          const choice = data.choices[0];
          
          return {
            content: choice?.message?.content || '',
            usage: this.extractUsage(data),
            finishReason: choice?.finish_reason || 'stop',
            toolCalls: choice?.message?.toolCalls,
            choice: choice
          };
        },
        
        buildLLMResponse: async (
          content: string,
          model: string,
          usage?: any,
          metadata?: any,
          finishReason?: any,
          toolCalls?: any[]
        ) => {
          return this.buildLLMResponse(content, model, usage, metadata, finishReason, toolCalls);
        }
      }
    );
  }

  /**
   * Generate using standard chat completions
   */
  private async generateWithChatCompletions(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;
    
    const requestBody: any = {
      model,
      messages: this.buildMessages(prompt, options?.systemPrompt),
      temperature: options?.temperature,
      max_tokens: options?.maxTokens,
      response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
      stop: options?.stopSequences
    };

    // Add tools if provided
    if (options?.tools) {
      requestBody.tools = options.tools;
    }

    const response = await fetch(`${this.baseUrl}/chat/completions`, {
      method: 'POST',
      headers: {
        ...this.buildHeaders(),
        'Authorization': `Bearer ${this.apiKey}`,
        'HTTP-Referer': 'https://synaptic-lab-kit.com',
        'X-Title': 'Synaptic Lab Kit',
        'User-Agent': 'Synaptic-Lab-Kit/1.0.0'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }

    const data = await response.json() as any;
    const choice = data.choices[0];
    
    if (!choice) {
      throw new Error('No response from Requesty');
    }
    
    let text = choice.message?.content || '';
    const usage = this.extractUsage(data);
    let finishReason = choice.finish_reason || 'stop';

    // If tools were provided and we got tool calls, we need to handle them
    // For now, just return the response as-is since tool execution is complex
    if (options?.tools && choice.message?.toolCalls && choice.message.toolCalls.length > 0) {
      console.log(`[Requesty Adapter] Received ${choice.message.toolCalls.length} tool calls, but tool execution not implemented in basic mode`);
      text = text || '[AI requested tool calls but tool execution not available]';
    }

    return this.buildLLMResponse(
      text,
      model,
      usage,
      { provider: 'requesty' },
      finishReason as any
    );
  }

  // Private methods
  private extractToolCalls(message: any): any[] {
    return message?.toolCalls || [];
  }

  private mapFinishReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'stop': 'stop',
      'length': 'length',
      'tool_calls': 'tool_calls',
      'content_filter': 'content_filter'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): any {
    const usage = response.usage;
    if (usage) {
      return {
        promptTokens: usage.prompt_tokens || 0,
        completionTokens: usage.completion_tokens || 0,
        totalTokens: usage.total_tokens || 0
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = REQUESTY_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/requesty/RequestyModels.ts

```typescript
/**
 * Requesty Model Specifications
 * Requesty provides access to multiple providers through a unified API
 * Updated June 17, 2025
 */

import { ModelSpec } from '../modelTypes';

// Requesty provides access to models from other providers
// Each model has its own specific API name in Requesty
export const REQUESTY_MODELS: ModelSpec[] = [
  // OpenAI models via Requesty
  {
    provider: 'requesty',
    name: 'GPT-4o',
    apiName: 'openai/gpt-4o',
    contextWindow: 128000,
    maxTokens: 16384,
    inputCostPerMillion: 2.50,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'requesty',
    name: 'GPT-4.1',
    apiName: 'openai/gpt-4.1',
    contextWindow: 1047576,
    maxTokens: 32768,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'requesty',
    name: 'GPT-4.1 Mini',
    apiName: 'openai/gpt-4.1-mini',
    contextWindow: 1047576,
    maxTokens: 32768,
    inputCostPerMillion: 0.40,
    outputCostPerMillion: 1.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'requesty',
    name: 'GPT-4.1 Nano',
    apiName: 'openai/gpt-4.1-nano',
    contextWindow: 1047576,
    maxTokens: 32768,
    inputCostPerMillion: 0.10,
    outputCostPerMillion: 0.40,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'requesty',
    name: 'o3',
    apiName: 'openai/o3',
    contextWindow: 200000,
    maxTokens: 100000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: true
    }
  },
  {
    provider: 'requesty',
    name: 'o3 Pro',
    apiName: 'openai/o3-pro',
    contextWindow: 200000,
    maxTokens: 100000,
    inputCostPerMillion: 20.00,
    outputCostPerMillion: 80.00,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: true
    }
  },
  {
    provider: 'requesty',
    name: 'o4 Mini',
    apiName: 'openai/o4-mini',
    contextWindow: 200000,
    maxTokens: 100000,
    inputCostPerMillion: 1.10,
    outputCostPerMillion: 4.40,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: true
    }
  },

  // Google models via Requesty
  {
    provider: 'requesty',
    name: 'Gemini 2.5 Pro Experimental',
    apiName: 'google/gemini-2.5-pro',
    contextWindow: 1048576,
    maxTokens: 65535,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'requesty',
    name: 'Gemini 2.5 Flash',
    apiName: 'google/gemini-2.5-flash',
    contextWindow: 1048576,
    maxTokens: 65536,
    inputCostPerMillion: 0.15,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Anthropic models via Requesty
  {
    provider: 'requesty',
    name: 'Claude 3.5 Haiku',
    apiName: 'anthropic/claude-3-5-haiku-20241022',
    contextWindow: 200000,
    maxTokens: 8192,
    inputCostPerMillion: 0.80,
    outputCostPerMillion: 4.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'requesty',
    name: 'Claude 4.1 Opus',
    apiName: 'anthropic/claude-opus-4-1',
    contextWindow: 200000,
    maxTokens: 32000,
    inputCostPerMillion: 15.00,
    outputCostPerMillion: 75.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'requesty',
    name: 'Claude 4 Sonnet',
    apiName: 'anthropic/claude-sonnet-4-20250514',
    contextWindow: 200000,
    maxTokens: 64000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Mistral models via Requesty
  {
    provider: 'requesty',
    name: 'Mistral Large',
    apiName: 'mistral/mistral-large-latest',
    contextWindow: 131000,
    maxTokens: 130000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 6.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  }
];

export const REQUESTY_DEFAULT_MODEL = 'anthropic/claude-sonnet-4-20250514';
```

## services/llm/adapters/shared/MCPToolExecution.ts

```typescript
/**
 * Shared MCP Tool Execution Utility
 * Implements DRY principle for MCP tool calling across all LLM adapters
 * Follows SOLID principles with single responsibility and provider abstraction
 */

import { SupportedProvider } from '../../../mcp-bridge/types/BridgeTypes';

export interface MCPToolCall {
  id: string;
  function: {
    name: string;
    arguments: string;
  };
}

export interface MCPToolResult {
  id: string;
  name?: string; // Tool name for UI display
  success: boolean;
  result?: any;
  error?: string;
  executionTime?: number;
}

export interface MCPCapableAdapter {
  mcpConnector?: any;
}

/**
 * Static utility class for MCP tool execution across all adapters
 * Eliminates code duplication and provides consistent tool calling interface
 */
export class MCPToolExecution {
  
  /**
   * Check if adapter supports MCP integration using mcpConnector
   */
  static supportsMCP(adapter: MCPCapableAdapter): boolean {
    return !!adapter.mcpConnector;
  }

  /**
   * Get available tools for a provider using mcpConnector
   * Note: mcpConnector approach doesn't pre-fetch tools, returns empty array
   */
  static async getToolsForProvider(
    adapter: MCPCapableAdapter, 
    provider: SupportedProvider
  ): Promise<any[]> {
    if (!this.supportsMCP(adapter)) {
      console.warn(`[MCPToolExecution] MCP not available for ${provider}`);
      return [];
    }

    // mcpConnector approach: tools are resolved dynamically during execution
    console.log(`[MCPToolExecution] Using mcpConnector for ${provider} - tools resolved dynamically`);
    return [];
  }

  /**
   * Execute tool calls using mcpConnector
   * Standardized execution logic across all adapters
   */
  static async executeToolCalls(
    adapter: MCPCapableAdapter,
    toolCalls: MCPToolCall[],
    provider: SupportedProvider,
    onToolEvent?: (event: 'started' | 'completed', data: any) => void
  ): Promise<MCPToolResult[]> {
    if (!this.supportsMCP(adapter)) {
      throw new Error(`MCP not available for ${provider}`);
    }

    console.log(`[MCPToolExecution] Executing ${toolCalls.length} tool calls for ${provider}`);

    try {
      return await this.executeViaConnector(adapter.mcpConnector, toolCalls, onToolEvent);
    } catch (error) {
      console.error(`[MCPToolExecution] Tool execution failed for ${provider}:`, error);
      throw error;
    }
  }


  /**
   * Execute tools via MCP connector (legacy support)
   */
  private static async executeViaConnector(
    mcpConnector: any,
    toolCalls: MCPToolCall[],
    onToolEvent?: (event: 'started' | 'completed', data: any) => void
  ): Promise<MCPToolResult[]> {
    const results: MCPToolResult[] = [];

    for (const toolCall of toolCalls) {
      try {
        // Parse and validate tool arguments with error handling
        let parameters: any = {};
        const argumentsStr = toolCall.function.arguments || '{}';
        
        console.log(`[MCPToolExecution] Parsing arguments for ${toolCall.function.name}:`);
        console.log(`[MCPToolExecution] Arguments details:`, {
          length: argumentsStr.length,
          startsWithBrace: argumentsStr.startsWith('{'),
          endsWithBrace: argumentsStr.endsWith('}'),
          preview: argumentsStr.slice(0, 150) + (argumentsStr.length > 150 ? '...' : ''),
          lastChars: argumentsStr.slice(-20)
        });
        
        try {
          parameters = JSON.parse(argumentsStr);
          console.log(`[MCPToolExecution] Successfully parsed arguments:`, Object.keys(parameters));
        } catch (parseError) {
          console.error(`[MCPToolExecution] Failed to parse tool arguments:`, parseError);
          console.error(`[MCPToolExecution] Raw arguments (${argumentsStr.length} chars):`, argumentsStr);
          console.error(`[MCPToolExecution] Character codes at failure point:`, 
            argumentsStr.split('').slice(0, 50).map((c, i) => `${i}:'${c}'(${c.charCodeAt(0)})`));
          
          // Try to fix common JSON issues or use empty parameters
          throw new Error(`Invalid tool arguments: ${parseError instanceof Error ? parseError.message : 'Unknown parsing error'}`);
        }

        // Notify tool started with parsed parameters
        onToolEvent?.('started', {
          id: toolCall.id,
          name: toolCall.function.name,
          parameters: parameters
        });

        const originalToolName = toolCall.function.name.replace('_', '.');
        const [agent, mode] = originalToolName.split('.');
        const agentModeParams = { agent, mode, params: parameters };

        const result = await mcpConnector.callTool(agentModeParams);
        
        results.push({
          id: toolCall.id,
          name: toolCall.function.name, // Preserve the tool name
          success: result.success, // Fixed: Use result.success not !result.error
          result: result.success ? result : undefined,
          error: result.success ? undefined : (result.error || 'Tool execution failed')
        });

        // Notify tool completed
        onToolEvent?.('completed', {
          toolId: toolCall.id,
          result: result.success ? result : undefined,
          success: result.success,
          error: result.success ? undefined : (result.error || 'Tool execution failed')
        });

      } catch (error) {
        console.error('[MCPToolExecution] Tool call failed:', error);
        results.push({
          id: toolCall.id,
          name: toolCall.function.name, // Preserve the tool name even on error
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });

        // Notify tool completed (with error)
        onToolEvent?.('completed', {
          toolId: toolCall.id,
          result: undefined,
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    return results;
  }

  /**
   * Build tool messages for continuation (OpenAI/OpenRouter format)
   */
  static buildToolMessages(toolResults: MCPToolResult[]): Array<{
    role: 'tool';
    tool_call_id: string;
    content: string;
  }> {
    return toolResults.map(result => ({
      role: 'tool' as const,
      tool_call_id: result.id,
      content: result.success 
        ? JSON.stringify(result.result)
        : `Error: ${result.error}`
    }));
  }

  /**
   * Build tool metadata for response
   */
  static buildToolMetadata(toolResults: MCPToolResult[]) {
    return {
      mcpEnabled: true,
      toolCallCount: toolResults.length,
      toolCalls: toolResults.length > 0 ? toolResults.map(result => ({
        id: result.id,
        name: result.name, // Include the tool name for UI display
        result: result.result, // Include actual tool execution result
        success: result.success,
        error: result.error,
        executionTime: result.executionTime
      })) : undefined
    };
  }

  /**
   * Check if generation should use tools (with safety checks)
   * Only uses mcpConnector approach
   */
  static shouldUseMCPTools(
    adapter: MCPCapableAdapter,
    options?: { enableTools?: boolean }
  ): boolean {
    const enableTools = options?.enableTools !== false; // Default to true
    if (!enableTools) return false;
    
    return this.supportsMCP(adapter);
  }

  /**
   * Centralized tool-enabled generation wrapper
   * Eliminates code duplication across all adapters by handling common tool execution logic
   */
  static async executeWithToolSupport<T>(
    adapter: MCPCapableAdapter,
    provider: SupportedProvider,
    options: {
      model: string;
      tools: any[];
      prompt: string;
      systemPrompt?: string;
      onToolEvent?: (event: 'started' | 'completed', data: any) => void;
    },
    callbacks: {
      buildMessages: (prompt: string, systemPrompt?: string) => any[];
      makeApiCall: (requestBody: any, isInitial: boolean) => Promise<T>;
      extractResponse: (apiResponse: T) => Promise<{
        content: string;
        usage?: any;
        finishReason?: string;
        toolCalls?: any[];
        choice?: any;
      }>;
      buildLLMResponse: (
        content: string,
        model: string,
        usage?: any,
        metadata?: any,
        finishReason?: any,
        toolCalls?: any[]
      ) => Promise<any>;
      buildRequestBody: (messages: any[], isInitial: boolean) => any;
    }
  ): Promise<any> {
    // Extract tool event callback from options for DRY approach across all adapters
    const onToolEvent = options.onToolEvent;
    console.log('[MCPToolExecution Debug] executeWithToolSupport called, onToolEvent callback:', !!onToolEvent);
    console.log('[MCPToolExecution Debug] executeWithToolSupport called, onToolEvent callback:', !!onToolEvent);
    
    const TOOL_ITERATION_THRESHOLD = 15;
    let totalToolIterations = 0;
    let allToolResults: MCPToolResult[] = [];

    // Build initial messages
    const messages = callbacks.buildMessages(options.prompt, options.systemPrompt);
    let conversationMessages = [...messages];

    // Initial API call
    const initialRequestBody = callbacks.buildRequestBody(conversationMessages, true);
    let apiResponse = await callbacks.makeApiCall(initialRequestBody, true);
    let responseData = await callbacks.extractResponse(apiResponse);

    let finalText = responseData.content || '';
    const usage = responseData.usage;
    let finishReason = responseData.finishReason || 'stop';

    // Tool execution loop
    while (responseData.choice?.message?.toolCalls && responseData.choice.message.toolCalls.length > 0) {
      totalToolIterations++;
      
      console.log(`[${provider} Tool Safety] Tool iteration ${totalToolIterations}/${TOOL_ITERATION_THRESHOLD}`);
      
      // Check threshold
      if (totalToolIterations >= TOOL_ITERATION_THRESHOLD) {
        console.log(`[${provider} Tool Safety] Hit ${TOOL_ITERATION_THRESHOLD} tool iteration threshold - activating dead switch`);
        
        const deadSwitchMessage = {
          role: 'system' as const,
          content: `TOOL_LIMIT_REACHED: You have used ${TOOL_ITERATION_THRESHOLD} tool iterations. You must now ask the user if they want to continue with more tool calls. Explain what you've accomplished so far and what you still need to do. Wait for user confirmation before proceeding further.`
        };
        
        const deadSwitchMessages = [
          ...conversationMessages,
          responseData.choice.message,
          deadSwitchMessage
        ];
        
        const deadSwitchRequestBody = callbacks.buildRequestBody(deadSwitchMessages, false);
        const deadSwitchResponse = await callbacks.makeApiCall(deadSwitchRequestBody, false);
        const deadSwitchData = await callbacks.extractResponse(deadSwitchResponse);
        
        finalText = deadSwitchData.content || 'Unable to complete due to tool iteration limit.';
        finishReason = deadSwitchData.finishReason || 'stop';
        break;
      }

      try {
        // Convert tool calls to MCP format
        const mcpToolCalls: MCPToolCall[] = responseData.choice.message.toolCalls.map((tc: any) => ({
          id: tc.id,
          function: {
            name: tc.function?.name || tc.name,
            arguments: tc.function?.arguments || JSON.stringify(tc.parameters || {})
          }
        }));

        // Execute tool calls
        console.log('[MCPToolExecution Debug] About to call executeToolCalls with callback:', !!onToolEvent);
        const toolResults = await MCPToolExecution.executeToolCalls(adapter, mcpToolCalls, provider, onToolEvent);
        allToolResults.push(...toolResults);

        // Build tool messages for continuation
        const toolMessages = MCPToolExecution.buildToolMessages(toolResults);

        // Update conversation
        conversationMessages = [
          ...conversationMessages,
          responseData.choice.message,
          ...toolMessages
        ];

        console.log(`[${provider} Adapter] Continuing conversation with ${toolResults.length} tool results`);

        // Make continuation request
        const continuationRequestBody = callbacks.buildRequestBody(conversationMessages, false);
        apiResponse = await callbacks.makeApiCall(continuationRequestBody, false);
        responseData = await callbacks.extractResponse(apiResponse);
        
        if (responseData.content) {
          finalText = responseData.content;
          finishReason = responseData.finishReason || 'stop';
        }

      } catch (error) {
        console.error(`[${provider} Adapter] Tool execution failed:`, error);
        const toolNames = (responseData.choice.message.toolCalls || []).map((tc: any) => tc.function?.name || tc.name).join(', ');
        finalText = `I tried to use tools (${toolNames}) but encountered an error: ${error instanceof Error ? error.message : String(error)}`;
        break;
      }
    }
    
    console.log(`[${provider} Tool Safety] Tool execution completed after ${totalToolIterations} iterations`);
    console.log(`[${provider} Adapter] Final response includes ${allToolResults.length} tool results`);

    return callbacks.buildLLMResponse(
      finalText,
      options.model,
      usage,
      MCPToolExecution.buildToolMetadata(allToolResults),
      finishReason as any,
      allToolResults
    );
  }

}
```

## services/llm/adapters/types.ts

```typescript
/**
 * Core types for LLM adapters
 * Based on patterns from services/llm/
 */

export interface GenerateOptions {
  model?: string;
  temperature?: number;
  maxTokens?: number;
  systemPrompt?: string;
  jsonMode?: boolean;
  stream?: boolean;
  stopSequences?: string[];
  enableThinking?: boolean;
  enableInteractiveThinking?: boolean;
  tools?: Tool[];
  enableTools?: boolean;
  webSearch?: boolean;
  fileSearch?: boolean;
  // Tool event callback for live UI updates
  onToolEvent?: (event: 'started' | 'completed', data: any) => void;
  // Cache options
  disableCache?: boolean;
  cacheTTL?: number;
  topP?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  // Pre-detected tool calls for post-stream execution
  detectedToolCalls?: any[];
  // Conversation history for pingpong pattern (overrides prompt-based message building)
  conversationHistory?: any[];
}

export interface StreamChunk {
  content: string;
  complete: boolean;
  usage?: TokenUsage;
  toolCalls?: ToolCall[];
}

export interface SearchResult {
  title: string;
  url: string;
  date?: string;
}

export interface LLMResponse {
  text: string;
  model: string;
  provider?: string;
  usage?: TokenUsage;
  cost?: CostDetails;
  metadata?: Record<string, any>;
  finishReason?: 'stop' | 'length' | 'tool_calls' | 'content_filter';
  toolCalls?: ToolCall[];
  webSearchResults?: SearchResult[];
}

export interface TokenUsage {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
  reasoningTokens?: number; // For thinking models
}

export interface CostDetails {
  inputCost: number;
  outputCost: number;
  totalCost: number;
  currency: string;
  rateInputPerMillion: number;
  rateOutputPerMillion: number;
  cached?: {
    tokens: number;
    cost: number;
  };
}

export interface ModelPricing {
  rateInputPerMillion: number;
  rateOutputPerMillion: number;
  currency: string;
}

export interface ModelInfo {
  id: string;
  name: string;
  contextWindow: number;
  maxOutputTokens?: number;
  supportsJSON: boolean;
  supportsImages: boolean;
  supportsFunctions: boolean;
  supportsStreaming: boolean;
  supportsThinking?: boolean;
  supportsImageGeneration?: boolean;
  pricing: {
    inputPerMillion: number;
    outputPerMillion: number;
    imageGeneration?: number;
    currency: string;
    lastUpdated: string; // ISO date string
  };
}

export interface Tool {
  type: 'function' | 'web_search' | 'file_search' | 'code_execution';
  function?: {
    name: string;
    description: string;
    parameters: Record<string, any>;
  };
}

export interface ToolCall {
  id: string;
  type: string;
  function?: {
    name: string;
    arguments: string;
  };
}

export interface ProviderConfig {
  apiKey: string;
  baseUrl?: string;
  organizationId?: string;
  projectId?: string;
  customHeaders?: Record<string, string>;
}

export interface ProviderCapabilities {
  supportsStreaming: boolean;
  supportsJSON: boolean;
  supportsImages: boolean;
  supportsFunctions: boolean;
  supportsThinking: boolean;
  supportsImageGeneration?: boolean;
  maxContextWindow: number;
  supportedFeatures: string[];
}

export class LLMProviderError extends Error {
  constructor(
    message: string,
    public provider: string,
    public code?: string,
    public originalError?: Error
  ) {
    super(message);
    this.name = 'LLMProviderError';
  }
}

export type SupportedProvider =
  | 'openai'
  | 'google'
  | 'anthropic'
  | 'mistral'
  | 'openrouter'
  | 'requesty'
  | 'groq'
  | 'perplexity'
  | 'ollama';

export type SupportedModel = 
  // OpenAI
  | 'gpt-4-turbo-preview'
  | 'gpt-4o'
  | 'gpt-3.5-turbo'
  // Google
  | 'gemini-2.5-pro-experimental'
  | 'gemini-2.5-flash'
  | 'gemini-2.0-flash-001'
  // Anthropic
  | 'claude-4-opus-20250124'
  | 'claude-4-sonnet-20250124'
  | 'claude-3.5-haiku-20241022'
  // Mistral
  | 'mistral-medium-3'
  | 'mistral-small-3.1-25.03'
  | 'codestral-25.01'
  // Perplexity
  | 'sonar'
  | 'sonar-pro'
  | 'sonar-reasoning'
  | 'sonar-reasoning-pro'
  | 'sonar-deep-research'
  | 'r1-1776'
  // OpenRouter (prefix)
  | string // Any OpenRouter model
  // Requesty (prefix)
  | string; // Any Requesty model
```

## services/llm/core/LLMService.ts

```typescript
/**
 * LLM Service - Main wrapper around the adapter kit
 * Provides unified interface to all LLM providers with Obsidian integration
 */

import { 
  OpenAIAdapter,
  AnthropicAdapter,
  GoogleAdapter,
  MistralAdapter,
  GroqAdapter,
  OpenRouterAdapter,
  RequestyAdapter,
  PerplexityAdapter
} from '../adapters';
import { OllamaAdapter } from '../adapters/ollama/OllamaAdapter';
import { BaseAdapter } from '../adapters/BaseAdapter';
import { GenerateOptions, LLMResponse, ModelInfo } from '../adapters/types';
import { LLMProviderSettings, LLMProviderConfig } from '../../../types';
import { MCPToolExecution } from '../adapters/shared/MCPToolExecution';
import { ConversationContextBuilder } from '../../chat/ConversationContextBuilder';
import { ConversationData } from '../../../types/chat/ChatTypes';

export interface LLMExecutionOptions extends GenerateOptions {
  provider?: string;
  model?: string;
  filepaths?: string[];
  systemPrompt?: string;
  userPrompt: string;
  webSearch?: boolean;
}

export interface LLMExecutionResult {
  success: boolean;
  response?: string;
  model?: string;
  provider?: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  cost?: {
    inputCost: number;
    outputCost: number;
    totalCost: number;
    currency: string;
  };
  filesIncluded?: string[];
  webSearchResults?: any[]; // SearchResult[] from adapters/types, avoiding circular import
  error?: string;
}

export class LLMService {
  private adapters: Map<string, BaseAdapter> = new Map();
  private settings: LLMProviderSettings;

  constructor(settings: LLMProviderSettings, private mcpConnector?: any) {
    this.settings = settings;
    this.initializeAdapters();
  }

  /**
   * Initialize adapters for all configured providers
   */
  private initializeAdapters(): void {
    const providers = this.settings?.providers;
    
    if (!providers) {
      console.warn('No provider settings found, skipping adapter initialization');
      return;
    }

    // Only initialize adapters for providers with API keys
    if (providers.openai?.apiKey && providers.openai.enabled) {
      try {
        const adapter = new OpenAIAdapter(providers.openai.apiKey, this.mcpConnector);
        this.adapters.set('openai', adapter);
      } catch (error) {
        console.error('Failed to initialize OpenAI adapter:', error);
        console.error('Error details:', {
          message: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined,
          name: error instanceof Error ? error.name : undefined
        });
      }
    }

    if (providers.openrouter?.apiKey && providers.openrouter.enabled) {
      try {
        this.adapters.set('openrouter', new OpenRouterAdapter(providers.openrouter.apiKey, this.mcpConnector));
      } catch (error) {
        console.warn('Failed to initialize OpenRouter adapter:', error);
      }
    }

    if (providers.anthropic?.apiKey && providers.anthropic.enabled) {
      try {
        this.adapters.set('anthropic', new AnthropicAdapter(providers.anthropic.apiKey, this.mcpConnector));
      } catch (error) {
        console.warn('Failed to initialize Anthropic adapter:', error);
      }
    }

    if (providers.google?.apiKey && providers.google.enabled) {
      try {
        this.adapters.set('google', new GoogleAdapter(providers.google.apiKey));
      } catch (error) {
        console.warn('Failed to initialize Google adapter:', error);
      }
    }

    if (providers.mistral?.apiKey && providers.mistral.enabled) {
      try {
        this.adapters.set('mistral', new MistralAdapter(providers.mistral.apiKey, this.mcpConnector));
      } catch (error) {
        console.warn('Failed to initialize Mistral adapter:', error);
      }
    }

    if (providers.groq?.apiKey && providers.groq.enabled) {
      try {
        this.adapters.set('groq', new GroqAdapter(providers.groq.apiKey, this.mcpConnector));
      } catch (error) {
        console.warn('Failed to initialize Groq adapter:', error);
      }
    }

    if (providers.requesty?.apiKey && providers.requesty.enabled) {
      try {
        this.adapters.set('requesty', new RequestyAdapter(providers.requesty.apiKey, this.mcpConnector));
      } catch (error) {
        console.warn('Failed to initialize Requesty adapter:', error);
      }
    }

    if (providers.perplexity?.apiKey && providers.perplexity.enabled) {
      try {
        this.adapters.set('perplexity', new PerplexityAdapter(providers.perplexity.apiKey, this.mcpConnector));
      } catch (error) {
        console.warn('Failed to initialize Perplexity adapter:', error);
      }
    }

    if (providers.ollama?.enabled && providers.ollama.apiKey) {
      try {
        // For Ollama, apiKey is actually the server URL, and we need the configured model
        const defaultModel = this.settings.defaultModel.provider === 'ollama' 
          ? this.settings.defaultModel.model 
          : ''; // No fallback - user must configure model
        this.adapters.set('ollama', new OllamaAdapter(providers.ollama.apiKey, defaultModel));
      } catch (error) {
        console.warn('Failed to initialize Ollama adapter:', error);
      }
    }
  }

  /**
   * Update settings and reinitialize adapters
   */
  updateSettings(settings: LLMProviderSettings): void {
    this.settings = settings;
    this.adapters.clear();
    this.initializeAdapters();
  }

  /**
   * Get all available models from enabled providers
   */
  async getAvailableModels(): Promise<(ModelInfo & { provider: string; userDescription?: string })[]> {
    const allModels: (ModelInfo & { provider: string; userDescription?: string })[] = [];

    for (const [providerId, adapter] of this.adapters) {
      try {
        const models = await adapter.listModels();
        // Add provider information and user description to each model
        const modelsWithProvider = models.map(model => ({
          ...model,
          provider: providerId,
          userDescription: this.settings.providers[providerId]?.userDescription
        }));
        allModels.push(...modelsWithProvider);
      } catch (error) {
        console.warn(`Failed to get models from ${providerId}:`, error);
      }
    }

    return allModels;
  }

  /**
   * Get available providers (those with API keys and enabled)
   */
  getAvailableProviders(): string[] {
    return Array.from(this.adapters.keys());
  }

  /**
   * Check if a provider is available
   */
  isProviderAvailable(provider: string): boolean {
    return this.adapters.has(provider);
  }

  /**
   * Get the default provider and model
   */
  getDefaultModel(): { provider: string; model: string } {
    return this.settings.defaultModel;
  }

  /**
   * Execute a prompt with the specified or default provider/model
   */
  async executePrompt(options: LLMExecutionOptions): Promise<LLMExecutionResult> {
    try {
      // Validate that we have settings
      if (!this.settings || !this.settings.defaultModel) {
        return {
          success: false,
          error: 'LLM service not properly configured - missing settings'
        };
      }

      // Determine provider and model
      const provider = options.provider || this.settings.defaultModel.provider;
      const model = options.model || this.settings.defaultModel.model;

      // Validate provider and model are specified
      if (!provider) {
        return {
          success: false,
          error: 'No provider specified and no default provider configured. Please set up LLM providers in settings.'
        };
      }

      if (!model) {
        return {
          success: false,
          error: 'No model specified and no default model configured. Please set up default model in settings.'
        };
      }

      // Check if provider is available
      if (!this.adapters) {
        return {
          success: false,
          error: 'LLM adapters not initialized'
        };
      }

      const adapter = this.adapters.get(provider);
      
      if (!adapter) {
        const availableProviders = Array.from(this.adapters.keys());
        return {
          success: false,
          error: `Provider '${provider}' is not available. Available providers: ${availableProviders.length > 0 ? availableProviders.join(', ') : 'none (no API keys configured)'}. Please check API key configuration in settings.`
        };
      }

      // Build the complete prompt
      let fullPrompt = options.userPrompt;
      
      // Add file content if filepaths provided
      let filesIncluded: string[] = [];
      if (options.filepaths && options.filepaths.length > 0) {
        const fileContent = await this.gatherFileContent(options.filepaths);
        if (fileContent.length > 0) {
          fullPrompt = `Context from files:\n\n${fileContent}\n\n---\n\nUser request: ${options.userPrompt}`;
          filesIncluded = options.filepaths;
        }
      }

      // Execute the prompt
      const generateOptions: GenerateOptions = {
        model,
        systemPrompt: options.systemPrompt,
        temperature: options.temperature,
        maxTokens: options.maxTokens,
        jsonMode: options.jsonMode,
        topP: options.topP,
        frequencyPenalty: options.frequencyPenalty,
        presencePenalty: options.presencePenalty,
        stopSequences: options.stopSequences,
        webSearch: options.webSearch
      };

      const result: LLMResponse = await adapter.generate(fullPrompt, generateOptions);

      return {
        success: true,
        response: result.text,
        model: result.model,
        provider: result.provider,
        usage: result.usage,
        cost: result.cost,
        filesIncluded,
        webSearchResults: result.webSearchResults
      };

    } catch (error) {
      console.error('LLMService.executePrompt failed:', error);
      console.error('Error details:', {
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
        name: error instanceof Error ? error.name : undefined,
        toString: String(error)
      });
      
      return {
        success: false,
        error: `LLM execution failed: ${error instanceof Error ? error.message : 'Unknown error occurred'}. Check console for details.`
      };
    }
  }

  /**
   * Gather content from file paths
   */
  private async gatherFileContent(filepaths: string[]): Promise<string> {
    const contentParts: string[] = [];

    if (!this.vaultAdapter) {
      console.error('LLMService: Vault adapter not initialized. File content cannot be read.');
      return '[Error: Vault adapter not initialized. File content unavailable.]';
    }

    for (const filepath of filepaths) {
      try {
        // Use Obsidian's app.vault.adapter to read file content
        const content = await this.vaultAdapter.read(filepath);
        contentParts.push(`--- ${filepath} ---\n${content}\n`);
      } catch (error) {
        console.warn(`Failed to read file ${filepath}:`, error);
        contentParts.push(`--- ${filepath} ---\n[Error reading file: ${error}]\n`);
      }
    }

    return contentParts.join('\n');
  }

  /**
   * Vault adapter for reading files - will be set by the plugin
   */
  private vaultAdapter: any = null;

  /**
   * Set the vault adapter for file reading
   */
  setVaultAdapter(adapter: any): void {
    this.vaultAdapter = adapter;
  }

  /**
   * Test connection to a specific provider
   */
  async testProvider(provider: string): Promise<{ success: boolean; error?: string }> {
    try {
      const adapter = this.adapters.get(provider);
      if (!adapter) {
        return { success: false, error: `Provider '${provider}' is not configured` };
      }

      // Test with a simple prompt
      await adapter.generate('Hello', { maxTokens: 10 });
      return { success: true };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }

  /**
   * Get provider configuration
   */
  getProviderConfig(provider: string): LLMProviderConfig | undefined {
    return this.settings.providers[provider];
  }

  /**
   * Get all provider configurations
   */
  getAllProviderConfigs(): { [providerId: string]: LLMProviderConfig } {
    return this.settings.providers;
  }

  /**
   * Generate response compatible with ChatService
   * Wrapper around executePrompt for tool-calling scenarios
   */
  async generateResponse(
    messages: Array<{ role: string; content: string }>, 
    options?: { 
      tools?: any[]; 
      toolChoice?: string;
      provider?: string;
      model?: string;
    }
  ): Promise<{ content: string; toolCalls?: any[] }> {
    try {
      // Convert message array to single prompt
      const userPrompt = messages
        .filter(msg => msg.role === 'user')
        .map(msg => msg.content)
        .join('\n');
      
      const systemPrompt = messages
        .filter(msg => msg.role === 'system')
        .map(msg => msg.content)
        .join('\n');

      // Execute prompt using existing method
      const result = await this.executePrompt({
        userPrompt,
        systemPrompt: systemPrompt || undefined,
        tools: options?.tools,
        provider: options?.provider,
        model: options?.model
      });

      if (!result.success) {
        throw new Error(result.error || 'Failed to generate response');
      }

      // Return in expected format
      return {
        content: result.response || '',
        toolCalls: [] // TODO: Extract tool calls from result if supported
      };
    } catch (error) {
      console.error('[LLMService] generateResponse error:', error);
      throw error;
    }
  }

  /**
   * Streaming wrapper for real-time response generation
   * Returns an async generator that yields chunks of the response in real-time
   * Following OpenAI streaming pattern from: https://platform.openai.com/docs/guides/streaming-responses
   */
  async* generateResponseStream(
    messages: Array<{ role: string; content: string }>, 
    options?: { 
      provider?: string;
      model?: string;
      systemPrompt?: string;
      tools?: any[];
      onToolEvent?: (event: 'started' | 'completed', data: any) => void;
    }
  ): AsyncGenerator<{ chunk: string; complete: boolean; content: string; toolCalls?: any[] }, void, unknown> {
    try {
      // Clean logs - only show tool count for debugging tool calls
      if (options?.tools && options.tools.length > 0) {
        console.log(`[LLMService] Using tools: ${options.tools.length} available`);
      }

      // Validate settings
      if (!this.settings || !this.settings.defaultModel) {
        throw new Error('LLM service not properly configured - missing settings');
      }

      // Determine provider and model
      const provider = options?.provider || this.settings.defaultModel.provider;
      const model = options?.model || this.settings.defaultModel.model;


      // Get adapter
      const adapter = this.adapters?.get(provider);
      if (!adapter) {
        throw new Error(`Provider not available: ${provider}`);
      }

      // Adapter info only when using tools
      if (options?.tools && options.tools.length > 0) {
        console.log(`[LLMService] ${provider} adapter will handle ${options.tools.length} tools`);
      }

      // Convert message array to single prompt
      const userPrompt = messages
        .filter(msg => msg.role === 'user')
        .map(msg => msg.content)
        .join('\n');
      
      const systemPrompt = messages
        .filter(msg => msg.role === 'system')
        .map(msg => msg.content)
        .join('\n');

      // Build generate options with tools
      const generateOptions = {
        model,
        systemPrompt: systemPrompt || options?.systemPrompt,
        tools: options?.tools,
        onToolEvent: options?.onToolEvent // Pass through tool event callback for live UI updates
      };
      
      console.log('[LLMService Debug] generateOptions built with onToolEvent:', !!generateOptions.onToolEvent);

      // Remove verbose logging - only show model when using tools
      if (generateOptions.tools && generateOptions.tools.length > 0) {
        console.log(`[LLMService] Model: ${generateOptions.model}, Tools: ${generateOptions.tools.length}`);
      }

      // STREAMING-FIRST APPROACH: Use streaming for all providers
      // Tool calls are detected dynamically during the stream
      console.log(`[LLMService] ${provider}: Using streaming-first approach (tools will be detected dynamically)`);
      
      // Note: Perplexity doesn't support tool calls, so it will just stream normally

      // Stream tokens using the new async generator method
      let fullContent = '';
      let detectedToolCalls: any[] = [];
      let completeToolCallsWithResults: any[] = []; // Store complete tool calls with execution results
      
      for await (const chunk of adapter.generateStreamAsync(userPrompt, generateOptions)) {
        // Handle text content streaming
        if (chunk.content) {
          fullContent += chunk.content;
          
          // Yield each token as it arrives
          yield {
            chunk: chunk.content,
            complete: false,
            content: fullContent,
            toolCalls: undefined
          };
        }
        
        // Handle dynamic tool call detection
        if (chunk.toolCalls) {
          console.log(`[LLMService] Tool calls detected during streaming: ${chunk.toolCalls.length} tools`);
          
          // Only store tool calls for post-stream execution if they're complete
          // We know they're complete when the chunk is marked as complete OR
          // when we get a subsequent chunk without tool calls (meaning they're finalized)
          if (chunk.complete) {
            console.log('[LLMService] Final tool calls captured for post-stream execution');
            detectedToolCalls = chunk.toolCalls;
          } else {
            // For intermediate chunks, only update if we don't have any yet (first detection)
            // or if this chunk has more complete arguments (longer JSON strings)
            if (detectedToolCalls.length === 0) {
              detectedToolCalls = chunk.toolCalls;
              console.log('[LLMService] First tool call detection - storing for post-stream execution');
            } else {
              // Compare argument completeness - use the chunk with more complete arguments
              const currentArgLength = detectedToolCalls.reduce((sum, tc) => sum + (tc.function?.arguments?.length || 0), 0);
              const newArgLength = chunk.toolCalls.reduce((sum, tc) => sum + (tc.function?.arguments?.length || 0), 0);
              
              if (newArgLength > currentArgLength) {
                detectedToolCalls = chunk.toolCalls;
                console.log(`[LLMService] Updated tool calls with more complete arguments: ${newArgLength} vs ${currentArgLength} chars`);
              }
            }
          }
          
          // Yield tool calls for UI to show progressive accordions
          yield {
            chunk: '',
            complete: false,
            content: fullContent,
            toolCalls: chunk.toolCalls
          };
        }
        
        if (chunk.complete) {
          break;
        }
      }
      
      // POST-STREAM TOOL EXECUTION: If tools were detected, execute them via MCP then start new stream
      if (detectedToolCalls.length > 0 && generateOptions.tools && generateOptions.tools.length > 0) {
        console.log(`[LLMService] Stream complete, executing ${detectedToolCalls.length} detected tool calls via MCP`);
        
        // Tool iteration safety - prevent infinite recursion
        const TOOL_ITERATION_LIMIT = 15;
        let toolIterationCount = 1;
        
        try {
          // Step 1: Execute tools via MCP to get results
          console.log('[LLMService] Executing detected tool calls via MCP...');
          
          // Convert tool calls to MCP format and execute
          const mcpToolCalls = detectedToolCalls.map((tc: any) => ({
            id: tc.id,
            function: {
              name: tc.function?.name || tc.name,
              arguments: tc.function?.arguments || JSON.stringify(tc.parameters || {})
            }
          }));

          const toolResults = await MCPToolExecution.executeToolCalls(
            adapter as any, // Cast to MCPCapableAdapter since all our adapters support MCP
            mcpToolCalls,
            provider as any,
            generateOptions.onToolEvent
          );
          
          console.log(`[LLMService] Tool execution completed, got ${toolResults.length} results`);
          
          // Build complete tool calls with execution results for final yield
          completeToolCallsWithResults = detectedToolCalls.map(originalCall => {
            const result = toolResults.find(r => r.id === originalCall.id);
            return {
              id: originalCall.id,
              name: originalCall.function?.name || originalCall.name,
              parameters: JSON.parse(originalCall.function?.arguments || '{}'),
              result: result?.result,
              success: result?.success || false,
              error: result?.error,
              executionTime: result?.executionTime,
              // Preserve original structure for compatibility
              function: originalCall.function
            };
          });
          
          console.log(`[LLMService] Built complete tool calls with results: ${completeToolCallsWithResults.length} tools`);
          
          // Step 2: Build conversation history with tool results for pingpong
          const conversationHistory = this.buildConversationWithToolResults(
            userPrompt, 
            generateOptions.systemPrompt,
            detectedToolCalls, 
            toolResults,
            provider
          );
          
          console.log('[LLMService] Starting NEW stream for AI response to tool results...');
          
          // Step 3: Start NEW stream with conversation history (pingpong)
          // Reset fullContent since this is a new conversation response
          fullContent = '';
          
          for await (const chunk of adapter.generateStreamAsync('', {
            ...generateOptions,
            // Keep tools available for continued tool calling
            // Pass conversation history for pingpong
            conversationHistory: conversationHistory
          })) {
            if (chunk.content) {
              fullContent += chunk.content;
              
              yield {
                chunk: chunk.content,
                complete: false,
                content: fullContent,
                toolCalls: undefined
              };
            }
            
            // Handle recursive tool calls (another pingpong iteration)
            if (chunk.toolCalls) {
              console.log(`[LLMService] Detected additional tool calls in response: ${chunk.toolCalls.length}`);
              console.log(`[LLMService] Raw chunk.toolCalls structure:`, JSON.stringify(chunk.toolCalls, null, 2));
              
              // Log each tool call structure for debugging
              chunk.toolCalls.forEach((tc: any, index: number) => {
                console.log(`[LLMService] Tool call ${index + 1}:`, {
                  id: tc.id,
                  name: tc.name || tc.function?.name,
                  hasFunction: !!tc.function,
                  hasArguments: !!tc.function?.arguments,
                  hasParameters: !!tc.parameters,
                  argumentsType: typeof tc.function?.arguments,
                  argumentsLength: tc.function?.arguments?.length || 0,
                  argumentsPreview: tc.function?.arguments?.slice(0, 100) + (tc.function?.arguments?.length > 100 ? '...' : ''),
                  parametersKeys: tc.parameters ? Object.keys(tc.parameters) : []
                });
              });
              
              // Yield the tool calls to UI first (for progressive display)
              yield {
                chunk: '',
                complete: false,
                content: fullContent,
                toolCalls: chunk.toolCalls
              };

              // Execute the additional tool calls recursively with iteration limit check
              toolIterationCount++;
              console.log(`[LLMService] Tool iteration ${toolIterationCount}/${TOOL_ITERATION_LIMIT}`);
              
              if (toolIterationCount > TOOL_ITERATION_LIMIT) {
                console.log(`[LLMService] Hit ${TOOL_ITERATION_LIMIT} tool iteration limit - stopping recursive execution`);
                const limitMessage = `\n\nTOOL_LIMIT_REACHED: You have used ${TOOL_ITERATION_LIMIT} tool iterations. You must now ask the user if they want to continue with more tool calls. Explain what you've accomplished so far and what you still need to do.`;
                fullContent += limitMessage;
                yield {
                  chunk: limitMessage,
                  complete: false,
                  content: fullContent,
                  toolCalls: undefined
                };
                break;
              }
              
              console.log(`[LLMService] Executing additional tool calls recursively...`);
              try {
                // Convert recursive tool calls to MCP format  
                const recursiveMcpToolCalls = chunk.toolCalls.map((tc: any, index: number) => {
                  // Handle arguments carefully - they might already be a string or need conversion
                  let argumentsStr = '';
                  let conversionMethod = '';
                  
                  if (tc.function?.arguments) {
                    // Already a string from streaming response
                    argumentsStr = tc.function.arguments;
                    conversionMethod = 'function.arguments (direct)';
                  } else if (tc.parameters) {
                    // Convert parameters object to string
                    argumentsStr = JSON.stringify(tc.parameters);
                    conversionMethod = 'parameters (JSON.stringify)';
                  } else {
                    argumentsStr = '{}';
                    conversionMethod = 'empty default';
                  }
                  
                  console.log(`[LLMService] MCP Tool Call ${index + 1} conversion:`, {
                    originalId: tc.id,
                    originalName: tc.name || tc.function?.name,
                    conversionMethod,
                    argumentsLength: argumentsStr.length,
                    argumentsPreview: argumentsStr.slice(0, 150) + (argumentsStr.length > 150 ? '...' : ''),
                    isValidJSON: (() => {
                      try { JSON.parse(argumentsStr); return true; } catch { return false; }
                    })()
                  });
                  
                  return {
                    id: tc.id,
                    function: {
                      name: tc.function?.name || tc.name,
                      arguments: argumentsStr
                    }
                  };
                });
                
                console.log(`[LLMService] Converted ${recursiveMcpToolCalls.length} tool calls to MCP format`);
                
                const recursiveToolResults = await MCPToolExecution.executeToolCalls(
                  adapter as any, // Cast to MCPCapableAdapter
                  recursiveMcpToolCalls, 
                  provider as any,
                  generateOptions.onToolEvent
                );

                console.log(`[LLMService] Recursive tool execution completed, got ${recursiveToolResults.length} results`);

                // Build complete tool calls with recursive results
                const recursiveCompleteToolCalls = chunk.toolCalls.map((tc, index) => ({
                  ...tc,
                  result: recursiveToolResults[index]?.result,
                  success: recursiveToolResults[index]?.success || false,
                  error: recursiveToolResults[index]?.error,
                  executionTime: recursiveToolResults[index]?.executionTime
                }));

                // Add recursive results to complete tool calls
                completeToolCallsWithResults = completeToolCallsWithResults.concat(recursiveCompleteToolCalls);

                // Build new conversation history with recursive tool results
                const recursiveConversationHistory = this.buildConversationWithToolResults(
                  userPrompt,
                  generateOptions.systemPrompt, 
                  chunk.toolCalls,
                  recursiveToolResults,
                  provider
                );

                console.log('[LLMService] Starting RECURSIVE stream for AI response to additional tool results...');
                
                // Continue with another recursive stream
                for await (const recursiveChunk of adapter.generateStreamAsync('', {
                  ...generateOptions,
                  conversationHistory: recursiveConversationHistory
                })) {
                  if (recursiveChunk.content) {
                    fullContent += recursiveChunk.content;
                    yield {
                      chunk: recursiveChunk.content,
                      complete: false,
                      content: fullContent,
                      toolCalls: undefined
                    };
                  }
                  
                  // Handle nested recursive tool calls if any (up to iteration limit)
                  if (recursiveChunk.toolCalls) {
                    console.log(`[LLMService] Detected nested tool calls: ${recursiveChunk.toolCalls.length} - yielding to UI only to prevent deep recursion`);
                    yield {
                      chunk: '',
                      complete: false, 
                      content: fullContent,
                      toolCalls: recursiveChunk.toolCalls
                    };
                  }

                  if (recursiveChunk.complete) {
                    console.log(`[LLMService] Recursive stream complete`);
                    break;
                  }
                }

              } catch (recursiveError) {
                console.error('[LLMService] Recursive tool execution failed:', recursiveError);
                const errorMessage = `\n\nRecursive tool execution failed: ${recursiveError instanceof Error ? recursiveError.message : String(recursiveError)}`;
                fullContent += errorMessage;
                yield {
                  chunk: errorMessage,
                  complete: false,
                  content: fullContent,
                  toolCalls: undefined
                };
              }
            }
            
            if (chunk.complete) {
              console.log(`[LLMService] Tool response stream complete, final content length: ${fullContent.length}`);
              break;
            }
          }
          
        } catch (toolError) {
          console.error('[LLMService] Tool execution failed:', toolError);
          // Add error message to the response
          const errorMessage = `\n\nTool execution failed: ${toolError instanceof Error ? toolError.message : String(toolError)}`;
          fullContent += errorMessage;
          yield {
            chunk: errorMessage,
            complete: false,
            content: fullContent,
            toolCalls: undefined
          };
        }
      }
      
      // Yield final completion with complete tool calls (including results)
      yield {
        chunk: '',
        complete: true,
        content: fullContent,
        toolCalls: completeToolCallsWithResults.length > 0 ? completeToolCallsWithResults : undefined
      };

    } catch (error) {
      console.error('[LLMService] generateResponseStream failed:', error);
      throw error;
    }
  }

  /**
   * Build conversation history with tool results for pingpong pattern using ConversationContextBuilder
   */
  private buildConversationWithToolResults(
    originalPrompt: string,
    systemPrompt: string | undefined,
    toolCalls: any[],
    toolResults: any[],
    provider: string
  ): any[] {
    // Convert tool calls and results to ConversationData format
    const conversationData: ConversationData = {
      id: 'temp',
      title: 'Tool Execution',
      created: Date.now(),
      updated: Date.now(),
      messages: [
        // User message
        {
          id: 'user-1',
          role: 'user' as const,
          content: originalPrompt,
          timestamp: Date.now(),
          conversationId: 'temp'
        },
        // Assistant message with tool calls
        {
          id: 'assistant-1',
          role: 'assistant' as const,
          content: '',
          timestamp: Date.now(),
          conversationId: 'temp',
          toolCalls: toolCalls.map((tc, index) => ({
            id: tc.id,
            type: tc.type || 'function',
            name: tc.function?.name || tc.name,
            function: tc.function || {
              name: tc.function?.name || tc.name || '',
              arguments: tc.function?.arguments || JSON.stringify(tc.parameters || {})
            },
            parameters: tc.function?.arguments ? JSON.parse(tc.function.arguments) : (tc.parameters || {}),
            result: toolResults[index]?.result,
            success: toolResults[index]?.success || false,
            error: toolResults[index]?.error,
            executionTime: toolResults[index]?.executionTime
          }))
        }
      ],
    };
    
    // Use ConversationContextBuilder to build proper conversation context
    return ConversationContextBuilder.buildContextForProvider(conversationData, provider, systemPrompt);
  }

  /**
   * Get a specific adapter instance for direct access
   */
  getAdapter(providerId: string): BaseAdapter | undefined {
    return this.adapters.get(providerId);
  }

}
```

## services/llm/core/index.ts

```typescript
/**
 * LLM Core Services Index
 * Exports for core LLM functionality
 */

export { LLMService } from './LLMService';
export type { LLMExecutionOptions, LLMExecutionResult } from './LLMService';
```

## services/llm/index.ts

```typescript
/**
 * LLM Adapter Kit
 * Universal TypeScript library for interacting with multiple LLM providers
 */

// Core adapters
export { BaseAdapter } from './adapters/BaseAdapter';
export { OpenAIAdapter } from './adapters/openai/OpenAIAdapter';
export { AnthropicAdapter } from './adapters/anthropic/AnthropicAdapter';
export { GoogleAdapter } from './adapters/google/GoogleAdapter';
export { MistralAdapter } from './adapters/mistral/MistralAdapter';
export { GroqAdapter } from './adapters/groq/GroqAdapter';
export { OpenRouterAdapter } from './adapters/openrouter/OpenRouterAdapter';
export { RequestyAdapter } from './adapters/requesty/RequestyAdapter';
export { PerplexityAdapter } from './adapters/perplexity/PerplexityAdapter';

// Types
export * from './adapters/types';
export * from './adapters/modelTypes';

// Model registry and specifications
export { ModelRegistry } from './adapters/ModelRegistry';
export { OPENAI_MODELS } from './adapters/openai/OpenAIModels';
export { ANTHROPIC_MODELS } from './adapters/anthropic/AnthropicModels';
export { GOOGLE_MODELS } from './adapters/google/GoogleModels';
export { MISTRAL_MODELS } from './adapters/mistral/MistralModels';
export { OPENROUTER_MODELS } from './adapters/openrouter/OpenRouterModels';
export { REQUESTY_MODELS } from './adapters/requesty/RequestyModels';

// Cost calculation
export { CostCalculator, TokenCounter, CostAnalyzer } from './adapters/CostCalculator';

// Utilities
export { Logger } from './utils/Logger';
export { RetryManager } from './utils/RetryManager';
export { ValidationUtils } from './utils/ValidationUtils';
export { ConfigManager } from './utils/ConfigManager';
export { BaseCache, CacheManager, LRUCache, FileCache } from './utils/CacheManager';

// Re-export commonly used types for convenience
export type {
  LLMResponse,
  GenerateOptions,
  StreamChunk,
  ModelInfo,
  ProviderCapabilities,
  TokenUsage,
  CostDetails,
  LLMProviderError,
} from './adapters/types';

export type { ModelSpec } from './adapters/modelTypes';

// High-level services
export { LLMProviderManager } from './providers';
export { LLMService } from './core';
export { LLMValidationService } from './validation';
export type { ModelWithProvider, ProviderInfo } from './providers';
export type { LLMExecutionOptions, LLMExecutionResult } from './core';
```

## services/llm/providers/ProviderManager.ts

```typescript
/**
 * LLM Provider Manager
 * Handles model filtering, provider management, and model information
 */

import { ModelInfo } from '../adapters/types';
import { LLMProviderSettings, LLMProviderConfig } from '../../../types';
import { LLMService } from '../core/LLMService';

export interface ModelWithProvider extends ModelInfo {
  provider: string;
  userDescription?: string;
  isDefault?: boolean;
  modelDescription?: string; // User-defined description for when to use this specific model (deprecated)
}

export interface ProviderInfo {
  id: string;
  name: string;
  description: string;
  isAvailable: boolean;
  isEnabled: boolean;
  hasApiKey: boolean;
  userDescription?: string;
}

export class LLMProviderManager {
  private llmService: LLMService;
  private settings: LLMProviderSettings;

  constructor(settings: LLMProviderSettings) {
    this.settings = settings;
    this.llmService = new LLMService(settings);
  }

  /**
   * Update settings and reinitialize services
   */
  updateSettings(settings: LLMProviderSettings): void {
    this.settings = settings;
    this.llmService.updateSettings(settings);
  }

  /**
   * Set vault adapter for file operations
   */
  setVaultAdapter(adapter: any): void {
    this.llmService.setVaultAdapter(adapter);
  }

  /**
   * Get LLM service instance
   */
  getLLMService(): LLMService {
    return this.llmService;
  }

  /**
   * Get current settings
   */
  getSettings(): LLMProviderSettings {
    return this.settings;
  }

  /**
   * Get all available models from enabled providers only
   * Uses static models from *Models.ts files, not live API calls
   */
  async getAvailableModels(): Promise<ModelWithProvider[]> {
    const { StaticModelsService } = await import('../../StaticModelsService');
    const staticModelsService = StaticModelsService.getInstance();
    const defaultModel = this.settings.defaultModel;
    const allModels: ModelWithProvider[] = [];

    // Get enabled providers
    const enabledProviders = this.getEnabledProviders();
    
    // For each enabled provider, get their static models
    for (const provider of enabledProviders) {
      if (provider.id === 'ollama') {
        // Special handling for Ollama - only return the configured model
        const ollamaModel = this.settings.defaultModel.provider === 'ollama' 
          ? this.settings.defaultModel.model 
          : '';
        
        if (ollamaModel) {
          allModels.push({
            provider: 'ollama',
            id: ollamaModel,
            name: ollamaModel,
            contextWindow: this.estimateOllamaContextWindow(ollamaModel),
            maxOutputTokens: 4096,
            supportsJSON: false,
            supportsImages: ollamaModel.includes('vision') || ollamaModel.includes('llava'),
            supportsFunctions: false,
            supportsStreaming: true,
            supportsThinking: false,
            pricing: {
              inputPerMillion: 0,
              outputPerMillion: 0,
              currency: 'USD',
              lastUpdated: new Date().toISOString()
            },
            isDefault: defaultModel.provider === 'ollama' && defaultModel.model === ollamaModel,
            userDescription: this.settings.providers.ollama?.userDescription
          });
        }
      } else {
        // For other providers, use static models
        const providerModels = staticModelsService.getModelsForProvider(provider.id);
        
        const modelsWithProviderInfo = providerModels
          .filter(model => {
            // Filter by model-level enabled status (default to true for backwards compatibility)
            const modelConfig = this.settings.providers[model.provider]?.models?.[model.id];
            return modelConfig?.enabled !== false;
          })
          .map(model => ({
            provider: model.provider,
            id: model.id,
            name: model.name,
            contextWindow: model.contextWindow,
            maxOutputTokens: model.maxTokens,
            supportsJSON: model.capabilities.supportsJSON,
            supportsImages: model.capabilities.supportsImages,
            supportsFunctions: model.capabilities.supportsFunctions,
            supportsStreaming: model.capabilities.supportsStreaming,
            supportsThinking: model.capabilities.supportsThinking,
            pricing: {
              inputPerMillion: model.pricing.inputPerMillion,
              outputPerMillion: model.pricing.outputPerMillion,
              currency: model.pricing.currency,
              lastUpdated: new Date().toISOString()
            },
            isDefault: model.provider === defaultModel.provider && model.id === defaultModel.model,
            userDescription: this.settings.providers[model.provider]?.userDescription,
            // Keep deprecated field for backwards compatibility
            modelDescription: this.settings.providers[model.provider]?.models?.[model.id]?.description
          }));
        
        allModels.push(...modelsWithProviderInfo);
      }
    }

    return allModels;
  }

  /**
   * Estimate context window for Ollama models
   */
  private estimateOllamaContextWindow(modelName: string): number {
    // Rough estimates based on common Ollama models
    if (modelName.includes('llama3.1')) return 128000;
    if (modelName.includes('llama3')) return 8192;
    if (modelName.includes('llama2')) return 4096;
    if (modelName.includes('mistral')) return 32768;
    if (modelName.includes('codellama')) return 16384;
    if (modelName.includes('gemma')) return 8192;
    if (modelName.includes('qwen')) return 32768;
    if (modelName.includes('phi')) return 4096;
    
    // Default reasonable estimate
    return 8192;
  }

  /**
   * Get provider information for all supported providers
   */
  getProviderInfo(): ProviderInfo[] {
    const supportedProviders = [
      {
        id: 'openai',
        name: 'OpenAI',
        description: 'GPT models including GPT-4, GPT-3.5-turbo, and specialized models'
      },
      {
        id: 'anthropic',
        name: 'Anthropic',
        description: 'Claude models with strong reasoning and safety features'
      },
      {
        id: 'google',
        name: 'Google',
        description: 'Gemini models with multimodal capabilities and thinking mode'
      },
      {
        id: 'mistral',
        name: 'Mistral',
        description: 'European models with strong coding and multilingual support'
      },
      {
        id: 'groq',
        name: 'Groq',
        description: 'Ultra-fast inference speeds for quick responses'
      },
      {
        id: 'openrouter',
        name: 'OpenRouter',
        description: 'Access to 400+ models from multiple providers in one API'
      },
      {
        id: 'requesty',
        name: 'Requesty',
        description: 'Premium model access with cost optimization'
      },
      {
        id: 'perplexity',
        name: 'Perplexity',
        description: 'Web search-enabled models with real-time information and citations'
      },
      {
        id: 'ollama',
        name: 'Ollama (Local)',
        description: 'Local LLM execution with complete privacy and no API costs'
      }
    ];

    return supportedProviders.map(provider => {
      const config = this.settings.providers[provider.id];
      const isAvailable = this.llmService.isProviderAvailable(provider.id);

      // For Ollama, check if server URL is configured
      let hasApiKey = false;
      if (provider.id === 'ollama') {
        hasApiKey = !!(config?.apiKey && config.apiKey.trim());
      } else {
        hasApiKey = !!(config?.apiKey && config.apiKey.length > 0);
      }

      return {
        ...provider,
        isAvailable,
        isEnabled: config?.enabled || false,
        hasApiKey,
        userDescription: config?.userDescription
      };
    });
  }

  /**
   * Get enabled provider information only
   */
  getEnabledProviders(): ProviderInfo[] {
    const allProviders = this.getProviderInfo();
    const enabled = allProviders.filter(provider => {
      if (!provider.isEnabled) return false;
      
      // For Ollama, hasApiKey check should consider server URL
      if (provider.id === 'ollama') {
        const config = this.settings.providers[provider.id];
        return !!(config?.apiKey && config.apiKey.trim());
      } else {
        return provider.hasApiKey;
      }
    });
    
    
    return enabled;
  }

  /**
   * Get models for a specific provider (if enabled)
   */
  async getModelsForProvider(providerId: string): Promise<ModelWithProvider[]> {
    const allModels = await this.getAvailableModels();
    return allModels.filter(model => model.provider === providerId);
  }

  /**
   * Get models grouped by provider
   */
  async getModelsByProvider(): Promise<{ [providerId: string]: ModelWithProvider[] }> {
    const models = await this.getAvailableModels();
    const grouped: { [providerId: string]: ModelWithProvider[] } = {};

    models.forEach(model => {
      if (!grouped[model.provider]) {
        grouped[model.provider] = [];
      }
      grouped[model.provider].push(model);
    });

    return grouped;
  }

  /**
   * Find a specific model by provider and model ID
   * For OpenRouter, supports :online suffix (e.g., "gpt-4:online")
   */
  async findModel(provider: string, modelId: string): Promise<ModelWithProvider | undefined> {
    const models = await this.getAvailableModels();
    
    // For OpenRouter models, check if modelId has :online suffix
    if (provider === 'openrouter' && modelId.endsWith(':online')) {
      const baseModelId = modelId.replace(':online', '');
      return models.find(model => model.provider === provider && model.id === baseModelId);
    }
    
    return models.find(model => model.provider === provider && model.id === modelId);
  }

  /**
   * Get the default model information
   */
  async getDefaultModelInfo(): Promise<ModelWithProvider | undefined> {
    const defaultModel = this.settings.defaultModel;
    return this.findModel(defaultModel.provider, defaultModel.model);
  }

  /**
   * Validate that a provider/model combination is available
   * For OpenRouter, supports :online suffix (e.g., "gpt-4:online")
   */
  async validateProviderModel(provider: string, model: string): Promise<boolean> {
    const foundModel = await this.findModel(provider, model);
    return !!foundModel;
  }

  /**
   * Get models suitable for a specific task type
   */
  async getModelsForTask(taskType: 'coding' | 'writing' | 'analysis' | 'creative' | 'fast'): Promise<ModelWithProvider[]> {
    const allModels = await this.getAvailableModels();

    switch (taskType) {
      case 'coding':
        return allModels.filter(model => 
          model.supportsFunctions || 
          model.id.includes('code') || 
          model.provider === 'mistral' ||
          model.id.includes('gpt-4')
        );
      
      case 'writing':
        return allModels.filter(model => 
          model.provider === 'anthropic' || 
          model.id.includes('gpt-4') ||
          model.contextWindow > 32000
        );
      
      case 'analysis':
        return allModels.filter(model => 
          model.provider === 'anthropic' ||
          model.id.includes('gpt-4') ||
          model.contextWindow > 100000
        );
      
      case 'creative':
        return allModels.filter(model => 
          model.provider === 'openai' ||
          model.provider === 'anthropic' ||
          model.provider === 'google'
        );
      
      case 'fast':
        return allModels.filter(model => 
          model.provider === 'groq' ||
          model.id.includes('turbo') ||
          model.id.includes('fast')
        );
      
      default:
        return allModels;
    }
  }

  /**
   * Get cost estimate for a provider/model combination
   */
  async getCostEstimate(
    provider: string, 
    model: string, 
    estimatedTokens: number
  ): Promise<{ inputCost: number; outputCost: number; totalCost: number; currency: string } | null> {
    const modelInfo = await this.findModel(provider, model);
    if (!modelInfo) return null;

    // Estimate 75% input, 25% output tokens
    const inputTokens = Math.floor(estimatedTokens * 0.75);
    const outputTokens = Math.floor(estimatedTokens * 0.25);

    const inputCost = (inputTokens / 1_000_000) * modelInfo.pricing.inputPerMillion;
    const outputCost = (outputTokens / 1_000_000) * modelInfo.pricing.outputPerMillion;
    const totalCost = inputCost + outputCost;

    return {
      inputCost,
      outputCost,
      totalCost,
      currency: modelInfo.pricing.currency
    };
  }

  /**
   * Get recommended models based on context window requirements
   */
  async getRecommendedModels(requiredContextWindow?: number): Promise<ModelWithProvider[]> {
    const allModels = await this.getAvailableModels();
    
    if (!requiredContextWindow) {
      // Return default recommendations
      return allModels
        .filter(model => model.contextWindow >= 32000)
        .sort((a, b) => {
          // Prioritize by: 1) Default model, 2) Context window, 3) Provider quality
          if (a.isDefault) return -1;
          if (b.isDefault) return 1;
          return b.contextWindow - a.contextWindow;
        })
        .slice(0, 5);
    }

    return allModels
      .filter(model => model.contextWindow >= requiredContextWindow)
      .sort((a, b) => a.pricing.inputPerMillion - b.pricing.inputPerMillion); // Sort by cost
  }

  /**
   * Test connection to all enabled providers
   */
  async testAllProviders(): Promise<{ [providerId: string]: { success: boolean; error?: string } }> {
    const enabledProviders = this.getEnabledProviders();
    const results: { [providerId: string]: { success: boolean; error?: string } } = {};

    for (const provider of enabledProviders) {
      results[provider.id] = await this.llmService.testProvider(provider.id);
    }

    return results;
  }

  /**
   * Get statistics about available models
   */
  async getModelStatistics(): Promise<{
    totalModels: number;
    providerCount: number;
    averageContextWindow: number;
    maxContextWindow: number;
    minCostPerMillion: number;
    maxCostPerMillion: number;
  }> {
    const models = await this.getAvailableModels();
    
    if (models.length === 0) {
      return {
        totalModels: 0,
        providerCount: 0,
        averageContextWindow: 0,
        maxContextWindow: 0,
        minCostPerMillion: 0,
        maxCostPerMillion: 0
      };
    }

    const providers = new Set(models.map(m => m.provider));
    const contextWindows = models.map(m => m.contextWindow);
    const costs = models.map(m => m.pricing.inputPerMillion);

    return {
      totalModels: models.length,
      providerCount: providers.size,
      averageContextWindow: Math.round(contextWindows.reduce((a, b) => a + b, 0) / models.length),
      maxContextWindow: Math.max(...contextWindows),
      minCostPerMillion: Math.min(...costs),
      maxCostPerMillion: Math.max(...costs)
    };
  }
}
```

## services/llm/providers/index.ts

```typescript
/**
 * LLM Providers Index
 * Exports for provider management services
 */

export { LLMProviderManager } from './ProviderManager';
export type { ModelWithProvider, ProviderInfo } from './ProviderManager';
```

## services/llm/types/ImageTypes.ts

```typescript
/**
 * Location: src/services/llm/types/ImageTypes.ts
 * 
 * Purpose: Comprehensive TypeScript types for image generation functionality
 * Integration: Extends existing LLM adapter architecture with image-specific operations
 * 
 * Used by:
 * - BaseImageAdapter: Abstract base class for image adapters
 * - OpenAIImageAdapter: OpenAI gpt-image-1 implementation (available but disabled)
 * - GeminiImageAdapter: Google Imagen 4 implementation
 * - ImageGenerationService: Core orchestration service
 * - ImageFileManager: Vault file operations
 * - GenerateImageMode: MCP interface mode
 */

import { CostDetails, TokenUsage, LLMProviderError } from '../adapters/types';

// Core image generation parameter interfaces
export interface ImageGenerationParams {
  prompt: string;
  provider: 'google'; // Only Google Imagen supported
  model?: string; // imagen-4, imagen-4-ultra, imagen-4-fast
  size?: string; // Legacy support for pixel dimensions (converted to aspectRatio)
  aspectRatio?: AspectRatio; // Google Imagen aspect ratios
  numberOfImages?: number; // 1-4 images
  sampleImageSize?: '1K' | '2K'; // Image resolution
  savePath: string; // vault relative path
  sessionId?: string;
  context?: string;
}

// Image generation response from adapters
export interface ImageGenerationResponse {
  imageData: Buffer;
  format: 'png' | 'jpeg' | 'webp';
  dimensions: { width: number; height: number };
  metadata: Record<string, any>;
  usage?: ImageUsage;
  revisedPrompt?: string; // Some providers may revise the prompt
}

// Image-specific usage tracking
export interface ImageUsage {
  imagesGenerated: number;
  resolution: string;
  model: string;
  provider: string;
}

// Image model pricing structure
export interface ImageModelPricing {
  provider: string;
  model: string;
  costPerImage: number;
  costPerMegapixel?: number;
  currency: string;
  sizes: Record<string, number>; // size -> cost multiplier
  lastUpdated: string; // ISO date string
}

// Image cost calculation details
export interface ImageCostDetails extends Omit<CostDetails, 'rateInputPerMillion' | 'rateOutputPerMillion'> {
  ratePerImage: number;
  ratePerMegapixel?: number;
  resolution: string;
  imagesGenerated: number;
}

// Validation result for image parameters
export interface ImageValidationResult {
  isValid: boolean;
  errors: string[];
  warnings?: string[];
  adjustedParams?: Partial<ImageGenerationParams>;
}

// File save operation result
export interface ImageSaveResult {
  success: boolean;
  filePath: string;
  fileName: string;
  fileSize: number;
  dimensions: { width: number; height: number };
  format: string;
  error?: string;
}

// Complete image generation result
export interface ImageGenerationResult {
  success: boolean;
  data?: {
    imagePath: string;
    prompt: string;
    revisedPrompt?: string;
    model: string;
    provider: string;
    dimensions: { width: number; height: number };
    fileSize: number;
    format: string;
    cost?: ImageCostDetails;
    usage?: ImageUsage;
    metadata?: Record<string, any>;
  };
  error?: string;
  validationErrors?: string[];
}

// Provider-specific configuration
export interface ImageProviderConfig {
  provider: 'openai' | 'google'; // OpenAI available but not active
  apiKey: string;
  baseUrl?: string;
  defaultModel?: string;
  defaultSize?: string;
  defaultQuality?: string;
  maxFileSize?: number; // bytes
  supportedFormats?: string[];
  supportedSizes?: string[];
  supportedQualities?: string[];
}

// Image buffer with metadata for internal processing
export interface ImageBuffer {
  data: Buffer;
  format: 'png' | 'jpeg' | 'webp';
  dimensions: { width: number; height: number };
  metadata: {
    prompt: string;
    revisedPrompt?: string;
    model: string;
    provider: string;
    generatedAt: string;
    fileSize: number;
    originalResponse?: Record<string, any>;
  };
}

// OpenAI specific types (available but not active)
export namespace OpenAI {
  export interface ImageGenerationRequest {
    model: 'gpt-4.1'; // Model that supports image_generation tool
    input: string;
    tools: Array<{
      type: 'image_generation';
      size?: '1024x1024' | '1536x1024' | '1024x1536' | 'auto';
      quality?: 'low' | 'medium' | 'high' | 'auto';
      background?: 'transparent' | 'opaque' | 'auto';
    }>;
  }

  export interface ImageGenerationResponse {
    created: number;
    data: Array<{
      url?: string;
      b64_json?: string;
      revised_prompt?: string;
    }>;
  }
}

// Google specific types
export namespace Google {
  export interface ImageGenerationRequest {
    model: 'imagen-4' | 'imagen-4-ultra';
    prompt: { text: string };
    safetySettings?: SafetySetting[];
    generationConfig?: {
      responseMimeType?: string;
      responseSchema?: any;
      seed?: number;
      candidateCount?: number;
    };
  }

  export interface SafetySetting {
    category: string;
    threshold: 'BLOCK_NONE' | 'BLOCK_LOW_AND_ABOVE' | 'BLOCK_MEDIUM_AND_ABOVE' | 'BLOCK_HIGH_AND_ABOVE';
  }

  export interface ImageGenerationResponse {
    candidates: Array<{
      content?: {
        parts: Array<{
          inlineData?: {
            mimeType: string;
            data: string; // base64
          };
          text?: string;
        }>;
      };
      safetyRatings?: Array<{
        category: string;
        probability: string;
      }>;
      finishReason?: string;
    }>;
    usageMetadata?: {
      promptTokenCount: number;
      candidatesTokenCount: number;
      totalTokenCount: number;
    };
  }
}

// Image generation error types
export class ImageGenerationError extends LLMProviderError {
  constructor(
    message: string,
    provider: string,
    code?: string,
    originalError?: Error,
    public imageParams?: ImageGenerationParams
  ) {
    super(message, provider, code, originalError);
    this.name = 'ImageGenerationError';
  }
}

// Supported providers and models
export type ImageProvider = 'openai' | 'google'; // OpenAI available but not active

export type ImageModel = 
  | 'gpt-image-1'        // OpenAI (available but not active)
  | 'imagen-4'           // Google
  | 'imagen-4-ultra'     // Google
  | 'imagen-4-fast';     // Google

// Aspect ratio constants
export enum AspectRatio {
  SQUARE = '1:1',
  PORTRAIT_3_4 = '3:4',
  LANDSCAPE_4_3 = '4:3',
  PORTRAIT_9_16 = '9:16',
  LANDSCAPE_16_9 = '16:9'
}

// Image size presets
export const IMAGE_SIZES = {
  SQUARE_1024: '1024x1024',
  PORTRAIT: '1024x1536',  // Supported by both providers
  LANDSCAPE: '1536x1024', // Supported by both providers
  AUTO: 'auto'            // OpenAI automatic sizing (available but not active)
} as const;

export type ImageSize = typeof IMAGE_SIZES[keyof typeof IMAGE_SIZES];

// Image quality options
export const IMAGE_QUALITIES = {
  STANDARD: 'standard',
  HD: 'hd'
} as const;

export type ImageQuality = typeof IMAGE_QUALITIES[keyof typeof IMAGE_QUALITIES];

// Supported image formats
export const IMAGE_FORMATS = {
  PNG: 'png',
  JPEG: 'jpeg', 
  WEBP: 'webp'
} as const;

export type ImageFormat = typeof IMAGE_FORMATS[keyof typeof IMAGE_FORMATS];

// Safety levels for content filtering
export const SAFETY_LEVELS = {
  STRICT: 'strict',
  STANDARD: 'standard', 
  PERMISSIVE: 'permissive'
} as const;

export type SafetyLevel = typeof SAFETY_LEVELS[keyof typeof SAFETY_LEVELS];
```

## services/llm/utils/CacheManager.ts

```typescript
/**
 * Cache Manager
 * Provides in-memory LRU cache and file-based cache implementations
 */

import { createHash } from 'crypto';
import { promises as fs } from 'fs';
import { join } from 'path';
import { logger } from './Logger';

export interface CacheEntry<T> {
  value: T;
  timestamp: number;
  ttl?: number;
  hits: number;
}

export interface CacheConfig {
  maxSize: number;
  defaultTTL: number; // in milliseconds
  persistToDisk: boolean;
  cacheDir: string;
}

export interface CacheMetrics {
  hits: number;
  misses: number;
  evictions: number;
  size: number;
}

export abstract class BaseCache<T> {
  protected config: CacheConfig;
  protected metrics: CacheMetrics = {
    hits: 0,
    misses: 0,
    evictions: 0,
    size: 0
  };

  constructor(config: Partial<CacheConfig> = {}) {
    this.config = {
      maxSize: config.maxSize || 1000,
      defaultTTL: config.defaultTTL || 3600000, // 1 hour default
      persistToDisk: config.persistToDisk || false,
      cacheDir: config.cacheDir || '.cache'
    };
  }

  abstract get(key: string): Promise<T | null>;
  abstract set(key: string, value: T, ttl?: number): Promise<void>;
  abstract delete(key: string): Promise<boolean>;
  abstract clear(): Promise<void>;
  abstract size(): number;

  getMetrics(): CacheMetrics {
    return { ...this.metrics };
  }

  protected isExpired(entry: CacheEntry<T>): boolean {
    if (!entry.ttl) return false;
    return Date.now() - entry.timestamp > entry.ttl;
  }

  protected generateHash(input: string): string {
    return createHash('sha256').update(input).digest('hex');
  }
}

export class LRUCache<T> extends BaseCache<T> {
  private cache = new Map<string, CacheEntry<T>>();
  private accessOrder = new Map<string, number>();
  private accessCounter = 0;

  async get(key: string): Promise<T | null> {
    const entry = this.cache.get(key);
    
    if (!entry) {
      this.metrics.misses++;
      return null;
    }

    if (this.isExpired(entry)) {
      this.cache.delete(key);
      this.accessOrder.delete(key);
      this.metrics.misses++;
      this.metrics.size--;
      return null;
    }

    // Update access order and hit count
    entry.hits++;
    this.accessOrder.set(key, ++this.accessCounter);
    this.metrics.hits++;
    
    return entry.value;
  }

  async set(key: string, value: T, ttl?: number): Promise<void> {
    // Remove existing entry if present
    if (this.cache.has(key)) {
      this.cache.delete(key);
      this.accessOrder.delete(key);
      this.metrics.size--;
    }

    // Evict LRU entries if at capacity
    while (this.cache.size >= this.config.maxSize) {
      this.evictLRU();
    }

    const entry: CacheEntry<T> = {
      value,
      timestamp: Date.now(),
      ttl: ttl || this.config.defaultTTL,
      hits: 0
    };

    this.cache.set(key, entry);
    this.accessOrder.set(key, ++this.accessCounter);
    this.metrics.size++;

    if (this.config.persistToDisk) {
      await this.persistEntry(key, entry);
    }
  }

  async delete(key: string): Promise<boolean> {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this.accessOrder.delete(key);
      this.metrics.size--;
    }
    return deleted;
  }

  async clear(): Promise<void> {
    this.cache.clear();
    this.accessOrder.clear();
    this.metrics.size = 0;
    this.metrics.evictions = 0;
  }

  size(): number {
    return this.cache.size;
  }

  private evictLRU(): void {
    let oldestKey: string | null = null;
    let oldestAccess = Infinity;

    for (const [key, accessTime] of this.accessOrder) {
      if (accessTime < oldestAccess) {
        oldestAccess = accessTime;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
      this.accessOrder.delete(oldestKey);
      this.metrics.evictions++;
      this.metrics.size--;
    }
  }

  private async persistEntry(key: string, entry: CacheEntry<T>): Promise<void> {
    try {
      await fs.mkdir(this.config.cacheDir, { recursive: true });
      const filePath = join(this.config.cacheDir, `${this.generateHash(key)}.json`);
      await fs.writeFile(filePath, JSON.stringify({ key, entry }));
    } catch (error) {
      logger.warn('Failed to persist cache entry:', { error: (error as Error).message });
    }
  }
}

export class FileCache<T> extends BaseCache<T> {
  private memoryCache = new Map<string, CacheEntry<T>>();

  constructor(config: Partial<CacheConfig> = {}) {
    super({ ...config, persistToDisk: true });
    this.initializeCache();
  }

  async get(key: string): Promise<T | null> {
    // Check memory first
    let entry = this.memoryCache.get(key);
    
    // If not in memory, try disk
    if (!entry) {
      entry = (await this.loadFromDisk(key)) || undefined;
      if (entry) {
        this.memoryCache.set(key, entry);
      }
    }

    if (!entry) {
      this.metrics.misses++;
      return null;
    }

    if (this.isExpired(entry)) {
      await this.delete(key);
      this.metrics.misses++;
      return null;
    }

    entry.hits++;
    this.metrics.hits++;
    return entry.value;
  }

  async set(key: string, value: T, ttl?: number): Promise<void> {
    const entry: CacheEntry<T> = {
      value,
      timestamp: Date.now(),
      ttl: ttl || this.config.defaultTTL,
      hits: 0
    };

    this.memoryCache.set(key, entry);
    await this.saveToDisk(key, entry);
    this.metrics.size++;
  }

  async delete(key: string): Promise<boolean> {
    const memoryDeleted = this.memoryCache.delete(key);
    const diskDeleted = await this.deleteFromDisk(key);
    
    if (memoryDeleted || diskDeleted) {
      this.metrics.size--;
      return true;
    }
    return false;
  }

  async clear(): Promise<void> {
    this.memoryCache.clear();
    try {
      await fs.rm(this.config.cacheDir, { recursive: true, force: true });
    } catch (error) {
      logger.warn('Failed to clear disk cache:', { error: (error as Error).message });
    }
    this.metrics.size = 0;
  }

  size(): number {
    return this.memoryCache.size;
  }

  private async initializeCache(): Promise<void> {
    try {
      await fs.mkdir(this.config.cacheDir, { recursive: true });
    } catch (error) {
      logger.warn('Failed to initialize cache directory:', { error: (error as Error).message });
    }
  }

  private async loadFromDisk(key: string): Promise<CacheEntry<T> | null> {
    try {
      const filePath = join(this.config.cacheDir, `${this.generateHash(key)}.json`);
      const data = await fs.readFile(filePath, 'utf-8');
      const parsed = JSON.parse(data);
      return parsed.entry;
    } catch (error) {
      return null;
    }
  }

  private async saveToDisk(key: string, entry: CacheEntry<T>): Promise<void> {
    try {
      const filePath = join(this.config.cacheDir, `${this.generateHash(key)}.json`);
      await fs.writeFile(filePath, JSON.stringify({ key, entry }));
    } catch (error) {
      logger.warn('Failed to save cache entry to disk:', { error: (error as Error).message });
    }
  }

  private async deleteFromDisk(key: string): Promise<boolean> {
    try {
      const filePath = join(this.config.cacheDir, `${this.generateHash(key)}.json`);
      await fs.unlink(filePath);
      return true;
    } catch (error) {
      return false;
    }
  }
}

export class CacheManager {
  private static instances = new Map<string, BaseCache<any>>();

  static createLRUCache<T>(name: string, config?: Partial<CacheConfig>): LRUCache<T> {
    const cache = new LRUCache<T>(config);
    this.instances.set(name, cache);
    return cache;
  }

  static createFileCache<T>(name: string, config?: Partial<CacheConfig>): FileCache<T> {
    const cache = new FileCache<T>(config);
    this.instances.set(name, cache);
    return cache;
  }

  static getCache<T>(name: string): BaseCache<T> | null {
    return this.instances.get(name) || null;
  }

  static async clearAll(): Promise<void> {
    for (const cache of this.instances.values()) {
      await cache.clear();
    }
  }

  static getAllMetrics(): Record<string, CacheMetrics> {
    const metrics: Record<string, CacheMetrics> = {};
    for (const [name, cache] of this.instances.entries()) {
      metrics[name] = cache.getMetrics();
    }
    return metrics;
  }
}
```

## services/llm/utils/ConfigManager.ts

```typescript
/**
 * Configuration Manager
 * Centralized configuration management for the lab kit
 * Handles environment variables, validation, and default settings
 */

import { readFileSync, existsSync } from 'fs';
import { join } from 'path';

export interface LabKitConfig {
  // Provider configurations
  providers: {
    openai: {
      apiKey?: string;
      baseUrl?: string;
      organization?: string;
      project?: string;
    };
    google: {
      apiKey?: string;
      projectId?: string;
      location?: string;
    };
    anthropic: {
      apiKey?: string;
      version?: string;
    };
    mistral: {
      apiKey?: string;
      endpoint?: string;
    };
    openrouter: {
      apiKey?: string;
      httpReferer?: string;
      xTitle?: string;
    };
    requesty: {
      apiKey?: string;
      baseUrl?: string;
    };
  };

  // Database configuration
  database: {
    supabase: {
      url?: string;
      anonKey?: string;
      serviceRoleKey?: string;
    };
  };


  // Default test settings
  defaults: {
    timeout: number;
    retries: number;
    concurrency: number;
    batchSize: number;
  };

  // Logging and debugging
  logging: {
    level: 'debug' | 'info' | 'warn' | 'error';
    enableFileLogging: boolean;
    logDirectory: string;
  };

  // Cache configuration
  cache: {
    llm: {
      enabled: boolean;
      type: 'memory' | 'file';
      maxSize: number;
      defaultTTL: number; // in milliseconds
      persistToDisk: boolean;
      cacheDir: string;
    };
    questions: {
      enabled: boolean;
      defaultTTL: number;
      cacheDir: string;
    };
  };
}

export class ConfigManager {
  private static instance: ConfigManager;
  private config: LabKitConfig;
  private configPath?: string;

  private constructor() {
    this.config = this.loadDefaultConfig();
    this.loadEnvironmentConfig();
    this.loadFileConfig();
    this.validateConfig();
  }

  /**
   * Get singleton instance
   */
  static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }

  /**
   * Get the complete configuration
   */
  getConfig(): LabKitConfig {
    return { ...this.config };
  }

  /**
   * Get provider configuration
   */
  getProvider(name: keyof LabKitConfig['providers']): any {
    return this.config.providers[name];
  }

  /**
   * Get database configuration
   */
  getDatabase(): LabKitConfig['database'] {
    return this.config.database;
  }


  /**
   * Update configuration
   */
  updateConfig(updates: Partial<LabKitConfig>): void {
    this.config = this.mergeConfigs(this.config, updates);
    this.validateConfig();
  }

  /**
   * Load configuration from file
   */
  loadFromFile(path: string): void {
    this.configPath = path;
    this.loadFileConfig();
    this.validateConfig();
  }

  /**
   * Check if a provider is configured
   */
  isProviderConfigured(name: keyof LabKitConfig['providers']): boolean {
    const provider = this.config.providers[name];
    return !!(provider.apiKey);
  }

  /**
   * Get list of configured providers
   */
  getConfiguredProviders(): string[] {
    return Object.keys(this.config.providers).filter(name => 
      this.isProviderConfigured(name as keyof LabKitConfig['providers'])
    );
  }

  /**
   * Check if database is configured
   */
  isDatabaseConfigured(): boolean {
    const db = this.config.database.supabase;
    return !!(db.url && (db.anonKey || db.serviceRoleKey));
  }


  /**
   * Get cache configuration
   */
  getCacheConfig(): LabKitConfig['cache'] {
    return this.config.cache;
  }

  /**
   * Get LLM cache configuration
   */
  getLLMCacheConfig() {
    return this.config.cache.llm;
  }


  /**
   * Get questions cache configuration
   */
  getQuestionsCacheConfig() {
    return this.config.cache.questions;
  }

  /**
   * Check if LLM caching is enabled
   */
  isLLMCacheEnabled(): boolean {
    return this.config.cache.llm.enabled;
  }


  /**
   * Check if questions caching is enabled
   */
  isQuestionsCacheEnabled(): boolean {
    return this.config.cache.questions.enabled;
  }

  // Private methods

  private loadDefaultConfig(): LabKitConfig {
    return {
      providers: {
        openai: {
          baseUrl: 'https://api.openai.com/v1'
        },
        google: {
          location: 'us-central1'
        },
        anthropic: {
          version: '2024-02-15'
        },
        mistral: {
          endpoint: 'https://api.mistral.ai/v1'
        },
        openrouter: {},
        requesty: {}
      },
      database: {
        supabase: {}
      },
      defaults: {
        timeout: 30000,
        retries: 3,
        concurrency: 5,
        batchSize: 10
      },
      logging: {
        level: 'info',
        enableFileLogging: false,
        logDirectory: './logs'
      },
      cache: {
        llm: {
          enabled: true,
          type: 'memory',
          maxSize: 1000,
          defaultTTL: 3600000, // 1 hour
          persistToDisk: false,
          cacheDir: '.cache/llm'
        },
        questions: {
          enabled: true,
          defaultTTL: 86400000, // 24 hours
          cacheDir: '.cache/questions'
        }
      }
    };
  }

  private loadEnvironmentConfig(): void {
    // Provider API keys
    this.setIfExists('providers.openai.apiKey', process.env.OPENAI_API_KEY);
    this.setIfExists('providers.openai.organization', process.env.OPENAI_ORGANIZATION);
    this.setIfExists('providers.openai.project', process.env.OPENAI_PROJECT);
    
    this.setIfExists('providers.google.apiKey', process.env.GOOGLE_API_KEY);
    this.setIfExists('providers.google.projectId', process.env.GOOGLE_PROJECT_ID);
    
    this.setIfExists('providers.anthropic.apiKey', process.env.ANTHROPIC_API_KEY);
    
    this.setIfExists('providers.mistral.apiKey', process.env.MISTRAL_API_KEY);
    
    this.setIfExists('providers.openrouter.apiKey', process.env.OPENROUTER_API_KEY);
    this.setIfExists('providers.openrouter.httpReferer', process.env.OPENROUTER_HTTP_REFERER);
    this.setIfExists('providers.openrouter.xTitle', process.env.OPENROUTER_X_TITLE);
    
    this.setIfExists('providers.requesty.apiKey', process.env.REQUESTY_API_KEY);
    this.setIfExists('providers.requesty.baseUrl', process.env.REQUESTY_BASE_URL);

    // Database
    this.setIfExists('database.supabase.url', process.env.SUPABASE_URL);
    this.setIfExists('database.supabase.anonKey', process.env.SUPABASE_ANON_KEY);
    this.setIfExists('database.supabase.serviceRoleKey', process.env.SUPABASE_SERVICE_ROLE_KEY);


    // Defaults
    if (process.env.LAB_KIT_TIMEOUT) {
      this.config.defaults.timeout = parseInt(process.env.LAB_KIT_TIMEOUT);
    }
    if (process.env.LAB_KIT_RETRIES) {
      this.config.defaults.retries = parseInt(process.env.LAB_KIT_RETRIES);
    }
    if (process.env.LAB_KIT_CONCURRENCY) {
      this.config.defaults.concurrency = parseInt(process.env.LAB_KIT_CONCURRENCY);
    }

    // Logging
    if (process.env.LAB_KIT_LOG_LEVEL) {
      this.config.logging.level = process.env.LAB_KIT_LOG_LEVEL as any;
    }
    if (process.env.LAB_KIT_LOG_DIRECTORY) {
      this.config.logging.logDirectory = process.env.LAB_KIT_LOG_DIRECTORY;
    }

    // Cache configuration
    if (process.env.LAB_KIT_CACHE_LLM_ENABLED) {
      this.config.cache.llm.enabled = process.env.LAB_KIT_CACHE_LLM_ENABLED === 'true';
    }
    if (process.env.LAB_KIT_CACHE_LLM_TYPE) {
      this.config.cache.llm.type = process.env.LAB_KIT_CACHE_LLM_TYPE as 'memory' | 'file';
    }
    if (process.env.LAB_KIT_CACHE_LLM_MAX_SIZE) {
      this.config.cache.llm.maxSize = parseInt(process.env.LAB_KIT_CACHE_LLM_MAX_SIZE);
    }
    if (process.env.LAB_KIT_CACHE_LLM_TTL) {
      this.config.cache.llm.defaultTTL = parseInt(process.env.LAB_KIT_CACHE_LLM_TTL);
    }
    if (process.env.LAB_KIT_CACHE_LLM_PERSIST) {
      this.config.cache.llm.persistToDisk = process.env.LAB_KIT_CACHE_LLM_PERSIST === 'true';
    }
    if (process.env.LAB_KIT_CACHE_LLM_DIR) {
      this.config.cache.llm.cacheDir = process.env.LAB_KIT_CACHE_LLM_DIR;
    }


    if (process.env.LAB_KIT_CACHE_QUESTIONS_ENABLED) {
      this.config.cache.questions.enabled = process.env.LAB_KIT_CACHE_QUESTIONS_ENABLED === 'true';
    }
    if (process.env.LAB_KIT_CACHE_QUESTIONS_TTL) {
      this.config.cache.questions.defaultTTL = parseInt(process.env.LAB_KIT_CACHE_QUESTIONS_TTL);
    }
    if (process.env.LAB_KIT_CACHE_QUESTIONS_DIR) {
      this.config.cache.questions.cacheDir = process.env.LAB_KIT_CACHE_QUESTIONS_DIR;
    }
  }

  private loadFileConfig(): void {
    const configPaths = [
      this.configPath,
      './lab-kit.config.json',
      './lab-kit.config.js',
      './.labkitrc',
      join(process.cwd(), 'lab-kit.config.json')
    ].filter(Boolean);

    for (const path of configPaths) {
      if (existsSync(path!)) {
        try {
          let fileConfig;
          
          if (path!.endsWith('.js')) {
            fileConfig = require(path!);
          } else {
            const content = readFileSync(path!, 'utf8');
            fileConfig = JSON.parse(content);
          }

          this.config = this.mergeConfigs(this.config, fileConfig);
          console.log(`üìÅ Loaded configuration from ${path}`);
          break;
        } catch (error) {
          console.warn(`Failed to load config from ${path}:`, error);
        }
      }
    }
  }

  private setIfExists(path: string, value: any): void {
    if (value !== undefined && value !== null && value !== '') {
      this.setNestedValue(this.config, path, value);
    }
  }

  private setNestedValue(obj: any, path: string, value: any): void {
    const keys = path.split('.');
    let current = obj;
    
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (!key) continue;
      if (!(key in current)) {
        current[key] = {};
      }
      current = current[key];
    }
    
    const lastKey = keys[keys.length - 1];
    if (lastKey) {
      current[lastKey] = value;
    }
  }

  private mergeConfigs(base: any, override: any): any {
    const result = { ...base };
    
    for (const key in override) {
      if (override[key] && typeof override[key] === 'object' && !Array.isArray(override[key])) {
        result[key] = this.mergeConfigs(result[key] || {}, override[key]);
      } else {
        result[key] = override[key];
      }
    }
    
    return result;
  }

  private validateConfig(): void {
    const errors: string[] = [];

    // Check for at least one provider
    const configuredProviders = this.getConfiguredProviders();
    if (configuredProviders.length === 0) {
      errors.push('At least one LLM provider must be configured');
    }

    // Validate timeout values
    if (this.config.defaults.timeout < 1000) {
      errors.push('Timeout must be at least 1000ms');
    }

    if (this.config.defaults.retries < 0 || this.config.defaults.retries > 10) {
      errors.push('Retries must be between 0 and 10');
    }

    if (this.config.defaults.concurrency < 1 || this.config.defaults.concurrency > 50) {
      errors.push('Concurrency must be between 1 and 50');
    }

    if (errors.length > 0) {
      throw new Error(`Configuration validation failed:\n${errors.join('\n')}`);
    }
  }

  /**
   * Get configuration summary for debugging
   */
  getConfigSummary(): Record<string, any> {
    return {
      providers: {
        configured: this.getConfiguredProviders(),
        total: Object.keys(this.config.providers).length
      },
      database: {
        configured: this.isDatabaseConfigured()
      },
      defaults: this.config.defaults,
      logging: this.config.logging
    };
  }
}
```

## services/llm/utils/Logger.ts

```typescript
/**
 * Enhanced Logger
 * Structured logging with multiple outputs and severity levels
 * Based on patterns from existing logging services
 */

import { appendFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface LogEntry {
  timestamp: Date;
  level: LogLevel;
  message: string;
  component?: string;
  metadata?: Record<string, any>;
  executionId?: string;
  testId?: string;
}

export interface LoggerConfig {
  level: LogLevel;
  enableConsole: boolean;
  enableFile: boolean;
  logDirectory: string;
  maxFileSize: number; // in bytes
  maxFiles: number;
  includeTimestamp: boolean;
  includeStackTrace: boolean;
}

export class Logger {
  private static instance: Logger;
  private config: LoggerConfig;
  private logLevels: Record<LogLevel, number> = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3
  };

  private constructor(config?: Partial<LoggerConfig>) {
    this.config = {
      level: 'info',
      enableConsole: true,
      enableFile: false,
      logDirectory: './logs',
      maxFileSize: 10 * 1024 * 1024, // 10MB
      maxFiles: 5,
      includeTimestamp: true,
      includeStackTrace: false,
      ...config
    };

    this.ensureLogDirectory();
  }

  /**
   * Get singleton instance
   */
  static getInstance(config?: Partial<LoggerConfig>): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger(config);
    }
    return Logger.instance;
  }

  /**
   * Create a child logger with component context
   */
  child(component: string): ComponentLogger {
    return new ComponentLogger(this, component);
  }

  /**
   * Debug level logging
   */
  debug(message: string, metadata?: Record<string, any>): void {
    this.log('debug', message, metadata);
  }

  /**
   * Info level logging
   */
  info(message: string, metadata?: Record<string, any>): void {
    this.log('info', message, metadata);
  }

  /**
   * Warning level logging
   */
  warn(message: string, metadata?: Record<string, any>): void {
    this.log('warn', message, metadata);
  }

  /**
   * Error level logging
   */
  error(message: string, error?: Error | Record<string, any>): void {
    const metadata = error instanceof Error ? {
      error: error.message,
      stack: error.stack
    } : error;
    
    this.log('error', message, metadata);
  }

  /**
   * Log test execution events
   */
  testEvent(event: string, testId: string, metadata?: Record<string, any>): void {
    this.log('info', `Test Event: ${event}`, {
      testId,
      eventType: 'test',
      ...metadata
    });
  }

  /**
   * Log optimization events
   */
  optimizationEvent(event: string, generation: number, metadata?: Record<string, any>): void {
    this.log('info', `Optimization: ${event}`, {
      generation,
      eventType: 'optimization',
      ...metadata
    });
  }

  /**
   * Log provider API calls
   */
  apiCall(provider: string, method: string, latency: number, tokens?: number, cost?: number): void {
    this.log('debug', `API Call: ${provider}.${method}`, {
      provider,
      method,
      latency,
      tokens,
      cost,
      eventType: 'api'
    });
  }

  /**
   * Log performance metrics
   */
  performance(operation: string, duration: number, metadata?: Record<string, any>): void {
    this.log('info', `Performance: ${operation}`, {
      operation,
      duration,
      eventType: 'performance',
      ...metadata
    });
  }

  /**
   * Main logging method
   */
  log(level: LogLevel, message: string, metadata?: Record<string, any>, component?: string): void {
    if (!this.shouldLog(level)) {
      return;
    }

    const entry: LogEntry = {
      timestamp: new Date(),
      level,
      message
    };
    
    if (component !== undefined) entry.component = component;
    if (metadata !== undefined) entry.metadata = metadata;

    if (this.config.enableConsole) {
      this.logToConsole(entry);
    }

    if (this.config.enableFile) {
      this.logToFile(entry);
    }
  }

  /**
   * Update logger configuration
   */
  configure(config: Partial<LoggerConfig>): void {
    this.config = { ...this.config, ...config };
    this.ensureLogDirectory();
  }

  /**
   * Get current log level
   */
  getLevel(): LogLevel {
    return this.config.level;
  }

  /**
   * Set log level
   */
  setLevel(level: LogLevel): void {
    this.config.level = level;
  }

  /**
   * Enable file logging
   */
  enableFileLogging(directory?: string): void {
    this.config.enableFile = true;
    if (directory) {
      this.config.logDirectory = directory;
    }
    this.ensureLogDirectory();
  }

  /**
   * Disable file logging
   */
  disableFileLogging(): void {
    this.config.enableFile = false;
  }

  /**
   * Flush logs (useful for testing)
   */
  flush(): void {
    // In a real implementation, this would flush any buffered logs
  }

  // Private methods

  private shouldLog(level: LogLevel): boolean {
    return this.logLevels[level] >= this.logLevels[this.config.level];
  }

  private logToConsole(entry: LogEntry): void {
    const timestamp = this.config.includeTimestamp 
      ? `[${entry.timestamp.toISOString()}] `
      : '';
    
    const component = entry.component ? `[${entry.component}] ` : '';
    const level = `[${entry.level.toUpperCase()}] `;
    
    let output = `${timestamp}${level}${component}${entry.message}`;
    
    if (entry.metadata && Object.keys(entry.metadata).length > 0) {
      output += ` ${JSON.stringify(entry.metadata, null, 2)}`;
    }

    switch (entry.level) {
      case 'debug':
        console.debug(output);
        break;
      case 'info':
        console.info(output);
        break;
      case 'warn':
        console.warn(output);
        break;
      case 'error':
        console.error(output);
        break;
    }
  }

  private logToFile(entry: LogEntry): void {
    const logFile = join(this.config.logDirectory, `lab-kit-${this.getDateString()}.log`);
    const line = JSON.stringify(entry) + '\n';
    
    try {
      appendFileSync(logFile, line);
      this.rotateLogsIfNeeded(logFile);
    } catch (error) {
      console.error('Failed to write to log file:', error);
    }
  }

  private ensureLogDirectory(): void {
    if (this.config.enableFile && !existsSync(this.config.logDirectory)) {
      try {
        mkdirSync(this.config.logDirectory, { recursive: true });
      } catch (error) {
        console.error('Failed to create log directory:', error);
        this.config.enableFile = false;
      }
    }
  }

  private getDateString(): string {
    return new Date().toISOString().split('T')[0]!;
  }

  private rotateLogsIfNeeded(logFile: string): void {
    try {
      const stats = require('fs').statSync(logFile);
      if (stats.size > this.config.maxFileSize) {
        // Simple rotation - rename current file with timestamp
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const rotatedFile = logFile.replace('.log', `-${timestamp}.log`);
        require('fs').renameSync(logFile, rotatedFile);
        
        // Clean up old files if we exceed maxFiles
        this.cleanupOldLogs();
      }
    } catch (error) {
      // Ignore rotation errors
    }
  }

  private cleanupOldLogs(): void {
    try {
      const fs = require('fs');
      const files = fs.readdirSync(this.config.logDirectory)
        .filter((file: string) => file.startsWith('lab-kit-') && file.endsWith('.log'))
        .map((file: string) => ({
          name: file,
          path: join(this.config.logDirectory, file),
          stats: fs.statSync(join(this.config.logDirectory, file))
        }))
        .sort((a: any, b: any) => b.stats.mtime - a.stats.mtime);

      // Keep only the most recent files
      if (files.length > this.config.maxFiles) {
        const filesToDelete = files.slice(this.config.maxFiles);
        filesToDelete.forEach((file: any) => {
          try {
            fs.unlinkSync(file.path);
          } catch (error) {
            // Ignore cleanup errors
          }
        });
      }
    } catch (error) {
      // Ignore cleanup errors
    }
  }
}

/**
 * Component-specific logger that includes component context
 */
export class ComponentLogger {
  constructor(
    private parent: Logger,
    private component: string
  ) {}

  debug(message: string, metadata?: Record<string, any>): void {
    this.parent.log('debug', message, metadata, this.component);
  }

  info(message: string, metadata?: Record<string, any>): void {
    this.parent.log('info', message, metadata, this.component);
  }

  warn(message: string, metadata?: Record<string, any>): void {
    this.parent.log('warn', message, metadata, this.component);
  }

  error(message: string, error?: Error | Record<string, any>): void {
    const metadata = error instanceof Error ? {
      error: error.message,
      stack: error.stack
    } : error;
    
    this.parent.log('error', message, metadata, this.component);
  }

  testEvent(event: string, testId: string, metadata?: Record<string, any>): void {
    this.parent.testEvent(event, testId, { component: this.component, ...metadata });
  }

  apiCall(provider: string, method: string, latency: number, tokens?: number, cost?: number): void {
    this.parent.apiCall(provider, method, latency, tokens, cost);
  }

  performance(operation: string, duration: number, metadata?: Record<string, any>): void {
    this.parent.performance(operation, duration, { component: this.component, ...metadata });
  }
}

/**
 * Global logger instance
 */
export const logger = Logger.getInstance();

/**
 * Create a logger for a specific component
 */
export function createLogger(component: string): ComponentLogger {
  return logger.child(component);
}
```

## services/llm/utils/README.md

```markdown
# Utilities & Infrastructure

Essential utilities for configuration management, logging, validation, and reliability patterns across the framework.

## üéØ Purpose

The utilities provide the foundational infrastructure that powers the entire framework:
- **ConfigManager**: Environment and configuration management
- **Logger**: Structured logging with multiple outputs
- **RetryManager**: Retry logic with circuit breakers and exponential backoff
- **ValidationUtils**: Input validation and schema enforcement
- **Performance monitoring** and setup utilities

## ‚öôÔ∏è ConfigManager

Centralized configuration management with environment variables, config files, and validation.

### Quick Setup
```typescript
import { ConfigManager, quickSetup } from './utils';

// Automatic setup with validation
const { config, logger, isReady, summary } = await quickSetup({
  logLevel: 'info',
  enableFileLogging: true,
  validateConfig: true
});

if (!isReady) {
  console.log('‚ùå Setup incomplete. Please check configuration.');
  console.log(summary);
  process.exit(1);
}

console.log('‚úÖ Lab Kit ready for testing!');
```

### Manual Configuration
```typescript
const config = ConfigManager.getInstance();

// Check provider configuration
const configuredProviders = config.getConfiguredProviders();
console.log(`Configured providers: ${configuredProviders.join(', ')}`);

// Get specific provider config
const openaiConfig = config.getProvider('openai');
if (openaiConfig.apiKey) {
  console.log('‚úÖ OpenAI configured');
} else {
  console.log('‚ùå OpenAI API key missing');
}

// Check database configuration
if (config.isDatabaseConfigured()) {
  console.log('‚úÖ Database configured');
} else {
  console.log('‚ö†Ô∏è Database not configured - some features unavailable');
}
```

### Configuration Sources
The ConfigManager loads configuration from multiple sources in order of priority:

1. **Environment Variables** (highest priority)
2. **Config Files** (`lab-kit.config.json`, `.labkitrc`)
3. **Default Values** (lowest priority)

```typescript
// Environment variables
OPENAI_API_KEY=sk-...
GOOGLE_API_KEY=AIza...
SUPABASE_URL=https://project.supabase.co
LAB_KIT_LOG_LEVEL=debug

// Config file (lab-kit.config.json)
{
  "defaults": {
    "timeout": 30000,
    "retries": 3,
    "concurrency": 5
  },
  "logging": {
    "level": "info",
    "enableFileLogging": true
  }
}
```

### Configuration Validation
```typescript
// Get configuration summary
const summary = config.getConfigSummary();
console.log({
  providers: summary.providers.configured,     // ['openai', 'anthropic']
  database: summary.database.configured,      // true/false
    // ['openai', 'voyage']
  readyForTesting: summary.providers.configured.length > 0
});

// Validate environment
import { validateEnvironment } from './utils';
const envValidation = validateEnvironment();

if (!envValidation.isValid) {
  console.log('‚ùå Environment validation failed:');
  envValidation.errors.forEach(error => console.log(`  ‚Ä¢ ${error}`));
}

if (envValidation.warnings.length > 0) {
  console.log('‚ö†Ô∏è Warnings:');
  envValidation.warnings.forEach(warning => console.log(`  ‚Ä¢ ${warning}`));
}
```

## üìù Logger

Structured logging with multiple outputs, component isolation, and performance tracking.

### Basic Logging
```typescript
import { logger, createLogger } from './utils';

// Global logger
logger.info('Application started');
logger.warn('High memory usage detected');
logger.error('Failed to connect to database', { 
  error: 'Connection timeout',
  retryCount: 3 
});

// Component-specific logger
const testLogger = createLogger('TestRunner');
testLogger.info('Starting test execution', { 
  testId: 'test_123',
  scenarios: 15 
});
```

### Advanced Logging Features
```typescript
// Event-specific logging methods
logger.testEvent('test_started', 'test_123', {
  provider: 'openai',
  scenarios: 15,
  personas: 3
});

logger.optimizationEvent('generation_complete', 5, {
  bestScore: 0.85,
  improvement: 0.12
});

logger.apiCall('openai', 'chat.completions', 1234, 150, 0.003);

logger.performance('prompt_optimization', 45000, {
  generations: 10,
  improvements: 3
});
```

### File Logging & Configuration
```typescript
// Enable file logging
logger.enableFileLogging('./logs');

// Configure logging levels and outputs
logger.configure({
  level: 'debug',
  enableFile: true,
  logDirectory: './app-logs',
  maxFileSize: 10 * 1024 * 1024, // 10MB
  maxFiles: 5
});

// Component logger with context
const optimizerLogger = logger.child('PromptOptimizer');
optimizerLogger.info('Starting optimization', {
  basePrompt: 'Help users...',
  generations: 10,
  populationSize: 12
});
```

### Log Structure
```json
{
  "timestamp": "2025-01-10T15:30:45.123Z",
  "level": "info",
  "message": "Test completed successfully",
  "component": "TestRunner",
  "metadata": {
    "testId": "test_123",
    "accuracy": 0.85,
    "duration": 45000,
    "eventType": "test"
  }
}
```

## üîÑ RetryManager

Sophisticated retry logic with circuit breakers, exponential backoff, and failure pattern recognition.

### Basic Retry Usage
```typescript
import { RetryManager, RetryPatterns } from './utils';

const retryManager = RetryManager.getInstance();

// Basic retry with default configuration
const result = await retryManager.withRetry(
  async () => {
    // Operation that might fail
    return await unstableApiCall();
  },
  {
    maxAttempts: 3,
    baseDelay: 1000,
    exponentialBase: 2
  },
  'unstable_api_call'
);
```

### Convenient Retry Patterns
```typescript
// API calls with smart retry logic
const apiResult = await RetryPatterns.apiCall(async () => {
  return await llmProvider.generate(prompt);
}, 'llm_generation');

// Database operations
const dbResult = await RetryPatterns.databaseOperation(async () => {
  return await database.query('SELECT * FROM users');
}, 'user_query');

// File operations
const fileResult = await RetryPatterns.fileOperation(async () => {
  return await fs.writeFile('report.json', data);
}, 'report_write');
```

### Circuit Breaker Pattern
```typescript
// Protect against cascading failures
const result = await retryManager.withCircuitBreaker(
  async () => {
    return await externalService.call();
  },
  'external_service',
  {
    failureThreshold: 5,      // Open after 5 failures
    resetTimeout: 60000,      // Try again after 1 minute
    monitoringPeriod: 120000  // Monitor over 2 minutes
  }
);

// Check circuit breaker status
const state = retryManager.getCircuitState('external_service');
// 'closed' (normal) | 'open' (failing) | 'half-open' (testing)

// Get statistics
const stats = retryManager.getCircuitStats('external_service');
console.log({
  state: stats.state,
  failureRate: stats.failureRate,
  totalRequests: stats.totalRequests
});
```

### Combined Retry + Circuit Breaker
```typescript
// Ultimate reliability pattern
const result = await retryManager.withRetryAndCircuitBreaker(
  async () => {
    return await criticalOperation();
  },
  'critical_operation',
  // Retry config
  {
    maxAttempts: 3,
    baseDelay: 1000,
    retryCondition: (error) => error.status >= 500
  },
  // Circuit breaker config
  {
    failureThreshold: 5,
    resetTimeout: 30000
  }
);
```

### Custom Retry Conditions
```typescript
const result = await retryManager.withRetry(
  async () => {
    return await llmProvider.generate(prompt);
  },
  {
    maxAttempts: 5,
    baseDelay: 1000,
    maxDelay: 30000,
    jitter: true,
    retryCondition: (error) => {
      // Retry on rate limits and server errors
      if (error.status === 429) return true;
      if (error.status >= 500) return true;
      
      // Retry on network errors
      if (error.code === 'ECONNRESET') return true;
      if (error.code === 'ETIMEDOUT') return true;
      
      // Don't retry on client errors
      return false;
    },
    onRetry: (attempt, error) => {
      logger.warn(`Retry attempt ${attempt}`, { 
        error: error.message,
        operation: 'llm_generation'
      });
    }
  },
  'llm_generation'
);
```

## ‚úÖ ValidationUtils

Comprehensive validation for all framework inputs with detailed error reporting.

### Test Configuration Validation
```typescript
import { ValidationUtils } from './utils';

// Validate test configuration
const testConfig = {
  name: 'Customer Service Test',
  provider: 'openai',
  scenarios: [
    {
      id: 'return_policy',
      userInput: 'How do I return a product?',
      expectedOutput: 'Should mention return process'
    }
  ],
  evaluation: {
    criteria: [
      { name: 'accuracy', type: 'llm_judge', weight: 0.4 }
    ]
  }
};

const validation = ValidationUtils.validateTestConfig(testConfig);
if (!validation.isValid) {
  console.log('‚ùå Test configuration invalid:');
  validation.errors.forEach(error => console.log(`  ‚Ä¢ ${error}`));
}

if (validation.warnings.length > 0) {
  console.log('‚ö†Ô∏è Warnings:');
  validation.warnings.forEach(warning => console.log(`  ‚Ä¢ ${warning}`));
}
```

### Provider Configuration Validation
```typescript
// Validate provider configurations
const providers = ['openai', 'anthropic', 'google'];

for (const provider of providers) {
  const config = configManager.getProvider(provider);
  const validation = ValidationUtils.validateProviderConfig(provider, config);
  
  if (validation.isValid) {
    console.log(`‚úÖ ${provider} configuration valid`);
  } else {
    console.log(`‚ùå ${provider} configuration invalid:`);
    validation.errors.forEach(error => console.log(`  ‚Ä¢ ${error}`));
  }
}
```

### Schema Validation
```typescript
import { CommonSchemas } from './utils';

// Use pre-built schemas
const scenarioValidation = ValidationUtils.validateSchema(
  scenario,
  CommonSchemas.scenario
);

// Custom schema validation
const customSchema = [
  { field: 'name', type: 'string', required: true, minLength: 1 },
  { field: 'email', type: 'email', required: true },
  { field: 'age', type: 'number', required: false, min: 18, max: 120 },
  { field: 'preferences', type: 'array', required: false },
  { 
    field: 'role', 
    type: 'string', 
    required: true,
    allowedValues: ['admin', 'user', 'guest']
  }
];

const result = ValidationUtils.validateSchema(userData, customSchema);
```

### API Response Validation
```typescript
// Validate API responses
const response = await llmProvider.generate(prompt);

const validation = ValidationUtils.validateAPIResponse(response, [
  'content',
  'tokens', 
  'cost',
  'latency'
]);

if (!validation.isValid) {
  throw new Error(`Invalid API response: ${validation.errors.join(', ')}`);
}

// Validate test results
const testResult = {
  id: 'test_123',
  response: { content: 'Response text', tokens: 150 },
  evaluation: { overall: 0.85, passed: true },
  timestamp: new Date()
};

const resultValidation = ValidationUtils.validateTestResult(testResult);
```

## üîß Performance Monitoring

### Built-in Performance Utilities
```typescript
import { PerformanceMonitor } from './utils';

// Time operations
PerformanceMonitor.startTimer('test_execution');
await runTests();
const duration = PerformanceMonitor.endTimer('test_execution');
console.log(`Tests completed in ${duration}ms`);

// Time async operations
const result = await PerformanceMonitor.timeAsync('prompt_optimization', async () => {
  return await optimizer.optimize();
});

// Time synchronous operations
const parsed = PerformanceMonitor.time('json_parsing', () => {
  return JSON.parse(largeJsonString);
});
```

### Environment Setup Report
```typescript
import { createSetupReport } from './utils';

// Generate comprehensive setup report
const report = createSetupReport();
console.log(report);

// Example output:
/*
# Synaptic Lab Kit Setup Report

## Environment Validation
‚úÖ Environment validation passed

## Configuration Summary
**LLM Providers:** openai, anthropic, google
**Database:** Configured
** voyage
**Log Level:** info

## Readiness Status
‚úÖ Ready for testing
*/
```

## üõ†Ô∏è Integration Examples

### Complete Setup Flow
```typescript
async function setupLabKit() {
  try {
    // 1. Quick setup with validation
    const { config, logger, isReady, summary } = await quickSetup({
      logLevel: 'info',
      enableFileLogging: true,
      validateConfig: true
    });

    if (!isReady) {
      logger.error('Setup failed', summary);
      return false;
    }

    // 2. Setup retry patterns for reliability
    const retryManager = RetryManager.getInstance();
    
    // 3. Configure performance monitoring
    const testLogger = createLogger('TestRunner');
    
    // 4. Validate critical configurations
    const providers = config.getConfiguredProviders();
    for (const provider of providers) {
      const providerConfig = config.getProvider(provider);
      const validation = ValidationUtils.validateProviderConfig(provider, providerConfig);
      
      if (!validation.isValid) {
        logger.error(`Invalid ${provider} configuration`, validation.errors);
        return false;
      }
    }

    logger.info('üöÄ Lab Kit setup complete', {
      providers: providers.length,
      database: config.isDatabaseConfigured(),
      embeddings: config.getConfiguredProviders().length
    });

    return true;
  } catch (error) {
    console.error('Setup failed:', error);
    return false;
  }
}
```

### Error Handling Pipeline
```typescript
async function robustTestExecution(testConfig: any) {
  const logger = createLogger('RobustTestRunner');
  const retryManager = RetryManager.getInstance();

  try {
    // 1. Validate configuration
    const validation = ValidationUtils.validateTestConfig(testConfig);
    if (!validation.isValid) {
      throw new Error(`Invalid config: ${validation.errors.join(', ')}`);
    }

    // 2. Execute with retry and circuit breaker
    const results = await retryManager.withRetryAndCircuitBreaker(
      async () => {
        return await executeTests(testConfig);
      },
      'test_execution',
      {
        maxAttempts: 3,
        baseDelay: 5000,
        retryCondition: (error) => {
          // Retry on temporary failures, not configuration errors
          return error.temporary === true;
        }
      },
      {
        failureThreshold: 3,
        resetTimeout: 300000 // 5 minutes
      }
    );

    logger.info('Test execution completed', {
      testId: testConfig.id,
      accuracy: results.summary.accuracy,
      duration: results.duration
    });

    return results;
  } catch (error) {
    logger.error('Test execution failed', {
      testId: testConfig.id,
      error: error.message,
      stack: error.stack
    });
    throw error;
  }
}
```

## üéØ Best Practices

### 1. Configuration Management
- **Environment first** - Use environment variables for secrets
- **Validate early** - Check configuration at startup
- **Fail fast** - Don't continue with invalid configuration
- **Document requirements** - Clear documentation of required env vars

### 2. Logging Strategy
- **Structured logging** - Use consistent metadata fields
- **Component isolation** - Use component-specific loggers
- **Appropriate levels** - Debug for development, info for production
- **Include context** - Add relevant metadata to all log entries

### 3. Retry Patterns
- **Know your errors** - Different retry strategies for different error types
- **Avoid retry storms** - Use jitter and circuit breakers
- **Monitor patterns** - Track retry rates and failure patterns
- **Graceful degradation** - Have fallback plans

### 4. Validation Philosophy
- **Validate at boundaries** - Check all external inputs
- **Fail early** - Validate before expensive operations
- **Clear error messages** - Help users fix validation errors
- **Schema evolution** - Plan for changing requirements

The utilities layer provides the rock-solid foundation that makes the entire framework reliable, observable, and maintainable! üõ†Ô∏è‚ú®
```

## services/llm/utils/RetryManager.ts

```typescript
/**
 * Retry Manager
 * Handles retry logic with exponential backoff and circuit breaker patterns
 * Based on patterns from existing retry utilities
 */

import { createLogger } from './Logger';

const logger = createLogger('RetryManager');

export interface RetryConfig {
  maxAttempts: number;
  baseDelay: number;
  maxDelay: number;
  exponentialBase: number;
  jitter: boolean;
  retryCondition?: (error: any) => boolean;
  onRetry?: (attempt: number, error: any) => void;
}

export interface CircuitBreakerConfig {
  failureThreshold: number;
  resetTimeout: number;
  monitoringPeriod: number;
}

export type CircuitState = 'closed' | 'open' | 'half-open';

export class RetryManager {
  private static instance: RetryManager;
  private circuitBreakers: Map<string, CircuitBreaker> = new Map();

  private constructor() {}

  static getInstance(): RetryManager {
    if (!RetryManager.instance) {
      RetryManager.instance = new RetryManager();
    }
    return RetryManager.instance;
  }

  /**
   * Execute operation with retry logic
   */
  async withRetry<T>(
    operation: () => Promise<T>,
    config: Partial<RetryConfig> = {},
    operationName?: string
  ): Promise<T> {
    const finalConfig: RetryConfig = {
      maxAttempts: 3,
      baseDelay: 1000,
      maxDelay: 30000,
      exponentialBase: 2,
      jitter: true,
      retryCondition: this.defaultRetryCondition,
      ...config
    };

    let lastError: any;
    
    for (let attempt = 1; attempt <= finalConfig.maxAttempts; attempt++) {
      try {
        const result = await operation();
        
        if (attempt > 1) {
          logger.info(`Operation succeeded on attempt ${attempt}`, {
            operation: operationName,
            attempts: attempt
          });
        }
        
        return result;
      } catch (error) {
        lastError = error;
        
        logger.warn(`Operation failed on attempt ${attempt}`, {
          operation: operationName,
          attempt,
          maxAttempts: finalConfig.maxAttempts,
          error: error instanceof Error ? error.message : String(error)
        });

        // Check if we should retry
        if (attempt === finalConfig.maxAttempts || !finalConfig.retryCondition!(error)) {
          break;
        }

        // Call retry callback
        if (finalConfig.onRetry) {
          finalConfig.onRetry(attempt, error);
        }

        // Wait before next attempt
        const delay = this.calculateDelay(attempt, finalConfig);
        await this.sleep(delay);
      }
    }

    logger.error(`Operation failed after ${finalConfig.maxAttempts} attempts`, {
      operation: operationName,
      finalError: lastError instanceof Error ? lastError.message : String(lastError)
    });

    throw lastError;
  }

  /**
   * Execute operation with circuit breaker pattern
   */
  async withCircuitBreaker<T>(
    operation: () => Promise<T>,
    circuitName: string,
    config: Partial<CircuitBreakerConfig> = {}
  ): Promise<T> {
    let circuitBreaker = this.circuitBreakers.get(circuitName);
    
    if (!circuitBreaker) {
      circuitBreaker = new CircuitBreaker({
        failureThreshold: 5,
        resetTimeout: 60000,
        monitoringPeriod: 120000,
        ...config
      });
      this.circuitBreakers.set(circuitName, circuitBreaker);
    }

    return circuitBreaker.execute(operation);
  }

  /**
   * Execute operation with both retry and circuit breaker
   */
  async withRetryAndCircuitBreaker<T>(
    operation: () => Promise<T>,
    circuitName: string,
    retryConfig: Partial<RetryConfig> = {},
    circuitConfig: Partial<CircuitBreakerConfig> = {}
  ): Promise<T> {
    return this.withCircuitBreaker(
      () => this.withRetry(operation, retryConfig, circuitName),
      circuitName,
      circuitConfig
    );
  }

  /**
   * Get circuit breaker state
   */
  getCircuitState(circuitName: string): CircuitState | null {
    const circuit = this.circuitBreakers.get(circuitName);
    return circuit ? circuit.getState() : null;
  }

  /**
   * Reset circuit breaker
   */
  resetCircuit(circuitName: string): void {
    const circuit = this.circuitBreakers.get(circuitName);
    if (circuit) {
      circuit.reset();
    }
  }

  /**
   * Get circuit breaker statistics
   */
  getCircuitStats(circuitName: string): any {
    const circuit = this.circuitBreakers.get(circuitName);
    return circuit ? circuit.getStats() : null;
  }

  // Private helper methods

  private defaultRetryCondition(error: any): boolean {
    // Retry on network errors, timeouts, and 5xx status codes
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT') {
      return true;
    }
    
    if (error.status >= 500 && error.status < 600) {
      return true;
    }
    
    if (error.status === 429) { // Rate limiting
      return true;
    }
    
    return false;
  }

  private calculateDelay(attempt: number, config: RetryConfig): number {
    let delay = config.baseDelay * Math.pow(config.exponentialBase, attempt - 1);
    
    // Apply maximum delay
    delay = Math.min(delay, config.maxDelay);
    
    // Add jitter to prevent thundering herd
    if (config.jitter) {
      delay = delay * (0.5 + Math.random() * 0.5);
    }
    
    return Math.floor(delay);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

/**
 * Circuit Breaker implementation
 */
class CircuitBreaker {
  private state: CircuitState = 'closed';
  private failureCount = 0;
  private lastFailureTime = 0;
  private successCount = 0;
  private totalRequests = 0;
  private config: CircuitBreakerConfig;

  constructor(config: CircuitBreakerConfig) {
    this.config = config;
  }

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailureTime > this.config.resetTimeout) {
        this.state = 'half-open';
        logger.info('Circuit breaker moved to half-open state');
      } else {
        throw new Error('Circuit breaker is open - operation not allowed');
      }
    }

    this.totalRequests++;

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  getState(): CircuitState {
    return this.state;
  }

  getStats(): any {
    return {
      state: this.state,
      failureCount: this.failureCount,
      successCount: this.successCount,
      totalRequests: this.totalRequests,
      failureRate: this.totalRequests > 0 ? this.failureCount / this.totalRequests : 0,
      lastFailureTime: this.lastFailureTime
    };
  }

  reset(): void {
    this.state = 'closed';
    this.failureCount = 0;
    this.successCount = 0;
    this.lastFailureTime = 0;
    logger.info('Circuit breaker manually reset');
  }

  private onSuccess(): void {
    this.successCount++;
    
    if (this.state === 'half-open') {
      this.state = 'closed';
      this.failureCount = 0;
      logger.info('Circuit breaker closed after successful half-open test');
    }
  }

  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.state === 'half-open') {
      this.state = 'open';
      logger.warn('Circuit breaker opened after half-open failure');
    } else if (this.failureCount >= this.config.failureThreshold) {
      this.state = 'open';
      logger.warn(`Circuit breaker opened after ${this.failureCount} failures`);
    }
  }
}

/**
 * Convenience functions for common retry patterns
 */
export class RetryPatterns {
  private static retryManager = RetryManager.getInstance();

  /**
   * API call with standard retry
   */
  static async apiCall<T>(
    operation: () => Promise<T>,
    operationName?: string
  ): Promise<T> {
    return this.retryManager.withRetry(operation, {
      maxAttempts: 3,
      baseDelay: 1000,
      maxDelay: 10000,
      retryCondition: (error) => {
        // Retry on network errors and 5xx, but not on 4xx (except 429)
        return error.status >= 500 || error.status === 429 || !error.status;
      }
    }, operationName);
  }

  /**
   * Database operation with retry
   */
  static async databaseOperation<T>(
    operation: () => Promise<T>,
    operationName?: string
  ): Promise<T> {
    return this.retryManager.withRetry(operation, {
      maxAttempts: 5,
      baseDelay: 500,
      maxDelay: 5000,
      retryCondition: (error) => {
        // Retry on connection errors and timeouts
        return error.code === 'ECONNRESET' || 
               error.code === 'ETIMEDOUT' || 
               error.message?.includes('connection');
      }
    }, operationName);
  }

  /**
   * File operation with retry
   */
  static async fileOperation<T>(
    operation: () => Promise<T>,
    operationName?: string
  ): Promise<T> {
    return this.retryManager.withRetry(operation, {
      maxAttempts: 3,
      baseDelay: 100,
      maxDelay: 1000,
      jitter: false, // File operations don't need jitter
      retryCondition: (error) => {
        // Retry on file system errors but not permission errors
        return error.code === 'EBUSY' || 
               error.code === 'EMFILE' || 
               error.code === 'ENFILE';
      }
    }, operationName);
  }
}

/**
 * Global retry manager instance
 */
export const retryManager = RetryManager.getInstance();
```

## services/llm/utils/ValidationUtils.ts

```typescript
/**
 * Validation Utilities
 * Comprehensive validation functions for lab kit operations
 * Based on patterns from existing validation services
 */


export interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export interface SchemaValidationRule {
  field: string;
  type: 'string' | 'number' | 'boolean' | 'array' | 'object' | 'email' | 'url';
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  min?: number;
  max?: number;
  pattern?: RegExp;
  allowedValues?: any[];
  customValidator?: (value: any) => string | null;
}

export class ValidationUtils {
  /**
   * Validate test configuration
   */
  static validateTestConfig(config: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    // Required fields
    if (!config.name || typeof config.name !== 'string') {
      result.errors.push('Test name is required and must be a string');
      result.isValid = false;
    }

    if (!config.provider || typeof config.provider !== 'string') {
      result.errors.push('Provider is required and must be a string');
      result.isValid = false;
    }

    if (!config.scenarios || !Array.isArray(config.scenarios) || config.scenarios.length === 0) {
      result.errors.push('At least one test scenario is required');
      result.isValid = false;
    }

    // Validate scenarios
    if (config.scenarios && Array.isArray(config.scenarios)) {
      config.scenarios.forEach((scenario: any, index: number) => {
        const scenarioResult = this.validateTestScenario(scenario);
        if (!scenarioResult.isValid) {
          result.errors.push(...scenarioResult.errors.map(err => `Scenario ${index + 1}: ${err}`));
          result.isValid = false;
        }
        result.warnings.push(...scenarioResult.warnings.map(warn => `Scenario ${index + 1}: ${warn}`));
      });
    }

    // Validate evaluation criteria
    if (config.evaluation) {
      const evalResult = this.validateEvaluationConfig(config.evaluation);
      if (!evalResult.isValid) {
        result.errors.push(...evalResult.errors);
        result.isValid = false;
      }
      result.warnings.push(...evalResult.warnings);
    }

    return result;
  }

  /**
   * Validate test scenario
   */
  static validateTestScenario(scenario: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    if (!scenario.id || typeof scenario.id !== 'string') {
      result.errors.push('Scenario ID is required and must be a string');
      result.isValid = false;
    }

    if (!scenario.userInput || typeof scenario.userInput !== 'string') {
      result.errors.push('User input is required and must be a string');
      result.isValid = false;
    }

    if (scenario.expectedOutput && typeof scenario.expectedOutput !== 'string') {
      result.errors.push('Expected output must be a string if provided');
      result.isValid = false;
    }

    // Validate metadata
    if (scenario.metadata && typeof scenario.metadata !== 'object') {
      result.errors.push('Scenario metadata must be an object');
      result.isValid = false;
    }

    // Check for overly long inputs
    if (scenario.userInput && scenario.userInput.length > 10000) {
      result.warnings.push('User input is very long (>10,000 characters) - may affect performance');
    }

    return result;
  }

  /**
   * Validate evaluation configuration
   */
  static validateEvaluationConfig(evaluation: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    if (!evaluation.criteria || !Array.isArray(evaluation.criteria)) {
      result.errors.push('Evaluation criteria must be an array');
      result.isValid = false;
      return result;
    }

    evaluation.criteria.forEach((criterion: any, index: number) => {
      if (!criterion.name || typeof criterion.name !== 'string') {
        result.errors.push(`Criterion ${index + 1}: name is required and must be a string`);
        result.isValid = false;
      }

      if (!criterion.type || typeof criterion.type !== 'string') {
        result.errors.push(`Criterion ${index + 1}: type is required and must be a string`);
        result.isValid = false;
      }

      if (criterion.weight !== undefined) {
        if (typeof criterion.weight !== 'number' || criterion.weight < 0 || criterion.weight > 1) {
          result.errors.push(`Criterion ${index + 1}: weight must be a number between 0 and 1`);
          result.isValid = false;
        }
      }
    });

    return result;
  }

  /**
   * Validate optimization configuration
   */
  static validateOptimizationConfig(config: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    if (!config.basePrompt || typeof config.basePrompt !== 'string') {
      result.errors.push('Base prompt is required and must be a string');
      result.isValid = false;
    }

    if (!config.testScenarios || !Array.isArray(config.testScenarios)) {
      result.errors.push('Test scenarios are required and must be an array');
      result.isValid = false;
    }

    if (config.generations && (typeof config.generations !== 'number' || config.generations < 1)) {
      result.errors.push('Generations must be a positive number');
      result.isValid = false;
    }

    if (config.populationSize && (typeof config.populationSize !== 'number' || config.populationSize < 2)) {
      result.errors.push('Population size must be at least 2');
      result.isValid = false;
    }

    if (config.mutationRate && (typeof config.mutationRate !== 'number' || config.mutationRate < 0 || config.mutationRate > 1)) {
      result.errors.push('Mutation rate must be a number between 0 and 1');
      result.isValid = false;
    }

    return result;
  }

  /**
   * Validate provider configuration
   */
  static validateProviderConfig(provider: string, config: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    const providerValidators: Record<string, (config: any) => ValidationResult> = {
      openai: this.validateOpenAIConfig,
      google: this.validateGoogleConfig,
      anthropic: this.validateAnthropicConfig,
      mistral: this.validateMistralConfig,
      openrouter: this.validateOpenRouterConfig,
      requesty: this.validateRequestyConfig
    };

    const validator = providerValidators[provider.toLowerCase()];
    if (!validator) {
      result.errors.push(`Unknown provider: ${provider}`);
      result.isValid = false;
      return result;
    }

    return validator(config);
  }

  /**
   * Validate using custom schema
   */
  static validateSchema(data: any, rules: SchemaValidationRule[]): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    for (const rule of rules) {
      const value = this.getNestedValue(data, rule.field);
      const validation = this.validateField(value, rule);
      
      if (validation.error) {
        result.errors.push(`${rule.field}: ${validation.error}`);
        result.isValid = false;
      }

      if (validation.warning) {
        result.warnings.push(`${rule.field}: ${validation.warning}`);
      }
    }

    return result;
  }

  /**
   * Validate API response format
   */
  static validateAPIResponse(response: any, expectedFields: string[]): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    if (!response || typeof response !== 'object') {
      result.errors.push('Response must be an object');
      result.isValid = false;
      return result;
    }

    for (const field of expectedFields) {
      if (!(field in response)) {
        result.errors.push(`Missing required field: ${field}`);
        result.isValid = false;
      }
    }

    return result;
  }

  /**
   * Validate test result
   */
  static validateTestResult(result: any): ValidationResult {
    const validationResult: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    const requiredFields = ['id', 'response', 'evaluation', 'timestamp'];
    const fieldValidation = this.validateAPIResponse(result, requiredFields);
    
    if (!fieldValidation.isValid) {
      validationResult.errors.push(...fieldValidation.errors);
      validationResult.isValid = false;
    }

    // Validate response structure
    if (result.response) {
      if (!result.response.content || typeof result.response.content !== 'string') {
        validationResult.errors.push('Response content is required and must be a string');
        validationResult.isValid = false;
      }

      if (result.response.tokens && typeof result.response.tokens !== 'number') {
        validationResult.errors.push('Response tokens must be a number');
        validationResult.isValid = false;
      }
    }

    // Validate evaluation structure
    if (result.evaluation) {
      if (typeof result.evaluation.overall !== 'number' || result.evaluation.overall < 0 || result.evaluation.overall > 1) {
        validationResult.errors.push('Evaluation overall score must be a number between 0 and 1');
        validationResult.isValid = false;
      }

      if (typeof result.evaluation.passed !== 'boolean') {
        validationResult.errors.push('Evaluation passed must be a boolean');
        validationResult.isValid = false;
      }
    }

    return validationResult;
  }

  // Private validation methods for specific providers

  private static validateOpenAIConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('OpenAI API key is required');
      result.isValid = false;
    }

    if (config.organization && typeof config.organization !== 'string') {
      result.errors.push('OpenAI organization must be a string');
      result.isValid = false;
    }

    return result;
  }

  private static validateGoogleConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('Google API key is required');
      result.isValid = false;
    }

    return result;
  }

  private static validateAnthropicConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('Anthropic API key is required');
      result.isValid = false;
    }

    return result;
  }

  private static validateMistralConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('Mistral API key is required');
      result.isValid = false;
    }

    return result;
  }

  private static validateOpenRouterConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('OpenRouter API key is required');
      result.isValid = false;
    }

    return result;
  }

  private static validateRequestyConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('Requesty API key is required');
      result.isValid = false;
    }

    return result;
  }

  // Helper methods

  private static validateField(value: any, rule: SchemaValidationRule): { error?: string; warning?: string } {
    // Check required
    if (rule.required && (value === undefined || value === null)) {
      return { error: 'is required' };
    }

    if (value === undefined || value === null) {
      return {}; // Optional field, skip validation
    }

    // Check type
    const actualType = Array.isArray(value) ? 'array' : typeof value;
    if (rule.type === 'email' && actualType === 'string') {
      if (!this.isValidEmail(value)) {
        return { error: 'must be a valid email address' };
      }
    } else if (rule.type === 'url' && actualType === 'string') {
      if (!this.isValidUrl(value)) {
        return { error: 'must be a valid URL' };
      }
    } else if (rule.type !== actualType) {
      return { error: `must be of type ${rule.type}` };
    }

    // Check string constraints
    if (rule.type === 'string' && typeof value === 'string') {
      if (rule.minLength && value.length < rule.minLength) {
        return { error: `must be at least ${rule.minLength} characters long` };
      }
      if (rule.maxLength && value.length > rule.maxLength) {
        return { error: `must be no more than ${rule.maxLength} characters long` };
      }
      if (rule.pattern && !rule.pattern.test(value)) {
        return { error: 'does not match the required pattern' };
      }
    }

    // Check number constraints
    if (rule.type === 'number' && typeof value === 'number') {
      if (rule.min !== undefined && value < rule.min) {
        return { error: `must be at least ${rule.min}` };
      }
      if (rule.max !== undefined && value > rule.max) {
        return { error: `must be no more than ${rule.max}` };
      }
    }

    // Check allowed values
    if (rule.allowedValues && !rule.allowedValues.includes(value)) {
      return { error: `must be one of: ${rule.allowedValues.join(', ')}` };
    }

    // Custom validation
    if (rule.customValidator) {
      const customError = rule.customValidator(value);
      if (customError) {
        return { error: customError };
      }
    }

    return {};
  }

  private static getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }

  private static isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  private static isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }
}

/**
 * Common validation schemas
 */
export const CommonSchemas = {
  testConfig: [
    { field: 'name', type: 'string' as const, required: true, minLength: 1 },
    { field: 'provider', type: 'string' as const, required: true },
    { field: 'scenarios', type: 'array' as const, required: true },
    { field: 'description', type: 'string' as const, required: false },
    { field: 'timeout', type: 'number' as const, required: false, min: 1000 }
  ],

  scenario: [
    { field: 'id', type: 'string' as const, required: true, minLength: 1 },
    { field: 'userInput', type: 'string' as const, required: true, minLength: 1 },
    { field: 'expectedOutput', type: 'string' as const, required: false },
    { field: 'metadata', type: 'object' as const, required: false }
  ],

  optimizationConfig: [
    { field: 'basePrompt', type: 'string' as const, required: true, minLength: 10 },
    { field: 'testScenarios', type: 'array' as const, required: true },
    { field: 'generations', type: 'number' as const, required: false, min: 1, max: 100 },
    { field: 'populationSize', type: 'number' as const, required: false, min: 2, max: 50 },
    { field: 'mutationRate', type: 'number' as const, required: false, min: 0, max: 1 }
  ]
};
```

## services/llm/utils/WebSearchUtils.ts

```typescript
/**
 * Location: src/services/llm/utils/WebSearchUtils.ts
 * Summary: Utility functions for web search source extraction and formatting
 * Used by: LLM adapters for standardized source extraction and markdown formatting
 */

import { SearchResult } from '../adapters/types';

export class WebSearchUtils {
  /**
   * Format web search sources as markdown
   */
  static formatSourcesAsMarkdown(sources: SearchResult[]): string {
    if (!sources || sources.length === 0) {
      return '';
    }

    return sources
      .map(source =>
        `- [${source.title}](${source.url})${source.date ? ` - ${source.date}` : ''}`
      )
      .join('\n');
  }

  /**
   * Validate and normalize a search result
   */
  static validateSearchResult(result: any): SearchResult | null {
    if (!result || typeof result !== 'object') {
      return null;
    }

    if (!result.title || !result.url) {
      return null;
    }

    // Validate URL format
    try {
      new URL(result.url);
    } catch {
      return null;
    }

    return {
      title: String(result.title).trim(),
      url: String(result.url).trim(),
      date: result.date ? String(result.date).trim() : undefined
    };
  }

  /**
   * Extract and validate multiple search results
   */
  static extractSearchResults(results: any[]): SearchResult[] {
    if (!Array.isArray(results)) {
      return [];
    }

    return results
      .map(result => this.validateSearchResult(result))
      .filter((result): result is SearchResult => result !== null);
  }

  /**
   * Generate sources section for markdown content
   */
  static generateSourcesSection(sources: SearchResult[]): string {
    if (!sources || sources.length === 0) {
      return '';
    }

    const sourcesMarkdown = this.formatSourcesAsMarkdown(sources);
    return `\n\n---\n\n## Sources\n\n${sourcesMarkdown}`;
  }

  /**
   * Check if provider supports web search
   */
  static isWebSearchSupported(provider: string): boolean {
    const supportedProviders = [
      'perplexity',
      'openrouter',
      'openai',
      'google',
      'anthropic',
      'groq',
      'mistral'
    ];

    return supportedProviders.includes(provider.toLowerCase());
  }

  /**
   * Validate web search request
   */
  static validateWebSearchRequest(provider: string, webSearchRequested: boolean): void {
    if (webSearchRequested && !this.isWebSearchSupported(provider)) {
      const supportedProviders = [
        'perplexity', 'openrouter', 'openai',
        'google', 'anthropic', 'groq', 'mistral'
      ];

      throw new Error(
        `Web search not supported by ${provider}. ` +
        `Supported providers: ${supportedProviders.join(', ')}`
      );
    }
  }
}
```

## services/llm/utils/index.ts

```typescript
/**
 * Utilities module exports
 * Essential utility functions and managers for the lab kit
 */

export { ConfigManager, type LabKitConfig } from './ConfigManager';
export { Logger, ComponentLogger, logger, createLogger, type LogLevel, type LogEntry } from './Logger';
export { 
  RetryManager, 
  RetryPatterns, 
  retryManager, 
  type RetryConfig, 
  type CircuitBreakerConfig,
  type CircuitState 
} from './RetryManager';
export { 
  ValidationUtils, 
  CommonSchemas, 
  type ValidationResult, 
  type SchemaValidationRule 
} from './ValidationUtils';
export {
  CacheManager,
  LRUCache,
  FileCache,
  BaseCache,
  type CacheEntry,
  type CacheConfig,
  type CacheMetrics
} from './CacheManager';
export { WebSearchUtils } from './WebSearchUtils';

/**
 * Quick setup function for basic lab kit initialization
 */
import { ConfigManager } from './ConfigManager';
import { Logger, createLogger } from './Logger';

export interface QuickSetupOptions {
  logLevel?: 'debug' | 'info' | 'warn' | 'error';
  enableFileLogging?: boolean;
  logDirectory?: string;
  configPath?: string;
  validateConfig?: boolean;
}

export async function quickSetup(options: QuickSetupOptions = {}): Promise<{
  config: ConfigManager;
  logger: Logger;
  isReady: boolean;
  summary: any;
}> {
  // Initialize configuration
  const config = ConfigManager.getInstance();
  
  if (options.configPath) {
    config.loadFromFile(options.configPath);
  }

  // Initialize logging
  const logger = Logger.getInstance({
    level: options.logLevel || 'info',
    enableFile: options.enableFileLogging || false,
    logDirectory: options.logDirectory || './logs'
  });

  logger.info('üöÄ Synaptic Lab Kit initializing...');

  // Validate configuration if requested
  if (options.validateConfig) {
    const summary = config.getConfigSummary();
    
    if (summary.providers.configured.length === 0) {
      logger.warn('No LLM providers configured - add API keys to environment or config file');
    } else {
      logger.info(`Configured providers: ${summary.providers.configured.join(', ')}`);
    }

    if (!summary.database.configured) {
      logger.warn('Database not configured - some features may not work');
    }

  }

  const isReady = config.getConfiguredProviders().length > 0;
  const summary = config.getConfigSummary();

  logger.info(`‚úÖ Lab Kit initialization ${isReady ? 'completed' : 'completed with warnings'}`);

  return {
    config,
    logger,
    isReady,
    summary
  };
}

/**
 * Environment validation helper
 */
export function validateEnvironment(): {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  recommendations: string[];
} {
  const result = {
    isValid: true,
    errors: [] as string[],
    warnings: [] as string[],
    recommendations: [] as string[]
  };

  // Check Node.js version
  const nodeVersion = process.version;
  const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0] || '0');
  
  if (majorVersion < 18) {
    result.errors.push(`Node.js version ${nodeVersion} is not supported. Please use Node.js 18 or higher.`);
    result.isValid = false;
  }

  // Check for required environment variables
  const requiredEnvVars = [
    'OPENAI_API_KEY',
    'GOOGLE_API_KEY', 
    'ANTHROPIC_API_KEY',
    'MISTRAL_API_KEY',
    'OPENROUTER_API_KEY',
    'REQUESTY_API_KEY',
    'PERPLEXITY_API_KEY'
  ];

  const configuredVars = requiredEnvVars.filter(varName => process.env[varName]);
  
  if (configuredVars.length === 0) {
    result.errors.push('No LLM provider API keys found in environment variables');
    result.isValid = false;
  } else if (configuredVars.length < 2) {
    result.warnings.push('Only one LLM provider configured - consider adding more for comparison testing');
  }

  // Check database configuration
  const hasSupabase = process.env.SUPABASE_URL && process.env.SUPABASE_ANON_KEY;
  if (!hasSupabase) {
    result.warnings.push('Supabase not configured - database features will not be available');
    result.recommendations.push('Add SUPABASE_URL and SUPABASE_ANON_KEY to enable database functionality');
  }


  return result;
}

/**
 * Create a validation report for the current setup
 */
export function createSetupReport(): string {
  const config = ConfigManager.getInstance();
  const envValidation = validateEnvironment();
  const summary = config.getConfigSummary();

  let report = '# Synaptic Lab Kit Setup Report\n\n';
  
  // Environment validation
  report += '## Environment Validation\n\n';
  if (envValidation.isValid) {
    report += '‚úÖ Environment validation passed\n\n';
  } else {
    report += '‚ùå Environment validation failed\n\n';
    report += '**Errors:**\n';
    envValidation.errors.forEach(error => {
      report += `- ${error}\n`;
    });
    report += '\n';
  }

  if (envValidation.warnings.length > 0) {
    report += '**Warnings:**\n';
    envValidation.warnings.forEach(warning => {
      report += `- ${warning}\n`;
    });
    report += '\n';
  }

  if (envValidation.recommendations.length > 0) {
    report += '**Recommendations:**\n';
    envValidation.recommendations.forEach(rec => {
      report += `- ${rec}\n`;
    });
    report += '\n';
  }

  // Configuration summary
  report += '## Configuration Summary\n\n';
  report += `**LLM Providers:** ${summary.providers.configured.join(', ') || 'None'}\n`;
  report += `**Database:** ${summary.database.configured ? 'Configured' : 'Not configured'}\n`;
  report += `**Log Level:** ${summary.logging.level}\n\n`;

  // Readiness status
  report += '## Readiness Status\n\n';
  if (summary.providers.configured.length > 0) {
    report += '‚úÖ Ready for testing\n';
  } else {
    report += '‚ùå Not ready - no providers configured\n';
  }

  return report;
}

/**
 * Performance monitoring utilities
 */
export class PerformanceMonitor {
  private static timers: Map<string, number> = new Map();
  private static logger = createLogger('Performance');

  static startTimer(name: string): void {
    this.timers.set(name, Date.now());
  }

  static endTimer(name: string, logResult = true): number {
    const startTime = this.timers.get(name);
    if (!startTime) {
      throw new Error(`Timer '${name}' was not started`);
    }

    const duration = Date.now() - startTime;
    this.timers.delete(name);

    if (logResult) {
      this.logger.performance(name, duration);
    }

    return duration;
  }

  static async timeAsync<T>(name: string, operation: () => Promise<T>): Promise<T> {
    this.startTimer(name);
    try {
      const result = await operation();
      this.endTimer(name);
      return result;
    } catch (error) {
      this.endTimer(name);
      throw error;
    }
  }

  static time<T>(name: string, operation: () => T): T {
    this.startTimer(name);
    try {
      const result = operation();
      this.endTimer(name);
      return result;
    } catch (error) {
      this.endTimer(name);
      throw error;
    }
  }
}
```

## services/llm/validation/ValidationService.ts

```typescript
/**
 * LLM Validation Service
 * Direct API key validation without full adapter initialization
 */

import OpenAI from 'openai';
import { requestUrl } from 'obsidian';

export class LLMValidationService {
  private static readonly VALIDATION_TIMEOUT = 10000; // 10 seconds
  private static readonly VALIDATION_DELAY = 2000; // 2 seconds delay before validation

  /**
   * Wrapper for requestUrl with timeout support
   */
  private static async requestWithTimeout(config: any): Promise<any> {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error('Request timeout'));
      }, this.VALIDATION_TIMEOUT);

      requestUrl(config)
        .then(response => {
          clearTimeout(timeoutId);
          resolve(response);
        })
        .catch(error => {
          clearTimeout(timeoutId);
          reject(error);
        });
    });
  }

  /**
   * Validate an API key by making a simple test request
   */
  static async validateApiKey(provider: string, apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Wait a couple seconds before validation as requested
      await new Promise(resolve => setTimeout(resolve, this.VALIDATION_DELAY));
      
      switch (provider) {
        case 'openai':
          return await this.validateOpenAI(apiKey);
        case 'anthropic':
          return await this.validateAnthropic(apiKey);
        case 'google':
          return await this.validateGoogle(apiKey);
        case 'mistral':
          return await this.validateMistral(apiKey);
        case 'groq':
          return await this.validateGroq(apiKey);
        case 'openrouter':
          return await this.validateOpenRouter(apiKey);
        case 'perplexity':
          return await this.validatePerplexity(apiKey);
        case 'requesty':
          return await this.validateRequesty(apiKey);
        default:
          return { success: false, error: `Unsupported provider: ${provider}` };
      }
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }

  private static async validateOpenAI(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const client = new OpenAI({
        apiKey: apiKey,
        dangerouslyAllowBrowser: true,
        timeout: this.VALIDATION_TIMEOUT
      });

      // Make a simple test request
      const response = await client.chat.completions.create({
        model: 'gpt-4.1-nano',
        messages: [{ role: 'user', content: 'Hi' }],
        max_tokens: 5
      });

      return { success: true };
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'OpenAI API key validation failed' 
      };
    }
  }

  private static async validateAnthropic(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Use Obsidian's requestUrl to bypass CORS restrictions
      const response = await this.requestWithTimeout({
        url: 'https://api.anthropic.com/v1/messages',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: 'claude-3-5-haiku-latest',
          max_tokens: 5,
          messages: [{ role: 'user', content: 'Hi' }]
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Anthropic API key validation failed' 
      };
    }
  }

  private static async validateGoogle(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-goog-api-key': apiKey
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: 'Hi' }] }],
          generationConfig: { maxOutputTokens: 5 }
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Google API key validation failed' 
      };
    }
  }

  private static async validateMistral(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://api.mistral.ai/v1/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'mistral-tiny',
          messages: [{ role: 'user', content: 'Hi' }],
          max_tokens: 5
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Mistral API key validation failed' 
      };
    }
  }

  private static async validateGroq(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://api.groq.com/openai/v1/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'llama3-8b-8192',
          messages: [{ role: 'user', content: 'Hi' }],
          max_tokens: 5
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Groq API key validation failed' 
      };
    }
  }

  private static async validateOpenRouter(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://openrouter.ai/api/v1/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
          'HTTP-Referer': 'https://github.com/anthropics/claude-code',
          'X-Title': 'Claude Code Obsidian Plugin'
        },
        body: JSON.stringify({
          model: 'openai/gpt-4.1-nano',
          messages: [{ role: 'user', content: 'Hi' }],
          max_tokens: 5
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'OpenRouter API key validation failed' 
      };
    }
  }

  private static async validatePerplexity(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://api.perplexity.ai/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'sonar',
          messages: [{ role: 'user', content: 'Hi' }],
          max_tokens: 5
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Perplexity API key validation failed' 
      };
    }
  }

  private static async validateRequesty(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://router.requesty.ai/v1/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'openai/gpt-4.1-nano',
          messages: [{ role: 'user', content: 'Hi' }],
          max_tokens: 5
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Requesty API key validation failed' 
      };
    }
  }
}
```

## services/llm/validation/index.ts

```typescript
/**
 * LLM Validation Services Index
 * Exports for API key validation functionality
 */

export { LLMValidationService } from './ValidationService';
```

## services/mcp-bridge/core/MCPFunctionBridge.ts

```typescript
/**
 * Location: /src/services/mcp-bridge/core/MCPFunctionBridge.ts
 * 
 * This file implements the main MCP Function Bridge orchestrator that provides a unified
 * interface for converting MCP tools to function calling formats and executing tool calls.
 * It coordinates between tool discovery, schema conversion, and tool execution components.
 * 
 * Used by: LLM adapters (OpenAI, OpenRouter, etc.) for MCP tool integration
 * Dependencies: ToolSchemaConverter, MCPToolExecutor, BridgeTypes
 */

import {
  IMCPFunctionBridge,
  MCPTool,
  ProviderTool,
  ToolCallRequest,
  ToolCallResult,
  BridgeConfiguration,
  BridgeDiagnostics,
  ExecutionStats,
  ToolFeature,
  SupportedProvider,
  MCPToolListResponse,
  BridgeError,
  BridgeErrorType,
  DiagnosticLevel
} from '../types/BridgeTypes';
import { ToolSchemaConverter } from './ToolSchemaConverter';
import { MCPToolExecutor } from './MCPToolExecutor';

/**
 * Bridge state for tracking initialization and health
 */
interface BridgeState {
  isInitialized: boolean;
  lastToolDiscovery: string | null;
  mcpServerStatus: 'connected' | 'disconnected' | 'error';
  availableTools: MCPTool[];
  enabledProviders: SupportedProvider[];
  initializationError: Error | null;
}

/**
 * Default bridge configuration
 */
const DEFAULT_CONFIG: BridgeConfiguration = {
  mcpServer: {
    url: 'http://localhost:3000',
    timeout: 30000,
    retries: 2,
    healthCheckInterval: 60000 // 1 minute
  },
  providers: {
    openai: {
      enabled: true,
      features: [ToolFeature.FUNCTION_CALLING, ToolFeature.PARALLEL_CALLS, ToolFeature.STREAMING, ToolFeature.VALIDATION]
    },
    openrouter: {
      enabled: true,
      features: [ToolFeature.FUNCTION_CALLING, ToolFeature.PARALLEL_CALLS, ToolFeature.STREAMING, ToolFeature.VALIDATION]
    },
    anthropic: {
      enabled: false, // TODO: Enable when converter is implemented
      features: [ToolFeature.FUNCTION_CALLING]
    },
    google: {
      enabled: false, // TODO: Enable when converter is implemented
      features: [ToolFeature.FUNCTION_CALLING]
    },
    groq: {
      enabled: false, // TODO: Enable when converter is implemented
      features: [ToolFeature.FUNCTION_CALLING, ToolFeature.PARALLEL_CALLS]
    },
    mistral: {
      enabled: false, // TODO: Enable when converter is implemented
      features: [ToolFeature.FUNCTION_CALLING]
    }
  },
  diagnostics: {
    enabled: true,
    level: DiagnosticLevel.INFO,
    retentionDays: 7,
    maxEvents: 1000
  },
  cache: {
    enabled: true,
    toolSchemaTTL: 300000, // 5 minutes
    resultTTL: 60000, // 1 minute
    maxSize: 100
  },
  ui: {
    showAccordion: true,
    expandByDefault: false,
    showTimings: true,
    showParameters: true
  }
};

/**
 * MCP Function Bridge Implementation
 * 
 * Main orchestrator that coordinates tool discovery, schema conversion,
 * and tool execution across all supported LLM providers.
 */
export class MCPFunctionBridge implements IMCPFunctionBridge {
  private config: BridgeConfiguration;
  private schemaConverter: ToolSchemaConverter;
  private toolExecutor: MCPToolExecutor;
  private state: BridgeState;
  private healthCheckInterval: NodeJS.Timeout | null = null;
  
  constructor(config: Partial<BridgeConfiguration> = {}) {
    this.config = this.mergeConfig(DEFAULT_CONFIG, config);
    
    // Initialize state
    this.state = {
      isInitialized: false,
      lastToolDiscovery: null,
      mcpServerStatus: 'disconnected',
      availableTools: [],
      enabledProviders: this.getEnabledProviders(),
      initializationError: null
    };
    
    // Initialize components
    this.schemaConverter = new ToolSchemaConverter({
      enableLogging: this.config.diagnostics.enabled,
      logLevel: this.config.diagnostics.level,
      validateConversions: true,
      cacheConversions: this.config.cache.enabled,
      maxCacheSize: this.config.cache.maxSize
    });
    
    this.toolExecutor = new MCPToolExecutor({
      serverUrl: this.config.mcpServer.url,
      timeout: this.config.mcpServer.timeout,
      retries: this.config.mcpServer.retries,
      enableLogging: this.config.diagnostics.enabled,
      logLevel: this.config.diagnostics.level
    });
    
    if (this.config.diagnostics.enabled) {
      console.log('[MCPFunctionBridge] Initialized with config:', {
        mcpServerUrl: this.config.mcpServer.url,
        enabledProviders: this.state.enabledProviders,
        diagnosticsLevel: this.config.diagnostics.level
      });
    }
  }

  /**
   * Initialize the bridge system
   */
  async initialize(): Promise<void> {
    try {
      if (this.config.diagnostics.enabled) {
        console.log('[MCPFunctionBridge] Initializing bridge system...');
      }
      
      // Test MCP server connection
      const isServerHealthy = await this.toolExecutor.testConnection();
      if (!isServerHealthy) {
        throw new BridgeError(
          BridgeErrorType.MCP_SERVER_UNREACHABLE,
          `MCP server at ${this.config.mcpServer.url} is not reachable`
        );
      }
      
      this.state.mcpServerStatus = 'connected';
      
      // Discover available tools
      await this.refreshTools();
      
      // Start health check interval
      this.startHealthCheck();
      
      this.state.isInitialized = true;
      this.state.initializationError = null;
      
      if (this.config.diagnostics.enabled) {
        console.log('[MCPFunctionBridge] Bridge system initialized successfully:', {
          toolCount: this.state.availableTools.length,
          enabledProviders: this.state.enabledProviders,
          serverStatus: this.state.mcpServerStatus
        });
      }
      
    } catch (error) {
      this.state.isInitialized = false;
      this.state.initializationError = error as Error;
      this.state.mcpServerStatus = 'error';
      
      console.error('[MCPFunctionBridge] Failed to initialize bridge system:', error);
      throw error;
    }
  }

  /**
   * Check if bridge is initialized
   */
  isInitialized(): boolean {
    return this.state.isInitialized;
  }

  /**
   * Get available MCP tools
   */
  async getAvailableTools(): Promise<MCPTool[]> {
    if (!this.state.isInitialized) {
      throw new BridgeError(
        BridgeErrorType.BRIDGE_NOT_INITIALIZED,
        'Bridge must be initialized before getting tools'
      );
    }
    
    return [...this.state.availableTools]; // Return copy to prevent mutation
  }

  /**
   * Get tools converted for specific provider
   */
  async getToolsForProvider(provider: SupportedProvider): Promise<ProviderTool[]> {
    if (!this.state.isInitialized) {
      throw new BridgeError(
        BridgeErrorType.BRIDGE_NOT_INITIALIZED,
        'Bridge must be initialized before getting provider tools'
      );
    }
    
    if (!this.isProviderEnabled(provider)) {
      if (this.config.diagnostics.enabled) {
        console.warn(`[MCPFunctionBridge] Provider ${provider} is not enabled`);
      }
      return [];
    }
    
    if (!this.schemaConverter.isProviderSupported(provider)) {
      throw new BridgeError(
        BridgeErrorType.PROVIDER_NOT_SUPPORTED,
        `Provider ${provider} is not supported`,
        provider
      );
    }
    
    try {
      const convertedTools = await this.schemaConverter.convertToolsForProvider(
        this.state.availableTools,
        provider
      );
      
      if (this.config.diagnostics.enabled && this.config.diagnostics.level !== DiagnosticLevel.ERROR) {
        console.log(`[MCPFunctionBridge] Converted ${convertedTools.length} tools for ${provider}`);
      }
      
      return convertedTools;
      
    } catch (error) {
      console.error(`[MCPFunctionBridge] Failed to convert tools for ${provider}:`, error);
      throw error;
    }
  }

  /**
   * Refresh available tools from MCP server
   */
  async refreshTools(): Promise<void> {
    try {
      if (this.config.diagnostics.enabled && this.config.diagnostics.level !== DiagnosticLevel.ERROR) {
        console.log('[MCPFunctionBridge] Refreshing tools from MCP server...');
      }
      
      const response = await fetch(`${this.config.mcpServer.url}/list_tools`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
        signal: AbortSignal.timeout(this.config.mcpServer.timeout)
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data: MCPToolListResponse = await response.json();
      
      if (!data.tools || !Array.isArray(data.tools)) {
        throw new Error('Invalid response format: missing tools array');
      }
      
      this.state.availableTools = data.tools;
      this.state.lastToolDiscovery = new Date().toISOString();
      this.state.mcpServerStatus = 'connected';
      
      // Clear schema converter cache since tools may have changed
      this.schemaConverter.clearCache();
      
      if (this.config.diagnostics.enabled) {
        console.log(`[MCPFunctionBridge] Successfully refreshed ${data.tools.length} tools from MCP server`);
      }
      
    } catch (error) {
      this.state.mcpServerStatus = 'error';
      console.error('[MCPFunctionBridge] Failed to refresh tools:', error);
      
      if (error instanceof Error && error.name === 'AbortError') {
        throw new BridgeError(
          BridgeErrorType.MCP_SERVER_UNREACHABLE,
          `Tool discovery timeout after ${this.config.mcpServer.timeout}ms`
        );
      } else if (error instanceof TypeError && error.message.includes('fetch')) {
        throw new BridgeError(
          BridgeErrorType.MCP_SERVER_UNREACHABLE,
          `Cannot connect to MCP server at ${this.config.mcpServer.url}`
        );
      }
      
      throw error;
    }
  }

  /**
   * Execute a single tool call
   */
  async executeToolCall(call: ToolCallRequest): Promise<ToolCallResult> {
    if (!this.state.isInitialized) {
      throw new BridgeError(
        BridgeErrorType.BRIDGE_NOT_INITIALIZED,
        'Bridge must be initialized before executing tools'
      );
    }
    
    if (this.config.diagnostics.enabled && this.config.diagnostics.level !== DiagnosticLevel.ERROR) {
      console.log(`[MCPFunctionBridge] Executing tool call: ${call.name}`, {
        id: call.id,
        provider: call.provider
      });
    }
    
    try {
      const result = await this.toolExecutor.executeTool(call);
      
      if (this.config.diagnostics.enabled && this.config.diagnostics.level !== DiagnosticLevel.ERROR) {
        console.log(`[MCPFunctionBridge] Tool execution completed: ${call.name}`, {
          success: result.success,
          executionTime: result.executionTime
        });
      }
      
      return result;
      
    } catch (error) {
      console.error(`[MCPFunctionBridge] Tool execution failed for ${call.name}:`, error);
      throw error;
    }
  }

  /**
   * Execute multiple tool calls
   */
  async executeToolCalls(calls: ToolCallRequest[]): Promise<ToolCallResult[]> {
    if (!this.state.isInitialized) {
      throw new BridgeError(
        BridgeErrorType.BRIDGE_NOT_INITIALIZED,
        'Bridge must be initialized before executing tools'
      );
    }
    
    if (this.config.diagnostics.enabled && this.config.diagnostics.level !== DiagnosticLevel.ERROR) {
      console.log(`[MCPFunctionBridge] Executing ${calls.length} tool calls`);
    }
    
    try {
      // Execute in parallel for better performance
      const results = await this.toolExecutor.executeToolsParallel(calls);
      
      if (this.config.diagnostics.enabled && this.config.diagnostics.level !== DiagnosticLevel.ERROR) {
        const successful = results.filter(r => r.success).length;
        console.log(`[MCPFunctionBridge] Batch execution completed:`, {
          total: results.length,
          successful,
          failed: results.length - successful
        });
      }
      
      return results;
      
    } catch (error) {
      console.error('[MCPFunctionBridge] Batch tool execution failed:', error);
      throw error;
    }
  }

  /**
   * Check if bridge is healthy
   */
  isHealthy(): boolean {
    return this.state.isInitialized && 
           this.state.mcpServerStatus === 'connected' &&
           this.state.availableTools.length > 0;
  }

  /**
   * Get bridge diagnostics
   */
  getDiagnostics(): BridgeDiagnostics {
    return {
      isHealthy: this.isHealthy(),
      mcpServerStatus: this.state.mcpServerStatus,
      lastToolDiscovery: this.state.lastToolDiscovery || 'never',
      toolCount: this.state.availableTools.length,
      enabledProviders: this.state.enabledProviders,
      recentEvents: [] // TODO: Implement event tracking
    };
  }

  /**
   * Get execution statistics
   */
  getExecutionStats(): ExecutionStats {
    return this.toolExecutor.getExecutionMetrics();
  }

  /**
   * Update bridge configuration
   */
  updateConfiguration(config: Partial<BridgeConfiguration>): void {
    this.config = this.mergeConfig(this.config, config);
    this.state.enabledProviders = this.getEnabledProviders();
    
    // Update component configurations
    this.toolExecutor.updateConfig({
      serverUrl: this.config.mcpServer.url,
      timeout: this.config.mcpServer.timeout,
      retries: this.config.mcpServer.retries,
      enableLogging: this.config.diagnostics.enabled,
      logLevel: this.config.diagnostics.level
    });
    
    this.schemaConverter.updateConfig({
      enableLogging: this.config.diagnostics.enabled,
      logLevel: this.config.diagnostics.level,
      cacheConversions: this.config.cache.enabled,
      maxCacheSize: this.config.cache.maxSize
    });
    
    // Restart health check with new interval
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.startHealthCheck();
    }
    
    if (this.config.diagnostics.enabled) {
      console.log('[MCPFunctionBridge] Configuration updated:', config);
    }
  }

  /**
   * Get current configuration
   */
  getConfiguration(): BridgeConfiguration {
    return JSON.parse(JSON.stringify(this.config)); // Deep copy
  }

  /**
   * Start periodic health checks
   */
  private startHealthCheck(): void {
    this.healthCheckInterval = setInterval(async () => {
      try {
        const isHealthy = await this.toolExecutor.testConnection();
        this.state.mcpServerStatus = isHealthy ? 'connected' : 'disconnected';
        
        if (this.config.diagnostics.enabled && this.config.diagnostics.level === DiagnosticLevel.DEBUG) {
          console.log(`[MCPFunctionBridge] Health check: ${this.state.mcpServerStatus}`);
        }
      } catch (error) {
        this.state.mcpServerStatus = 'error';
        if (this.config.diagnostics.enabled) {
          console.error('[MCPFunctionBridge] Health check failed:', error);
        }
      }
    }, this.config.mcpServer.healthCheckInterval);
  }

  /**
   * Get enabled providers from configuration
   */
  private getEnabledProviders(): SupportedProvider[] {
    return Object.entries(this.config.providers)
      .filter(([_, config]) => config?.enabled)
      .map(([provider, _]) => provider as SupportedProvider);
  }

  /**
   * Check if provider is enabled
   */
  private isProviderEnabled(provider: SupportedProvider): boolean {
    return this.state.enabledProviders.includes(provider);
  }

  /**
   * Merge configuration objects recursively
   */
  private mergeConfig(base: BridgeConfiguration, override: Partial<BridgeConfiguration>): BridgeConfiguration {
    const result = { ...base };
    
    for (const [key, value] of Object.entries(override)) {
      if (value !== undefined) {
        if (typeof value === 'object' && !Array.isArray(value) && value !== null) {
          result[key as keyof BridgeConfiguration] = {
            ...result[key as keyof BridgeConfiguration] as any,
            ...value
          };
        } else {
          (result as any)[key] = value;
        }
      }
    }
    
    return result;
  }

  /**
   * Clean up resources
   */
  public dispose(): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }
    
    this.toolExecutor.cleanup();
    this.schemaConverter.clearCache();
    
    this.state.isInitialized = false;
    
    if (this.config.diagnostics.enabled) {
      console.log('[MCPFunctionBridge] Bridge system disposed');
    }
  }
}
```

## services/mcp-bridge/core/MCPToolExecutor.ts

```typescript
/**
 * Location: /src/services/mcp-bridge/core/MCPToolExecutor.ts
 * 
 * This file implements the MCP tool executor that handles communication with the local MCP server
 * via HTTP requests. It provides tool execution, error handling, retry logic, and performance tracking.
 * 
 * Used by: MCPFunctionBridge for executing tool calls via the MCP server
 * Dependencies: BridgeTypes, HTTP client (fetch)
 */

import {
  IMCPToolExecutor,
  ToolCallRequest,
  ToolCallResult,
  ExecutionContext,
  ExecutionStatus,
  ExecutionStats,
  MCPExecutionRequest,
  MCPExecutionResponse,
  BridgeError,
  BridgeErrorType,
  DiagnosticLevel
} from '../types/BridgeTypes';

/**
 * Configuration for MCP tool executor
 */
interface MCPToolExecutorConfig {
  serverUrl: string;
  timeout: number;
  retries: number;
  retryDelayMs: number;
  enableLogging: boolean;
  logLevel: DiagnosticLevel;
}

/**
 * Execution tracking entry
 */
interface ExecutionEntry {
  id: string;
  status: ExecutionStatus;
  startTime: number;
  endTime?: number;
  retryCount: number;
}

/**
 * MCP Tool Executor Implementation
 * 
 * Handles communication with the MCP server at localhost:3000 to execute tools.
 * Provides retry logic, timeout handling, and comprehensive error recovery.
 */
export class MCPToolExecutor implements IMCPToolExecutor {
  private config: MCPToolExecutorConfig;
  private executionMap = new Map<string, ExecutionEntry>();
  private stats: ExecutionStats = {
    totalExecutions: 0,
    successfulExecutions: 0,
    failedExecutions: 0,
    averageExecutionTime: 0,
    currentQueueSize: 0,
    lastExecutionTime: new Date().toISOString()
  };
  
  constructor(config: Partial<MCPToolExecutorConfig> = {}) {
    this.config = {
      serverUrl: 'http://localhost:3000',
      timeout: 30000, // 30 seconds
      retries: 2,
      retryDelayMs: 1000,
      enableLogging: true,
      logLevel: DiagnosticLevel.INFO,
      ...config
    };
    
    if (this.config.enableLogging) {
      console.log('[MCPToolExecutor] Initialized with config:', {
        serverUrl: this.config.serverUrl,
        timeout: this.config.timeout,
        retries: this.config.retries
      });
    }
  }

  /**
   * Execute a single tool call
   */
  async executeTool(call: ToolCallRequest, context?: ExecutionContext): Promise<ToolCallResult> {
    const startTime = Date.now();
    const timestamp = new Date().toISOString();
    
    // Track execution
    this.executionMap.set(call.id, {
      id: call.id,
      status: ExecutionStatus.EXECUTING,
      startTime,
      retryCount: 0
    });
    
    this.stats.currentQueueSize++;
    this.updateStats();
    
    if (this.config.enableLogging && this.config.logLevel !== DiagnosticLevel.ERROR) {
      console.log(`[MCPToolExecutor] Executing tool: ${call.name}`, {
        id: call.id,
        parameters: call.parameters,
        provider: call.provider
      });
    }

    try {
      const result = await this.executeWithRetry(call, context);
      
      // Update tracking
      const execution = this.executionMap.get(call.id);
      if (execution) {
        execution.status = ExecutionStatus.COMPLETED;
        execution.endTime = Date.now();
      }
      
      this.stats.successfulExecutions++;
      this.stats.currentQueueSize--;
      this.updateStats();
      
      if (this.config.enableLogging && this.config.logLevel !== DiagnosticLevel.ERROR) {
        console.log(`[MCPToolExecutor] Tool executed successfully: ${call.name}`, {
          id: call.id,
          executionTime: result.executionTime
        });
      }
      
      return result;
      
    } catch (error) {
      // Update tracking
      const execution = this.executionMap.get(call.id);
      if (execution) {
        execution.status = ExecutionStatus.FAILED;
        execution.endTime = Date.now();
      }
      
      this.stats.failedExecutions++;
      this.stats.currentQueueSize--;
      this.updateStats();
      
      const executionTime = Date.now() - startTime;
      
      console.error(`[MCPToolExecutor] Tool execution failed: ${call.name}`, error);
      
      // Return error result instead of throwing
      return {
        id: call.id,
        name: call.name,
        success: false,
        error: error instanceof Error ? error.message : String(error),
        executionTime,
        timestamp,
        metadata: {
          provider: call.provider,
          mcpServer: this.config.serverUrl,
          errorType: error instanceof BridgeError ? error.type : BridgeErrorType.TOOL_EXECUTION_ERROR,
          retryCount: execution?.retryCount || 0
        }
      };
    }
  }

  /**
   * Execute multiple tools in sequence (batch)
   */
  async executeToolsBatch(calls: ToolCallRequest[], context?: ExecutionContext): Promise<ToolCallResult[]> {
    if (this.config.enableLogging && this.config.logLevel !== DiagnosticLevel.ERROR) {
      console.log(`[MCPToolExecutor] Executing ${calls.length} tools in batch`);
    }
    
    const results: ToolCallResult[] = [];
    
    for (const call of calls) {
      const result = await this.executeTool(call, context);
      results.push(result);
    }
    
    return results;
  }

  /**
   * Execute multiple tools in parallel
   */
  async executeToolsParallel(calls: ToolCallRequest[], context?: ExecutionContext): Promise<ToolCallResult[]> {
    if (this.config.enableLogging && this.config.logLevel !== DiagnosticLevel.ERROR) {
      console.log(`[MCPToolExecutor] Executing ${calls.length} tools in parallel`);
    }
    
    const promises = calls.map(call => this.executeTool(call, context));
    return Promise.all(promises);
  }

  /**
   * Cancel a tool execution
   */
  async cancelExecution(callId: string): Promise<boolean> {
    const execution = this.executionMap.get(callId);
    if (!execution) {
      return false;
    }
    
    execution.status = ExecutionStatus.CANCELLED;
    execution.endTime = Date.now();
    
    if (this.config.enableLogging) {
      console.log(`[MCPToolExecutor] Cancelled execution: ${callId}`);
    }
    
    return true;
  }

  /**
   * Get execution status for a tool call
   */
  getExecutionStatus(callId: string): ExecutionStatus {
    const execution = this.executionMap.get(callId);
    return execution?.status || ExecutionStatus.PENDING;
  }

  /**
   * Test connection to MCP server
   */
  async testConnection(): Promise<boolean> {
    try {
      const response = await fetch(`${this.config.serverUrl}/health`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
        signal: AbortSignal.timeout(5000) // 5 second timeout for health check
      });
      
      const isHealthy = response.ok;
      
      if (this.config.enableLogging) {
        console.log(`[MCPToolExecutor] Health check: ${isHealthy ? 'HEALTHY' : 'UNHEALTHY'}`, {
          status: response.status,
          url: this.config.serverUrl
        });
      }
      
      return isHealthy;
      
    } catch (error) {
      if (this.config.enableLogging) {
        console.error(`[MCPToolExecutor] Health check failed:`, error);
      }
      return false;
    }
  }

  /**
   * Get execution metrics
   */
  getExecutionMetrics(): ExecutionStats {
    return { ...this.stats };
  }

  /**
   * Execute tool with retry logic
   */
  private async executeWithRetry(call: ToolCallRequest, context?: ExecutionContext): Promise<ToolCallResult> {
    const startTime = Date.now();
    let lastError: Error | null = null;
    
    const execution = this.executionMap.get(call.id);
    
    for (let attempt = 0; attempt <= this.config.retries; attempt++) {
      try {
        if (execution) {
          execution.retryCount = attempt;
        }
        
        const result = await this.executeToolCall(call, context);
        
        return {
          id: call.id,
          name: call.name,
          success: true,
          result: result.result,
          executionTime: Date.now() - startTime,
          timestamp: new Date().toISOString(),
          metadata: {
            provider: call.provider,
            mcpServer: this.config.serverUrl,
            retryCount: attempt
          }
        };
        
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        
        if (attempt < this.config.retries) {
          if (this.config.enableLogging && this.config.logLevel === DiagnosticLevel.DEBUG) {
            console.warn(`[MCPToolExecutor] Retry ${attempt + 1}/${this.config.retries} for ${call.name}:`, error);
          }
          
          // Wait before retry
          await this.delay(this.config.retryDelayMs * Math.pow(2, attempt)); // Exponential backoff
        }
      }
    }
    
    // All retries failed
    throw lastError || new BridgeError(
      BridgeErrorType.TOOL_EXECUTION_ERROR,
      `Tool execution failed after ${this.config.retries + 1} attempts`,
      call.provider,
      call.name
    );
  }

  /**
   * Execute a single tool call against MCP server
   */
  private async executeToolCall(call: ToolCallRequest, context?: ExecutionContext): Promise<MCPExecutionResponse> {
    const requestBody: MCPExecutionRequest = {
      name: call.name,
      arguments: call.parameters
    };

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

    try {
      if (this.config.enableLogging && this.config.logLevel === DiagnosticLevel.TRACE) {
        console.log(`[MCPToolExecutor] Sending request to ${this.config.serverUrl}/execute_tool`, requestBody);
      }

      const response = await fetch(`${this.config.serverUrl}/execute_tool`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
        signal: controller.signal
      });

      if (!response.ok) {
        if (response.status === 404) {
          throw new BridgeError(
            BridgeErrorType.TOOL_NOT_FOUND,
            `Tool not found: ${call.name}`,
            call.provider,
            call.name
          );
        } else if (response.status >= 500) {
          throw new BridgeError(
            BridgeErrorType.MCP_SERVER_UNREACHABLE,
            `MCP server error: ${response.status} ${response.statusText}`,
            call.provider,
            call.name
          );
        } else {
          throw new BridgeError(
            BridgeErrorType.TOOL_EXECUTION_ERROR,
            `HTTP ${response.status}: ${response.statusText}`,
            call.provider,
            call.name
          );
        }
      }

      const data: MCPExecutionResponse = await response.json();
      
      if (this.config.enableLogging && this.config.logLevel === DiagnosticLevel.TRACE) {
        console.log(`[MCPToolExecutor] Received response from MCP server:`, data);
      }

      if (!data.success && data.error) {
        throw new BridgeError(
          BridgeErrorType.TOOL_EXECUTION_ERROR,
          `Tool execution error: ${data.error.message}`,
          call.provider,
          call.name,
          new Error(data.error.message)
        );
      }

      return data;

    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new BridgeError(
          BridgeErrorType.TOOL_EXECUTION_ERROR,
          `Tool execution timeout after ${this.config.timeout}ms`,
          call.provider,
          call.name
        );
      }

      if (error instanceof TypeError && error.message.includes('fetch')) {
        throw new BridgeError(
          BridgeErrorType.MCP_SERVER_UNREACHABLE,
          `Cannot connect to MCP server at ${this.config.serverUrl}`,
          call.provider,
          call.name,
          error
        );
      }

      throw error;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  /**
   * Update execution statistics
   */
  private updateStats(): void {
    this.stats.totalExecutions = this.stats.successfulExecutions + this.stats.failedExecutions;
    this.stats.lastExecutionTime = new Date().toISOString();
    
    // Calculate average execution time
    let totalTime = 0;
    let completedCount = 0;
    
    for (const execution of this.executionMap.values()) {
      if (execution.endTime) {
        totalTime += execution.endTime - execution.startTime;
        completedCount++;
      }
    }
    
    if (completedCount > 0) {
      this.stats.averageExecutionTime = totalTime / completedCount;
    }
  }

  /**
   * Delay helper for retry logic
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Clean up completed executions to prevent memory leaks
   */
  public cleanup(): void {
    const cutoffTime = Date.now() - (1000 * 60 * 60); // 1 hour
    
    for (const [id, execution] of this.executionMap.entries()) {
      if (execution.endTime && execution.endTime < cutoffTime) {
        this.executionMap.delete(id);
      }
    }
    
    if (this.config.enableLogging && this.config.logLevel === DiagnosticLevel.DEBUG) {
      console.log(`[MCPToolExecutor] Cleaned up old executions, remaining: ${this.executionMap.size}`);
    }
  }

  /**
   * Update configuration
   */
  public updateConfig(config: Partial<MCPToolExecutorConfig>): void {
    this.config = { ...this.config, ...config };
    
    if (this.config.enableLogging) {
      console.log('[MCPToolExecutor] Configuration updated:', config);
    }
  }

  /**
   * Get current configuration
   */
  public getConfig(): MCPToolExecutorConfig {
    return { ...this.config };
  }
}
```

## services/mcp-bridge/core/ToolSchemaConverter.ts

```typescript
/**
 * Location: /src/services/mcp-bridge/core/ToolSchemaConverter.ts
 * 
 * This file implements the tool schema converter that orchestrates conversion of MCP tools
 * to different provider formats. It manages provider-specific converters and provides
 * a unified interface for schema transformation across all supported LLM providers.
 * 
 * Used by: MCPFunctionBridge for converting tools to provider-specific formats
 * Dependencies: BridgeTypes, provider converters (OpenAIToolConverter, etc.)
 */

import {
  IToolSchemaConverter,
  IProviderConverter,
  MCPTool,
  ProviderTool,
  ValidationResult,
  SupportedProvider,
  BridgeError,
  BridgeErrorType,
  DiagnosticLevel
} from '../types/BridgeTypes';
import { OpenAIToolConverter } from '../providers/openai/OpenAIToolConverter';

/**
 * Configuration for the tool schema converter
 */
interface ToolSchemaConverterConfig {
  enableLogging: boolean;
  logLevel: DiagnosticLevel;
  validateConversions: boolean;
  cacheConversions: boolean;
  maxCacheSize: number;
}

/**
 * Cache entry for converted tools
 */
interface ConversionCacheEntry {
  tools: ProviderTool[];
  timestamp: string;
  mcpToolsHash: string; // Hash of source MCP tools for invalidation
}

/**
 * Tool Schema Converter Implementation
 * 
 * Manages provider-specific converters and provides unified interface
 * for converting MCP tools to various LLM provider formats.
 */
export class ToolSchemaConverter implements IToolSchemaConverter {
  private converters = new Map<SupportedProvider, IProviderConverter>();
  private config: ToolSchemaConverterConfig;
  private conversionCache = new Map<string, ConversionCacheEntry>();
  
  constructor(config: Partial<ToolSchemaConverterConfig> = {}) {
    this.config = {
      enableLogging: true,
      logLevel: DiagnosticLevel.INFO,
      validateConversions: true,
      cacheConversions: true,
      maxCacheSize: 100,
      ...config
    };
    
    this.initializeDefaultConverters();
    
    if (this.config.enableLogging) {
      console.log('[ToolSchemaConverter] Initialized with converters for:', 
        Array.from(this.converters.keys()));
    }
  }

  /**
   * Register a provider-specific converter
   */
  registerProviderConverter(provider: SupportedProvider, converter: IProviderConverter): void {
    if (converter.provider !== provider) {
      throw new BridgeError(
        BridgeErrorType.PROVIDER_NOT_SUPPORTED,
        `Converter provider mismatch: expected ${provider}, got ${converter.provider}`,
        provider
      );
    }
    
    this.converters.set(provider, converter);
    
    if (this.config.enableLogging) {
      console.log(`[ToolSchemaConverter] Registered converter for ${provider}`);
    }
  }

  /**
   * Convert multiple MCP tools to provider-specific format
   */
  async convertToolsForProvider(mcpTools: MCPTool[], provider: SupportedProvider): Promise<ProviderTool[]> {
    if (this.config.enableLogging && this.config.logLevel !== DiagnosticLevel.ERROR) {
      console.log(`[ToolSchemaConverter] Converting ${mcpTools.length} tools for ${provider}`);
    }

    // Check cache first
    if (this.config.cacheConversions) {
      const cacheKey = this.generateCacheKey(mcpTools, provider);
      const cached = this.conversionCache.get(cacheKey);
      
      if (cached && this.isCacheValid(cached, mcpTools)) {
        if (this.config.enableLogging && this.config.logLevel === DiagnosticLevel.DEBUG) {
          console.log(`[ToolSchemaConverter] Cache hit for ${provider}, returning ${cached.tools.length} tools`);
        }
        return [...cached.tools]; // Return copy to prevent mutation
      }
    }

    const converter = this.getConverter(provider);
    const convertedTools: ProviderTool[] = [];
    const errors: string[] = [];

    // Convert each tool
    for (const mcpTool of mcpTools) {
      try {
        const providerTool = await this.convertSingleTool(mcpTool, provider);
        convertedTools.push(providerTool);
      } catch (error) {
        console.error(`[ToolSchemaConverter] Failed to convert tool ${mcpTool.name} for ${provider}:`, error);
        errors.push(`${mcpTool.name}: ${(error as Error).message}`);
      }
    }

    // Log conversion summary
    if (this.config.enableLogging && this.config.logLevel !== DiagnosticLevel.ERROR) {
      console.log(`[ToolSchemaConverter] Conversion completed for ${provider}:`, {
        total: mcpTools.length,
        successful: convertedTools.length,
        failed: errors.length,
        errors: errors.length > 0 ? errors : undefined
      });
    }

    // Cache successful conversions
    if (this.config.cacheConversions && convertedTools.length > 0) {
      const cacheKey = this.generateCacheKey(mcpTools, provider);
      this.cacheConversions(cacheKey, convertedTools, mcpTools);
    }

    return convertedTools;
  }

  /**
   * Convert a single MCP tool to provider-specific format
   */
  async convertSingleTool(mcpTool: MCPTool, provider: SupportedProvider): Promise<ProviderTool> {
    if (this.config.enableLogging && this.config.logLevel === DiagnosticLevel.TRACE) {
      console.log(`[ToolSchemaConverter] Converting single tool ${mcpTool.name} for ${provider}`);
    }

    // Validate input
    const mcpValidation = this.validateMCPTool(mcpTool);
    if (!mcpValidation.isValid) {
      throw new BridgeError(
        BridgeErrorType.SCHEMA_CONVERSION_ERROR,
        `Invalid MCP tool: ${mcpValidation.errors?.join(', ')}`,
        provider,
        mcpTool.name
      );
    }

    const converter = this.getConverter(provider);
    
    try {
      const providerTool = converter.convertMCPTool(mcpTool);
      
      // Validate conversion if enabled
      if (this.config.validateConversions) {
        const conversionValidation = converter.validateConversion(mcpTool, providerTool);
        if (!conversionValidation.isValid) {
          console.warn(`[ToolSchemaConverter] Conversion validation warnings for ${mcpTool.name}:`, 
            conversionValidation.warnings);
        }
      }
      
      return providerTool;
      
    } catch (error) {
      throw new BridgeError(
        BridgeErrorType.SCHEMA_CONVERSION_ERROR,
        `Failed to convert tool ${mcpTool.name} for ${provider}: ${(error as Error).message}`,
        provider,
        mcpTool.name,
        error as Error
      );
    }
  }

  /**
   * Validate MCP tool structure
   */
  validateMCPTool(tool: MCPTool): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Required fields
    if (!tool.name) {
      errors.push('Tool name is required');
    } else if (typeof tool.name !== 'string') {
      errors.push('Tool name must be a string');
    }

    if (!tool.description) {
      errors.push('Tool description is required');
    } else if (typeof tool.description !== 'string') {
      errors.push('Tool description must be a string');
    }

    if (!tool.inputSchema) {
      errors.push('Tool inputSchema is required');
    } else if (typeof tool.inputSchema !== 'object') {
      errors.push('Tool inputSchema must be an object');
    }

    // Schema validation
    if (tool.inputSchema && typeof tool.inputSchema === 'object') {
      if (!tool.inputSchema.type) {
        warnings.push('Tool inputSchema should have a type property');
      }
      
      if (tool.inputSchema.type === 'object' && !tool.inputSchema.properties) {
        warnings.push('Object schema should have properties');
      }
    }

    // Name format validation
    if (tool.name) {
      const namePattern = /^[a-zA-Z][a-zA-Z0-9_]*$/;
      if (!namePattern.test(tool.name)) {
        warnings.push('Tool name should start with letter and contain only alphanumeric and underscore');
      }
    }

    return {
      isValid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  /**
   * Validate provider tool structure
   */
  validateProviderTool(tool: ProviderTool): ValidationResult {
    const errors: string[] = [];

    if (!tool.provider) {
      errors.push('Provider tool must specify provider');
    }

    if (!tool.originalName) {
      errors.push('Provider tool must specify originalName');
    }

    if (!tool.tool) {
      errors.push('Provider tool must have tool definition');
    }

    if (tool.provider && !this.isProviderSupported(tool.provider)) {
      errors.push(`Unsupported provider: ${tool.provider}`);
    }

    return {
      isValid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined
    };
  }

  /**
   * Get list of supported providers
   */
  getSupportedProviders(): SupportedProvider[] {
    return Array.from(this.converters.keys());
  }

  /**
   * Check if a provider is supported
   */
  isProviderSupported(provider: SupportedProvider): boolean {
    return this.converters.has(provider);
  }

  /**
   * Get converter for provider (with validation)
   */
  private getConverter(provider: SupportedProvider): IProviderConverter {
    const converter = this.converters.get(provider);
    
    if (!converter) {
      throw new BridgeError(
        BridgeErrorType.PROVIDER_NOT_SUPPORTED,
        `No converter registered for provider: ${provider}`,
        provider
      );
    }
    
    return converter;
  }

  /**
   * Initialize default converters for supported providers
   */
  private initializeDefaultConverters(): void {
    // OpenAI converter (also works for OpenRouter)
    const openAIConverter = new OpenAIToolConverter();
    this.converters.set('openai', openAIConverter);
    this.converters.set('openrouter', openAIConverter); // Same schema format
    
    // TODO: Add more converters as they're implemented
    // this.converters.set('anthropic', new AnthropicToolConverter());
    // this.converters.set('google', new GoogleToolConverter());
    // this.converters.set('groq', openAIConverter); // Uses OpenAI format
    // this.converters.set('mistral', openAIConverter); // Uses OpenAI format
  }

  /**
   * Generate cache key for tool conversions
   */
  private generateCacheKey(mcpTools: MCPTool[], provider: SupportedProvider): string {
    const toolsHash = this.generateToolsHash(mcpTools);
    return `${provider}:${toolsHash}`;
  }

  /**
   * Generate hash for MCP tools to detect changes
   */
  private generateToolsHash(mcpTools: MCPTool[]): string {
    // Simple hash based on tool names and descriptions
    const content = mcpTools
      .map(tool => `${tool.name}:${tool.description}`)
      .sort()
      .join('|');
    
    // Simple hash function (for production, use crypto.createHash)
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString(36);
  }

  /**
   * Cache conversion results
   */
  private cacheConversions(cacheKey: string, tools: ProviderTool[], mcpTools: MCPTool[]): void {
    // Implement LRU eviction if cache is full
    if (this.conversionCache.size >= this.config.maxCacheSize) {
      const oldestKey = this.conversionCache.keys().next().value;
      if (oldestKey) {
        this.conversionCache.delete(oldestKey);
      }
    }

    this.conversionCache.set(cacheKey, {
      tools: [...tools], // Store copy to prevent mutation
      timestamp: new Date().toISOString(),
      mcpToolsHash: this.generateToolsHash(mcpTools)
    });

    if (this.config.enableLogging && this.config.logLevel === DiagnosticLevel.DEBUG) {
      console.log(`[ToolSchemaConverter] Cached ${tools.length} converted tools with key: ${cacheKey}`);
    }
  }

  /**
   * Check if cached conversion is still valid
   */
  private isCacheValid(cached: ConversionCacheEntry, currentMcpTools: MCPTool[]): boolean {
    const currentHash = this.generateToolsHash(currentMcpTools);
    return cached.mcpToolsHash === currentHash;
  }

  /**
   * Clear conversion cache
   */
  public clearCache(): void {
    this.conversionCache.clear();
    
    if (this.config.enableLogging) {
      console.log('[ToolSchemaConverter] Cleared conversion cache');
    }
  }

  /**
   * Get cache statistics
   */
  public getCacheStats(): { size: number; maxSize: number; hitRatio?: number } {
    return {
      size: this.conversionCache.size,
      maxSize: this.config.maxCacheSize
      // TODO: Track hit ratio if needed
    };
  }

  /**
   * Update configuration
   */
  public updateConfig(config: Partial<ToolSchemaConverterConfig>): void {
    this.config = { ...this.config, ...config };
    
    if (this.config.enableLogging) {
      console.log('[ToolSchemaConverter] Configuration updated:', config);
    }
  }

  /**
   * Get current configuration
   */
  public getConfig(): ToolSchemaConverterConfig {
    return { ...this.config };
  }
}
```

## services/mcp-bridge/providers/base/BaseProviderConverter.ts

```typescript
/**
 * Location: /src/services/mcp-bridge/providers/base/BaseProviderConverter.ts
 * 
 * This file provides the abstract base class for all provider-specific converters.
 * It defines the common interface and provides shared functionality for converting
 * MCP tools to different LLM provider formats (OpenAI, Anthropic, Google, etc.).
 * 
 * Used by: Provider-specific converters (OpenAIToolConverter, AnthropicToolConverter, etc.)
 * Dependencies: BridgeTypes, JSON Schema validation
 */

import {
  IProviderConverter,
  MCPTool,
  ProviderTool,
  ToolCallRequest,
  ToolCallResult,
  ValidationResult,
  ProviderCapabilities,
  ToolFeature,
  SupportedProvider,
  BridgeError,
  BridgeErrorType,
  DiagnosticLevel
} from '../../types/BridgeTypes';

// JSONSchema type from BridgeTypes
type JSONSchema = {
  type?: string | string[];
  properties?: Record<string, JSONSchema>;
  required?: string[];
  description?: string;
  items?: JSONSchema;
  additionalProperties?: boolean | JSONSchema;
  enum?: any[];
  [key: string]: any;
};
// JSON Schema type is now defined in BridgeTypes

/**
 * Base configuration for provider converters
 */
export interface BaseConverterConfig {
  provider: SupportedProvider;
  enableLogging: boolean;
  logLevel: DiagnosticLevel;
  validateSchemas: boolean;
  maxToolNameLength: number;
  maxDescriptionLength: number;
}

/**
 * Abstract base class for all provider converters
 * 
 * Provides common functionality and enforces consistent interface
 * across all provider-specific implementations.
 */
export abstract class BaseProviderConverter implements IProviderConverter {
  public readonly provider: SupportedProvider;
  protected config: BaseConverterConfig;
  
  constructor(provider: SupportedProvider, config: Partial<BaseConverterConfig> = {}) {
    this.provider = provider;
    this.config = {
      provider,
      enableLogging: true,
      logLevel: DiagnosticLevel.INFO,
      validateSchemas: true,
      maxToolNameLength: 64,
      maxDescriptionLength: 1024,
      ...config
    };
    
    if (this.config.enableLogging) {
      console.log(`[${this.provider}Converter] Initialized converter for ${provider}`);
    }
  }

  // ============================================================================
  // Abstract methods that must be implemented by concrete converters
  // ============================================================================

  /**
   * Convert MCP tool to provider-specific format
   * Must be implemented by each provider converter
   */
  abstract convertMCPTool(mcpTool: MCPTool): ProviderTool;

  /**
   * Parse provider-specific tool call to normalized format
   * Must be implemented by each provider converter
   */
  abstract parseToolCall(providerToolCall: any): ToolCallRequest;

  /**
   * Format tool result for provider consumption
   * Must be implemented by each provider converter
   */
  abstract formatToolResult(result: ToolCallResult): any;

  /**
   * Get provider-specific capabilities
   * Must be implemented by each provider converter
   */
  abstract getCapabilities(): ProviderCapabilities;

  // ============================================================================
  // Concrete methods with default implementations
  // ============================================================================

  /**
   * Validate MCP tool conversion to provider format
   */
  validateConversion(mcpTool: MCPTool, providerTool: ProviderTool): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Validate basic structure
    if (!providerTool.tool) {
      errors.push('Provider tool is missing tool definition');
    }

    if (providerTool.provider !== this.provider) {
      errors.push(`Provider mismatch: expected ${this.provider}, got ${providerTool.provider}`);
    }

    if (providerTool.originalName !== mcpTool.name) {
      errors.push(`Original name mismatch: expected ${mcpTool.name}, got ${providerTool.originalName}`);
    }

    // Validate tool name length
    if (mcpTool.name.length > this.config.maxToolNameLength) {
      warnings.push(`Tool name exceeds maximum length: ${mcpTool.name.length} > ${this.config.maxToolNameLength}`);
    }

    // Validate description length
    if (mcpTool.description.length > this.config.maxDescriptionLength) {
      warnings.push(`Description exceeds maximum length: ${mcpTool.description.length} > ${this.config.maxDescriptionLength}`);
    }

    // Provider-specific validation
    const providerValidation = this.validateProviderSpecific(mcpTool, providerTool);
    errors.push(...providerValidation.errors || []);
    warnings.push(...providerValidation.warnings || []);

    const result: ValidationResult = {
      isValid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };

    if (this.config.enableLogging && this.config.logLevel === DiagnosticLevel.DEBUG) {
      console.log(`[${this.provider}Converter] Validation result for ${mcpTool.name}:`, result);
    }

    return result;
  }

  /**
   * Check if provider supports a specific feature
   */
  supportsFeature(feature: ToolFeature): boolean {
    return this.getCapabilities().features.includes(feature);
  }

  /**
   * Sanitize tool name for provider compatibility
   */
  protected sanitizeToolName(name: string): string {
    // Remove invalid characters and ensure valid identifier
    let sanitized = name
      .replace(/[^a-zA-Z0-9_-]/g, '_')  // Replace invalid chars with underscore
      .replace(/^[0-9]/, '_$&')         // Prefix numbers with underscore
      .replace(/_+/g, '_')              // Collapse multiple underscores
      .replace(/^_+|_+$/g, '');         // Trim underscores from ends

    // Ensure minimum length
    if (sanitized.length === 0) {
      sanitized = 'tool';
    }

    // Ensure maximum length
    if (sanitized.length > this.config.maxToolNameLength) {
      sanitized = sanitized.substring(0, this.config.maxToolNameLength);
    }

    return sanitized;
  }

  /**
   * Sanitize description for provider compatibility
   */
  protected sanitizeDescription(description: string): string {
    let sanitized = description.trim();
    
    // Ensure maximum length
    if (sanitized.length > this.config.maxDescriptionLength) {
      sanitized = sanitized.substring(0, this.config.maxDescriptionLength - 3) + '...';
    }
    
    // Ensure minimum length
    if (sanitized.length === 0) {
      sanitized = 'No description available';
    }
    
    return sanitized;
  }

  /**
   * Deep clone JSON schema to avoid mutation
   */
  protected cloneSchema(schema: JSONSchema): JSONSchema {
    return JSON.parse(JSON.stringify(schema));
  }

  /**
   * Validate JSON schema structure
   */
  protected validateJsonSchema(schema: JSONSchema): ValidationResult {
    const errors: string[] = [];

    if (!schema.type) {
      errors.push('Schema missing type property');
    }

    if (schema.type === 'object' && !schema.properties) {
      errors.push('Object schema missing properties');
    }

    // Check for common schema issues
    if (schema.properties) {
      for (const [propName, propSchema] of Object.entries(schema.properties)) {
        if (typeof propSchema === 'object' && propSchema !== null && 'type' in propSchema) {
          if (!(propSchema as any).type) {
            errors.push(`Property ${propName} missing type`);
          }
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined
    };
  }

  /**
   * Generate unique ID for tool calls
   */
  protected generateToolCallId(): string {
    return `call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Parse JSON arguments safely
   */
  protected parseArguments(args: string): Record<string, any> {
    try {
      return JSON.parse(args);
    } catch (error) {
      if (this.config.enableLogging) {
        console.error(`[${this.provider}Converter] Failed to parse arguments:`, args, error);
      }
      throw new BridgeError(
        BridgeErrorType.PARAMETER_VALIDATION_ERROR,
        `Invalid JSON in tool call arguments: ${error instanceof Error ? error.message : String(error)}`,
        this.provider
      );
    }
  }

  /**
   * Stringify result safely
   */
  protected stringifyResult(result: any): string {
    try {
      if (typeof result === 'string') {
        return result;
      }
      return JSON.stringify(result, null, 2);
    } catch (error) {
      if (this.config.enableLogging) {
        console.error(`[${this.provider}Converter] Failed to stringify result:`, result, error);
      }
      return String(result);
    }
  }

  /**
   * Log conversion activity
   */
  protected logConversion(operation: string, toolName: string, details?: any): void {
    if (this.config.enableLogging && this.config.logLevel !== DiagnosticLevel.ERROR) {
      console.log(`[${this.provider}Converter] ${operation}: ${toolName}`, details);
    }
  }

  /**
   * Log error with context
   */
  protected logError(error: Error, toolName?: string, context?: any): void {
    console.error(`[${this.provider}Converter] Error${toolName ? ` for ${toolName}` : ''}:`, error, context);
  }

  // ============================================================================
  // Protected abstract methods for provider-specific validation
  // ============================================================================

  /**
   * Provider-specific validation logic
   * Override in concrete implementations if needed
   */
  protected validateProviderSpecific(mcpTool: MCPTool, providerTool: ProviderTool): ValidationResult {
    // Default implementation - no additional validation
    return { isValid: true };
  }

  // ============================================================================
  // Utility methods for common provider patterns
  // ============================================================================

  /**
   * Extract tool name from various provider formats
   */
  protected extractToolName(providerToolCall: any): string {
    // Handle different provider formats
    if (providerToolCall.function?.name) {
      return providerToolCall.function.name; // OpenAI format
    }
    if (providerToolCall.name) {
      return providerToolCall.name; // Anthropic format
    }
    throw new BridgeError(
      BridgeErrorType.PARAMETER_VALIDATION_ERROR,
      'Cannot extract tool name from provider tool call',
      this.provider
    );
  }

  /**
   * Extract parameters from various provider formats
   */
  protected extractParameters(providerToolCall: any): Record<string, any> {
    // Handle different provider formats
    if (providerToolCall.function?.arguments) {
      return this.parseArguments(providerToolCall.function.arguments); // OpenAI format
    }
    if (providerToolCall.input) {
      return providerToolCall.input; // Anthropic format
    }
    if (providerToolCall.args) {
      return providerToolCall.args; // Google format
    }
    return {}; // Default empty parameters
  }

  /**
   * Extract tool call ID from various provider formats
   */
  protected extractToolCallId(providerToolCall: any): string {
    if (providerToolCall.id) {
      return providerToolCall.id; // Most providers
    }
    // Generate ID if not provided
    return this.generateToolCallId();
  }

  /**
   * Update configuration
   */
  public updateConfig(config: Partial<BaseConverterConfig>): void {
    this.config = { ...this.config, ...config };
    
    if (this.config.enableLogging) {
      console.log(`[${this.provider}Converter] Configuration updated:`, config);
    }
  }

  /**
   * Get current configuration
   */
  public getConfig(): BaseConverterConfig {
    return { ...this.config };
  }
}
```

## services/mcp-bridge/providers/openai/OpenAIToolConverter.ts

```typescript
/**
 * Location: /src/services/mcp-bridge/providers/openai/OpenAIToolConverter.ts
 * 
 * This file implements the provider converter for OpenAI and OpenRouter function calling.
 * Both providers use the same schema format, so this converter handles both.
 * It converts MCP tools to OpenAI function calling format and handles tool call parsing.
 * 
 * Used by: ToolSchemaConverter for OpenAI and OpenRouter providers
 * Dependencies: BaseProviderConverter, BridgeTypes, OpenAI function calling schemas
 */

import {
  MCPTool,
  ProviderTool,
  ToolCallRequest,
  ToolCallResult,
  ValidationResult,
  ProviderCapabilities,
  ToolFeature,
  OpenAITool,
  OpenAIToolCall,
  BridgeError,
  BridgeErrorType,
  DiagnosticLevel
} from '../../types/BridgeTypes';
import { BaseProviderConverter } from '../base/BaseProviderConverter';
import { mergeWithCommonSchema } from '../../../../utils/schemaUtils';

// JSONSchema type from BridgeTypes
type JSONSchema = {
  type?: string | string[];
  properties?: Record<string, JSONSchema>;
  required?: string[];
  description?: string;
  items?: JSONSchema;
  additionalProperties?: boolean | JSONSchema;
  enum?: any[];
  [key: string]: any;
};
// JSON Schema type is now defined in BridgeTypes

/**
 * OpenAI Tool Converter Implementation
 * 
 * Handles conversion between MCP tools and OpenAI function calling format.
 * Also compatible with OpenRouter since they use the same schema.
 */
export class OpenAIToolConverter extends BaseProviderConverter {
  
  constructor() {
    super('openai', {
      enableLogging: false,
      logLevel: DiagnosticLevel.ERROR,
      validateSchemas: true,
      maxToolNameLength: 64,
      maxDescriptionLength: 1024
    });
  }

  /**
   * Convert MCP tool to OpenAI function calling format
   */
  convertMCPTool(mcpTool: MCPTool): ProviderTool {
    this.logConversion('Converting MCP tool to OpenAI format', mcpTool.name);

    try {
      // Validate input
      if (!mcpTool.name || !mcpTool.description || !mcpTool.inputSchema) {
        throw new BridgeError(
          BridgeErrorType.SCHEMA_CONVERSION_ERROR,
          'MCP tool missing required fields (name, description, or inputSchema)',
          this.provider,
          mcpTool.name
        );
      }

      // Sanitize name and description
      const sanitizedName = this.sanitizeToolName(mcpTool.name);
      const sanitizedDescription = this.sanitizeDescription(mcpTool.description);

      // Clone and merge with common schema (sessionId, context, etc.)
      const baseParameters = this.cloneSchema(mcpTool.inputSchema);
      const parametersWithCommon = mergeWithCommonSchema(baseParameters);
      const schemaValidation = this.validateJsonSchema(parametersWithCommon);
      
      if (!schemaValidation.isValid) {
        console.warn(`[OpenAIToolConverter] Schema validation warnings for ${mcpTool.name}:`, schemaValidation.errors);
      }

      // Create OpenAI tool format
      const openAITool: OpenAITool = {
        type: 'function',
        function: {
          name: sanitizedName,
          description: sanitizedDescription,
          parameters: this.convertSchemaForOpenAI(parametersWithCommon)
        }
      };

      const providerTool: ProviderTool = {
        provider: this.provider,
        originalName: mcpTool.name,
        tool: openAITool
      };

      // Validate conversion
      const conversionValidation = this.validateConversion(mcpTool, providerTool);
      if (!conversionValidation.isValid) {
        console.warn(`[OpenAIToolConverter] Conversion validation warnings for ${mcpTool.name}:`, conversionValidation);
      }

      this.logConversion('Successfully converted to OpenAI format', mcpTool.name, {
        originalName: mcpTool.name,
        sanitizedName,
        hasParameters: !!parametersWithCommon.properties,
        addedCommonParams: true
      });

      return providerTool;

    } catch (error) {
      this.logError(error as Error, mcpTool.name, { inputSchema: mcpTool.inputSchema });
      throw error instanceof BridgeError ? error : new BridgeError(
        BridgeErrorType.SCHEMA_CONVERSION_ERROR,
        `Failed to convert MCP tool to OpenAI format: ${(error as Error).message}`,
        this.provider,
        mcpTool.name,
        error as Error
      );
    }
  }

  /**
   * Parse OpenAI tool call to normalized format
   */
  parseToolCall(providerToolCall: OpenAIToolCall): ToolCallRequest {
    this.logConversion('Parsing OpenAI tool call', providerToolCall.function?.name || 'unknown');

    try {
      // Validate tool call structure
      if (!providerToolCall.id) {
        throw new BridgeError(
          BridgeErrorType.PARAMETER_VALIDATION_ERROR,
          'OpenAI tool call missing required id field',
          this.provider
        );
      }

      if (!providerToolCall.function?.name) {
        throw new BridgeError(
          BridgeErrorType.PARAMETER_VALIDATION_ERROR,
          'OpenAI tool call missing function.name field',
          this.provider
        );
      }

      // Extract and parse parameters
      const toolName = providerToolCall.function.name;
      const parametersJson = providerToolCall.function.arguments || '{}';
      const parameters = this.parseArguments(parametersJson);

      const toolCallRequest: ToolCallRequest = {
        id: providerToolCall.id,
        name: toolName,
        parameters,
        provider: this.provider,
        metadata: {
          timestamp: new Date().toISOString()
        }
      };

      this.logConversion('Successfully parsed OpenAI tool call', toolName, {
        id: providerToolCall.id,
        parameterCount: Object.keys(parameters).length
      });

      return toolCallRequest;

    } catch (error) {
      this.logError(error as Error, providerToolCall.function?.name, providerToolCall);
      throw error instanceof BridgeError ? error : new BridgeError(
        BridgeErrorType.PARAMETER_VALIDATION_ERROR,
        `Failed to parse OpenAI tool call: ${(error as Error).message}`,
        this.provider,
        providerToolCall.function?.name,
        error as Error
      );
    }
  }

  /**
   * Format tool result for OpenAI consumption
   */
  formatToolResult(result: ToolCallResult): any {
    this.logConversion('Formatting tool result for OpenAI', result.name);

    try {
      // OpenAI expects tool results in message format
      const content = result.success 
        ? this.stringifyResult(result.result)
        : JSON.stringify({
            error: result.error,
            errorCode: result.metadata?.errorCode || 'TOOL_EXECUTION_ERROR'
          });

      const toolMessage = {
        role: 'tool',
        tool_call_id: result.id,
        content: content
      };

      this.logConversion('Successfully formatted tool result for OpenAI', result.name, {
        success: result.success,
        contentLength: content.length,
        executionTime: result.executionTime
      });

      return toolMessage;

    } catch (error) {
      this.logError(error as Error, result.name, result);
      
      // Return error message format
      return {
        role: 'tool',
        tool_call_id: result.id,
        content: JSON.stringify({
          error: `Failed to format tool result: ${(error as Error).message}`,
          originalError: result.error
        })
      };
    }
  }

  /**
   * Get OpenAI provider capabilities
   */
  getCapabilities(): ProviderCapabilities {
    return {
      supportsParallelCalls: true,
      supportsStreaming: true,
      maxToolsPerCall: 100, // OpenAI's documented limit
      features: [
        ToolFeature.FUNCTION_CALLING,
        ToolFeature.PARALLEL_CALLS,
        ToolFeature.STREAMING,
        ToolFeature.VALIDATION
      ]
    };
  }

  /**
   * Convert JSON schema for OpenAI compatibility
   */
  private convertSchemaForOpenAI(schema: JSONSchema): JSONSchema {
    const convertedSchema = this.cloneSchema(schema);
    
    // OpenAI-specific schema transformations
    this.removeUnsupportedSchemaFields(convertedSchema);
    this.normalizeSchemaTypes(convertedSchema);
    
    return convertedSchema;
  }

  /**
   * Remove schema fields not supported by OpenAI
   */
  private removeUnsupportedSchemaFields(schema: any): void {
    // OpenAI doesn't support some JSON Schema features
    const unsupportedFields = [
      'examples',
      'const',
      'if',
      'then',
      'else',
      'allOf',
      'anyOf',
      'oneOf',
      'not'
    ];
    
    for (const field of unsupportedFields) {
      if (field in schema) {
        delete schema[field];
      }
    }
    
    // Recursively clean nested schemas
    if (schema.properties && typeof schema.properties === 'object') {
      for (const prop of Object.values(schema.properties)) {
        if (typeof prop === 'object' && prop !== null) {
          this.removeUnsupportedSchemaFields(prop);
        }
      }
    }
    
    if (schema.items && typeof schema.items === 'object') {
      this.removeUnsupportedSchemaFields(schema.items);
    }
  }

  /**
   * Normalize schema types for OpenAI compatibility
   */
  private normalizeSchemaTypes(schema: any): void {
    // Ensure type is a string, not an array
    if (Array.isArray(schema.type)) {
      schema.type = schema.type[0]; // Take first type
    }
    
    // Handle integer type (OpenAI prefers number)
    if (schema.type === 'integer') {
      schema.type = 'number';
    }
    
    // Recursively normalize nested schemas
    if (schema.properties && typeof schema.properties === 'object') {
      for (const prop of Object.values(schema.properties)) {
        if (typeof prop === 'object' && prop !== null) {
          this.normalizeSchemaTypes(prop);
        }
      }
    }
    
    if (schema.items && typeof schema.items === 'object') {
      this.normalizeSchemaTypes(schema.items);
    }
  }

  /**
   * Provider-specific validation for OpenAI tools
   */
  protected validateProviderSpecific(mcpTool: MCPTool, providerTool: ProviderTool): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    
    const openAITool = providerTool.tool as OpenAITool;
    
    // Validate OpenAI-specific requirements
    if (!openAITool.type || openAITool.type !== 'function') {
      errors.push('OpenAI tool must have type "function"');
    }
    
    if (!openAITool.function) {
      errors.push('OpenAI tool must have function definition');
    } else {
      // Validate function definition
      if (!openAITool.function.name) {
        errors.push('OpenAI function must have name');
      }
      
      if (!openAITool.function.description) {
        errors.push('OpenAI function must have description');
      }
      
      // Check name format (OpenAI requirements)
      const namePattern = /^[a-zA-Z0-9_-]+$/;
      if (openAITool.function.name && !namePattern.test(openAITool.function.name)) {
        errors.push('OpenAI function name contains invalid characters (must be alphanumeric, underscore, or dash)');
      }
      
      // Validate parameters schema
      if (openAITool.function.parameters) {
        const schemaValidation = this.validateJsonSchema(openAITool.function.parameters);
        if (!schemaValidation.isValid) {
          errors.push(...(schemaValidation.errors || []));
        }
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }
}
```

## services/mcp-bridge/types/BridgeTypes.ts

```typescript
/**
 * Location: /src/services/mcp-bridge/types/BridgeTypes.ts
 * 
 * This file defines all TypeScript interfaces and types for the MCP-to-Function-Calling bridge system.
 * It provides comprehensive type safety for converting MCP tools to provider-specific function calling formats.
 * 
 * Used by: All bridge components for type safety and interface contracts
 * Dependencies: JSON Schema types, LLM provider types
 */

// Using built-in JSON Schema types instead of external dependency
type JSONSchema = {
  type?: string | string[];
  properties?: Record<string, JSONSchema>;
  required?: string[];
  description?: string;
  items?: JSONSchema;
  additionalProperties?: boolean | JSONSchema;
  enum?: any[];
  [key: string]: any;
};

// ============================================================================
// Core Bridge Types
// ============================================================================

/**
 * Supported LLM providers that can use the bridge system
 */
export type SupportedProvider = 'openai' | 'openrouter' | 'anthropic' | 'google' | 'groq' | 'mistral' | 'perplexity' | 'requesty';

/**
 * Diagnostic levels for bridge system logging
 */
export enum DiagnosticLevel {
  ERROR = 'error',     // Only errors and critical issues
  INFO = 'info',       // Tool executions and major events
  DEBUG = 'debug',     // Detailed request/response data
  TRACE = 'trace'      // Complete execution flow
}

/**
 * Execution status for tool calls
 */
export enum ExecutionStatus {
  PENDING = 'pending',
  EXECUTING = 'executing', 
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

/**
 * Tool features supported by different providers
 */
export enum ToolFeature {
  FUNCTION_CALLING = 'function_calling',
  PARALLEL_CALLS = 'parallel_calls',
  STREAMING = 'streaming',
  VALIDATION = 'validation'
}

// ============================================================================
// MCP Tool Types (from server)
// ============================================================================

/**
 * MCP tool definition from the server
 */
export interface MCPTool {
  name: string;
  description: string;
  inputSchema: JSONSchema;
}

/**
 * Response from MCP server list_tools endpoint
 */
export interface MCPToolListResponse {
  tools: MCPTool[];
}

/**
 * MCP tool execution request format
 */
export interface MCPExecutionRequest {
  name: string;
  arguments: Record<string, any>;
}

/**
 * MCP tool execution response format
 */
export interface MCPExecutionResponse {
  success: boolean;
  result?: any;
  error?: {
    code: string;
    message: string;
    details?: Record<string, any>;
  };
  executionTime?: number;
}

// ============================================================================
// Provider Tool Types
// ============================================================================

/**
 * Generic provider tool wrapper
 */
export interface ProviderTool {
  provider: SupportedProvider;
  originalName: string;
  tool: any; // Provider-specific format
}

/**
 * OpenAI function calling tool format
 */
export interface OpenAITool {
  type: 'function';
  function: {
    name: string;
    description: string;
    parameters: JSONSchema;
  };
}

/**
 * OpenAI tool call from LLM response
 */
export interface OpenAIToolCall {
  id: string;
  type: 'function';
  function: {
    name: string;
    arguments: string; // JSON string
  };
}

/**
 * Anthropic tool definition format
 */
export interface AnthropicTool {
  name: string;
  description: string;
  input_schema: JSONSchema;
}

/**
 * Anthropic tool call from LLM response
 */
export interface AnthropicToolCall {
  id: string;
  name: string;
  input: Record<string, any>;
}

/**
 * Google/Gemini function declaration format
 */
export interface GoogleTool {
  name: string;
  description: string;
  parameters: JSONSchema;
}

/**
 * Google function call from LLM response
 */
export interface GoogleToolCall {
  name: string;
  args: Record<string, any>;
}

// ============================================================================
// Bridge Internal Types
// ============================================================================

/**
 * Normalized tool call request (internal format)
 */
export interface ToolCallRequest {
  id: string;
  name: string;
  parameters: Record<string, any>;
  provider: SupportedProvider;
  metadata?: {
    timestamp?: string;
    sessionId?: string;
    executionContext?: Record<string, any>;
  };
}

/**
 * Normalized tool call result (internal format)
 */
export interface ToolCallResult {
  id: string;
  name: string;
  success: boolean;
  result?: any;
  error?: string;
  executionTime: number;
  timestamp: string;
  metadata?: {
    provider?: SupportedProvider;
    mcpServer?: string;
    errorCode?: string;
    errorType?: string;
    retryCount?: number;
  };
}

/**
 * Execution context for tool calls
 */
export interface ExecutionContext {
  sessionId?: string;
  userId?: string;
  conversationId?: string;
  provider: SupportedProvider;
  model: string;
  timestamp: string;
}

/**
 * Validation result for tool calls and schemas
 */
export interface ValidationResult {
  isValid: boolean;
  errors?: string[];
  warnings?: string[];
}

// ============================================================================
// Configuration Types
// ============================================================================

/**
 * Bridge system configuration
 */
export interface BridgeConfiguration {
  mcpServer: {
    url: string;
    timeout: number;
    retries: number;
    healthCheckInterval: number;
  };
  providers: {
    [K in SupportedProvider]?: {
      enabled: boolean;
      features: ToolFeature[];
    };
  };
  diagnostics: {
    enabled: boolean;
    level: DiagnosticLevel;
    retentionDays: number;
    maxEvents: number;
  };
  cache: {
    enabled: boolean;
    toolSchemaTTL: number;
    resultTTL: number;
    maxSize: number;
  };
  ui: {
    showAccordion: boolean;
    expandByDefault: boolean;
    showTimings: boolean;
    showParameters: boolean;
  };
}

/**
 * Provider capabilities
 */
export interface ProviderCapabilities {
  supportsParallelCalls: boolean;
  supportsStreaming: boolean;
  maxToolsPerCall: number;
  features: ToolFeature[];
}

// ============================================================================
// Diagnostic and Monitoring Types
// ============================================================================

/**
 * Diagnostic event for bridge system logging
 */
export interface DiagnosticEvent {
  id: string;
  type: 'tool_discovery' | 'tool_execution' | 'schema_conversion' | 'error';
  timestamp: string;
  level: DiagnosticLevel;
  component: string;
  data: Record<string, any>;
  context?: ExecutionContext;
}

/**
 * Bridge system diagnostics
 */
export interface BridgeDiagnostics {
  isHealthy: boolean;
  mcpServerStatus: 'connected' | 'disconnected' | 'error';
  lastToolDiscovery: string;
  toolCount: number;
  enabledProviders: SupportedProvider[];
  recentEvents: DiagnosticEvent[];
}

/**
 * Execution statistics
 */
export interface ExecutionStats {
  totalExecutions: number;
  successfulExecutions: number;
  failedExecutions: number;
  averageExecutionTime: number;
  currentQueueSize: number;
  lastExecutionTime: string;
}

/**
 * Performance metrics
 */
export interface PerformanceMetrics {
  period: {
    start: string;
    end: string;
    duration: number;
  };
  toolExecutions: {
    total: number;
    successful: number;
    failed: number;
    averageTime: number;
    medianTime: number;
    p95Time: number;
  };
  byTool: Record<string, {
    calls: number;
    successRate: number;
    averageTime: number;
  }>;
  byProvider: Record<string, {
    calls: number;
    successRate: number;
    averageTime: number;
  }>;
  errors: {
    total: number;
    byType: Record<string, number>;
    byTool: Record<string, number>;
  };
}

// ============================================================================
// UI Integration Types
// ============================================================================

/**
 * Tool call status update for UI
 */
export interface ToolCallStatusUpdate {
  callId: string;
  status: ExecutionStatus;
  data?: {
    name?: string;
    parameters?: Record<string, any>;
    result?: any;
    error?: string;
    executionTime?: number;
  };
  timestamp: string;
}

/**
 * Tool accordion state for UI
 */
export interface AccordionState {
  isExpanded: boolean;
  toolCalls: Array<{
    id: string;
    name: string;
    status: ExecutionStatus;
    parameters: Record<string, any>;
    result?: any;
    error?: string;
    executionTime?: number;
    timestamp: string;
  }>;
  summary: {
    total: number;
    completed: number;
    failed: number;
    executing: number;
  };
}

// ============================================================================
// Cache Types
// ============================================================================

/**
 * Tool schema cache entry
 */
export interface ToolSchemaCacheEntry {
  tools: ProviderTool[];
  lastUpdated: string;
  ttl: number;
  version: string;
}

/**
 * Tool schema cache by provider
 */
export interface ToolSchemaCache {
  [provider: string]: ToolSchemaCacheEntry;
}

/**
 * Execution result cache entry
 */
export interface ExecutionResultCacheEntry {
  result: ToolCallResult;
  timestamp: string;
  ttl: number;
  accessCount: number;
}

/**
 * Execution result cache by key hash
 */
export interface ExecutionResultCache {
  [key: string]: ExecutionResultCacheEntry; // key = hash(toolName + parameters)
}

// ============================================================================
// Interface Definitions for Core Components
// ============================================================================

/**
 * Main bridge orchestrator interface
 */
export interface IMCPFunctionBridge {
  // Initialization
  initialize(): Promise<void>;
  isInitialized(): boolean;
  
  // Tool Management
  getAvailableTools(): Promise<MCPTool[]>;
  getToolsForProvider(provider: SupportedProvider): Promise<ProviderTool[]>;
  refreshTools(): Promise<void>;
  
  // Tool Execution
  executeToolCall(call: ToolCallRequest): Promise<ToolCallResult>;
  executeToolCalls(calls: ToolCallRequest[]): Promise<ToolCallResult[]>;
  
  // Health and Diagnostics
  isHealthy(): boolean;
  getDiagnostics(): BridgeDiagnostics;
  getExecutionStats(): ExecutionStats;
  
  // Configuration
  updateConfiguration(config: Partial<BridgeConfiguration>): void;
  getConfiguration(): BridgeConfiguration;
}

/**
 * Tool schema converter interface
 */
export interface IToolSchemaConverter {
  // Provider registration
  registerProviderConverter(provider: SupportedProvider, converter: IProviderConverter): void;
  
  // Schema conversion
  convertToolsForProvider(mcpTools: MCPTool[], provider: SupportedProvider): Promise<ProviderTool[]>;
  convertSingleTool(mcpTool: MCPTool, provider: SupportedProvider): Promise<ProviderTool>;
  
  // Validation
  validateMCPTool(tool: MCPTool): ValidationResult;
  validateProviderTool(tool: ProviderTool): ValidationResult;
  
  // Supported providers
  getSupportedProviders(): SupportedProvider[];
  isProviderSupported(provider: SupportedProvider): boolean;
}

/**
 * Provider converter interface
 */
export interface IProviderConverter {
  provider: SupportedProvider;
  
  // Core conversion
  convertMCPTool(mcpTool: MCPTool): ProviderTool;
  validateConversion(mcpTool: MCPTool, providerTool: ProviderTool): ValidationResult;
  
  // Tool call handling
  parseToolCall(providerToolCall: any): ToolCallRequest;
  formatToolResult(result: ToolCallResult): any;
  
  // Provider capabilities
  getCapabilities(): ProviderCapabilities;
  supportsFeature(feature: ToolFeature): boolean;
}

/**
 * MCP tool executor interface
 */
export interface IMCPToolExecutor {
  // Single execution
  executeTool(call: ToolCallRequest, context?: ExecutionContext): Promise<ToolCallResult>;
  
  // Batch execution
  executeToolsBatch(calls: ToolCallRequest[], context?: ExecutionContext): Promise<ToolCallResult[]>;
  executeToolsParallel(calls: ToolCallRequest[], context?: ExecutionContext): Promise<ToolCallResult[]>;
  
  // Execution control
  cancelExecution(callId: string): Promise<boolean>;
  getExecutionStatus(callId: string): ExecutionStatus;
  
  // Health and monitoring
  testConnection(): Promise<boolean>;
  getExecutionMetrics(): ExecutionStats;
}

/**
 * Tool call diagnostics interface
 */
export interface IToolCallDiagnostics {
  // Event logging
  logEvent(event: DiagnosticEvent): void;
  logToolStart(call: ToolCallRequest): void;
  logToolComplete(call: ToolCallRequest, result: ToolCallResult): void;
  logError(error: Error, context?: ExecutionContext): void;
  
  // Diagnostics retrieval
  getDiagnostics(level?: DiagnosticLevel): DiagnosticEvent[];
  getMetrics(timeRange?: { start: string; end: string }): PerformanceMetrics;
  
  // Configuration
  setLevel(level: DiagnosticLevel): void;
  clearDiagnostics(): void;
}

// ============================================================================
// Error Types
// ============================================================================

/**
 * Bridge system error types
 */
export enum BridgeErrorType {
  MCP_SERVER_UNREACHABLE = 'MCP_SERVER_UNREACHABLE',
  TOOL_NOT_FOUND = 'TOOL_NOT_FOUND',
  SCHEMA_CONVERSION_ERROR = 'SCHEMA_CONVERSION_ERROR',
  TOOL_EXECUTION_ERROR = 'TOOL_EXECUTION_ERROR',
  PARAMETER_VALIDATION_ERROR = 'PARAMETER_VALIDATION_ERROR',
  PROVIDER_NOT_SUPPORTED = 'PROVIDER_NOT_SUPPORTED',
  BRIDGE_NOT_INITIALIZED = 'BRIDGE_NOT_INITIALIZED'
}

/**
 * Bridge system error class
 */
export class BridgeError extends Error {
  constructor(
    public type: BridgeErrorType,
    message: string,
    public provider?: SupportedProvider,
    public toolName?: string,
    public originalError?: Error
  ) {
    super(message);
    this.name = 'BridgeError';
  }
}
```

## services/mcp/MCPConfigurationManager.ts

```typescript
/**
 * MCP Configuration Manager - Unified MCP configuration across providers
 * Manages MCP server URL, tool availability, and provider-specific configurations
 */

import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';

export interface MCPServerConfig {
  /** Server URL (HTTP/HTTPS endpoint) */
  url: string;
  
  /** Server display label */
  label: string;
  
  /** Server description */
  description?: string;
  
  /** Whether server is enabled */
  enabled: boolean;
  
  /** Authentication token if required */
  authToken?: string;
  
  /** Allowed tools (empty = all allowed) */
  allowedTools?: string[];
  
  /** Require approval for tool calls */
  requireApproval: 'always' | 'never' | { never: { tool_names: string[] } };
}

export interface ProviderMCPConfig {
  /** Whether this provider supports MCP */
  supported: boolean;
  
  /** Whether MCP is enabled for this provider */
  enabled: boolean;
  
  /** Provider-specific MCP configuration */
  config?: Record<string, any>;
}

export interface MCPConfiguration {
  /** Local MCP server configuration */
  server: MCPServerConfig;
  
  /** Per-provider MCP settings */
  providers: Record<string, ProviderMCPConfig>;
  
  /** Global MCP settings */
  global: {
    /** Default tool approval setting */
    defaultApproval: 'always' | 'never';
    
    /** Enable MCP logging */
    enableLogging: boolean;
    
    /** Maximum concurrent MCP connections */
    maxConnections: number;
  };
}

export class MCPConfigurationManager extends EventEmitter {
  private config: MCPConfiguration;
  private serverUrl: string | null = null;
  
  constructor() {
    super();
    
    // Initialize with default configuration
    this.config = this.getDefaultConfiguration();
  }

  /**
   * Initialize with server URL from running MCP server
   */
  initialize(serverUrl: string): void {
    this.serverUrl = serverUrl;
    
    // Update server configuration
    this.config.server.url = serverUrl;
    this.config.server.enabled = true;
    
    logger.systemLog(`[MCP Config] Initialized with server URL: ${serverUrl}`);
    this.emit('configUpdated', this.config);
  }

  /**
   * Get current MCP configuration
   */
  getConfiguration(): MCPConfiguration {
    return { ...this.config };
  }

  /**
   * Get server configuration for a specific provider
   */
  getProviderConfig(providerId: string): ProviderMCPConfig | null {
    return this.config.providers[providerId] || null;
  }

  /**
   * Enable/disable MCP for a specific provider
   */
  setProviderEnabled(providerId: string, enabled: boolean): void {
    if (!this.config.providers[providerId]) {
      this.config.providers[providerId] = {
        supported: true,
        enabled: false
      };
    }
    
    this.config.providers[providerId].enabled = enabled;
    
    logger.systemLog(`[MCP Config] ${providerId} MCP ${enabled ? 'enabled' : 'disabled'}`);
    this.emit('providerConfigChanged', providerId, this.config.providers[providerId]);
  }

  /**
   * Update provider MCP support status
   */
  setProviderSupported(providerId: string, supported: boolean): void {
    if (!this.config.providers[providerId]) {
      this.config.providers[providerId] = {
        supported,
        enabled: false
      };
    } else {
      this.config.providers[providerId].supported = supported;
      
      // Disable if no longer supported
      if (!supported) {
        this.config.providers[providerId].enabled = false;
      }
    }
    
    logger.systemLog(`[MCP Config] ${providerId} MCP support: ${supported}`);
    this.emit('providerConfigChanged', providerId, this.config.providers[providerId]);
  }

  /**
   * Update server configuration
   */
  updateServerConfig(updates: Partial<MCPServerConfig>): void {
    this.config.server = { ...this.config.server, ...updates };
    
    logger.systemLog(`[MCP Config] Server config updated`);
    this.emit('serverConfigChanged', this.config.server);
  }

  /**
   * Get server URL for provider integrations
   */
  getServerUrl(): string | null {
    return this.config.server.enabled ? this.config.server.url : null;
  }

  /**
   * Get server configuration for provider MCP tools
   */
  getServerConfigForProvider(providerId: string): MCPServerConfig | null {
    const providerConfig = this.config.providers[providerId];
    
    if (!providerConfig || !providerConfig.enabled || !this.config.server.enabled) {
      return null;
    }
    
    return this.config.server;
  }

  /**
   * Check if MCP is available for a provider
   */
  isProviderMCPAvailable(providerId: string): boolean {
    const providerConfig = this.config.providers[providerId];
    return !!(
      providerConfig?.supported &&
      providerConfig?.enabled &&
      this.config.server.enabled &&
      this.serverUrl
    );
  }

  /**
   * Get available tools for a provider
   */
  getAvailableToolsForProvider(providerId: string): string[] | null {
    if (!this.isProviderMCPAvailable(providerId)) {
      return null;
    }
    
    // Return allowed tools list, or null for all tools
    return this.config.server.allowedTools || null;
  }

  /**
   * Update global MCP settings
   */
  updateGlobalConfig(updates: Partial<MCPConfiguration['global']>): void {
    this.config.global = { ...this.config.global, ...updates };
    
    logger.systemLog(`[MCP Config] Global config updated`);
    this.emit('globalConfigChanged', this.config.global);
  }

  /**
   * Export configuration for persistence
   */
  exportConfig(): MCPConfiguration {
    return JSON.parse(JSON.stringify(this.config));
  }

  /**
   * Import configuration from persistence
   */
  importConfig(config: Partial<MCPConfiguration>): void {
    this.config = {
      ...this.getDefaultConfiguration(),
      ...config
    };
    
    logger.systemLog(`[MCP Config] Configuration imported`);
    this.emit('configUpdated', this.config);
  }

  /**
   * Get default MCP configuration
   */
  private getDefaultConfiguration(): MCPConfiguration {
    return {
      server: {
        url: 'http://localhost:3000/sse',
        label: 'Claudesidian',
        description: 'Local Claudesidian MCP server providing vault operations and AI agents',
        enabled: false,
        requireApproval: 'never'
      },
      providers: {
        openai: {
          supported: false, // Will be detected at runtime
          enabled: false
        },
        anthropic: {
          supported: false, // Will be detected at runtime  
          enabled: false
        },
        mistral: {
          supported: false,
          enabled: false
        },
        google: {
          supported: false,
          enabled: false
        }
      },
      global: {
        defaultApproval: 'never',
        enableLogging: true,
        maxConnections: 10
      }
    };
  }

  /**
   * Get configuration summary for debugging
   */
  getConfigSummary(): any {
    return {
      serverEnabled: this.config.server.enabled,
      serverUrl: this.config.server.url,
      providersEnabled: Object.entries(this.config.providers)
        .filter(([, config]) => config.enabled)
        .map(([id]) => id),
      providersSupported: Object.entries(this.config.providers)
        .filter(([, config]) => config.supported)
        .map(([id]) => id)
    };
  }
}
```

## services/mcp/MCPConnectionManager.ts

```typescript
import { App, Plugin } from 'obsidian';
import { MCPServer } from '../../server';
import { EventManager } from '../EventManager';
import { SessionContextManager } from '../SessionContextManager';
import { CustomPromptStorageService } from "../../agents/agentManager/services/CustomPromptStorageService";
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';

/**
 * Location: src/services/mcp/MCPConnectionManager.ts
 * 
 * This service manages the MCP server connection lifecycle, including:
 * - Server creation and initialization
 * - Connection handling and management
 * - Server lifecycle (start/stop/shutdown)
 * 
 * Used by: MCPConnector
 * Dependencies: MCPServer, EventManager, SessionContextManager
 */

export interface MCPConnectionManagerInterface {
    /**
     * Initializes MCP connection manager
     * @throws InitializationError when initialization fails
     */
    initialize(): Promise<void>;

    /**
     * Creates and configures MCP server
     * @returns Configured MCP server instance
     * @throws ServerCreationError when server creation fails
     */
    createServer(): Promise<MCPServer>;

    /**
     * Starts the MCP server
     * @throws ServerStartError when server start fails
     */
    start(): Promise<void>;

    /**
     * Stops the MCP server
     * @throws ServerStopError when server stop fails
     */
    stop(): Promise<void>;

    /**
     * Shuts down connection manager and cleans up resources
     */
    shutdown(): Promise<void>;

    /**
     * Gets current MCP server instance
     * @returns Current server instance or null if not initialized
     */
    getServer(): MCPServer | null;

    /**
     * Gets connection status information
     * @returns Connection status details
     */
    getConnectionStatus(): MCPConnectionStatus;

    /**
     * Reinitializes the request router
     * Used after agent registration changes
     */
    reinitializeRequestRouter(): void;
}

export interface MCPConnectionStatus {
    /** Whether manager is initialized */
    isInitialized: boolean;
    
    /** Whether server is running */
    isServerRunning: boolean;
    
    /** Server creation timestamp */
    serverCreatedAt?: Date;
    
    /** Last error encountered */
    lastError?: {
        message: string;
        timestamp: Date;
    };
}

export class MCPConnectionManager implements MCPConnectionManagerInterface {
    private server: MCPServer | null = null;
    private isInitialized = false;
    private isServerRunning = false;
    private serverCreatedAt?: Date;
    private lastError?: { message: string; timestamp: Date };

    constructor(
        private app: App,
        private plugin: Plugin,
        private eventManager: EventManager,
        private sessionContextManager: SessionContextManager,
        private customPromptStorage?: CustomPromptStorageService,
        private onToolCall?: (toolName: string, params: any) => Promise<void>,
        private onToolResponse?: (toolName: string, params: any, response: any, success: boolean, executionTime: number) => Promise<void>
    ) {}

    /**
     * Initializes MCP connection manager
     */
    async initialize(): Promise<void> {
        if (this.isInitialized) {
            return; // Already initialized
        }

        try {
            // Create the MCP server
            this.server = await this.createServer();
            this.isInitialized = true;
            
            logger.systemLog('MCP Connection Manager initialized successfully');
        } catch (error) {
            this.lastError = {
                message: (error as Error).message,
                timestamp: new Date()
            };
            
            logger.systemError(error as Error, 'MCP Connection Manager Initialization');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to initialize MCP connection manager',
                error
            );
        }
    }

    /**
     * Creates and configures MCP server
     */
    async createServer(): Promise<MCPServer> {
        try {
            const server = new MCPServer(
                this.app,
                this.plugin,
                this.eventManager,
                this.sessionContextManager,
                undefined, // serviceContainer will be set later if needed
                this.customPromptStorage,
                this.onToolCall,
                this.onToolResponse
            );

            this.serverCreatedAt = new Date();
            
            logger.systemLog('MCP Server created successfully');
            return server;
        } catch (error) {
            this.lastError = {
                message: (error as Error).message,
                timestamp: new Date()
            };
            
            logger.systemError(error as Error, 'MCP Server Creation');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to create MCP server',
                error
            );
        }
    }

    /**
     * Starts the MCP server
     */
    async start(): Promise<void> {
        if (!this.server) {
            logger.systemError(new Error('Server not initialized'), 'Cannot start server: server not initialized');
            throw new McpError(
                ErrorCode.InternalError,
                'Cannot start server: server not initialized'
            );
        }

        try {
            await this.server.start();
            this.isServerRunning = true;
            
            logger.systemLog('MCP Server started successfully');
        } catch (error) {
            this.lastError = {
                message: (error as Error).message,
                timestamp: new Date()
            };
            
            logger.systemError(error as Error, 'MCP Server Start');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to start MCP server',
                error
            );
        }
    }

    /**
     * Stops the MCP server
     */
    async stop(): Promise<void> {
        if (!this.server) {
            return; // No server to stop
        }

        try {
            await this.server.stop();
            this.isServerRunning = false;
            
            logger.systemLog('MCP Server stopped successfully');
        } catch (error) {
            this.lastError = {
                message: (error as Error).message,
                timestamp: new Date()
            };
            
            logger.systemError(error as Error, 'MCP Server Stop');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to stop MCP server',
                error
            );
        }
    }

    /**
     * Shuts down connection manager and cleans up resources
     */
    async shutdown(): Promise<void> {
        try {
            if (this.isServerRunning) {
                await this.stop();
            }

            this.server = null;
            this.isInitialized = false;
            this.isServerRunning = false;
            this.serverCreatedAt = undefined;
            this.lastError = undefined;
            
            logger.systemLog('MCP Connection Manager shut down successfully');
        } catch (error) {
            this.lastError = {
                message: (error as Error).message,
                timestamp: new Date()
            };
            
            logger.systemError(error as Error, 'MCP Connection Manager Shutdown');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to shutdown MCP connection manager',
                error
            );
        }
    }

    /**
     * Gets current MCP server instance
     */
    getServer(): MCPServer | null {
        return this.server;
    }

    /**
     * Gets connection status information
     */
    getConnectionStatus(): MCPConnectionStatus {
        return {
            isInitialized: this.isInitialized,
            isServerRunning: this.isServerRunning,
            serverCreatedAt: this.serverCreatedAt,
            lastError: this.lastError
        };
    }

    /**
     * Reinitializes the request router
     */
    reinitializeRequestRouter(): void {
        if (!this.server) {
            logger.systemWarn('Cannot reinitialize request router: server not initialized');
            return;
        }

        try {
            this.server.reinitializeRequestRouter();
            logger.systemLog('Request router reinitialized successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Request Router Reinitialization');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to reinitialize request router',
                error
            );
        }
    }
}
```

## services/mcp/ToolCallRouter.ts

```typescript
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';

/**
 * Location: src/services/mcp/ToolCallRouter.ts
 * 
 * This service handles routing tool calls to appropriate agents and modes, including:
 * - Tool call request validation
 * - Agent/mode resolution and execution
 * - Error handling and response formatting
 * - Tool call capture coordination
 * 
 * Used by: MCPConnector
 * Dependencies: Agent implementations, ToolCallCaptureService
 */

export interface AgentModeParams {
    agent: string;
    mode: string;
    params: Record<string, any>;
}

export interface ToolCallRequest {
    params: {
        name: string;
        arguments: Record<string, any>;
    };
    meta?: {
        requestId?: string;
        timestamp?: Date;
        source?: string;
    };
}

export interface ToolCallResponse {
    content: Array<{
        type: 'text' | 'resource';
        text?: string;
        resource?: any;
    }>;
    isError?: boolean;
    error?: {
        code: string;
        message: string;
        data?: any;
    };
}

export interface ToolCallRouterInterface {
    /**
     * Routes tool call request to appropriate agent/mode
     * @param request MCP tool call request
     * @returns Promise resolving to tool call response
     * @throws RoutingError when routing fails
     * @throws ValidationError when request is invalid
     */
    route(request: ToolCallRequest): Promise<ToolCallResponse>;

    /**
     * Executes agent mode directly
     * @param agent Agent name
     * @param mode Mode name
     * @param params Mode parameters
     * @returns Promise resolving to execution result
     */
    executeAgentMode(agent: string, mode: string, params: Record<string, any>): Promise<any>;

    /**
     * Validates tool call request
     * @param request Request to validate
     * @returns Validation result
     */
    validateRequest(request: ToolCallRequest): ValidationResult;

    /**
     * Validates batch operations if present
     * @param params Parameters that may contain batch operations
     * @throws ValidationError when batch operations are invalid
     */
    validateBatchOperations(params: Record<string, any>): void;

    /**
     * Sets the server reference for agent mode execution
     * @param server Server instance that handles agent mode execution
     */
    setServer(server: any): void;
}

export interface ValidationResult {
    isValid: boolean;
    errors: string[];
}

export class ToolCallRouter implements ToolCallRouterInterface {
    private server: any = null;

    constructor() {}

    /**
     * Routes tool call request to appropriate agent/mode
     */
    async route(request: ToolCallRequest): Promise<ToolCallResponse> {
        try {
            // Validate the request
            const validation = this.validateRequest(request);
            if (!validation.isValid) {
                throw new McpError(
                    ErrorCode.InvalidRequest,
                    `Invalid tool call: ${validation.errors.join(', ')}`
                );
            }

            // Parse tool name to get agent and mode
            const { agentName, modeName } = this.parseToolName(request.params.name);
            
            // Validate batch operations if present
            this.validateBatchOperations(request.params.arguments);

            // Execute the agent mode
            const result = await this.executeAgentMode(
                agentName, 
                modeName, 
                request.params.arguments
            );

            return this.buildSuccessResponse(result);

        } catch (error) {
            return this.buildErrorResponse(error);
        }
    }

    /**
     * Executes agent mode directly
     */
    async executeAgentMode(agent: string, mode: string, params: Record<string, any>): Promise<any> {
        if (!this.server) {
            throw new McpError(
                ErrorCode.InternalError,
                'Server not initialized for tool call routing'
            );
        }

        try {
            // Delegate to server's executeAgentMode method
            return await this.server.executeAgentMode(agent, mode, params);
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            
            logger.systemError(error as Error, 'Agent Mode Execution');
            throw new McpError(
                ErrorCode.InternalError,
                `Failed to execute ${agent}.${mode}`,
                error
            );
        }
    }

    /**
     * Validates tool call request
     */
    validateRequest(request: ToolCallRequest): ValidationResult {
        const errors: string[] = [];

        if (!request.params?.name) {
            errors.push('Tool name is required');
        }

        if (!request.params?.arguments) {
            errors.push('Tool arguments are required');
        }

        // Validate tool name format
        if (request.params?.name) {
            try {
                this.parseToolName(request.params.name);
            } catch (error) {
                errors.push((error as Error).message);
            }
        }

        return { isValid: errors.length === 0, errors };
    }

    /**
     * Validates batch operations if present in parameters
     */
    validateBatchOperations(params: Record<string, any>): void {
        // Validate batch operations if they exist
        if (params && params.operations && Array.isArray(params.operations)) {
            params.operations.forEach((operation: any, index: number) => {
                if (!operation || typeof operation !== 'object') {
                    throw new McpError(
                        ErrorCode.InvalidParams,
                        `Invalid operation at index ${index} in batch operations: operation must be an object`
                    );
                }

                if (!operation.type) {
                    throw new McpError(
                        ErrorCode.InvalidParams,
                        `Invalid operation at index ${index} in batch operations: missing 'type' property`
                    );
                }

                // Check for either filePath in params or path at the operation level
                if ((!operation.params || !operation.params.filePath) && !operation.path) {
                    throw new McpError(
                        ErrorCode.InvalidParams,
                        `Invalid operation at index ${index} in batch operations: missing 'filePath' property in params`
                    );
                }
            });
        }

        // Validate batch read paths if they exist
        if (params && params.paths && Array.isArray(params.paths)) {
            params.paths.forEach((path: any, index: number) => {
                if (typeof path !== 'string') {
                    throw new McpError(
                        ErrorCode.InvalidParams,
                        `Invalid path at index ${index} in batch paths: path must be a string`
                    );
                }
            });
        }
    }

    /**
     * Sets the server reference for agent mode execution
     */
    setServer(server: any): void {
        this.server = server;
    }

    /**
     * Parses tool name into agent and mode components
     * @private
     */
    private parseToolName(toolName: string): { agentName: string; modeName: string } {
        const parts = toolName.split('_');
        if (parts.length !== 2) {
            throw new McpError(
                ErrorCode.InvalidRequest,
                `Invalid tool name format: ${toolName}. Expected format: agentName_modeName`
            );
        }

        return { agentName: parts[0], modeName: parts[1] };
    }

    /**
     * Builds successful response
     * @private
     */
    private buildSuccessResponse(result: any): ToolCallResponse {
        return {
            content: [{
                type: 'text',
                text: typeof result === 'string' ? result : JSON.stringify(result, null, 2)
            }],
            isError: false
        };
    }

    /**
     * Builds error response
     * @private
     */
    private buildErrorResponse(error: any): ToolCallResponse {
        const errorMessage = error instanceof Error ? error.message : String(error);
        const errorCode = error instanceof McpError ? error.code : ErrorCode.InternalError;

        return {
            content: [{
                type: 'text',
                text: `Error: ${errorMessage}`
            }],
            isError: true,
            error: {
                code: String(errorCode),
                message: errorMessage,
                data: error instanceof McpError ? error.data : undefined
            }
        };
    }
}
```

## services/memory/SimpleMemoryMonitor.ts

```typescript
/**
 * Simple Memory Monitor - Hardcoded Balanced Approach
 * 
 * Provides basic memory monitoring without complex configuration.
 * Uses hardcoded balanced settings as requested by user.
 */

interface MemoryInfo {
  used: number;
  total: number;
  jsHeapSizeLimit?: number;
  usagePercent: number;
}

interface MemoryPressureLevel {
  level: 'normal' | 'warning' | 'high' | 'critical';
  threshold: number;
}

export class SimpleMemoryMonitor {
  private static instance: SimpleMemoryMonitor | null = null;
  private isMonitoring = false;
  private checkInterval: NodeJS.Timeout | null = null;
  
  // Hardcoded balanced thresholds
  private readonly thresholds = {
    warning: 60,   // 60% memory usage
    high: 75,      // 75% memory usage  
    critical: 85   // 85% memory usage
  };

  private constructor() {}

  static getInstance(): SimpleMemoryMonitor {
    if (!SimpleMemoryMonitor.instance) {
      SimpleMemoryMonitor.instance = new SimpleMemoryMonitor();
    }
    return SimpleMemoryMonitor.instance;
  }

  startMonitoring(): void {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    
    // Check memory every 30 seconds
    this.checkInterval = setInterval(() => {
      this.checkMemoryPressure();
    }, 30000);
  }

  stopMonitoring(): void {
    if (!this.isMonitoring) return;
    
    this.isMonitoring = false;
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
  }

  getCurrentMemoryInfo(): MemoryInfo {
    const memInfo = (performance as any).memory;
    
    if (!memInfo) {
      // Fallback if memory API not available
      return {
        used: 0,
        total: 0,
        usagePercent: 0
      };
    }

    const used = memInfo.usedJSHeapSize || 0;
    const total = memInfo.jsHeapSizeLimit || memInfo.totalJSHeapSize || 0;
    const usagePercent = total > 0 ? (used / total) * 100 : 0;

    return {
      used,
      total,
      jsHeapSizeLimit: memInfo.jsHeapSizeLimit,
      usagePercent
    };
  }

  getPressureLevel(): MemoryPressureLevel {
    const memInfo = this.getCurrentMemoryInfo();
    const usage = memInfo.usagePercent;

    if (usage >= this.thresholds.critical) {
      return { level: 'critical', threshold: this.thresholds.critical };
    } else if (usage >= this.thresholds.high) {
      return { level: 'high', threshold: this.thresholds.high };
    } else if (usage >= this.thresholds.warning) {
      return { level: 'warning', threshold: this.thresholds.warning };
    }
    
    return { level: 'normal', threshold: 0 };
  }

  private checkMemoryPressure(): void {
    const memInfo = this.getCurrentMemoryInfo();
    const pressure = this.getPressureLevel();

    // Log memory stats periodically
    if (pressure.level !== 'normal') {
      const usedMB = Math.round(memInfo.used / (1024 * 1024));
      const totalMB = Math.round(memInfo.total / (1024 * 1024));
      
      
      // Basic cleanup recommendations
      if (pressure.level === 'critical') {
      }
    }
  }

  // Utility method for other services to check if they should perform cleanup
  shouldPerformCleanup(): boolean {
    const pressure = this.getPressureLevel();
    return pressure.level === 'high' || pressure.level === 'critical';
  }

  getMemoryStats(): string {
    const memInfo = this.getCurrentMemoryInfo();
    const pressure = this.getPressureLevel();
    const usedMB = Math.round(memInfo.used / (1024 * 1024));
    const totalMB = Math.round(memInfo.total / (1024 * 1024));
    
    return `Memory: ${usedMB}MB / ${totalMB}MB (${Math.round(memInfo.usagePercent)}%) - ${pressure.level.toUpperCase()}`;
  }
}
```

## services/memory/index.ts

```typescript
/**
 * Memory Management Services - Simplified Implementation
 * 
 * Provides basic memory monitoring with hardcoded balanced approach.
 * No user configuration needed - uses optimal settings by default.
 */

import { SimpleMemoryMonitor } from './SimpleMemoryMonitor';

export { SimpleMemoryMonitor };

// Create singleton instance for easy access
export const memoryMonitor = SimpleMemoryMonitor.getInstance();
```

## services/migration/ChromaDataLoader.ts

```typescript
// Location: src/services/migration/ChromaDataLoader.ts
// Loads data from existing ChromaDB collections for migration to new JSON structure
// Used by: DataMigrationService to read legacy ChromaDB collection data
// Dependencies: FileSystemService for ChromaDB collection file reading

import { FileSystemService } from './FileSystemService';

export interface ChromaCollectionData {
  memoryTraces: any[];
  sessions: any[];
  conversations: any[];
  workspaces: any[];
  snapshots: any[];
}

export class ChromaDataLoader {
  private fileSystem: FileSystemService;

  constructor(fileSystem: FileSystemService) {
    this.fileSystem = fileSystem;
  }

  async loadAllCollections(): Promise<ChromaCollectionData> {
    console.log('[Claudesidian] Loading all ChromaDB collections...');

    const [memoryTraces, sessions, conversations, workspaces, snapshots] = await Promise.all([
      this.fileSystem.readChromaCollection('memory_traces'),
      this.fileSystem.readChromaCollection('sessions'),
      this.fileSystem.readChromaCollection('chat_conversations'),
      this.fileSystem.readChromaCollection('workspaces'),
      this.fileSystem.readChromaCollection('snapshots')
    ]);

    const result = {
      memoryTraces,
      sessions,
      conversations,
      workspaces,
      snapshots
    };

    console.log('[Claudesidian] Collection counts:', {
      memoryTraces: memoryTraces.length,
      sessions: sessions.length,
      conversations: conversations.length,
      workspaces: workspaces.length,
      snapshots: snapshots.length
    });

    console.log(`[Claudesidian] Loaded collections:`, {
      memoryTraces: result.memoryTraces.length,
      sessions: result.sessions.length,
      conversations: result.conversations.length,
      workspaces: result.workspaces.length,
      snapshots: result.snapshots.length
    });

    return result;
  }

  async detectLegacyData(): Promise<boolean> {
    console.log('[Claudesidian] Detecting legacy ChromaDB data...');

    try {
      const collections = await this.loadAllCollections();

      // Check if any collection has data
      const hasData = Object.values(collections).some(collection =>
        Array.isArray(collection) && collection.length > 0
      );

      console.log(`[Claudesidian] Legacy data detection result: ${hasData}`);
      return hasData;
    } catch (error) {
      console.warn('[Claudesidian] Error detecting legacy data:', error);
      return false;
    }
  }

  /**
   * Get summary statistics about the legacy data
   */
  async getDataSummary(): Promise<{
    totalItems: number;
    collections: Record<string, number>;
    oldestItem?: number;
    newestItem?: number;
  }> {
    const collections = await this.loadAllCollections();

    let totalItems = 0;
    let oldestTimestamp: number | undefined;
    let newestTimestamp: number | undefined;

    const collectionCounts: Record<string, number> = {};

    for (const [collectionName, items] of Object.entries(collections)) {
      collectionCounts[collectionName] = items.length;
      totalItems += items.length;

      // Find timestamp ranges
      for (const item of items) {
        const timestamp = item.metadata?.timestamp ||
                         item.metadata?.created ||
                         item.metadata?.created;

        if (timestamp) {
          if (!oldestTimestamp || timestamp < oldestTimestamp) {
            oldestTimestamp = timestamp;
          }
          if (!newestTimestamp || timestamp > newestTimestamp) {
            newestTimestamp = timestamp;
          }
        }
      }
    }

    return {
      totalItems,
      collections: collectionCounts,
      oldestItem: oldestTimestamp,
      newestItem: newestTimestamp
    };
  }

  /**
   * Test if ChromaDB collection files are accessible
   */
  async testCollectionAccess(): Promise<{
    accessible: string[];
    missing: string[];
    errors: string[];
  }> {
    const collectionNames = ['memory_traces', 'sessions', 'chat_conversations', 'workspaces', 'snapshots'];
    const accessible: string[] = [];
    const missing: string[] = [];
    const errors: string[] = [];

    for (const collectionName of collectionNames) {
      try {
        const items = await this.fileSystem.readChromaCollection(collectionName);
        if (Array.isArray(items)) {
          accessible.push(collectionName);
        } else {
          missing.push(collectionName);
        }
      } catch (error) {
        errors.push(`${collectionName}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    return { accessible, missing, errors };
  }
}
```

## services/migration/DataMigrationService.ts

```typescript
// Location: src/services/migration/DataMigrationService.ts
// Complete rewrite for the new simplified JSON-based architecture
// Used by: main.ts during plugin initialization to migrate from ChromaDB to JSON files
// Dependencies: FileSystemService, ChromaDataLoader, DataTransformer, SearchIndexBuilder

import { Plugin } from 'obsidian';
import { FileSystemService } from './FileSystemService';
import { ChromaDataLoader } from './ChromaDataLoader';
import { DataTransformer } from './DataTransformer';
import { SearchIndexBuilder } from './SearchIndexBuilder';

export interface MigrationStatus {
  isRequired: boolean;
  hasLegacyData: boolean;
  migrationComplete: boolean;
  migrationError?: string;
  lastMigrationAttempt?: number;
}

export interface MigrationResult {
  success: boolean;
  workspacesMigrated: number;
  sessionsMigrated: number;
  conversationsMigrated: number;
  memoryTracesMigrated: number;
  snapshotsMigrated: number;
  errors: string[];
  backupCreated: boolean;
  migrationTime: number;
}

export class DataMigrationService {
  private plugin: Plugin;
  private fileSystem: FileSystemService;
  private chromaLoader: ChromaDataLoader;
  private transformer: DataTransformer;
  private indexBuilder: SearchIndexBuilder;

  constructor(plugin: Plugin) {
    this.plugin = plugin;
    this.fileSystem = new FileSystemService(plugin);
    this.chromaLoader = new ChromaDataLoader(this.fileSystem);
    this.transformer = new DataTransformer();
    this.indexBuilder = new SearchIndexBuilder();

    console.log('[Claudesidian] DataMigrationService initialized with new architecture');
  }

  async checkMigrationStatus(): Promise<MigrationStatus> {
    console.log('[Claudesidian] Checking migration status...');

    // Check if new structure already exists
    const hasNewStructure = await this.fileSystem.fileExists('workspace-data.json');

    if (hasNewStructure) {
      console.log('[Claudesidian] New structure already exists - checking if settings cleanup needed');

      // Check if settings cleanup is needed
      const needsSettingsCleanup = await this.needsSettingsCleanup();
      if (needsSettingsCleanup) {
        console.log('[Claudesidian] Settings cleanup needed - running cleanup...');
        const cleanupResult = await this.cleanupObsoleteSettings();
        if (cleanupResult.success) {
          console.log(`[Claudesidian] Settings cleanup completed - removed ${cleanupResult.removedSettings.length} obsolete settings`);
        } else {
          console.warn('[Claudesidian] Settings cleanup failed:', cleanupResult.error);
        }
      } else {
        console.log('[Claudesidian] Settings already clean - no cleanup needed');
      }

      return {
        isRequired: false,
        hasLegacyData: false,
        migrationComplete: true
      };
    }

    // Check for legacy ChromaDB data
    const hasLegacyData = await this.chromaLoader.detectLegacyData();

    console.log(`[Claudesidian] Migration status: required=${hasLegacyData}, hasLegacy=${hasLegacyData}`);

    return {
      isRequired: hasLegacyData,
      hasLegacyData,
      migrationComplete: false
    };
  }

  async performMigration(): Promise<MigrationResult> {
    const startTime = Date.now();
    const result: MigrationResult = {
      success: false,
      workspacesMigrated: 0,
      sessionsMigrated: 0,
      conversationsMigrated: 0,
      memoryTracesMigrated: 0,
      snapshotsMigrated: 0,
      errors: [],
      backupCreated: false,
      migrationTime: 0
    };

    try {
      console.log('[Claudesidian] Starting migration to new JSON architecture...');

      // Step 1: Ensure data directory exists
      await this.fileSystem.ensureDataDirectory();
      console.log('[Claudesidian] Data directory ensured');

      // Step 2: Get data summary for reporting
      const dataSummary = await this.chromaLoader.getDataSummary();
      console.log('[Claudesidian] Data summary:', dataSummary);

      // Step 3: Load all ChromaDB collections
      const chromaData = await this.chromaLoader.loadAllCollections();
      console.log('[Claudesidian] ChromaDB collections loaded');

      // Step 4: Transform to new structure
      const { workspaceData, conversationData } = this.transformer.transformToNewStructure(chromaData);
      console.log('[Claudesidian] Data transformation completed');

      // Step 5: Count migrated items for reporting
      result.conversationsMigrated = Object.keys(conversationData.conversations).length;
      result.workspacesMigrated = Object.keys(workspaceData.workspaces).length;

      let totalSessions = 0;
      let totalTraces = 0;
      let totalSnapshots = 0;

      for (const workspace of Object.values(workspaceData.workspaces)) {
        totalSessions += Object.keys(workspace.sessions).length;
        for (const session of Object.values(workspace.sessions)) {
          totalTraces += Object.keys(session.memoryTraces).length;
          totalSnapshots += Object.keys(session.states).length;
        }
      }

      result.sessionsMigrated = totalSessions;
      result.memoryTracesMigrated = totalTraces;
      result.snapshotsMigrated = totalSnapshots;

      console.log('[Claudesidian] Migration counts:', {
        workspaces: result.workspacesMigrated,
        sessions: result.sessionsMigrated,
        conversations: result.conversationsMigrated,
        traces: result.memoryTracesMigrated,
        snapshots: result.snapshotsMigrated
      });

      // Step 6: Build search indexes
      console.log('[Claudesidian] Building search indexes...');
      const workspaceIndex = this.indexBuilder.buildWorkspaceIndex(workspaceData);
      const conversationIndex = this.indexBuilder.buildConversationIndex(conversationData);
      console.log('[Claudesidian] Search indexes built');

      // Step 7: Write all files atomically
      console.log('[Claudesidian] Writing JSON files...');
      await Promise.all([
        this.fileSystem.writeJSON('workspace-data.json', workspaceData),
        this.fileSystem.writeJSON('conversations.json', conversationData),
        this.fileSystem.writeJSON('workspace-index.json', workspaceIndex),
        this.fileSystem.writeJSON('conversations-index.json', conversationIndex)
      ]);

      // Step 8: Clean up obsolete settings
      console.log('[Claudesidian] Cleaning up obsolete embedding/vector settings...');
      const settingsCleanupResult = await this.cleanupObsoleteSettings();
      if (settingsCleanupResult.success) {
        console.log(`[Claudesidian] Settings cleanup completed - removed ${settingsCleanupResult.removedSettings.length} obsolete settings`);
      } else {
        console.warn('[Claudesidian] Settings cleanup failed:', settingsCleanupResult.error);
      }

      result.success = true;
      result.migrationTime = Date.now() - startTime;

      console.log('[Claudesidian] Migration completed successfully in', result.migrationTime, 'ms');
      console.log('[Claudesidian] Final result:', result);

    } catch (error) {
      console.error('[Claudesidian] Migration failed:', error);
      result.errors.push(`Migration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }

    result.migrationTime = Date.now() - startTime;
    return result;
  }

  /**
   * Get detailed information about the migration for debugging
   */
  async getMigrationInfo(): Promise<{
    chromaDataSummary?: any;
    newDataExists: boolean;
    accessTest?: any;
    errors: string[];
  }> {
    const info: {
      chromaDataSummary?: any;
      newDataExists: boolean;
      accessTest?: any;
      errors: string[];
    } = {
      newDataExists: false,
      errors: []
    };

    try {
      // Check if new structure exists
      info.newDataExists = await this.fileSystem.fileExists('workspace-data.json');

      // Test ChromaDB access
      info.accessTest = await this.chromaLoader.testCollectionAccess();

      // Get data summary if possible
      if (info.accessTest && info.accessTest.accessible.length > 0) {
        info.chromaDataSummary = await this.chromaLoader.getDataSummary();
      }
    } catch (error) {
      info.errors.push(`Error getting migration info: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }

    return info;
  }

  /**
   * Rebuild search indexes for existing data
   */
  async rebuildIndexes(): Promise<{ success: boolean; error?: string }> {
    try {
      console.log('[Claudesidian] Rebuilding search indexes...');

      // Load existing data
      const workspaceData = await this.fileSystem.readJSON('workspace-data.json');
      const conversationData = await this.fileSystem.readJSON('conversations.json');

      if (!workspaceData || !conversationData) {
        throw new Error('No existing data found to rebuild indexes');
      }

      // Rebuild indexes
      const { workspaceIndex, conversationIndex } = await this.indexBuilder.rebuildIndexes(
        workspaceData,
        conversationData
      );

      // Write updated indexes
      await Promise.all([
        this.fileSystem.writeJSON('workspace-index.json', workspaceIndex),
        this.fileSystem.writeJSON('conversations-index.json', conversationIndex)
      ]);

      console.log('[Claudesidian] Search indexes rebuilt successfully');
      return { success: true };
    } catch (error) {
      console.error('[Claudesidian] Failed to rebuild indexes:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Check if settings cleanup is needed
   */
  async needsSettingsCleanup(): Promise<boolean> {
    try {
      const currentData = await this.plugin.loadData() || {};

      // Check if any obsolete settings exist
      const obsoleteChecks = [
        currentData.memory?.enabled !== undefined,
        currentData.memory?.embeddingsEnabled !== undefined,
        currentData.memory?.apiProvider !== undefined,
        currentData.memory?.providerSettings !== undefined,
        currentData.incompleteFiles !== undefined,
        currentData.fileEventQueue !== undefined,
        currentData.memory?.openaiApiKey !== undefined,
        currentData.memory?.embeddingModel !== undefined
      ];

      return obsoleteChecks.some(check => check);
    } catch (error) {
      console.error('[Claudesidian] Error checking if settings cleanup needed:', error);
      return false;
    }
  }

  /**
   * Clean up obsolete embedding and vector-related settings from plugin data
   */
  async cleanupObsoleteSettings(): Promise<{
    success: boolean;
    removedSettings: string[];
    error?: string;
  }> {
    const result = {
      success: false,
      removedSettings: [] as string[],
      error: undefined as string | undefined
    };

    try {
      // Load current plugin data
      const currentData = await this.plugin.loadData() || {};
      console.log('[Claudesidian] Loaded current plugin settings for cleanup');

      // Define obsolete settings to remove
      const obsoleteSettings = [
        'memory.enabled',
        // Embedding provider settings
        'memory.embeddingsEnabled',
        'memory.apiProvider',
        'memory.providerSettings',
        'memory.maxTokensPerMonth',
        'memory.apiRateLimitPerMinute',
        'memory.chunkStrategy',
        'memory.chunkSize',
        'memory.chunkOverlap',
        'memory.maxTokensPerChunk',
        'memory.embeddingStrategy',
        'memory.dbStoragePath',
        'memory.vectorStoreType',
        'memory.costPerThousandTokens',
        'memory.contextualEmbedding',
        'memory.autoCleanOrphaned',
        'memory.maxDbSize',
        'memory.pruningStrategy',
        'memory.defaultResultLimit',
        'memory.includeNeighbors',
        'memory.graphBoostFactor',
        'memory.backlinksEnabled',
        'memory.useFilters',
        'memory.defaultThreshold',
        'memory.semanticThreshold',
        'memory.batchSize',
        'memory.concurrentRequests',
        'memory.processingDelay',
        'memory.openaiApiKey',
        'memory.embeddingModel',
        'memory.dimensions',
        'memory.indexingSchedule',
        'memory.backlinksWeight',
        'memory.hasEverConfiguredEmbeddings',
        'memory.lastIndexedDate',
        'memory.monthlyBudget',
        // File processing state (old vector-based)
        'incompleteFiles',
        'fileEventQueue'
      ];

      // Remove obsolete settings
      const updatedData = { ...currentData };

      for (const settingPath of obsoleteSettings) {
        if (this.removeSetting(updatedData, settingPath)) {
          result.removedSettings.push(settingPath);
        }
      }

      // If memory object is now empty, remove it entirely
      if (updatedData.memory && Object.keys(updatedData.memory).length === 0) {
        delete updatedData.memory;
        result.removedSettings.push('memory (entire section)');
      }

      // Save the cleaned-up settings
      await this.plugin.saveData(updatedData);
      console.log('[Claudesidian] Saved cleaned plugin settings');

      result.success = true;

    } catch (error) {
      result.error = error instanceof Error ? error.message : 'Unknown error';
      console.error('[Claudesidian] Error during settings cleanup:', error);
    }

    return result;
  }

  /**
   * Helper method to remove a nested setting by dot notation path
   */
  private removeSetting(obj: any, path: string): boolean {
    const parts = path.split('.');
    let current = obj;

    // Navigate to the parent object
    for (let i = 0; i < parts.length - 1; i++) {
      if (current[parts[i]] === undefined) {
        return false; // Path doesn't exist
      }
      current = current[parts[i]];
    }

    // Remove the final property
    const finalKey = parts[parts.length - 1];
    if (current[finalKey] !== undefined) {
      delete current[finalKey];
      return true;
    }

    return false;
  }

  /**
   * Clear migration data for testing (development only)
   */
  async clearMigrationData(): Promise<void> {
    console.warn('[Claudesidian] DEVELOPMENT: Clearing migration data...');

    const files = ['workspace-data.json', 'conversations.json', 'workspace-index.json', 'conversations-index.json'];

    for (const filename of files) {
      try {
        const filePath = `${this.fileSystem.getDataPath()}/${filename}`;
        await this.plugin.app.vault.adapter.remove(filePath);
        console.log(`[Claudesidian] Removed: ${filename}`);
      } catch (error) {
        // File might not exist, which is fine
        console.log(`[Claudesidian] Could not remove ${filename} (probably doesn't exist)`);
      }
    }
  }
}
```

## services/migration/DataTransformer.ts

```typescript
// Location: src/services/migration/DataTransformer.ts
// Transforms ChromaDB collection data into the new nested JSON structure
// Used by: DataMigrationService to convert legacy data to simplified architecture
// Dependencies: ChromaDataLoader for source data, MigrationTypes for target structure

import { WorkspaceDataStructure, ConversationDataStructure } from '../../types/migration/MigrationTypes';
import { ChromaCollectionData } from './ChromaDataLoader';

export class DataTransformer {

  transformToNewStructure(chromaData: ChromaCollectionData): {
    workspaceData: WorkspaceDataStructure;
    conversationData: ConversationDataStructure;
  } {
    console.log('[Claudesidian] Starting transformation to new structure...');

    // Step 1: Transform conversations (simpler structure)
    const conversationData = this.transformConversations(chromaData.conversations);

    // Step 2: Transform workspace hierarchy (complex nested structure)
    const workspaceData = this.transformWorkspaceHierarchy(
      chromaData.workspaces,
      chromaData.sessions,
      chromaData.memoryTraces,
      chromaData.snapshots
    );

    console.log('[Claudesidian] Transformation completed');
    return { workspaceData, conversationData };
  }

  private transformConversations(conversations: any[]): ConversationDataStructure {
    console.log(`[Claudesidian] Transforming ${conversations.length} conversations...`);

    const result: ConversationDataStructure = {
      conversations: {},
      metadata: {
        version: '2.0.0',
        lastUpdated: Date.now(),
        totalConversations: conversations.length
      }
    };

    for (const conv of conversations) {
      try {
        const conversationData = conv.metadata?.conversation || {};
        const messages = conversationData.messages || [];

        result.conversations[conv.id] = {
          id: conv.id,
          title: conv.metadata?.title || conversationData.title || 'Untitled Conversation',
          created: conv.metadata?.created || conversationData.created || Date.now(),
          updated: conv.metadata?.updated || conversationData.updated || Date.now(),
          vault_name: conv.metadata?.vault_name || conversationData.vault_name || 'Unknown',
          message_count: conv.metadata?.message_count || conversationData.message_count || messages.length,
          messages: this.transformMessages(messages)
        };

        console.log(`[Claudesidian] Transformed conversation: ${conv.id}`);
      } catch (error) {
        console.error(`[Claudesidian] Error transforming conversation ${conv.id}:`, error);
      }
    }

    return result;
  }

  private transformMessages(messages: any[]): any[] {
    if (!Array.isArray(messages)) return [];

    return messages.map(msg => ({
      id: msg.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`,
      role: msg.role || 'user',
      content: msg.content || '',
      timestamp: msg.timestamp || Date.now(),
      toolName: msg.toolName,
      toolParams: msg.toolParams,
      toolResult: msg.toolResult
    }));
  }

  private transformWorkspaceHierarchy(
    workspaces: any[],
    sessions: any[],
    memoryTraces: any[],
    snapshots: any[]
  ): WorkspaceDataStructure {
    console.log(`[Claudesidian] Transforming workspace hierarchy...`);
    console.log(`  - ${workspaces.length} workspaces`);
    console.log(`  - ${sessions.length} sessions`);
    console.log(`  - ${memoryTraces.length} memory traces`);
    console.log(`  - ${snapshots.length} snapshots`);

    // Group data by relationships
    const sessionsByWorkspace = this.groupBy(sessions, s => s.metadata?.workspaceId || 'unknown');
    const tracesBySession = this.groupBy(memoryTraces, t => t.metadata?.sessionId || 'orphan');
    const statesBySession = this.groupBy(snapshots, s => s.metadata?.sessionId || 'orphan');

    const result: WorkspaceDataStructure = {
      workspaces: {},
      metadata: {
        version: '2.0.0',
        lastUpdated: Date.now(),
        migrationCompleted: Date.now()
      }
    };

    // Build workspace metadata lookup
    const workspaceMetadata = this.keyBy(workspaces, 'id');

    // Process each workspace
    for (const [workspaceId, workspaceSessions] of Object.entries(sessionsByWorkspace)) {
      const wsMetadata = workspaceMetadata[workspaceId];

      try {
        // Parse context if it's a string
        let context;
        if (wsMetadata?.metadata?.context) {
          context = this.parseJSONString(wsMetadata.metadata.context);
          // Apply workspace context migration to new structure
          context = this.migrateWorkspaceContext(context);
        }

        result.workspaces[workspaceId] = {
          id: workspaceId,
          name: wsMetadata?.metadata?.name || `Workspace ${workspaceId}`,
          description: wsMetadata?.metadata?.description || '',
          rootFolder: wsMetadata?.metadata?.rootFolder || '/',
          created: wsMetadata?.metadata?.created || Date.now(),
          lastAccessed: wsMetadata?.metadata?.lastAccessed || Date.now(),
          isActive: wsMetadata?.metadata?.isActive ?? true,
          context,
          sessions: {}
        };

        // Process sessions within workspace
        for (const session of workspaceSessions) {
          const sessionTraces = tracesBySession[session.id] || [];
          const sessionStates = statesBySession[session.id] || [];

          result.workspaces[workspaceId].sessions[session.id] = {
            id: session.id,
            name: session.metadata?.name,
            description: session.metadata?.description,
            startTime: session.metadata?.startTime || session.metadata?.created || Date.now(),
            endTime: session.metadata?.endTime,
            isActive: session.metadata?.isActive ?? true,
            memoryTraces: this.transformTraces(sessionTraces),
            states: this.transformStates(sessionStates)
          };

          console.log(`[Claudesidian] Processed session ${session.id}: ${sessionTraces.length} traces, ${sessionStates.length} states`);
        }

        console.log(`[Claudesidian] Processed workspace ${workspaceId}: ${workspaceSessions.length} sessions`);
      } catch (error) {
        console.error(`[Claudesidian] Error processing workspace ${workspaceId}:`, error);
      }
    }

    return result;
  }

  private transformTraces(traces: any[]): Record<string, any> {
    const result: Record<string, any> = {};

    for (const trace of traces) {
      try {
        // Extract content from either document.content or direct content
        const content = trace.document?.content || trace.content || trace.metadata?.content || '';

        result[trace.id] = {
          id: trace.id,
          timestamp: trace.metadata?.timestamp || trace.document?.timestamp || Date.now(),
          type: trace.metadata?.activityType || trace.metadata?.type || 'unknown',
          content: content,
          metadata: {
            tool: trace.metadata?.tool || trace.document?.tool,
            params: this.parseJSONString(trace.metadata?.params),
            result: this.parseJSONString(trace.metadata?.result),
            relatedFiles: this.parseJSONString(trace.metadata?.relatedFiles) || []
          }
        };
      } catch (error) {
        console.error(`[Claudesidian] Error transforming trace ${trace.id}:`, error);
      }
    }

    return result;
  }

  private transformStates(states: any[]): Record<string, any> {
    const result: Record<string, any> = {};

    for (const state of states) {
      try {
        result[state.id] = {
          id: state.id,
          name: state.metadata?.name || 'Unnamed State',
          created: state.metadata?.created || Date.now(),
          snapshot: state.metadata?.snapshot || state.snapshot || {}
        };
      } catch (error) {
        console.error(`[Claudesidian] Error transforming state ${state.id}:`, error);
      }
    }

    return result;
  }

  // Utility methods
  private groupBy<T>(array: T[], keyFn: (item: T) => string): Record<string, T[]> {
    return array.reduce((groups, item) => {
      const key = keyFn(item);
      if (!groups[key]) groups[key] = [];
      groups[key].push(item);
      return groups;
    }, {} as Record<string, T[]>);
  }

  private keyBy<T>(array: T[], key: string): Record<string, T> {
    return array.reduce((result, item) => {
      const keyValue = (item as any)[key];
      if (keyValue) result[keyValue] = item;
      return result;
    }, {} as Record<string, T>);
  }

  private parseJSONString(str: string | undefined): any {
    if (!str) return undefined;
    if (typeof str !== 'string') return str;

    try {
      return JSON.parse(str);
    } catch {
      return str;
    }
  }

  /**
   * Migrate workspace context from old structure to new structure
   * - Convert agents array to single dedicatedAgent
   * - Convert complex keyFiles structure to simple array
   * - Remove status field (replaced by active toggle)
   */
  private migrateWorkspaceContext(context: any): any {
    if (!context || typeof context !== 'object') {
      return context;
    }

    const migratedContext = { ...context };

    // Migrate agents array to dedicatedAgent
    if (context.agents && Array.isArray(context.agents) && context.agents.length > 0) {
      const firstAgent = context.agents[0];
      if (firstAgent && firstAgent.name) {
        // For migration, we'll use the agent name as both ID and name
        // This will be resolved properly when loading the workspace
        migratedContext.dedicatedAgent = {
          agentId: firstAgent.id || firstAgent.name, // Use ID if available, fallback to name
          agentName: firstAgent.name
        };

        console.log(`[DataTransformer] Migrated agent '${firstAgent.name}' to dedicatedAgent structure`);
      }

      // Remove the old agents array
      delete migratedContext.agents;
    }

    // Migrate keyFiles from complex categorized structure to simple array
    if (context.keyFiles && Array.isArray(context.keyFiles)) {
      const simpleKeyFiles: string[] = [];

      context.keyFiles.forEach((category: any) => {
        if (category.files && typeof category.files === 'object') {
          Object.values(category.files).forEach((filePath: any) => {
            if (typeof filePath === 'string') {
              simpleKeyFiles.push(filePath);
            }
          });
        }
      });

      migratedContext.keyFiles = simpleKeyFiles;
      console.log(`[DataTransformer] Migrated ${simpleKeyFiles.length} key files to simple array format`);
    }

    // Migrate preferences from array to string
    if (context.preferences && Array.isArray(context.preferences)) {
      const preferencesString = context.preferences
        .filter((pref: any) => typeof pref === 'string' && pref.trim()) // Only keep non-empty strings
        .join('. ') + (context.preferences.length > 0 ? '.' : ''); // Join with periods

      migratedContext.preferences = preferencesString;
      console.log(`[DataTransformer] Migrated ${context.preferences.length} preferences to string format`);
    }

    // Remove status field (replaced by workspace active toggle)
    if (context.status) {
      console.log(`[DataTransformer] Removed status field: '${context.status}' (replaced by active toggle)`);
      delete migratedContext.status;
    }

    return migratedContext;
  }
}
```

## services/migration/FileSystemService.ts

```typescript
// Location: src/services/migration/FileSystemService.ts
// File system utility for managing the new .data directory and JSON operations
// Used by: DataMigrationService, ChromaDataLoader, and all new services
// Dependencies: Obsidian Plugin API for file system operations

import { normalizePath, TFile } from 'obsidian';
import { Plugin } from 'obsidian';

export class FileSystemService {
  private plugin: Plugin;
  private dataPath: string;

  constructor(plugin: Plugin) {
    this.plugin = plugin;
    this.dataPath = normalizePath(`${plugin.manifest.dir}/.data`);
  }

  async ensureDataDirectory(): Promise<void> {
    try {
      await this.plugin.app.vault.adapter.mkdir(this.dataPath);
      console.log(`[Claudesidian] Created data directory: ${this.dataPath}`);
    } catch (error) {
      // Directory might already exist - this is fine
      console.log(`[Claudesidian] Data directory exists: ${this.dataPath}`);
    }
  }

  async writeJSON(filename: string, data: any): Promise<void> {
    const filePath = normalizePath(`${this.dataPath}/${filename}`);
    const jsonString = JSON.stringify(data, null, 2);
    await this.plugin.app.vault.adapter.write(filePath, jsonString);
    console.log(`[Claudesidian] Wrote JSON file: ${filename} (${jsonString.length} chars)`);
  }

  async readJSON(filename: string): Promise<any> {
    const filePath = normalizePath(`${this.dataPath}/${filename}`);
    try {
      const content = await this.plugin.app.vault.adapter.read(filePath);
      const data = JSON.parse(content);
      console.log(`[Claudesidian] Read JSON file: ${filename} (${content.length} chars)`);
      return data;
    } catch (error) {
      console.log(`[Claudesidian] Could not read JSON file: ${filename}`, error);
      return null;
    }
  }

  async fileExists(filename: string): Promise<boolean> {
    const filePath = normalizePath(`${this.dataPath}/${filename}`);
    try {
      return await this.plugin.app.vault.adapter.exists(filePath);
    } catch (error) {
      console.error(`[Claudesidian] Error checking file existence: ${filePath}`, error);
      return false;
    }
  }

  async readChromaCollection(collectionName: string): Promise<any> {
    const chromaPath = normalizePath(`${this.plugin.manifest.dir}/data/chroma-db/collections/${collectionName}/items.json`);
    try {
      const content = await this.plugin.app.vault.adapter.read(chromaPath);
      const data = JSON.parse(content);
      const items = data.items || [];
      console.log(`[Claudesidian] Read ChromaDB collection: ${collectionName} (${items.length} items)`);
      return items;
    } catch (error) {
      console.warn(`[Claudesidian] Could not read ChromaDB collection: ${collectionName}`, error);
      return [];
    }
  }

  getDataPath(): string {
    return this.dataPath;
  }

  getChromaPath(): string {
    return normalizePath(`${this.plugin.manifest.dir}/data/chroma-db`);
  }
}
```

## services/migration/SearchIndexBuilder.ts

```typescript
// Location: src/services/migration/SearchIndexBuilder.ts
// Builds keyword-based search indexes for the new JSON data structure
// Used by: DataMigrationService to create searchable indexes for workspaces and conversations
// Dependencies: MigrationTypes for data structure definitions

import { WorkspaceDataStructure, ConversationDataStructure, WorkspaceSearchIndex, ConversationSearchIndex } from '../../types/migration/MigrationTypes';

export class SearchIndexBuilder {

  buildWorkspaceIndex(data: WorkspaceDataStructure): WorkspaceSearchIndex {
    console.log('[Claudesidian] Building workspace search index...');

    const index: WorkspaceSearchIndex = {
      byName: {},
      byDescription: {},
      byFolder: {},
      sessionsByWorkspace: {},
      sessionsByName: {},
      tracesByTool: {},
      tracesByType: {},
      lastUpdated: Date.now()
    };

    let totalWorkspaces = 0;
    let totalSessions = 0;
    let totalTraces = 0;

    for (const [workspaceId, workspace] of Object.entries(data.workspaces)) {
      totalWorkspaces++;

      // Index workspace by name
      this.addToIndex(index.byName, workspace.name, workspaceId);

      // Index workspace by description
      if (workspace.description) {
        this.addToIndex(index.byDescription, workspace.description, workspaceId);
      }

      // Index workspace by folder
      index.byFolder[workspace.rootFolder] = workspaceId;

      // Index sessions by workspace
      const sessionIds = Object.keys(workspace.sessions);
      index.sessionsByWorkspace[workspaceId] = sessionIds;

      // Index sessions and traces
      for (const [sessionId, session] of Object.entries(workspace.sessions)) {
        totalSessions++;

        // Index session by name
        if (session.name) {
          this.addToIndex(index.sessionsByName, session.name, sessionId);
        }

        // Index session by description
        if (session.description) {
          this.addToIndex(index.sessionsByName, session.description, sessionId);
        }

        // Index memory traces
        for (const trace of Object.values(session.memoryTraces)) {
          totalTraces++;

          if (trace.metadata?.tool) {
            this.addToIndex(index.tracesByTool, trace.metadata.tool, trace.id);
          }
          this.addToIndex(index.tracesByType, trace.type, trace.id);

          // Index trace content for text search
          if (trace.content) {
            this.addToIndex(index.tracesByType, trace.content, trace.id);
          }
        }
      }
    }

    console.log(`[Claudesidian] Workspace index built: ${totalWorkspaces} workspaces, ${totalSessions} sessions, ${totalTraces} traces`);
    return index;
  }

  buildConversationIndex(data: ConversationDataStructure): ConversationSearchIndex {
    console.log('[Claudesidian] Building conversation search index...');

    const index: ConversationSearchIndex = {
      byTitle: {},
      byContent: {},
      byVault: {},
      byDateRange: [],
      lastUpdated: Date.now()
    };

    // Build date range buckets (monthly)
    const dateRanges = this.createDateRangeBuckets();

    let totalConversations = 0;
    let totalMessages = 0;

    for (const [convId, conversation] of Object.entries(data.conversations)) {
      totalConversations++;

      // Index by title
      this.addToIndex(index.byTitle, conversation.title, convId);

      // Index by vault
      this.addToIndex(index.byVault, conversation.vault_name, convId);

      // Index by message content
      for (const message of conversation.messages) {
        totalMessages++;

        // Index message content
        if (message.content) {
          this.addToIndex(index.byContent, message.content, convId);
        }

        // Index tool-related content
        if (message.toolName) {
          this.addToIndex(index.byContent, message.toolName, convId);
        }
      }

      // Add to date range bucket
      this.addToDateRangeBucket(dateRanges, conversation.created, convId);
    }

    index.byDateRange = dateRanges;

    console.log(`[Claudesidian] Conversation index built: ${totalConversations} conversations, ${totalMessages} messages`);
    return index;
  }

  /**
   * Rebuild indexes for existing data files
   */
  async rebuildIndexes(
    workspaceData: WorkspaceDataStructure,
    conversationData: ConversationDataStructure
  ): Promise<{
    workspaceIndex: WorkspaceSearchIndex;
    conversationIndex: ConversationSearchIndex;
  }> {
    console.log('[Claudesidian] Rebuilding search indexes...');

    const workspaceIndex = this.buildWorkspaceIndex(workspaceData);
    const conversationIndex = this.buildConversationIndex(conversationData);

    console.log('[Claudesidian] Index rebuild completed');

    return {
      workspaceIndex,
      conversationIndex
    };
  }

  private addToIndex(index: Record<string, string[]>, text: string, id: string): void {
    if (!text || typeof text !== 'string') return;

    // Split text into words and clean them
    const words = text.toLowerCase()
      .replace(/[^\w\s]/g, ' ') // Replace punctuation with spaces
      .split(/\s+/)
      .filter(word => word.length > 2); // Only words longer than 2 characters

    for (const word of words) {
      if (!index[word]) index[word] = [];
      if (!index[word].includes(id)) {
        index[word].push(id);
      }
    }
  }

  private createDateRangeBuckets(): Array<{start: number, end: number, conversationIds: string[]}> {
    const buckets = [];
    const now = Date.now();
    const oneMonth = 30 * 24 * 60 * 60 * 1000;

    // Create 12 monthly buckets going back in time
    for (let i = 0; i < 12; i++) {
      const end = now - (i * oneMonth);
      const start = end - oneMonth;
      buckets.push({
        start,
        end,
        conversationIds: []
      });
    }

    return buckets;
  }

  private addToDateRangeBucket(buckets: any[], timestamp: number, id: string): void {
    for (const bucket of buckets) {
      if (timestamp >= bucket.start && timestamp < bucket.end) {
        bucket.conversationIds.push(id);
        break;
      }
    }
  }

  /**
   * Search utilities for using the built indexes
   */
  searchWorkspaces(index: WorkspaceSearchIndex, query: string): {
    workspaceIds: string[];
    sessionIds: string[];
    traceIds: string[];
  } {
    const words = query.toLowerCase().split(/\s+/).filter(word => word.length > 2);
    const workspaceIds = new Set<string>();
    const sessionIds = new Set<string>();
    const traceIds = new Set<string>();

    for (const word of words) {
      // Search workspace names and descriptions
      if (index.byName[word]) {
        index.byName[word].forEach(id => workspaceIds.add(id));
      }
      if (index.byDescription[word]) {
        index.byDescription[word].forEach(id => workspaceIds.add(id));
      }

      // Search session names
      if (index.sessionsByName[word]) {
        index.sessionsByName[word].forEach(id => sessionIds.add(id));
      }

      // Search traces by tool and type
      if (index.tracesByTool[word]) {
        index.tracesByTool[word].forEach(id => traceIds.add(id));
      }
      if (index.tracesByType[word]) {
        index.tracesByType[word].forEach(id => traceIds.add(id));
      }
    }

    return {
      workspaceIds: Array.from(workspaceIds),
      sessionIds: Array.from(sessionIds),
      traceIds: Array.from(traceIds)
    };
  }

  searchConversations(index: ConversationSearchIndex, query: string): {
    conversationIds: string[];
  } {
    const words = query.toLowerCase().split(/\s+/).filter(word => word.length > 2);
    const conversationIds = new Set<string>();

    for (const word of words) {
      // Search titles
      if (index.byTitle[word]) {
        index.byTitle[word].forEach(id => conversationIds.add(id));
      }

      // Search content
      if (index.byContent[word]) {
        index.byContent[word].forEach(id => conversationIds.add(id));
      }
    }

    return {
      conversationIds: Array.from(conversationIds)
    };
  }
}
```

## services/registry/ServiceRegistry.ts

```typescript
/**
 * ServiceRegistry - Singleton pattern for unified service instance management
 * 
 * This service registry implements the critical singleton enforcement system to eliminate
 * the vector store multiplicity crisis where 4 separate instances are created during startup.
 * 
 * Location: /src/services/registry/ServiceRegistry.ts
 * Usage: Coordinates with ServiceDescriptors and SimpleServiceManager to ensure single instance creation
 * Integration: Used by VectorStoreFactory and service managers to prevent duplicate service instantiation
 */

export interface ServiceOptions {
    timeout?: number;
    retryCount?: number;
    priority?: ServicePriority;
    dependencies?: string[];
    upgradeStrategy?: UpgradeStrategy;
}

export enum ServicePriority {
    CRITICAL = 'critical',
    HIGH = 'high',
    MEDIUM = 'medium',
    LOW = 'low'
}

export enum ServiceStatus {
    Creating = 'creating',
    Ready = 'ready',
    Failed = 'failed',
    Upgrading = 'upgrading'
}

export enum UpgradeStrategy {
    Replace = 'replace',
    Extend = 'extend',
    Merge = 'merge'
}

export interface ServiceInstance<T> {
    service: T;
    createdAt: number;
    dependencies: string[];
    status: ServiceStatus;
    metadata: ServiceMetadata;
    promise?: Promise<T>;
}

export interface ServiceMetadata {
    priority: ServicePriority;
    retryCount: number;
    lastError?: string;
    creationTime?: number;
    upgradeHistory?: string[];
}

/**
 * Global singleton service registry for preventing service instance duplication
 * Thread-safe singleton pattern with promise deduplication and error recovery
 */
export class ServiceRegistry {
    private static instance: ServiceRegistry | null = null;
    private services: Map<string, ServiceInstance<any>> = new Map();
    private creationPromises: Map<string, Promise<any>> = new Map();
    private lifecycleListeners: Map<string, Set<(instance: any) => void>> = new Map();
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private constructor() {
    }
    
    /**
     * Get the singleton ServiceRegistry instance
     */
    public static getInstance(): ServiceRegistry {
        if (ServiceRegistry.instance === null) {
            ServiceRegistry.instance = new ServiceRegistry();
        }
        return ServiceRegistry.instance;
    }
    
    /**
     * Get or create a service instance with atomic promise deduplication
     * This is the core method that prevents multiple service instance creation
     */
    public async getOrCreateService<T>(
        serviceName: string, 
        factory: () => Promise<T>,
        options: ServiceOptions = {}
    ): Promise<T> {
        // Fast path: Check if service is already ready
        const existingInstance = this.services.get(serviceName);
        if (existingInstance && existingInstance.status === ServiceStatus.Ready) {
            return existingInstance.service as T;
        }
        
        // Check if service is currently being created (promise deduplication)
        if (this.creationPromises.has(serviceName)) {
            return await this.creationPromises.get(serviceName) as T;
        }
        
        // Start new service creation
        const creationPromise = this.createServiceWithTimeout(serviceName, factory, options);
        this.creationPromises.set(serviceName, creationPromise);
        
        try {
            const service = await creationPromise;
            
            // Store successful service instance
            this.services.set(serviceName, {
                service,
                createdAt: Date.now(),
                dependencies: options.dependencies || [],
                status: ServiceStatus.Ready,
                metadata: {
                    priority: options.priority || ServicePriority.MEDIUM,
                    retryCount: 0,
                    creationTime: Date.now()
                }
            });
            
            // Notify lifecycle listeners
            this.notifyLifecycleListeners(serviceName, service);
            
            return service;
            
        } catch (error) {
            // Store failed service for debugging
            this.services.set(serviceName, {
                service: null,
                createdAt: Date.now(),
                dependencies: options.dependencies || [],
                status: ServiceStatus.Failed,
                metadata: {
                    priority: options.priority || ServicePriority.MEDIUM,
                    retryCount: 0,
                    lastError: error instanceof Error ? error.message : String(error)
                }
            });
            
            console.error(`[ServiceRegistry] ‚ùå Failed to create ${serviceName}:`, error);
            throw error;
        } finally {
            // Clean up creation promise
            this.creationPromises.delete(serviceName);
        }
    }
    
    /**
     * Create service with timeout protection
     */
    private async createServiceWithTimeout<T>(
        serviceName: string,
        factory: () => Promise<T>,
        options: ServiceOptions
    ): Promise<T> {
        const timeout = options.timeout || 30000; // 30 second default timeout
        const retryCount = options.retryCount || 1;
        
        for (let attempt = 1; attempt <= retryCount; attempt++) {
            try {
                const startTime = Date.now();
                
                // Create timeout promise
                const timeoutPromise = new Promise<never>((_, reject) => {
                    setTimeout(() => {
                        reject(new Error(`Service ${serviceName} creation timed out after ${timeout}ms`));
                    }, timeout);
                });
                
                // Race between service creation and timeout
                const service = await Promise.race([
                    factory(),
                    timeoutPromise
                ]);
                
                return service;
                
            } catch (error) {
                if (attempt < retryCount) {
                    const delay = 1000 * attempt; // Exponential backoff
                    console.warn(`[ServiceRegistry] ${serviceName} creation attempt ${attempt} failed, retrying in ${delay}ms:`, error);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    throw error;
                }
            }
        }
        
        throw new Error(`Service ${serviceName} creation failed after ${retryCount} attempts`);
    }
    
    /**
     * Check if a service exists in the registry
     */
    public hasService(serviceName: string): boolean {
        return this.services.has(serviceName);
    }
    
    /**
     * Get a service if it exists and is ready
     */
    public getService<T>(serviceName: string): T | null {
        const instance = this.services.get(serviceName);
        if (instance && instance.status === ServiceStatus.Ready) {
            return instance.service as T;
        }
        return null;
    }
    
    /**
     * Get service instance status
     */
    public getServiceStatus(serviceName: string): ServiceStatus | null {
        const instance = this.services.get(serviceName);
        return instance ? instance.status : null;
    }
    
    /**
     * Upgrade a service instance with enhanced functionality
     */
    public async upgradeService<T>(
        serviceName: string, 
        enhancedService: T,
        strategy: UpgradeStrategy = UpgradeStrategy.Replace
    ): Promise<void> {
        const existingInstance = this.services.get(serviceName);
        if (!existingInstance) {
            throw new Error(`Cannot upgrade non-existent service: ${serviceName}`);
        }
        
        
        // Mark as upgrading
        existingInstance.status = ServiceStatus.Upgrading;
        
        try {
            let finalService: T;
            
            switch (strategy) {
                case UpgradeStrategy.Replace:
                    finalService = enhancedService;
                    break;
                    
                case UpgradeStrategy.Extend:
                    // Merge properties if possible
                    if (typeof existingInstance.service === 'object' && typeof enhancedService === 'object') {
                        finalService = { ...existingInstance.service, ...enhancedService } as T;
                    } else {
                        finalService = enhancedService;
                    }
                    break;
                    
                case UpgradeStrategy.Merge:
                    // Custom merge logic (service-specific)
                    if (existingInstance.service && typeof existingInstance.service.upgrade === 'function') {
                        await existingInstance.service.upgrade(enhancedService);
                        finalService = existingInstance.service as T;
                    } else {
                        finalService = enhancedService;
                    }
                    break;
                    
                default:
                    finalService = enhancedService;
            }
            
            // Update instance
            existingInstance.service = finalService;
            existingInstance.status = ServiceStatus.Ready;
            existingInstance.metadata.upgradeHistory = existingInstance.metadata.upgradeHistory || [];
            existingInstance.metadata.upgradeHistory.push(`${strategy}:${Date.now()}`);
            
            // Notify listeners
            this.notifyLifecycleListeners(serviceName, finalService);
            
            
        } catch (error) {
            existingInstance.status = ServiceStatus.Failed;
            existingInstance.metadata.lastError = error instanceof Error ? error.message : String(error);
            throw error;
        }
    }
    
    /**
     * Clear a service instance (for testing or recovery)
     */
    public clearService(serviceName: string): void {
        this.services.delete(serviceName);
        this.creationPromises.delete(serviceName);
        this.lifecycleListeners.delete(serviceName);
    }
    
    /**
     * Get dependency graph for diagnostics
     */
    public getInstanceGraph(): Record<string, any> {
        const graph: Record<string, any> = {};
        
        for (const [serviceName, instance] of this.services) {
            graph[serviceName] = {
                status: instance.status,
                dependencies: instance.dependencies,
                createdAt: instance.createdAt,
                priority: instance.metadata.priority,
                hasService: !!instance.service,
                lastError: instance.metadata.lastError
            };
        }
        
        return graph;
    }
    
    /**
     * Add lifecycle listener for service events
     */
    public addLifecycleListener(serviceName: string, listener: (instance: any) => void): void {
        if (!this.lifecycleListeners.has(serviceName)) {
            this.lifecycleListeners.set(serviceName, new Set());
        }
        this.lifecycleListeners.get(serviceName)!.add(listener);
    }
    
    /**
     * Remove lifecycle listener
     */
    public removeLifecycleListener(serviceName: string, listener: (instance: any) => void): void {
        const listeners = this.lifecycleListeners.get(serviceName);
        if (listeners) {
            listeners.delete(listener);
            if (listeners.size === 0) {
                this.lifecycleListeners.delete(serviceName);
            }
        }
    }
    
    /**
     * Notify lifecycle listeners of service events
     */
    private notifyLifecycleListeners(serviceName: string, instance: any): void {
        const listeners = this.lifecycleListeners.get(serviceName);
        if (listeners) {
            for (const listener of listeners) {
                try {
                    listener(instance);
                } catch (error) {
                    console.warn(`[ServiceRegistry] Lifecycle listener error for ${serviceName}:`, error);
                }
            }
        }
    }
    
    /**
     * Clean up all services (for testing or shutdown)
     */
    public cleanup(): void {
        this.services.clear();
        this.creationPromises.clear();
        this.lifecycleListeners.clear();
    }
    
    /**
     * Get registry statistics for monitoring
     */
    public getStatistics(): {
        totalServices: number;
        readyServices: number;
        failedServices: number;
        creatingServices: number;
        averageCreationTime: number;
    } {
        let readyCount = 0;
        let failedCount = 0;
        let creatingCount = 0;
        let totalCreationTime = 0;
        let servicesWithTime = 0;
        
        for (const instance of this.services.values()) {
            switch (instance.status) {
                case ServiceStatus.Ready:
                    readyCount++;
                    break;
                case ServiceStatus.Failed:
                    failedCount++;
                    break;
                case ServiceStatus.Creating:
                    creatingCount++;
                    break;
            }
            
            if (instance.metadata.creationTime) {
                totalCreationTime += instance.metadata.creationTime;
                servicesWithTime++;
            }
        }
        
        return {
            totalServices: this.services.size,
            readyServices: readyCount,
            failedServices: failedCount,
            creatingServices: creatingCount + this.creationPromises.size,
            averageCreationTime: servicesWithTime > 0 ? totalCreationTime / servicesWithTime : 0
        };
    }
}
```

## services/search/index.ts

```typescript
/**
 * Search Services
 * Location: src/services/search/index.ts
 *
 * This plugin uses Obsidian's native search functionality for all search operations.
 * No additional search services are required.
 */
```

## services/session/SessionService.ts

```typescript
// import { SimpleMemoryService } from '../memory/SimpleMemoryService';

export interface SessionData {
  id: string;
  workspaceId: string;
  name?: string;
  description?: string;
  metadata?: Record<string, any>;
}

/**
 * Simple session management service for immediate functionality.
 * Provides basic session tracking that can be upgraded to full functionality.
 */
export class SessionService {
  private sessions = new Map<string, SessionData>();
  
  constructor(private simpleMemoryService: any) { // SimpleMemoryService removed
  }
  
  /**
   * Create a new session
   */
  async createSession(sessionData: Omit<SessionData, 'id'> | SessionData): Promise<SessionData> {
    // Use provided ID if available, otherwise generate one
    const id = (sessionData as any).id || this.generateSessionId();
    const session: SessionData = {
      ...sessionData,
      id
    };
    
    
    this.sessions.set(id, session);
    await this.simpleMemoryService.storeSession(id, session);
    
    
    // Session created
    return session;
  }
  
  /**
   * Get session by ID
   */
  async getSession(sessionId: string): Promise<SessionData | null> {
    let session = this.sessions.get(sessionId);
    if (!session) {
      // Try to load from memory service
      session = await this.simpleMemoryService.getSession(sessionId);
      if (session) {
        this.sessions.set(sessionId, session);
      }
    }
    return session || null;
  }
  
  /**
   * Get all sessions
   */
  async getAllSessions(): Promise<SessionData[]> {
    const memorySessions = await this.simpleMemoryService.getAllSessions();
    // Merge with in-memory sessions
    for (const session of memorySessions) {
      if (!this.sessions.has(session.id)) {
        this.sessions.set(session.id, session);
      }
    }
    return Array.from(this.sessions.values());
  }
  
  /**
   * Update session data
   */
  async updateSession(session: SessionData): Promise<void> {
    this.sessions.set(session.id, session);
    await this.simpleMemoryService.storeSession(session.id, session);
  }
  
  /**
   * Delete a session
   */
  async deleteSession(sessionId: string): Promise<void> {
    this.sessions.delete(sessionId);
    // Note: SimpleMemoryService doesn't have delete methods, but we can clear from memory
  }
  
  /**
   * Generate a unique session ID
   */
  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  /**
   * Get session statistics
   */
  getStats(): { totalSessions: number } {
    const allSessions = Array.from(this.sessions.values());
    return {
      totalSessions: allSessions.length
    };
  }
}
```

## services/workspace/DefaultWorkspaceManager.ts

```typescript
/**
 * Default Workspace Manager
 * 
 * Manages the default workspace for tool calls that don't specify a workspace.
 * Ensures all tool calls have a valid workspace association for memory traces.
 */

import { App } from 'obsidian';

export interface DefaultWorkspaceConfig {
  id: string;
  name: string;
  rootFolder: string;
  description: string;
}

/**
 * Service to manage default workspace fallback for tool call associations
 */
export class DefaultWorkspaceManager {
  private defaultWorkspaceId = 'default';
  private defaultConfig: DefaultWorkspaceConfig;
  private initialized = false;

  constructor(private app: App) {
    this.defaultConfig = {
      id: this.defaultWorkspaceId,
      name: 'Default Workspace',
      rootFolder: '/',
      description: 'Default workspace for tool calls without explicit workspace context'
    };
  }

  /**
   * Initialize the default workspace manager
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;
    
    try {
      // Ensure default workspace exists
      await this.ensureDefaultWorkspace();
      this.initialized = true;
    } catch (error) {
      console.error('[DefaultWorkspaceManager] Failed to initialize:', error);
      // Continue with basic functionality even if workspace creation fails
      this.initialized = true;
    }
  }

  /**
   * Get the default workspace ID
   */
  getDefaultWorkspaceId(): string {
    return this.defaultWorkspaceId;
  }

  /**
   * Get the default workspace configuration
   */
  getDefaultWorkspaceConfig(): DefaultWorkspaceConfig {
    return { ...this.defaultConfig };
  }

  /**
   * Set a custom default workspace ID
   */
  setDefaultWorkspaceId(workspaceId: string): void {
    if (!workspaceId || workspaceId.trim() === '') {
      console.warn('[DefaultWorkspaceManager] Invalid workspace ID provided, keeping current default');
      return;
    }
    
    this.defaultWorkspaceId = workspaceId.trim();
    this.defaultConfig.id = this.defaultWorkspaceId;
    console.log('[DefaultWorkspaceManager] Default workspace updated to:', this.defaultWorkspaceId);
  }

  /**
   * Validate if a workspace ID exists, return default if not
   */
  async validateWorkspaceId(workspaceId: string | undefined): Promise<string> {
    // If no workspace ID provided, use default
    if (!workspaceId || workspaceId.trim() === '') {
      return this.defaultWorkspaceId;
    }

    // If it's already the default, return as-is
    if (workspaceId === this.defaultWorkspaceId) {
      return workspaceId;
    }

    // For now, return the provided workspace ID
    // In the future, we could validate against actual workspace storage
    return workspaceId.trim();
  }

  /**
   * Ensure the default workspace exists (basic implementation)
   */
  private async ensureDefaultWorkspace(): Promise<void> {
    try {
      // Check if root folder exists
      const rootFolder = this.app.vault.getAbstractFileByPath('/');
      if (!rootFolder) {
        console.warn('[DefaultWorkspaceManager] Root folder not accessible, using basic default workspace');
        return;
      }

      // Default workspace is conceptual - it represents the entire vault
      // No need to create physical folders or files for it
      
    } catch (error) {
      console.warn('[DefaultWorkspaceManager] Could not verify default workspace setup:', error);
      // Continue - default workspace is conceptual anyway
    }
  }

  /**
   * Check if this is the default workspace
   */
  isDefaultWorkspace(workspaceId: string): boolean {
    return workspaceId === this.defaultWorkspaceId;
  }

  /**
   * Get workspace info for tool call context
   */
  getWorkspaceContextInfo(workspaceId: string): { workspaceId: string; isDefault: boolean } {
    const validatedId = workspaceId || this.defaultWorkspaceId;
    return {
      workspaceId: validatedId,
      isDefault: this.isDefaultWorkspace(validatedId)
    };
  }
}
```

## settings.ts

```typescript
import { Plugin } from 'obsidian';
import { MCPSettings, DEFAULT_SETTINGS } from './types';

/**
 * Settings manager
 * Handles loading and saving plugin settings
 */
export class Settings {
    private plugin: Plugin;
    settings: MCPSettings;

    /**
     * Create a new settings manager
     * @param plugin Plugin instance
     */
    constructor(plugin: Plugin) {
        this.plugin = plugin;
        this.settings = DEFAULT_SETTINGS;
    }

    /**
     * Load settings from plugin data
     * Now synchronous with minimal validation for fast startup
     */
    async loadSettings() {
        try {
            const loadedData = await this.plugin.loadData();
            this.applyLoadedData(loadedData);
        } catch (error) {
            console.warn('[Settings] Failed to load settings, using defaults:', error);
            // Continue with defaults - plugin should still function
        }
    }
    
    /**
     * Apply loaded data with minimal validation for fast startup
     */
    private applyLoadedData(loadedData: any) {
        if (!loadedData) {
            return; // Use defaults
        }
        
        // Start with default settings (includes memory)
        this.settings = Object.assign({}, DEFAULT_SETTINGS);
        
        // Quick shallow merge for startup - detailed validation deferred
        try {
            const { memory, llmProviders, ...otherSettings } = loadedData;
            Object.assign(this.settings, otherSettings);
            
            // Ensure memory settings exist
            this.settings.memory = DEFAULT_SETTINGS.memory;

            // Basic LLM provider settings merge
            if (llmProviders && DEFAULT_SETTINGS.llmProviders) {
                this.settings.llmProviders = {
                    ...DEFAULT_SETTINGS.llmProviders,
                    ...llmProviders,
                    // Ensure providers exists with all default providers
                    providers: {
                        ...DEFAULT_SETTINGS.llmProviders.providers,
                        ...(llmProviders.providers || {})
                    }
                };
            }
        } catch (error) {
            console.warn('[Settings] Failed to merge settings, using defaults:', error);
            // Continue with defaults - plugin should still function
        }
    }

    /**
     * Save settings to plugin data
     */
    async saveSettings() {
        // Simple JSON-based storage
        await this.plugin.saveData(this.settings);
    }
}

// Re-export types and constants from types.ts
export type { MCPSettings };
export { DEFAULT_SETTINGS };
```

## types.ts

```typescript
/**
 * Legacy Types File - Refactored for Modular Organization
 * 
 * This file now re-exports all types from the organized modular structure.
 * The original types.ts file has been broken down into domain-specific modules:
 * 
 * - src/types/llm/: LLM provider types
 * - src/types/mcp/: MCP protocol and agent types
 * - src/types/search/: Search and memory query types
 * - src/types/plugin/: Plugin configuration types
 * - src/types/common/: Shared/common types
 * 
 * This approach follows SOLID principles:
 * - Single Responsibility: Each module handles one domain
 * - Open/Closed: Easy to extend without modifying existing code
 * - Interface Segregation: Clients depend only on what they use
 * - Dependency Inversion: Modules depend on abstractions
 */

// Re-export all types from the modular structure for backward compatibility
// Import from specific modules to avoid circular dependency

// LLM-related types
export type {
  ModelConfig,
  LLMProviderConfig,
  DefaultModelSettings,
  LLMProviderSettings
} from './types/llm';

export {
  DEFAULT_LLM_PROVIDER_SETTINGS
} from './types/llm';

// Memory management settings
export interface MemorySettings {
  // Workspace management interface
}

export const DEFAULT_MEMORY_SETTINGS: MemorySettings = {
};

// MCP protocol types
export type {
  ModeCall,
  CommonParameters,
  CommonResult,
  ModeCallResult,
  CustomPrompt,
  CustomPromptsSettings,
  ServerStatus,
  IMCPServer,
  MutualTLSOptions,
  ServerState
} from './types/mcp';

export {
  DEFAULT_CUSTOM_PROMPTS_SETTINGS
} from './types/mcp';

// Search and memory types - simplified for JSON-based storage
export type {
  MemoryQueryParams,
  MemoryQueryResult
} from './types/search';

// Plugin configuration types
export type {
  MCPSettings,
  ChatViewSettings
} from './types/plugin/PluginTypes';

// Common/shared types
export type {
  IVaultManager,
  NoteInfo,
  FolderInfo,
  WorkspaceSessionInfo,
  WorkspaceStateInfo,
  EventData,
  EventSubscriber
} from './types/common';

// Create default settings object
import { DEFAULT_CUSTOM_PROMPTS_SETTINGS } from './types/mcp';
import { DEFAULT_LLM_PROVIDER_SETTINGS } from './types/llm';
import { MCPSettings } from './types/plugin';
// DEFAULT_MEMORY_SETTINGS defined above in this file

/**
 * Default plugin settings
 */
export const DEFAULT_SETTINGS: MCPSettings = {
  enabledVault: true,
  configFilePath: undefined,
  memory: DEFAULT_MEMORY_SETTINGS,
  customPrompts: DEFAULT_CUSTOM_PROMPTS_SETTINGS,
  llmProviders: DEFAULT_LLM_PROVIDER_SETTINGS,
  chatView: {
    enabled: false,
    acknowledgedExperimental: false
  },
  lastUpdateVersion: undefined,
  lastUpdateDate: undefined,
  availableUpdateVersion: undefined,
  lastUpdateCheckDate: undefined
};

// Extend Obsidian App interface (module augmentation)
declare module 'obsidian' {
  interface App {
    commands: {
      listCommands(): Command[];
      executeCommandById(id: string): Promise<void>;
      commands: { [id: string]: Command };
    };
    plugins: {
      getPlugin(id: string): any;
      enablePlugin(id: string): Promise<void>;
      disablePlugin(id: string): Promise<void>;
      plugins: { [id: string]: any };
    };
  }
}
```

## types/agent/AgentTypes.ts

```typescript
/**
 * Location: src/types/agent/AgentTypes.ts
 * 
 * Type definitions for agent-related interfaces and data structures.
 * Used throughout the agent system for type safety and consistency.
 */

/**
 * Interface for agent-mode tool call parameters
 */
export interface AgentModeParams {
    agent: string;
    mode: string;
    params: Record<string, any>;
}

/**
 * Agent registration status information
 */
export interface AgentRegistrationStatus {
    /** Total number of registered agents */
    totalAgents: number;
    
    /** Number of successfully initialized agents */
    initializedAgents: number;
    
    /** Number of failed agent initializations */
    failedAgents: number;
    
    /** Agent initialization errors */
    initializationErrors: Record<string, Error>;
    
    /** Registration timestamp */
    registrationTime: Date;
    
    /** Time taken for registration in milliseconds */
    registrationDuration: number;
}

/**
 * Workspace context information for tool calls
 */
export interface WorkspaceContext {
    workspaceId: string;
    workspacePath?: string[];
    activeWorkspace?: boolean;
}

/**
 * Tool call request information for capture
 */
export interface ToolCallRequest {
    toolCallId: string;
    agent: string;
    mode: string;
    params: Record<string, any>;
    timestamp: number;
    source: 'mcp-client' | 'internal' | 'api';
    workspaceContext?: WorkspaceContext | null;
}

/**
 * Tool call response information for capture
 */
export interface ToolCallResponse {
    result: any;
    success: boolean;
    executionTime: number;
    timestamp: number;
    resultType?: string;
    resultSummary?: string;
    affectedResources?: string[];
    error?: {
        type: string;
        message: string;
        code?: string;
        stack?: string;
    };
}

/**
 * Agent factory function type
 */
export type AgentFactory = () => Promise<any> | any;

/**
 * Agent constructor type
 */
export type AgentConstructor = new (...args: any[]) => any;

/**
 * Agent configuration options
 */
export interface AgentConfig {
    enabled?: boolean;
    modes?: string[];
    settings?: Record<string, any>;
    dependencies?: string[];
}

/**
 * Validation result structure
 */
export interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings?: string[];
}
```

## types/chat/ChatTypes.ts

```typescript
/**
 * Chat Types - Minimal type definitions for native chatbot
 * Pure JSON-based chat
 */

export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  timestamp: number;
  conversationId: string;
  toolCalls?: ToolCall[];
  tokens?: number;
  alternatives?: ChatMessage[];
  activeAlternativeIndex?: number;
  isLoading?: boolean;
}

export interface ToolCall {
  id: string;
  type: string;
  name?: string;
  function: {
    name: string;
    arguments: string;
  };
  result?: any;
  success?: boolean;
  error?: string;
  parameters?: any;
  executionTime?: number;
}

export interface Conversation {
  id: string;
  title: string;
  messages: ChatMessage[];
  created: number;
  updated: number;
  metadata?: Record<string, any>;
}

export interface ChatContext {
  conversationId: string;
  currentMessage?: ChatMessage;
  previousMessages: ChatMessage[];
  tokens: {
    input: number;
    output: number;
    total: number;
  };
}

export interface MessageBranch {
  id: string;
  parentId?: string;
  message: ChatMessage;
  children: string[];
  isActive: boolean;
}

// Legacy type aliases for compatibility
export type ConversationData = Conversation;
export type ConversationMessage = ChatMessage;

export interface ConversationDocument {
  id: string;
  data: Conversation;
}

export interface ConversationSearchOptions {
  query?: string;
  limit?: number;
  offset?: number;
}

export interface ConversationSearchResult {
  conversations: Conversation[];
  total: number;
}

export interface CreateConversationParams {
  title?: string;
  initialMessage?: string;
}

export interface AddMessageParams {
  conversationId: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  toolCalls?: ToolCall[];
}

export interface UpdateConversationParams {
  id: string;
  title?: string;
  metadata?: Record<string, any>;
}

export function documentToConversationData(doc: ConversationDocument): Conversation {
  return doc.data;
}
```

## types/chat/index.ts

```typescript
/**
 * Chat Types Index - Export all chat-related type definitions
 */

export * from './ChatTypes';
```

## types/common/EventTypes.ts

```typescript
/**
 * Event System Types
 * Extracted from types.ts for better organization
 */

/**
 * Event data structure
 */
export interface EventData<T = any> {
  eventName: string;
  data: T;
}

/**
 * Event subscriber function type
 */
export interface EventSubscriber<T = any> {
  (data: T): void;
}
```

## types/common/VaultTypes.ts

```typescript
/**
 * Vault and File System Types
 * Extracted from types.ts for better organization
 */

import { App, TFile } from 'obsidian';

/**
 * Vault manager interface
 */
export interface IVaultManager {
  app: App;
  ensureFolder(path: string): Promise<void>;
  folderExists(path: string): Promise<boolean>;
  createFolder(path: string): Promise<void>;
  createNote(path: string, content: string, options?: any): Promise<TFile>;
  readNote(path: string): Promise<string>;
  updateNote(path: string, content: string, options?: any): Promise<void>;
  deleteNote(path: string): Promise<void>;
  getNoteMetadata(path: string): Promise<any>;
}

/**
 * Note information structure
 */
export interface NoteInfo {
  path: string;
  name: string;
  extension: string;
  created: number;
  modified: number;
  size: number;
}

/**
 * Folder information structure
 */
export interface FolderInfo {
  path: string;
  name: string;
  children: (FolderInfo | NoteInfo)[];
}

/**
 * Memory Manager Types
 */
export interface WorkspaceSessionInfo {
  id: string;
  name: string;
  workspaceId: string;
  startTime: number;
  endTime?: number;
  isActive: boolean;
  description?: string;
  toolCalls: number;
  tags?: string[];
}

export interface WorkspaceStateInfo {
  id: string;
  name: string;
  workspaceId: string;
  sessionId: string;
  timestamp: number;
  description?: string;
  context?: {
    files: string[];
    traceCount: number;
    tags: string[];
    summary?: string;
  };
}
```

## types/common/index.ts

```typescript
/**
 * Common types export barrel
 * Centralizes all common/shared type exports
 */

export type {
  IVaultManager,
  NoteInfo,
  FolderInfo,
  WorkspaceSessionInfo,
  WorkspaceStateInfo
} from './VaultTypes';

export type {
  EventData,
  EventSubscriber
} from './EventTypes';
```

## types/google-genai.d.ts

```typescript
/**
 * Type declarations for @google/genai module
 * This provides basic typing to resolve TypeScript compilation errors
 */

declare module '@google/genai' {
  export interface GenerativeModel {
    generateContent(prompt: string | any): Promise<any>;
    generateContentStream(prompt: string | any): AsyncIterable<any>;
  }

  export interface ModelsAPI {
    generateContent(request: any): Promise<any>;
    generateContentStream(request: any): AsyncIterable<any>;
  }

  export interface GoogleGenAI {
    getGenerativeModel(options: { model: string }): GenerativeModel;
    models: ModelsAPI;
  }

  export class GoogleGenAI {
    constructor(options: { apiKey: string });
    getGenerativeModel(options: { model: string }): GenerativeModel;
    models: ModelsAPI;
  }

  export const GoogleGenAI: {
    new (options: { apiKey: string }): GoogleGenAI;
  };

  // Export other commonly used types as any for now
  export const HarmCategory: any;
  export const HarmBlockThreshold: any;
  export const GenerativeModel: any;
}
```

## types/index.ts

```typescript
/**
 * Main types export barrel
 * Provides a clean interface for importing types throughout the application
 * Organized by domain for better maintainability
 */

// LLM-related types
export type {
  ModelConfig,
  LLMProviderConfig,
  DefaultModelSettings,
  LLMProviderSettings
} from './llm';

export {
  DEFAULT_LLM_PROVIDER_SETTINGS
} from './llm';

// Simple memory management now uses JSON-based storage
export interface MemorySettings {
  enabled: boolean;
  dataPath?: string;
}

export const DEFAULT_MEMORY_SETTINGS: MemorySettings = {
  enabled: true,
  dataPath: '.data'
};

// MCP protocol types
export type {
  ModeCall,
  CommonParameters,
  CommonResult,
  ModeCallResult,
  CustomPrompt,
  CustomPromptsSettings,
  ServerStatus,
  IMCPServer,
  MutualTLSOptions,
  ServerState
} from './mcp';

export {
  DEFAULT_CUSTOM_PROMPTS_SETTINGS
} from './mcp';

// Search and memory types - simplified for JSON-based storage
export type {
  MemoryQueryParams,
  MemoryQueryResult
} from './search';

// Plugin configuration types
export type {
  MCPSettings
} from './plugin';

// Common/shared types
export type {
  IVaultManager,
  NoteInfo,
  FolderInfo,
  WorkspaceSessionInfo,
  WorkspaceStateInfo,
  EventData,
  EventSubscriber
} from './common';

// Chat types
export type {
  ConversationData,
  ConversationMessage,
  ToolCall,
  ConversationDocument,
  ConversationSearchOptions,
  ConversationSearchResult,
  CreateConversationParams,
  AddMessageParams,
  UpdateConversationParams
} from './chat/ChatTypes';

// Create default settings object
import { DEFAULT_CUSTOM_PROMPTS_SETTINGS } from './mcp';
import { DEFAULT_LLM_PROVIDER_SETTINGS } from './llm';
import { MCPSettings } from './plugin';
// DEFAULT_MEMORY_SETTINGS defined above in this file

/**
 * Default plugin settings
 */
export const DEFAULT_SETTINGS: MCPSettings = {
  enabledVault: true,
  configFilePath: undefined,
  memory: DEFAULT_MEMORY_SETTINGS,
  customPrompts: DEFAULT_CUSTOM_PROMPTS_SETTINGS,
  llmProviders: DEFAULT_LLM_PROVIDER_SETTINGS,
  lastUpdateVersion: undefined,
  lastUpdateDate: undefined,
  availableUpdateVersion: undefined,
  lastUpdateCheckDate: undefined
};

// Extend Obsidian App interface (module augmentation)
declare module 'obsidian' {
  interface App {
    commands: {
      listCommands(): Command[];
      executeCommandById(id: string): Promise<void>;
      commands: { [id: string]: Command };
    };
    plugins: {
      getPlugin(id: string): any;
      enablePlugin(id: string): Promise<void>;
      disablePlugin(id: string): Promise<void>;
      plugins: { [id: string]: any };
    };
  }
}
```

## types/llm/ProviderTypes.ts

```typescript
/**
 * LLM Provider Configuration Types
 * Extracted from types.ts for better organization and maintainability
 */

/**
 * Model configuration with enabled status and optional description
 */
export interface ModelConfig {
  enabled: boolean; // Primary field for controlling model visibility
  description?: string; // Optional user-defined description (for backwards compatibility)
}

/**
 * LLM provider configuration
 */
export interface LLMProviderConfig {
  apiKey: string;
  userDescription?: string;
  enabled: boolean;
  models?: { [modelId: string]: ModelConfig }; // Model-specific configurations
}

/**
 * Default model selection settings
 */
export interface DefaultModelSettings {
  provider: string;
  model: string;
}

/**
 * LLM provider settings
 */
export interface LLMProviderSettings {
  providers: {
    [providerId: string]: LLMProviderConfig;
  };
  defaultModel: DefaultModelSettings;
  monthlyBudget?: number; // Monthly budget in USD for LLM usage
}

/**
 * Default LLM provider settings
 */
export const DEFAULT_LLM_PROVIDER_SETTINGS: LLMProviderSettings = {
  providers: {
    openai: {
      apiKey: '',
      enabled: false
    },
    anthropic: {
      apiKey: '',
      enabled: false
    },
    google: {
      apiKey: '',
      enabled: false
    },
    mistral: {
      apiKey: '',
      enabled: false
    },
    groq: {
      apiKey: '',
      enabled: false
    },
    openrouter: {
      apiKey: '',
      enabled: false
    },
    requesty: {
      apiKey: '',
      enabled: false
    },
    perplexity: {
      apiKey: '',
      enabled: false
    },
    ollama: {
      apiKey: 'http://127.0.0.1:11434',
      enabled: false
    }
  },
  defaultModel: {
    provider: 'openai',
    model: 'gpt-4o'
  }
};
```

## types/llm/index.ts

```typescript
/**
 * LLM-related types export barrel
 * Centralizes all LLM provider type exports
 */

export type {
  ModelConfig,
  LLMProviderConfig,
  DefaultModelSettings,
  LLMProviderSettings
} from './ProviderTypes';

export {
  DEFAULT_LLM_PROVIDER_SETTINGS
} from './ProviderTypes';

// Memory settings now handled by simplified JSON-based memory system
```

## types/mcp/AgentTypes.ts

```typescript
/**
 * MCP Agent and Mode-related Types
 * Extracted from types.ts for better organization
 */

import { WorkspaceContext } from '../../utils/contextUtils';

/**
 * Mode call definition for chaining to another agent/mode
 */
export interface ModeCall {
  /**
   * Agent name to execute mode on
   */
  tool: string;
  
  /**
   * Mode to execute
   */
  mode: string;
  
  /**
   * Parameters to pass to the mode
   */
  parameters: any;
  
  /**
   * Whether to return results to original agent
   */
  returnHere?: boolean;
  
  /**
   * Whether this mode should be executed regardless of previous mode failures
   * Default is false - execution stops on first failure
   */
  continueOnFailure?: boolean;
  
  /**
   * Mode execution strategy
   * - serial: wait for previous modes to complete before executing (default)
   * - parallel: execute in parallel with other modes marked as parallel
   */
  strategy?: 'serial' | 'parallel';
  
  /**
   * Optional name to identify this mode call in the results
   */
  callName?: string;
}

/**
 * Common parameters structure for standardized agent modes
 * Provides session tracking and workspace context
 */
export interface CommonParameters {
  /**
   * Rich contextual information for this tool call including session management
   */
  context: {
    sessionId: string;
    workspaceId?: string;
    sessionDescription: string;
    sessionMemory: string;
    toolContext: string;
    primaryGoal: string;
    subgoal: string;
  };
  
  /**
   * Optional workspace context for scoping operations
   * Can be either an object with workspaceId or a JSON string representation
   */
  workspaceContext?: WorkspaceContext | string;
  
}

/**
 * Common result structure for standardized agent responses
 */
export interface CommonResult {
  /**
   * Whether the operation succeeded
   */
  success: boolean;
  
  /**
   * Error message if success is false
   */
  error?: string;
  
  /**
   * Operation-specific result data
   */
  data?: any;
  
  /**
   * Contextual information for this tool call including session management
   * Results can contain string context for backward compatibility
   */
  context?: {
    sessionId: string;
    workspaceId?: string;
    sessionDescription: string;
    sessionMemory: string;
    toolContext: string;
    primaryGoal: string;
    subgoal: string;
  } | string;
  
  /**
   * Workspace context that was used (for continuity)
   */
  workspaceContext?: WorkspaceContext;
  
}

/**
 * Mode call result for tracking execution outcomes
 */
export interface ModeCallResult extends CommonResult {
  /**
   * Agent name that executed the mode
   */
  tool?: string;
  
  /**
   * Mode that was executed
   */
  mode?: string;
  
  /**
   * Name of the mode call if specified
   */
  callName?: string;
  
  /**
   * Sequence number of this mode call
   */
  sequence?: number;
  
  /**
   * Timestamp when the mode call started
   */
  startTime?: number;
  
  /**
   * Timestamp when the mode call completed
   */
  endTime?: number;
  
  /**
   * Duration of the mode call in milliseconds
   */
  duration?: number;
}
```

## types/mcp/CustomPromptTypes.ts

```typescript
/**
 * Custom Prompt Types
 * Extracted from types.ts for better organization
 */

/**
 * Custom prompt definition for MCP
 */
export interface CustomPrompt {
  id: string;
  name: string;
  description: string;
  prompt: string;
  isEnabled: boolean;
}

/**
 * Custom prompts settings
 */
export interface CustomPromptsSettings {
  enabled: boolean;
  prompts: CustomPrompt[];
}

/**
 * Default custom prompts settings
 */
export const DEFAULT_CUSTOM_PROMPTS_SETTINGS: CustomPromptsSettings = {
  enabled: true,
  prompts: []
};
```

## types/mcp/ServerTypes.ts

```typescript
/**
 * MCP Server-related Types
 * Extracted from types.ts for better organization
 */

import { PluginManifest } from 'obsidian';
import { IAgent } from '../../agents/interfaces/IAgent';

/**
 * Server status enum
 */
export type ServerStatus = 'initializing' | 'starting' | 'running' | 'stopping' | 'stopped' | 'error';

/**
 * MCP Server interface
 */
export interface IMCPServer {
  start(): Promise<void>;
  stop(): Promise<void>;
  isRunning(): boolean;
  getStatus(): ServerStatus;
  registerAgent(agent: IAgent): void;
}

/**
 * Mutual TLS Options
 */
export interface MutualTLSOptions {
  certPath: string;
  keyPath: string;
  caPath?: string;
}

/**
 * Server State
 */
export interface ServerState {
  running: boolean;
  port: number;
  socketPath?: string;
  protocol: 'http' | 'unix';
  startTime?: Date;
  totalRequests: number;
  clientsConnected: number;
  lastError?: string;
  manifest: PluginManifest;
}
```

## types/mcp/ToolTypes.ts

```typescript
/**
 * Location: src/types/mcp/ToolTypes.ts
 * 
 * Type definitions for MCP tool-related interfaces and data structures.
 * Used throughout the MCP system for type safety and consistency.
 */

/**
 * MCP tool call request structure
 */
export interface MCPToolCallRequest {
    params: {
        name: string;
        arguments: Record<string, any>;
    };
    meta?: {
        requestId?: string;
        timestamp?: Date;
        source?: string;
    };
}

/**
 * MCP tool call response structure
 */
export interface MCPToolCallResponse {
    content: Array<{
        type: 'text' | 'resource';
        text?: string;
        resource?: any;
    }>;
    isError?: boolean;
    error?: {
        code: string;
        message: string;
        data?: any;
    };
}

/**
 * Tool descriptor for MCP tool registration
 */
export interface ToolDescriptor {
    /** Tool name in format 'agentName_modeName' */
    name: string;
    
    /** Tool description */
    description: string;
    
    /** Input parameter schema */
    inputSchema?: any;
    
    /** Output result schema */
    outputSchema?: any;
    
    /** Tool metadata */
    metadata?: ToolMetadata;
    
    /** Tool capabilities */
    capabilities?: ToolCapabilities;
}

/**
 * Tool metadata information
 */
export interface ToolMetadata {
    agent: string;
    mode: string;
    version?: string;
    category?: string;
    tags?: string[];
    deprecated?: boolean;
    experimental?: boolean;
}

/**
 * Tool capabilities definition
 */
export interface ToolCapabilities {
    requiresAuth?: boolean;
    requiresVectorStore?: boolean;
    requiresLLM?: boolean;
    supportsBatch?: boolean;
    supportsStreaming?: boolean;
    isIdempotent?: boolean;
}

/**
 * MCP connection status information
 */
export interface MCPConnectionStatus {
    /** Whether manager is initialized */
    isInitialized: boolean;
    
    /** Whether server is running */
    isServerRunning: boolean;
    
    /** Server creation timestamp */
    serverCreatedAt?: Date;
    
    /** Last error encountered */
    lastError?: {
        message: string;
        timestamp: Date;
    };
}

/**
 * Tool routing statistics
 */
export interface ToolRoutingStats {
    totalCalls: number;
    successfulCalls: number;
    failedCalls: number;
    averageExecutionTime: number;
    callsByAgent: Record<string, number>;
    callsByMode: Record<string, number>;
    errorsByType: Record<string, number>;
}

/**
 * Tool execution context
 */
export interface ToolExecutionContext {
    requestId?: string;
    sessionId?: string;
    userId?: string;
    timestamp: Date;
    source: 'mcp-client' | 'internal' | 'api';
    metadata?: Record<string, any>;
}
```

## types/mcp/index.ts

```typescript
/**
 * MCP-related types export barrel
 * Centralizes all MCP protocol type exports
 */

export type {
  ModeCall,
  CommonParameters,
  CommonResult,
  ModeCallResult
} from './AgentTypes';

export type {
  CustomPrompt,
  CustomPromptsSettings
} from './CustomPromptTypes';

export {
  DEFAULT_CUSTOM_PROMPTS_SETTINGS
} from './CustomPromptTypes';

export type {
  ServerStatus,
  IMCPServer,
  MutualTLSOptions,
  ServerState
} from './ServerTypes';
```

## types/memory/MemorySearchTypes.ts

```typescript
/**
 * Memory Search Types
 * 
 * Location: src/types/memory/MemorySearchTypes.ts
 * Purpose: Consolidated type definitions for memory search operations
 * Used by: MemorySearchProcessor, MemorySearchFilters, ResultFormatter, SearchMemoryMode
 */

import { CommonParameters } from '../mcp/AgentTypes';

// Core search parameters interface
export interface MemorySearchParameters extends CommonParameters {
  query: string;
  memoryTypes?: ('traces' | 'toolCalls' | 'sessions' | 'states' | 'workspaces')[];
  workspace?: string;
  dateRange?: DateRange;
  limit?: number;
  toolCallFilters?: ToolCallFilter;
  searchMethod?: 'semantic' | 'exact' | 'mixed';
  filterBySession?: boolean;
}

// Date range filter
export interface DateRange {
  start?: string;
  end?: string;
}

// Tool call specific filters
export interface ToolCallFilter {
  agent?: string;
  mode?: string;
  success?: boolean;
  minExecutionTime?: number;
  maxExecutionTime?: number;
}

// Search execution options for processor
export interface MemorySearchExecutionOptions {
  workspaceId?: string;
  sessionId?: string;
  limit?: number;
  toolCallFilters?: ToolCallFilter;
}

// Memory search context
export interface MemorySearchContext {
  params: MemorySearchParameters;
  timestamp: Date;
}

// Raw memory result from searches
export interface RawMemoryResult {
  trace: any; // MemoryTrace or ToolCallMemoryTrace
  similarity?: number;
}

// Processed memory search result
export interface MemorySearchResult {
  type: 'trace' | 'toolCall' | 'session' | 'state' | 'workspace';
  id: string;
  highlight: string;
  metadata: MemoryResultMetadata;
  context: SearchResultContext;
  score: number;
}

// Memory result metadata
export interface MemoryResultMetadata {
  created: string;
  updated?: string;
  sessionId?: string;
  workspaceId?: string;
  primaryGoal?: string;
  filesReferenced?: string[];
  toolUsed?: string;
  modeUsed?: string;
  type?: string;
  // Tool call specific metadata
  toolCallId?: string;
  agent?: string;
  mode?: string;
  executionTime?: number;
  success?: boolean;
  errorMessage?: string;
  affectedResources?: string[];
}

// Search result context
export interface SearchResultContext {
  before: string;
  match: string;
  after: string;
}

// Final search result response
export interface SearchMemoryModeResult {
  success: boolean;
  query: string;
  results: MemorySearchResult[];
  totalResults: number;
  error?: string;
}

// Filter options for filtering service
export interface MemoryFilterOptions {
  dateRange?: DateRange;
  toolCallFilters?: ToolCallFilter;
  sessionId?: string;
  workspaceId?: string;
  filterBySession?: boolean;
}

// Content filter options
export interface ContentFilterOptions {
  caseSensitive?: boolean;
  wholeWord?: boolean;
  regex?: boolean;
}

// Format options for formatter service
export interface FormatOptions {
  maxHighlightLength?: number;
  contextLength?: number;
  enhanceToolCallContext?: boolean;
}

// Formatted memory result
export interface FormattedMemoryResult {
  original: MemorySearchResult;
  formattedContent: string;
  preview: string;
  formattedTimestamp: string;
  title: string;
  subtitle?: string;
  formattedMetadata: Record<string, string>;
  highlights: SearchHighlight[];
  formatContext: FormatContext;
}

// Search highlight
export interface SearchHighlight {
  field: string;
  start: number;
  end: number;
  text: string;
  context?: string;
}

// Format context
export interface FormatContext {
  searchQuery: string;
  resultType: string;
  timestamp: Date;
}

// Memory sort options
export interface MemorySortOption {
  field: 'score' | 'timestamp' | 'relevance';
  direction: 'asc' | 'desc';
}

// Memory group options
export interface MemoryGroupOption {
  groupBy: 'type' | 'session' | 'workspace' | 'date';
  subGroupBy?: 'agent' | 'mode' | 'success';
}

// Grouped memory results
export interface GroupedMemoryResults {
  groups: MemoryResultGroup[];
  totalGroups: number;
  totalResults: number;
  groupedBy: MemoryGroupOption;
  groupStats: GroupStatistics;
}

// Memory result group
export interface MemoryResultGroup {
  key: string;
  displayName: string;
  results: MemorySearchResult[];
  count: number;
  totalScore: number;
  averageScore: number;
  metadata: Record<string, any>;
}

// Group statistics
export interface GroupStatistics {
  averageGroupSize: number;
  largestGroupSize: number;
  smallestGroupSize: number;
  scoreDistribution: Record<string, number>;
}

// Paginated memory results
export interface PaginatedMemoryResults {
  items: MemorySearchResult[];
  page: number;
  pageSize: number;
  totalItems: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}

// Pagination options
export interface PaginationOptions {
  page: number;
  pageSize: number;
  totalItems?: number;
}

// Memory result summary
export interface MemoryResultSummary {
  totalResults: number;
  averageScore: number;
  typeDistribution: Record<string, number>;
  dateRange: { start: Date; end: Date };
  executionTime: number;
}

// Highlight options
export interface HighlightOptions {
  maxHighlights?: number;
  highlightLength?: number;
  caseSensitive?: boolean;
  wholeWord?: boolean;
}

// Validation result
export interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

// Search options for different search types
export interface SearchOptions {
  includeTraces?: boolean;
  includeSnapshots?: boolean;
  includeMessages?: boolean;
  workspaceId?: string;
  sessionId?: string;
  limit?: number;
}

// Memory types enum
export enum MemoryType {
  TRACE = 'trace',
  TOOL_CALL = 'toolCall',
  SESSION = 'session',
  STATE = 'state',
  WORKSPACE = 'workspace'
}

// Search method enum
export enum SearchMethod {
  EXACT = 'exact',
  MIXED = 'mixed'
}


// Memory configuration
export interface MemoryProcessorConfiguration {
  defaultLimit: number;
  maxLimit: number;
  defaultSearchMethod: SearchMethod;
  enableSemanticSearch: boolean;
  enableExactSearch: boolean;
  timeoutMs: number;
}

// Filter configuration
export interface MemoryFilterConfiguration {
  enableDateFiltering: boolean;
  enableSessionFiltering: boolean;
  enableToolCallFiltering: boolean;
  defaultDateRange: DateRange | null;
  strictFiltering: boolean;
}

// Formatter configuration
export interface ResultFormatterConfiguration {
  maxHighlightLength: number;
  contextLength: number;
  enableToolCallEnhancement: boolean;
  dateFormat: string;
  timestampFormat: string;
}

// Processing options
export interface ProcessingOptions {
  enableFiltering: boolean;
  enableFormatting: boolean;
  enableGrouping: boolean;
  enableSorting: boolean;
  batchSize?: number;
}

// Error information
export interface ErrorInfo {
  timestamp: Date;
  message: string;
  operation: string;
}

// Time range
export interface TimeRange {
  start: Date;
  end: Date;
}

// Related memory reference
export interface RelatedMemory {
  id: string;
  type: MemoryType;
  relationshipType: 'parent' | 'child' | 'sibling' | 'reference';
  similarity?: number;
}

// Tool call information
export interface ToolCallInfo {
  id: string;
  name: string;
  agent: string;
  mode: string;
  executionTime?: number;
  success: boolean;
  input?: any;
  output?: any;
  error?: string;
}

// Execution status
export enum ExecutionStatus {
  SUCCESS = 'success',
  ERROR = 'error',
  TIMEOUT = 'timeout',
  CANCELLED = 'cancelled'
}
```

## types/memory/TraceTypes.ts

```typescript
/**
 * src/types/memory/TraceTypes.ts
 * 
 * Memory trace type definitions extracted from MemoryTraceService.ts
 * Contains interface definitions for memory traces, tool call traces, and search operations.
 * Used by MemoryTraceService, ToolCallTraceProcessor, and TraceSearchService.
 */

import { WorkspaceMemoryTrace } from '../../database/workspace-types';
// import type { PendingToolCallCapture } from '../../services/toolcall-capture/ToolCallCaptureService';
type PendingToolCallCapture = any;

/**
 * Search options for memory trace queries
 */
export interface MemoryTraceSearchOptions {
  workspaceId?: string;
  workspacePath?: string[];
  limit?: number;
  sessionId?: string;
}

/**
 * Activity trace data structure for tool interactions and user activities
 */
export interface ActivityTraceData {
  type: string;
  content: string;
  metadata: {
    tool: string;
    params: any;
    result: any;
    relatedFiles: string[];
  };
  sessionId?: string;
}

/**
 * Enhanced memory trace for tool call capture with complete JSON preservation.
 * Extends WorkspaceMemoryTrace with tool call specific fields.
 */
export interface ToolCallMemoryTrace extends WorkspaceMemoryTrace {
  // Tool call identification
  toolCallId: string;
  agent: string;
  mode: string;
  toolName: string;
  
  // Enhanced metadata with complete JSON preservation
  metadata: {
    // Tool call request data (complete JSON preservation)
    request: {
      originalParams: Record<string, any>;
      normalizedParams: Record<string, any>;
      workspaceContext?: {
        workspaceId: string;
        sessionId?: string;
        workspacePath?: string[];
      };
      source: 'mcp-client' | 'internal' | 'agent-trigger';
    };
    
    // Tool call response data (complete JSON preservation)
    response: {
      result: Record<string, any> | null;
      success: boolean;
      error?: {
        type: string;
        message: string;
        code?: string | number;
        stack?: string;
      };
      resultType?: string;
      resultSummary?: string;
      affectedResources?: string[];
    };
    
    // Legacy compatibility fields
    tool: string;
    params: any;
    result: any;
    relatedFiles: string[];
  };
  
  // Execution context
  executionContext: {
    timing: {
      startTimestamp: number;
      endTimestamp: number;
      executionTime: number;
    };
    environment: {
      pluginVersion: string;
      platform: string;
    };
    userContext: {
      sessionStart: number;
      sessionDuration: number;
      previousToolCalls: number;
    };
    performance: {
      importance: number;
      complexity: number;
      userEngagement: number;
    };
  };
  
  // Relationships
  relationships: {
    relatedFiles: string[];
    affectedResources: string[];
    sessionToolCalls: string[];
    workspaceContext: string[];
  };
  
  // Search optimization
  searchOptimization: {
    searchContent: {
      primary: string;
      keywords: string[];
      entities: string[];
    };
    categories: {
      functionalCategory: string;
      domainCategory: string;
      complexityCategory: string;
      impactCategory: string;
    };
    searchTags: string[];
    searchScoring: {
      recencyScore: number;
      frequencyScore: number;
      successScore: number;
      impactScore: number;
      userEngagementScore: number;
    };
    indexingHints: {
      shouldIndex: boolean;
      indexPriority: 'high' | 'medium' | 'low';
      cacheStrategy: 'session' | 'workspace' | 'global';
      searchFrequency: 'frequent' | 'occasional' | 'rare';
    };
  };
}

/**
 * Tool call performance metrics
 */
export interface ToolCallPerformanceMetrics {
  importance: number;
  complexity: number;
  userEngagement: number;
}

/**
 * Tool call relationships structure
 */
export interface ToolCallRelationships {
  relatedFiles: string[];
  affectedResources: string[];
  sessionToolCalls: string[];
  workspaceContext: string[];
}

/**
 * Search optimization data structure
 */
export interface ToolCallSearchOptimization {
  searchContent: {
    primary: string;
    keywords: string[];
    entities: string[];
  };
  categories: {
    functionalCategory: string;
    domainCategory: string;
    complexityCategory: string;
    impactCategory: string;
  };
  searchTags: string[];
  searchScoring: {
    recencyScore: number;
    frequencyScore: number;
    successScore: number;
    impactScore: number;
    userEngagementScore: number;
  };
  indexingHints: {
    shouldIndex: boolean;
    indexPriority: 'high' | 'medium' | 'low';
    cacheStrategy: 'session' | 'workspace' | 'global';
    searchFrequency: 'frequent' | 'occasional' | 'rare';
  };
}

/**
 * Search result with similarity score
 */
export interface MemoryTraceSearchResult {
  trace: WorkspaceMemoryTrace;
  similarity: number;
}

/**
 * Tool call processing context
 */
export interface ToolCallProcessingContext {
  request: any;
  response: any;
  sessionContext: any;
  shouldIndex: boolean;
  searchContent: string;
  relationships: ToolCallRelationships;
  performanceMetrics: ToolCallPerformanceMetrics;
  searchOptimization: ToolCallSearchOptimization;
}
```

## types/memory/index.ts

```typescript
/**
 * Memory Types Barrel Export
 * 
 * Location: src/types/memory/index.ts
 * Purpose: Centralizes all memory-related type exports
 */

export * from './MemorySearchTypes';
```

## types/migration/MigrationTypes.ts

```typescript
// Location: src/types/migration/MigrationTypes.ts
// Core type definitions for the simplified JSON-based data architecture
// Used by: DataMigrationService, WorkspaceService, MemoryService, and ConversationService
// Dependencies: Defines the target structure for migration from ChromaDB collections

import { WorkspaceContext } from '../../database/types/workspace/WorkspaceTypes';
import { WorkspaceStateSnapshot } from '../../database/types/session/SessionTypes';

export interface WorkspaceDataStructure {
  workspaces: {
    [workspaceId: string]: {
      // Core workspace info
      id: string;
      name: string;
      description?: string;
      rootFolder: string;
      created: number;
      lastAccessed: number;
      isActive?: boolean;
      context?: WorkspaceContext;

      // Nested sessions
      sessions: {
        [sessionId: string]: {
          id: string;
          name?: string;
          description?: string;
          startTime: number;
          endTime?: number;
          isActive: boolean;

          // Nested memory traces
          memoryTraces: {
            [traceId: string]: {
              id: string;
              timestamp: number;
              type: string;
              content: string;
              metadata?: {
                tool?: string;
                params?: any;
                result?: any;
                relatedFiles?: string[];
              };
            };
          };

          // Nested states
          states: {
            [stateId: string]: {
              id: string;
              name: string;
              created: number;
              snapshot: WorkspaceStateSnapshot;
            };
          };
        };
      };
    };
  };

  metadata: {
    version: string;
    lastUpdated: number;
    migrationCompleted?: number;
  };
}

export interface ConversationDataStructure {
  conversations: {
    [conversationId: string]: {
      id: string;
      title: string;
      created: number;
      updated: number;
      vault_name: string;
      message_count: number;

      messages: Array<{
        id: string;
        role: 'user' | 'assistant' | 'tool';
        content: string;
        timestamp: number;
        toolName?: string;
        toolParams?: any;
        toolResult?: any;
      }>;
    };
  };

  metadata: {
    version: string;
    lastUpdated: number;
    totalConversations: number;
  };
}

export interface WorkspaceSearchIndex {
  byName: Record<string, string[]>;
  byDescription: Record<string, string[]>;
  byFolder: Record<string, string>;
  sessionsByWorkspace: Record<string, string[]>;
  sessionsByName: Record<string, string[]>;
  tracesByTool: Record<string, string[]>;
  tracesByType: Record<string, string[]>;
  lastUpdated: number;
}

export interface ConversationSearchIndex {
  byTitle: Record<string, string[]>;
  byContent: Record<string, string[]>;
  byVault: Record<string, string[]>;
  byDateRange: Array<{
    start: number;
    end: number;
    conversationIds: string[];
  }>;
  lastUpdated: number;
}
```

## types/plugin/PluginTypes.ts

```typescript
/**
 * Plugin Configuration Types
 * Extracted from types.ts for better organization
 */

import { CustomPromptsSettings } from '../mcp/CustomPromptTypes';
import { LLMProviderSettings } from '../llm/ProviderTypes';

// Memory management settings
interface MemorySettings {
  // Workspace management interface
}

interface ProcessedFileState {
  filePath: string;
  lastModified: number;
  contentHash: string;
  processed: boolean;
}

/**
 * ChatView settings for experimental AI chat interface
 */
export interface ChatViewSettings {
  enabled: boolean;
  acknowledgedExperimental: boolean;
}

/**
 * Processed files data structure for file state management
 * Stores file processing state to prevent re-processing on startup
 */
export interface ProcessedFilesData {
  version: string;
  lastUpdated: number;
  files: Record<string, ProcessedFileState>;
}

/**
 * Plugin settings interface
 * Includes vault access toggle and version tracking
 */
export interface MCPSettings {
  enabledVault: boolean;
  configFilePath?: string;
  memory?: MemorySettings;
  customPrompts?: CustomPromptsSettings;
  llmProviders?: LLMProviderSettings;
  chatView?: ChatViewSettings;
  lastUpdateVersion?: string;
  lastUpdateDate?: string;
  availableUpdateVersion?: string;
  lastUpdateCheckDate?: string;
  processedFiles?: ProcessedFilesData;
}
```

## types/plugin/index.ts

```typescript
/**
 * Plugin-related types export barrel
 * Centralizes all plugin configuration type exports
 */

export type {
  MCPSettings
} from './PluginTypes';
```

## types/search/FuzzySearchTypes.ts

```typescript
/**
 * FuzzySearchTypes - Type definitions for fuzzy search functionality with typo tolerance and similarity matching
 * Location: src/types/search/FuzzySearchTypes.ts
 * Usage: Provides type safety for fuzzy search operations across the application
 */

export interface FuzzySearchResult {
  id: string;
  title: string;
  snippet: string;
  score: number;
  searchMethod: 'fuzzy';
  metadata: FuzzySearchMetadata;
  content?: string;
}

export interface FuzzySearchMetadata {
  filePath: string;
  fileId: string;
  timestamp: number;
  fuzzyMatches: FuzzyMatch[];
  editDistance: number;
  similarity: number;
  // Enhanced quality metadata
  qualityTier?: FuzzyQualityTier;
  confidenceLevel?: number;
  matchType?: string;
  qualityDescription?: string;
  matchCount?: number;
  searchTermCount?: number;
  matchRatio?: number;
  averageEditDistance?: number;
  exactMatches?: number;
  typoMatches?: number;
  phoneticMatches?: number;
  scoreMethod?: string;
}

export interface FuzzyMatch {
  original: string;
  matched: string;
  distance: number;
  similarity: number;
  matchType: FuzzyMatchType;
}

export interface FuzzyDocument {
  id: string;
  title: string;
  content: string;
  filePath: string;
  metadata: Record<string, any>;
}

export interface FuzzyMatchResult {
  score: number;
  matches: FuzzyMatch[];
  totalDistance: number;
}

export interface FuzzyQualityAssessment {
  tier: FuzzyQualityTier;
  confidence: number;
  matchType: string;
  description: string;
}

export interface FuzzySearchStats {
  totalDocuments: number;
  cachedStems: number;
  synonymMappings: number;
  scoreBasedRanking?: boolean;
}

export interface FuzzySearchOptions {
  limit?: number;
  threshold?: number;
  useScoreBasedRanking?: boolean;
  maxEditDistance?: number;
  minSimilarity?: number;
}

export interface FuzzyQualityDistribution {
  high: number;
  medium: number;
  low: number;
  minimal: number;
}

// Type enums
export type FuzzyMatchType = 'typo' | 'stem' | 'synonym' | 'phonetic';
export type FuzzyQualityTier = 'high' | 'medium' | 'low' | 'minimal';

// Constants for fuzzy search configuration
export const FUZZY_SEARCH_DEFAULTS = {
  LIMIT: 10,
  THRESHOLD: 0.6,
  MIN_WORD_LENGTH: 3,
  MAX_EDIT_DISTANCE_RATIO: 0.3,
  SNIPPET_MAX_LENGTH: 300,
  WINDOW_SIZE: 50,
  TOP_MATCHES_PER_TERM: 3,
  MIN_STEM_LENGTH: 3,
  SOUNDEX_LENGTH: 4,
  SCORE_THRESHOLDS: {
    HIGH_EXACT: 0.95,
    HIGH_TYPO: 0.8,
    MEDIUM: 0.6,
    LOW: 0.4
  },
  SIMILARITY_WEIGHTS: {
    EXACT: 1.0,
    STEM: 0.9,
    SYNONYM: 0.8,
    PHONETIC: 0.7,
    TYPO_MIN: 0.6
  }
} as const;

// Utility type for internal search operations
export interface FuzzySearchContext {
  searchTerms: string[];
  useThresholdFiltering: boolean;
  qualityDistribution?: FuzzyQualityDistribution;
}

// Type for synonym mappings
export type SynonymMappings = Record<string, string[]>;

// Type for stem cache
export type StemCache = Map<string, string>;

// Type for soundex character mappings
export type SoundexMapping = Record<string, string>;

// Type guards
export function isFuzzySearchResult(obj: any): obj is FuzzySearchResult {
  return obj && 
    typeof obj.id === 'string' && 
    typeof obj.title === 'string' && 
    typeof obj.snippet === 'string' && 
    typeof obj.score === 'number' && 
    obj.searchMethod === 'fuzzy' &&
    obj.metadata &&
    Array.isArray(obj.metadata.fuzzyMatches);
}

export function isFuzzyMatch(obj: any): obj is FuzzyMatch {
  return obj &&
    typeof obj.original === 'string' &&
    typeof obj.matched === 'string' &&
    typeof obj.distance === 'number' &&
    typeof obj.similarity === 'number' &&
    ['typo', 'stem', 'synonym', 'phonetic'].includes(obj.matchType);
}

export function isFuzzyDocument(obj: any): obj is FuzzyDocument {
  return obj &&
    typeof obj.id === 'string' &&
    typeof obj.title === 'string' &&
    typeof obj.content === 'string' &&
    typeof obj.filePath === 'string' &&
    obj.metadata &&
    typeof obj.metadata === 'object';
}
```

## types/search/SearchResults.ts

```typescript
/**
 * SearchResults.ts - Type definitions for search result interfaces
 * Location: src/types/search/SearchResults.ts
 * Purpose: Provides standardized interfaces for search results across all search services
 * Used by: HybridSearchService, SearchMetrics, ResultFusion, and QueryCoordinator
 */

export interface SearchResult {
  /** Unique result identifier */
  id: string;
  
  /** Result title */
  title: string;
  
  /** Content snippet or excerpt */
  snippet: string;
  
  /** Relevance score (0-1) */
  score: number;
  
  /** Search method that produced this result */
  searchMethod: 'semantic' | 'keyword' | 'fuzzy' | 'hybrid';
  
  /** Result metadata */
  metadata: SearchResultMetadata;
  
  /** Full content (optional) */
  content?: string;
  
  /** File path if applicable */
  filePath?: string;
}

export interface SearchResultMetadata {
  /** File path */
  filePath: string;
  
  /** File identifier */
  fileId: string;
  
  /** Result timestamp */
  timestamp: number;
  
  /** Content type */
  type?: string;
  
  /** Search method */
  searchMethod?: string;
  
  /** Quality tier classification */
  qualityTier?: 'high' | 'medium' | 'low' | 'minimal';
  
  /** Confidence level (0-1) */
  confidenceLevel?: number;
  
  /** Match type description */
  matchType?: string;
  
  /** Quality description */
  qualityDescription?: string;
  
  /** Score calculation method */
  scoreMethod?: string;
  
  /** Additional metadata */
  [key: string]: any;
}

export interface HybridSearchResult extends SearchResult {
  /** Always 'hybrid' for hybrid search results */
  searchMethod: 'hybrid';
  
  /** Original search methods that contributed to this result */
  originalMethods: string[];
  
  /** Enhanced hybrid-specific metadata */
  metadata: HybridSearchResultMetadata;
}

export interface HybridSearchResultMetadata extends SearchResultMetadata {
  /** Hybrid fusion score */
  hybridScore: number;
  
  /** Scores from individual search methods */
  methodScores: MethodScores;
  
  /** Content type boost applied */
  contentTypeBoost: number;
  
  /** Exact match boost applied */
  exactMatchBoost: number;
  
  /** Final ranking position */
  finalRank: number;
}

export interface MethodScores {
  semantic?: number;
  keyword?: number;
  fuzzy?: number;
}

export interface SearchResultSet {
  /** Search results */
  results: SearchResult[];
  
  /** Weight for fusion (0-1) */
  weight: number;
  
  /** Result set type identifier */
  type: string;
  
  /** Execution time in milliseconds */
  executionTime?: number;
  
  /** Search method */
  method: string;
  
  /** Additional metadata */
  metadata?: Record<string, any>;
}

export interface SearchOptions {
  /** Maximum number of results to return */
  limit?: number;
  
  /** Include full content in results */
  includeContent?: boolean;
  
  /** Force semantic search even if weights suggest otherwise */
  forceSemanticSearch?: boolean;
  
  /** Minimum keyword search threshold */
  keywordThreshold?: number;
  
  /** Minimum fuzzy search threshold */
  fuzzyThreshold?: number;
  
  /** Query type hint */
  queryType?: 'exact' | 'conceptual' | 'exploratory' | 'mixed';
  
  /** Search timeout in milliseconds */
  timeout?: number;
  
  /** Enable result caching */
  enableCaching?: boolean;
  
  /** Minimum score threshold for results */
  scoreThreshold?: number;
}

export interface CachedSearchResult {
  /** Cached search results */
  results: HybridSearchResult[];
  
  /** Cache timestamp */
  timestamp: number;
  
  /** Original query */
  query: string;
  
  /** Cache key */
  key: string;
  
  /** Cache hit count */
  hits?: number;
}

export interface SearchContext {
  /** Search session identifier */
  sessionId?: string;
  
  /** User preferences */
  preferences?: Record<string, any>;
  
  /** Search filters */
  filters?: Record<string, any>;
  
  /** Additional context data */
  metadata?: Record<string, any>;
}

export interface RerankItem {
  /** Item identifier */
  id: string;
  
  /** Item score */
  score: number;
  
  /** Search method */
  method: string;
  
  /** Original ranking position */
  rank?: number;
}

export interface FusionOptions {
  /** Fusion strategy to use */
  strategy?: 'rrf' | 'weighted' | 'simple';
  
  /** RRF k parameter */
  k?: number;
  
  /** Custom weights per result type */
  typeWeights?: Record<string, number>;
  
  /** Maximum results after fusion */
  maxResults?: number;
  
  /** Score threshold after fusion */
  scoreThreshold?: number;
}

export interface RankingStrategy {
  /** Ranking algorithm */
  algorithm: 'rrf' | 'weighted' | 'linear';
  
  /** Algorithm parameters */
  parameters: Record<string, any>;
}
```

## types/search/SearchTypes.ts

```typescript
/**
 * Search and Memory Query Types
 * Extracted from types.ts for better organization
 */

/**
 * Memory storage types (JSON-based storage)
 */

export interface MemoryQueryParams {
  query: string;         
  limit?: number;        
  threshold?: number;    
  filters?: {            
    tags?: string[];     
    paths?: string[];    
    properties?: Record<string, any>;
    dateRange?: {        
      start?: string;
      end?: string;
    }
  },
  graphOptions?: {
    useGraphBoost: boolean;
    boostFactor: number;
    includeNeighbors: boolean;
    maxDistance: number;
    seedNotes?: string[];
  }
}

export interface MemoryQueryResult {
  matches: Array<{
    content: string;
    filePath: string;
    lineStart: number;
    lineEnd: number;
    metadata: {
      frontmatter: Record<string, any>;
      tags: string[];
      links: {
        outgoing: Array<{
          displayText: string;
          targetPath: string;
        }>;
        incoming: Array<{
          sourcePath: string;
          displayText: string;
        }>;
      }
    }
  }>
}


```

## types/search/index.ts

```typescript
/**
 * Search Types
 * Provides type definitions for search operations using Obsidian's native search
 */

export type {
  MemoryQueryParams,
  MemoryQueryResult
} from './SearchTypes';

export * from './SearchResults';
```

## ui/chat/ChatView.old.ts.bak

```text
/**
 * ChatView - Main Obsidian sidebar view for native chatbot
 * 
 * Extends ItemView to integrate with Obsidian's workspace system.
 * Contains conversation list, message display, and input components.
 */

import { ItemView, WorkspaceLeaf } from 'obsidian';
import { ConversationList } from './components/ConversationList';
import { MessageDisplay } from './components/MessageDisplay';
import { ChatInput } from './components/ChatInput';
import { ModelSelector, ModelOption } from './components/ModelSelector';
import { AgentSelector, AgentOption } from './components/AgentSelector';
import { ContextProgressBar, ContextUsage } from './components/ContextProgressBar';
import { ChatService } from '../../services/chat/ChatService';
import { ConversationData } from '../../types/chat/ChatTypes';

export const CHAT_VIEW_TYPE = 'claudesidian-chat';

export class ChatView extends ItemView {
  private chatService: ChatService;
  private conversationList!: ConversationList;
  private messageDisplay!: MessageDisplay;
  private chatInput!: ChatInput;
  private modelSelector!: ModelSelector;
  private agentSelector!: AgentSelector;
  private contextProgressBar!: ContextProgressBar;
  
  private currentConversation: ConversationData | null = null;
  private isLoading = false;
  private sidebarVisible = false;
  
  // Model and agent state
  private selectedModel: ModelOption | null = null;
  private selectedAgent: AgentOption | null = null;
  private currentSystemPrompt: string | null = null;

  constructor(leaf: WorkspaceLeaf, chatService: ChatService) {
    super(leaf);
    this.chatService = chatService;
  }

  getViewType(): string {
    return CHAT_VIEW_TYPE;
  }

  getDisplayText(): string {
    return 'AI Chat';
  }

  getIcon(): string {
    return 'message-square';
  }

  async onOpen(): Promise<void> {
    console.log('[ChatView] Opening chat view');
    
    // Initialize the chat service if not already done
    if (!this.chatService) {
      console.error('[ChatView] ChatService not available');
      return;
    }

    // Initialize ChatService to load MCP tools
    try {
      await this.chatService.initialize();
      console.log('[ChatView] ChatService initialized successfully');
    } catch (error) {
      console.error('[ChatView] Failed to initialize ChatService:', error);
    }

    this.createChatInterface();
    await this.loadConversations();
  }

  async onClose(): Promise<void> {
    console.log('[ChatView] Closing chat view');
    this.cleanup();
  }

  /**
   * Create the main chat interface layout
   */
  private createChatInterface(): void {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass('chat-view-container');

    // Create main layout
    const chatLayout = container.createDiv('chat-layout');
    
    // Main chat area (always visible)
    const mainContainer = chatLayout.createDiv('chat-main');
    
    // Chat header with hamburger menu
    const chatHeader = mainContainer.createDiv('chat-header');
    
    // Hamburger menu button
    const hamburgerButton = chatHeader.createEl('button', { 
      cls: 'chat-hamburger-button'
    });
    hamburgerButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="18" y2="18"/></svg>';
    hamburgerButton.setAttribute('aria-label', 'Toggle conversations');
    hamburgerButton.addEventListener('click', () => this.toggleConversationList());
    
    // Chat title
    const chatTitle = chatHeader.createDiv('chat-title');
    chatTitle.textContent = 'AI Chat';
    
    const messageContainer = mainContainer.createDiv('message-display-container');
    
    // Model and Agent selectors above input (side by side)
    const selectorsContainer = mainContainer.createDiv('chat-selectors-container');
    const modelSelectorContainer = selectorsContainer.createDiv('selector-item');
    const agentSelectorContainer = selectorsContainer.createDiv('selector-item');
    
    const inputContainer = mainContainer.createDiv('chat-input-container');
    
    // Context progress bar at bottom
    const contextContainer = mainContainer.createDiv('chat-context-container');
    
    // Backdrop for closing sidebar on mobile
    const backdrop = chatLayout.createDiv('chat-backdrop');
    backdrop.addEventListener('click', () => this.toggleConversationList());
    
    // Sliding sidebar: Conversation list
    const sidebarContainer = chatLayout.createDiv('chat-sidebar');
    sidebarContainer.addClass('chat-sidebar-hidden'); // Start hidden
    
    const sidebarHeader = sidebarContainer.createDiv('chat-sidebar-header');
    sidebarHeader.createEl('h3', { text: 'Conversations' });
    
    const newChatButton = sidebarHeader.createEl('button', { 
      cls: 'chat-new-button',
      text: '+ New Chat'
    });
    newChatButton.addEventListener('click', () => this.createNewConversation());

    const conversationListContainer = sidebarContainer.createDiv('conversation-list-container');

    // Initialize components
    this.conversationList = new ConversationList(
      conversationListContainer,
      (conversation) => this.selectConversation(conversation),
      (conversationId) => this.deleteConversation(conversationId)
    );

    this.messageDisplay = new MessageDisplay(
      messageContainer,
      (messageId) => this.handleRetryMessage(messageId),
      (messageId, newContent) => this.handleEditMessage(messageId, newContent)
    );

    this.chatInput = new ChatInput(
      inputContainer,
      (message) => this.sendMessage(message),
      () => this.isLoading
    );

    // Initialize model selector
    this.modelSelector = new ModelSelector(
      modelSelectorContainer,
      (model) => this.handleModelChange(model),
      () => this.getAvailableModels()
    );

    // Initialize agent selector  
    this.agentSelector = new AgentSelector(
      agentSelectorContainer,
      (agent) => this.handleAgentChange(agent),
      () => this.getAvailableAgents()
    );

    // Initialize context progress bar
    this.contextProgressBar = new ContextProgressBar(
      contextContainer,
      () => this.getContextUsage()
    );

    // Show welcome state
    this.showWelcomeState();
  }

  /**
   * Load conversations from the chat service
   */
  private async loadConversations(): Promise<void> {
    try {
      const conversations = await this.chatService.listConversations({ limit: 50 });
      this.conversationList.setConversations(conversations);
      
      // Auto-select the most recent conversation
      if (conversations.length > 0) {
        await this.selectConversation(conversations[0]);
      }
    } catch (error) {
      console.error('[ChatView] Failed to load conversations:', error);
      this.showError('Failed to load conversations');
    }
  }

  /**
   * Select and display a conversation
   */
  private async selectConversation(conversation: ConversationData): Promise<void> {
    try {
      this.currentConversation = conversation;
      this.conversationList.setActiveConversation(conversation.id);
      
      // Load full conversation data
      const fullConversation = await this.chatService.getConversation(conversation.id);
      if (fullConversation) {
        this.messageDisplay.setConversation(fullConversation);
        this.showChatState();
        
        // Update context progress bar
        await this.updateContextProgress();
      }
    } catch (error) {
      console.error('[ChatView] Failed to select conversation:', error);
      this.showError('Failed to load conversation');
    }
  }

  /**
   * Create a new conversation
   */
  private async createNewConversation(): Promise<void> {
    // Prompt user for conversation title
    const title = await this.promptForConversationTitle();
    if (!title) return; // User cancelled
    
    try {
      const result = await this.chatService.createConversation(title);
      
      if (result.success && result.conversationId) {
        // Reload conversations and select the new one
        await this.loadConversations();
        const conversation = await this.chatService.getConversation(result.conversationId);
        if (conversation) {
          await this.selectConversation(conversation);
        }
      } else {
        this.showError(result.error || 'Failed to create conversation');
      }
    } catch (error) {
      console.error('[ChatView] Failed to create conversation:', error);
      this.showError('Failed to create conversation');
    }
  }

  /**
   * Send a message in the current conversation
   */
  private async sendMessage(message: string): Promise<void> {
    if (!this.currentConversation) {
      // Create new conversation with this message
      await this.createNewConversationWithMessage(message);
      return;
    }

    try {
      this.isLoading = true;
      this.chatInput.setLoading(true);

      // Send message via chat service with model and agent info
      // Don't add to display immediately - let the conversation reload handle it
      console.log('[ChatView] Sending message with model:', {
        provider: this.selectedModel?.providerId,
        model: this.selectedModel?.modelId,
        hasSystemPrompt: !!this.currentSystemPrompt
      });
      
      // 1. Add user message immediately and show it
      const userMessage = {
        id: `msg_${Date.now()}_user`,
        role: 'user' as const,
        content: message,
        timestamp: Date.now()
      };
      
      // Add user message to current conversation and display
      this.currentConversation.messages.push(userMessage);
      this.messageDisplay.setConversation(this.currentConversation);
      
      // 2. Create placeholder AI message with loading animation
      const aiMessageId = `msg_${Date.now()}_ai`;
      const placeholderAiMessage = {
        id: aiMessageId,
        role: 'assistant' as const,
        content: '',
        timestamp: Date.now(),
        isLoading: true
      };
      
      // Add placeholder AI message and show loading
      this.currentConversation.messages.push(placeholderAiMessage);
      this.messageDisplay.setConversation(this.currentConversation);
      this.showAILoadingState(aiMessageId);

      // 3. Stream AI response
      try {
        // First add the user message to repository
        await this.chatService.addMessage({
          conversationId: this.currentConversation.id,
          role: 'user',
          content: message
        });

        let finalAIMessageId = '';
        let streamedContent = '';

        // Stream the AI response
        for await (const chunk of this.chatService.generateResponseStreaming(
          this.currentConversation.id,
          message,
          this.currentConversation,
          {
            provider: this.selectedModel?.providerId,
            model: this.selectedModel?.modelId,
            systemPrompt: this.currentSystemPrompt || undefined,
            messageId: aiMessageId // Pass the placeholder messageId for UI consistency
          }
        )) {
          
          finalAIMessageId = chunk.messageId;
          
          // For token chunks, add to accumulated content
          if (chunk.chunk) {
            streamedContent += chunk.chunk;
          }

          // Update the placeholder message in our current conversation data
          const placeholderMessageIndex = this.currentConversation.messages.findIndex(msg => msg.id === aiMessageId);
          if (placeholderMessageIndex >= 0) {
            this.currentConversation.messages[placeholderMessageIndex] = {
              ...this.currentConversation.messages[placeholderMessageIndex],
              content: streamedContent,
              isLoading: !chunk.complete
            };
          }

          // Update the display with the current accumulated content (real-time streaming)
          if (this.messageDisplay) {
            this.messageDisplay.updateMessageContent(aiMessageId, streamedContent, !chunk.complete);
          } else {
            console.error(`[ChatView] MessageDisplay is null!`);
          }

          if (chunk.complete) {
            
            // Save the final AI message to database
            // Save AI response to database
            await this.chatService.addMessage({
              conversationId: this.currentConversation.id,
              role: 'assistant',
              content: streamedContent
            });
            // AI response saved successfully
            
            // Update the context progress bar
            await this.updateContextProgress();
            break;
          }
        }

      } catch (sendError) {
        console.error('[ChatView] Error during streaming:', sendError);
        this.showError('Failed to send message');
        this.removeLoadingMessage(aiMessageId);
        throw sendError; // Re-throw to be caught by outer try-catch
      }
    } catch (error) {
      console.error('[ChatView] Failed to send message:', error);
      this.showError('Failed to send message');
    } finally {
      this.isLoading = false;
      this.chatInput.setLoading(false);
    }
  }

  /**
   * Create new conversation with initial message
   */
  private async createNewConversationWithMessage(message: string): Promise<void> {
    const title = message.length > 50 ? message.substring(0, 47) + '...' : message;
    
    try {
      this.isLoading = true;
      this.chatInput.setLoading(true);

      const result = await this.chatService.createConversation(title, message, {
        provider: this.selectedModel?.providerId,
        model: this.selectedModel?.modelId,
        systemPrompt: this.currentSystemPrompt || undefined
      });
      
      if (result.success && result.conversationId) {
        // Reload conversations and select the new one
        await this.loadConversations();
        const conversation = await this.chatService.getConversation(result.conversationId);
        if (conversation) {
          await this.selectConversation(conversation);
        }
      } else {
        this.showError(result.error || 'Failed to create conversation');
      }
    } catch (error) {
      console.error('[ChatView] Failed to create conversation with message:', error);
      this.showError('Failed to create conversation');
    } finally {
      this.isLoading = false;
      this.chatInput.setLoading(false);
    }
  }

  /**
   * Delete a conversation
   */
  private async deleteConversation(conversationId: string): Promise<void> {
    try {
      const success = await this.chatService.deleteConversation(conversationId);
      
      if (success) {
        // If this was the current conversation, clear the display
        if (this.currentConversation?.id === conversationId) {
          this.currentConversation = null;
          this.showWelcomeState();
        }
        
        // Reload conversation list
        await this.loadConversations();
      } else {
        this.showError('Failed to delete conversation');
      }
    } catch (error) {
      console.error('[ChatView] Failed to delete conversation:', error);
      this.showError('Failed to delete conversation');
    }
  }

  /**
   * Handle retry message action
   */
  private async handleRetryMessage(messageId: string): Promise<void> {
    if (!this.currentConversation) return;
    
    const message = this.currentConversation.messages.find(msg => msg.id === messageId);
    if (!message) return;
    
    // For user messages, just resend the content
    if (message.role === 'user') {
      await this.sendMessage(message.content);
    }
    // For AI messages, get the previous user message and regenerate
    else if (message.role === 'assistant') {
      const messageIndex = this.currentConversation.messages.findIndex(msg => msg.id === messageId);
      if (messageIndex > 0) {
        const previousUserMessage = this.currentConversation.messages[messageIndex - 1];
        if (previousUserMessage.role === 'user') {
          // Remove the AI response and regenerate
          this.currentConversation.messages = this.currentConversation.messages.slice(0, messageIndex);
          await this.chatService.updateConversation(this.currentConversation);
          await this.sendMessage(previousUserMessage.content);
        }
      }
    }
  }

  /**
   * Handle edit message action
   */
  private async handleEditMessage(messageId: string, newContent: string): Promise<void> {
    if (!this.currentConversation) return;
    
    const messageIndex = this.currentConversation.messages.findIndex(msg => msg.id === messageId);
    if (messageIndex === -1) return;
    
    // Update the message content
    this.currentConversation.messages[messageIndex].content = newContent;
    
    // If this was a user message followed by AI responses, remove subsequent AI messages
    if (this.currentConversation.messages[messageIndex].role === 'user') {
      // Remove all messages after this one (they're now invalid)
      this.currentConversation.messages = this.currentConversation.messages.slice(0, messageIndex + 1);
    }
    
    // Update the conversation in storage
    await this.chatService.updateConversation(this.currentConversation);
    
    // Refresh the display
    this.messageDisplay.setConversation(this.currentConversation);
    
    // If this was a user message, automatically regenerate the response
    if (this.currentConversation.messages[messageIndex].role === 'user') {
      await this.sendMessage(newContent);
    }
  }

  /**
   * Show welcome state when no conversation is selected
   */
  private showWelcomeState(): void {
    this.messageDisplay.showWelcome();
    this.chatInput.setPlaceholder('Start a new conversation...');
  }

  /**
   * Show chat state when conversation is selected
   */
  private showChatState(): void {
    this.chatInput.setPlaceholder('Type your message...');
  }

  /**
   * Toggle conversation list visibility
   */
  private toggleConversationList(): void {
    const sidebar = this.containerEl.querySelector('.chat-sidebar');
    const backdrop = this.containerEl.querySelector('.chat-backdrop');
    if (!sidebar || !backdrop) return;
    
    this.sidebarVisible = !this.sidebarVisible;
    
    if (this.sidebarVisible) {
      sidebar.removeClass('chat-sidebar-hidden');
      sidebar.addClass('chat-sidebar-visible');
      backdrop.addClass('chat-backdrop-visible');
    } else {
      sidebar.removeClass('chat-sidebar-visible');
      sidebar.addClass('chat-sidebar-hidden');
      backdrop.removeClass('chat-backdrop-visible');
    }
  }

  /**
   * Show error message
   */
  private showError(message: string): void {
    // Create a temporary error display
    const container = this.containerEl.querySelector('.message-display-container');
    if (container) {
      const errorEl = container.createDiv('chat-error');
      errorEl.textContent = message;
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        errorEl.remove();
      }, 5000);
    }
  }

  /**
   * Prompt user for conversation title
   */
  private async promptForConversationTitle(): Promise<string | null> {
    return new Promise((resolve) => {
      // Create modal overlay
      const overlay = document.createElement('div');
      overlay.addClass('chat-modal-overlay');
      
      // Create modal dialog
      const modal = overlay.createDiv('chat-modal');
      
      // Modal header
      const header = modal.createDiv('chat-modal-header');
      header.createEl('h3', { text: 'New Conversation' });
      
      // Close button
      const closeBtn = header.createEl('button', { 
        cls: 'chat-modal-close',
        text: '√ó' 
      });
      
      // Modal content
      const content = modal.createDiv('chat-modal-content');
      content.createEl('p', { text: 'Enter a title for your new conversation:' });
      
      const input = content.createEl('input', {
        type: 'text',
        cls: 'chat-title-input',
        attr: { placeholder: 'e.g., "Help with React project"' }
      });
      
      // Modal actions
      const actions = modal.createDiv('chat-modal-actions');
      const cancelBtn = actions.createEl('button', { 
        text: 'Cancel',
        cls: 'chat-btn-secondary'
      });
      const createBtn = actions.createEl('button', { 
        text: 'Create Chat',
        cls: 'chat-btn-primary'
      });
      
      // Event handlers
      const cleanup = () => {
        overlay.remove();
      };
      
      const handleSubmit = () => {
        const title = input.value.trim();
        if (title) {
          cleanup();
          resolve(title);
        } else {
          input.focus();
          input.addClass('chat-input-error');
          setTimeout(() => input.removeClass('chat-input-error'), 2000);
        }
      };
      
      const handleCancel = () => {
        cleanup();
        resolve(null);
      };
      
      // Wire up events
      closeBtn.addEventListener('click', handleCancel);
      cancelBtn.addEventListener('click', handleCancel);
      createBtn.addEventListener('click', handleSubmit);
      
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleSubmit();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          handleCancel();
        }
      });
      
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          handleCancel();
        }
      });
      
      // Add to page and focus
      document.body.appendChild(overlay);
      input.focus();
      input.select();
    });
  }

  /**
   * Handle model selection change
   */
  private handleModelChange(model: ModelOption): void {
    this.selectedModel = model;
    console.log('[ChatView] Model changed:', model);
    
    // Update context progress bar when model changes
    if (this.contextProgressBar) {
      this.contextProgressBar.update();
    }
  }

  /**
   * Handle agent selection change
   */
  private handleAgentChange(agent: AgentOption | null): void {
    this.selectedAgent = agent;
    this.currentSystemPrompt = agent?.systemPrompt || null;
    
    console.log('[ChatView] Agent changed:', agent ? agent.name : 'No agent');
    if (agent) {
      console.log('[ChatView] System prompt:', this.currentSystemPrompt);
    }
  }

  /**
   * Get available models from validated providers
   */
  private async getAvailableModels(): Promise<ModelOption[]> {
    try {
      // Get plugin instance to access settings data
      const plugin = (this.app as any).plugins.plugins['claudesidian-mcp'];
      if (!plugin) {
        console.warn('[ChatView] Plugin not found for model loading');
        return [];
      }

      // Load plugin data directly
      const pluginData = await plugin.loadData();
      if (!pluginData?.llmProviders?.providers) {
        console.warn('[ChatView] No LLM providers found in plugin data');
        return [];
      }

      const models: ModelOption[] = [];
      const providers = pluginData.llmProviders.providers;
      
      // Import ModelRegistry to get actual model specs
      const { ModelRegistry } = await import('../../services/llm/adapters/ModelRegistry');
      
      // Iterate through enabled providers with valid API keys
      Object.entries(providers).forEach(([providerId, config]: [string, any]) => {
        // Only include providers that are enabled and have API keys
        if (!config.enabled || !config.apiKey || !config.apiKey.trim()) {
          console.log(`[ChatView] Skipping ${providerId} - not enabled or no API key`);
          return;
        }
        
        const providerName = this.getProviderDisplayName(providerId);
        
        // Get all available models for this provider from ModelRegistry
        const providerModels = ModelRegistry.getProviderModels(providerId);
        
        providerModels.forEach(modelSpec => {
          models.push({
            providerId,
            providerName,
            modelId: modelSpec.apiName,
            modelName: modelSpec.name,
            contextWindow: modelSpec.contextWindow
          });
        });
      });

      console.log('[ChatView] Found models:', models);
      return models;
    } catch (error) {
      console.error('[ChatView] Error loading models:', error);
      return [];
    }
  }

  /**
   * Get available agents from agent manager
   */
  private async getAvailableAgents(): Promise<AgentOption[]> {
    try {
      // Get plugin instance to access settings data
      const plugin = (this.app as any).plugins.plugins['claudesidian-mcp'];
      if (!plugin) {
        console.warn('[ChatView] Plugin not found for agent loading');
        return [];
      }

      // Load plugin data directly
      const pluginData = await plugin.loadData();
      const agentOptions: AgentOption[] = [];

      // Get custom prompts from plugin data - they are stored as an array, not object
      const customPrompts = pluginData?.customPrompts?.prompts || [];
      
      // Add custom prompt-based agents
      customPrompts.forEach((prompt: any) => {
        if (prompt.prompt && prompt.prompt.trim() && prompt.isEnabled !== false) {
          agentOptions.push({
            id: prompt.id,
            name: prompt.name || 'Unnamed Agent',
            description: prompt.description || 'Custom agent prompt',
            systemPrompt: prompt.prompt
          });
        }
      });

      console.log('[ChatView] Found agents:', agentOptions);
      return agentOptions;
    } catch (error) {
      console.error('[ChatView] Error loading agents:', error);
      return [];
    }
  }

  /**
   * Get current context usage
   */
  private async getContextUsage(): Promise<ContextUsage> {
    try {
      if (!this.selectedModel || !this.currentConversation) {
        return { used: 0, total: 0, percentage: 0 };
      }

      // Estimate token count for current conversation
      const totalTokens = this.estimateTokenCount(this.currentConversation);
      const contextWindow = this.selectedModel.contextWindow;
      const percentage = (totalTokens / contextWindow) * 100;

      return {
        used: totalTokens,
        total: contextWindow,
        percentage: Math.min(percentage, 100)
      };
    } catch (error) {
      console.error('[ChatView] Error calculating context usage:', error);
      return { used: 0, total: 0, percentage: 0 };
    }
  }

  /**
   * Estimate token count for a conversation
   */
  private estimateTokenCount(conversation: ConversationData): number {
    let totalTokens = 0;
    
    // Add system prompt tokens if agent is selected
    if (this.currentSystemPrompt) {
      totalTokens += this.estimateTextTokens(this.currentSystemPrompt);
    }
    
    // Add message tokens
    conversation.messages.forEach(message => {
      totalTokens += this.estimateTextTokens(message.content);
      
      // Add tokens for tool calls if present
      if (message.tool_calls) {
        message.tool_calls.forEach(toolCall => {
          if (toolCall.parameters) {
            totalTokens += this.estimateTextTokens(JSON.stringify(toolCall.parameters));
          }
          if (toolCall.result) {
            const resultText = typeof toolCall.result === 'string' 
              ? toolCall.result 
              : JSON.stringify(toolCall.result);
            totalTokens += this.estimateTextTokens(resultText);
          }
        });
      }
    });
    
    return totalTokens;
  }

  /**
   * Rough estimation of token count for text (4 chars ‚âà 1 token)
   */
  private estimateTextTokens(text: string): number {
    return Math.ceil(text.length / 4);
  }

  /**
   * Get display name for provider
   */
  private getProviderDisplayName(providerId: string): string {
    const displayNames: Record<string, string> = {
      'openai': 'OpenAI',
      'anthropic': 'Anthropic',
      'mistral': 'Mistral AI',
      'ollama': 'Ollama',
      'openrouter': 'OpenRouter'
    };
    return displayNames[providerId] || providerId;
  }


  /**
   * Capitalize agent name for display
   */
  private capitalizeAgentName(agentId: string): string {
    return agentId
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  /**
   * Update context progress bar after message changes
   */
  private async updateContextProgress(): Promise<void> {
    if (this.contextProgressBar) {
      await this.contextProgressBar.update();
      this.contextProgressBar.checkWarningThresholds();
    }
  }

  /**
   * Show loading animation for AI response
   */
  private showAILoadingState(messageId: string): void {
    console.log(`[ChatView] Showing loading state for message: ${messageId}`);
    
    // Find the message element and add loading animation
    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
      const contentElement = messageElement.querySelector('.message-bubble .message-content');
      if (contentElement) {
        contentElement.innerHTML = '<span class="ai-loading">Thinking<span class="dots">...</span></span>';
        this.startLoadingAnimation(contentElement);
      }
    }
  }

  /**
   * Remove loading message from conversation
   */
  private removeLoadingMessage(messageId: string): void {
    console.log(`[ChatView] Removing loading message: ${messageId}`);
    
    // Remove from current conversation
    if (this.currentConversation) {
      const messageIndex = this.currentConversation.messages.findIndex(msg => msg.id === messageId);
      if (messageIndex >= 0) {
        this.currentConversation.messages.splice(messageIndex, 1);
        if (this.messageDisplay) {
          this.messageDisplay.setConversation(this.currentConversation);
        }
      }
    }
  }

  /**
   * Start loading animation (animated dots)
   */
  private startLoadingAnimation(element: Element): void {
    const dotsElement = element.querySelector('.dots');
    if (dotsElement) {
      let dotCount = 0;
      const interval = setInterval(() => {
        dotCount = (dotCount + 1) % 4;
        dotsElement.textContent = '.'.repeat(dotCount);
      }, 500);
      
      // Store interval ID for cleanup
      (element as any)._loadingInterval = interval;
    }
  }

  /**
   * Stop loading animation
   */
  private stopLoadingAnimation(element: Element): void {
    const interval = (element as any)._loadingInterval;
    if (interval) {
      clearInterval(interval);
      delete (element as any)._loadingInterval;
    }
  }

  /**
   * Update streaming message content in real-time
   */
  private updateStreamingMessage(messageId: string, content: string, isStreaming: boolean): void {
    
    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    console.log(`[ChatView] Found message element:`, !!messageElement);
    
    if (messageElement) {
      const contentElement = messageElement.querySelector('.message-bubble .message-content');
      console.log(`[ChatView] Found content element:`, !!contentElement);
      
      if (contentElement) {
        // Stop loading animation
        this.stopLoadingAnimation(contentElement);
        
        // Update content with streaming text
        if (isStreaming) {
          contentElement.innerHTML = `<div class="streaming-content">${this.escapeHtml(content)}<span class="streaming-cursor">|</span></div>`;
        } else {
          contentElement.innerHTML = `<div class="final-content">${this.escapeHtml(content)}</div>`;
          console.log(`[ChatView] Set final content`);
        }
      } else {
        console.warn(`[ChatView] Content element not found for message ${messageId}`);
      }
    } else {
      console.warn(`[ChatView] Message element not found for messageId: ${messageId}`);
      // Log all message elements to debug
      const allMessages = this.containerEl.querySelectorAll('[data-message-id]');
      console.log(`[ChatView] Found ${allMessages.length} message elements:`, Array.from(allMessages).map(el => el.getAttribute('data-message-id')));
    }
  }

  /**
   * Escape HTML for safe display
   */
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Cleanup resources
   */
  private cleanup(): void {
    // Clean up any event listeners or resources
    if (this.conversationList) {
      this.conversationList.cleanup();
    }
    if (this.messageDisplay) {
      this.messageDisplay.cleanup();
    }
    if (this.chatInput) {
      this.chatInput.cleanup();
    }
    if (this.modelSelector) {
      this.modelSelector.cleanup();
    }
    if (this.agentSelector) {
      this.agentSelector.cleanup();
    }
    if (this.contextProgressBar) {
      this.contextProgressBar.cleanup();
    }
  }
}
```

## ui/chat/ChatView.ts

```typescript
/**
 * ChatView - Clean orchestrator for the chat interface
 * 
 * Coordinates between services, controllers, and UI components following SOLID principles.
 * This class is responsible for initialization, delegation, and high-level event coordination only.
 */

import { ItemView, WorkspaceLeaf } from 'obsidian';
import { ConversationList } from './components/ConversationList';
import { MessageDisplay } from './components/MessageDisplay';
import { ChatInput } from './components/ChatInput';
import { ModelSelector, ModelOption } from './components/ModelSelector';
import { AgentSelector, AgentOption } from './components/AgentSelector';
import { ContextProgressBar } from './components/ContextProgressBar';
// BranchNavigator removed - using message-level navigation
import { ChatService } from '../../services/chat/ChatService';
import { ConversationData, ConversationMessage } from '../../types/chat/ChatTypes';

// Services
import { ConversationManager, ConversationManagerEvents } from './services/ConversationManager';
import { MessageManager, MessageManagerEvents } from './services/MessageManager';
import { ModelAgentManager, ModelAgentManagerEvents } from './services/ModelAgentManager';
import { BranchManager, BranchManagerEvents } from './services/BranchManager';

// Controllers
import { UIStateController, UIStateControllerEvents } from './controllers/UIStateController';
import { StreamingController } from './controllers/StreamingController';

// Utils
import { TokenCalculator } from './utils/TokenCalculator';
import { ProviderUtils } from './utils/ProviderUtils';

export const CHAT_VIEW_TYPE = 'claudesidian-chat';

export class ChatView extends ItemView {
  // Core components
  private conversationList!: ConversationList;
  private messageDisplay!: MessageDisplay;
  private chatInput!: ChatInput;
  private modelSelector!: ModelSelector;
  private agentSelector!: AgentSelector;
  private contextProgressBar!: ContextProgressBar;
  // Branch navigation is now handled at message level
  
  // Services
  private conversationManager!: ConversationManager;
  private messageManager!: MessageManager;
  private modelAgentManager!: ModelAgentManager;
  private branchManager!: BranchManager;

  // Controllers
  private uiStateController!: UIStateController;
  private streamingController!: StreamingController;

  constructor(leaf: WorkspaceLeaf, private chatService: ChatService) {
    super(leaf);
  }

  getViewType(): string {
    return CHAT_VIEW_TYPE;
  }

  getDisplayText(): string {
    return 'AI Chat';
  }

  getIcon(): string {
    return 'message-square';
  }

  async onOpen(): Promise<void> {
    if (!this.chatService) {
      return;
    }

    try {
      await this.chatService.initialize();

      // Set up tool event callback for live UI updates
      this.chatService.setToolEventCallback((messageId, event, data) => {
        if (event === 'started') {
          this.handleToolExecutionStarted(messageId, data);
        } else if (event === 'completed') {
          this.handleToolExecutionCompleted(messageId, data.toolId, data.result, data.success, data.error);
        }
      });

    } catch (error) {
      // ChatService initialization failed
    }

    this.initializeArchitecture();
    await this.loadInitialData();
  }

  async onClose(): Promise<void> {
    this.cleanup();
  }

  /**
   * Initialize the clean architecture components
   */
  private initializeArchitecture(): void {
    this.createChatInterface();
    this.initializeServices();
    this.initializeControllers();
    this.initializeComponents();
    this.wireEventHandlers();
  }

  /**
   * Create the main chat interface layout (DOM only)
   */
  private createChatInterface(): void {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass('chat-view-container');

    // Create main layout structure
    const chatLayout = container.createDiv('chat-layout');
    const mainContainer = chatLayout.createDiv('chat-main');
    
    // Experimental warning banner (auto-hide after 5 seconds)
    const warningBanner = mainContainer.createDiv('chat-experimental-warning');
    warningBanner.innerHTML = `
      <span class="warning-icon">‚ö†Ô∏è</span>
      <span class="warning-text">Experimental Feature: AI Chat is in beta.</span>
      <a href="https://github.com/ProfSynapse/claudesidian-mcp/issues" target="_blank" rel="noopener noreferrer" class="warning-link">Report issues</a>
      <span class="warning-text">‚Ä¢ Use at your own risk</span>
    `;

    // Auto-hide warning after 5 seconds
    setTimeout(() => {
      warningBanner.style.opacity = '0';
      warningBanner.style.transition = 'opacity 0.5s ease-out';
      setTimeout(() => {
        warningBanner.style.display = 'none';
      }, 500); // Wait for fade transition to complete
    }, 5000);
    
    // Header
    const chatHeader = mainContainer.createDiv('chat-header');
    const hamburgerButton = chatHeader.createEl('button', { cls: 'chat-hamburger-button' });
    hamburgerButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="18" y2="18"/></svg>';
    hamburgerButton.setAttribute('aria-label', 'Toggle conversations');
    
    const chatTitle = chatHeader.createDiv('chat-title');
    chatTitle.textContent = 'AI Chat';
    
    // Branch navigation is now at message level - no global navigator needed
    
    // Main content areas
    const messageContainer = mainContainer.createDiv('message-display-container');
    const selectorsContainer = mainContainer.createDiv('chat-selectors-container');
    const modelSelectorContainer = selectorsContainer.createDiv('selector-item');
    const agentSelectorContainer = selectorsContainer.createDiv('selector-item');
    const inputContainer = mainContainer.createDiv('chat-input-container');
    const contextContainer = mainContainer.createDiv('chat-context-container');
    
    // Backdrop and sidebar
    const backdrop = chatLayout.createDiv('chat-backdrop');
    const sidebarContainer = chatLayout.createDiv('chat-sidebar');
    sidebarContainer.addClass('chat-sidebar-hidden');
    
    const sidebarHeader = sidebarContainer.createDiv('chat-sidebar-header');
    sidebarHeader.createEl('h3', { text: 'Conversations' });
    const newChatButton = sidebarHeader.createEl('button', { 
      cls: 'chat-new-button',
      text: '+ New Chat'
    });
    
    const conversationListContainer = sidebarContainer.createDiv('conversation-list-container');

    // Store references for services/controllers
    this.storeElementReferences({
      messageContainer,
      modelSelectorContainer,
      agentSelectorContainer,
      inputContainer,
      contextContainer,
      conversationListContainer,
      // branchNavigatorContainer removed - using message-level navigation
      newChatButton
    });
  }

  /**
   * Initialize business logic services
   */
  private initializeServices(): void {
    // Branch management - needed by other services
    const branchEvents: BranchManagerEvents = {
      onMessageAlternativeCreated: (messageId, alternativeIndex) => this.handleMessageAlternativeCreated(messageId, alternativeIndex),
      onMessageAlternativeSwitched: (messageId, alternativeIndex) => this.handleMessageAlternativeSwitched(messageId, alternativeIndex),
      onError: (message) => this.uiStateController.showError(message)
    };
    this.branchManager = new BranchManager(this.chatService.getConversationRepository(), branchEvents);

    // Conversation management
    const conversationEvents: ConversationManagerEvents = {
      onConversationSelected: (conversation) => this.handleConversationSelected(conversation),
      onConversationsChanged: () => this.handleConversationsChanged(),
      onError: (message) => this.uiStateController.showError(message)
    };
    this.conversationManager = new ConversationManager(this.chatService, this.branchManager, conversationEvents);

    // Message handling
    const messageEvents: MessageManagerEvents = {
      onMessageAdded: (message) => this.messageDisplay.addMessage(message),
      onAIMessageStarted: (message) => this.handleAIMessageStarted(message),
      onStreamingUpdate: (messageId, content, isComplete, isIncremental) => 
        this.handleStreamingUpdate(messageId, content, isComplete, isIncremental),
      onConversationUpdated: (conversation) => this.handleConversationUpdated(conversation),
      onLoadingStateChanged: (loading) => this.uiStateController.setInputLoading(loading),
      onError: (message) => this.uiStateController.showError(message),
      onToolCallsDetected: (messageId, toolCalls) => this.handleToolCallsDetected(messageId, toolCalls),
      onToolExecutionStarted: (messageId, toolCall) => this.handleToolExecutionStarted(messageId, toolCall),
      onToolExecutionCompleted: (messageId, toolId, result, success, error) => 
        this.handleToolExecutionCompleted(messageId, toolId, result, success, error),
      onMessageIdUpdated: (oldId, newId, updatedMessage) => this.handleMessageIdUpdated(oldId, newId, updatedMessage)
    };
    this.messageManager = new MessageManager(this.chatService, this.branchManager, messageEvents);

    // Model and agent management
    const modelAgentEvents: ModelAgentManagerEvents = {
      onModelChanged: (model) => this.handleModelChanged(model),
      onAgentChanged: (agent) => this.handleAgentChanged(agent),
      onSystemPromptChanged: () => this.updateContextProgress()
    };
    this.modelAgentManager = new ModelAgentManager(this.app, modelAgentEvents);
  }

  /**
   * Initialize UI controllers
   */
  private initializeControllers(): void {
    const uiStateEvents: UIStateControllerEvents = {
      onSidebarToggled: (visible) => { /* Sidebar toggled */ }
    };
    this.uiStateController = new UIStateController(this.containerEl, uiStateEvents);
    this.streamingController = new StreamingController(this.containerEl, this.app, this);
  }

  /**
   * Initialize UI components
   */
  private initializeComponents(): void {
    const refs = this.getElementReferences();

    this.conversationList = new ConversationList(
      refs.conversationListContainer,
      (conversation) => this.conversationManager.selectConversation(conversation),
      (conversationId) => this.conversationManager.deleteConversation(conversationId)
    );

    this.messageDisplay = new MessageDisplay(
      refs.messageContainer,
      this.app,
      this.branchManager,
      (messageId) => this.handleRetryMessage(messageId),
      (messageId, newContent) => this.handleEditMessage(messageId, newContent),
      (messageId, event, data) => this.handleToolEvent(messageId, event, data),
      (messageId, alternativeIndex) => this.handleMessageAlternativeSwitched(messageId, alternativeIndex)
    );

    this.chatInput = new ChatInput(
      refs.inputContainer,
      (message) => this.handleSendMessage(message),
      () => this.messageManager.getIsLoading()
    );

    this.modelSelector = new ModelSelector(
      refs.modelSelectorContainer,
      (model) => this.modelAgentManager.handleModelChange(model),
      () => this.modelAgentManager.getAvailableModels(),
      () => this.modelAgentManager.getDefaultModel()
    );

    this.agentSelector = new AgentSelector(
      refs.agentSelectorContainer,
      (agent) => this.modelAgentManager.handleAgentChange(agent),
      () => this.modelAgentManager.getAvailableAgents()
    );

    this.contextProgressBar = new ContextProgressBar(
      refs.contextContainer,
      () => this.getContextUsage()
    );

    // Branch navigation is now handled at message level - no global navigator needed

    // Update conversation list if conversations were already loaded
    const conversations = this.conversationManager.getConversations();
    if (conversations.length > 0) {
      this.conversationList.setConversations(conversations);
    }
  }

  /**
   * Wire up event handlers
   */
  private wireEventHandlers(): void {
    const refs = this.getElementReferences();
    
    // New chat button
    refs.newChatButton.addEventListener('click', () => 
      this.conversationManager.createNewConversation()
    );

    // UI state controller events
    this.uiStateController.initializeEventListeners();
  }

  /**
   * Load initial data
   */
  private async loadInitialData(): Promise<void> {
    await this.conversationManager.loadConversations();

    // Only show welcome state if no conversations exist
    const conversations = this.conversationManager.getConversations();
    if (conversations.length === 0) {
      this.uiStateController.showWelcomeState();
    }
    // If conversations exist, the ConversationManager will auto-select the most recent one
  }

  // Event Handlers

  private handleConversationSelected(conversation: ConversationData): void {
    this.messageDisplay.setConversation(conversation);
    // Branch navigation is now at message level
    this.uiStateController.setInputPlaceholder('Type your message...');
    this.updateContextProgress();
  }

  private handleConversationsChanged(): void {
    // Ensure component is initialized before updating
    if (this.conversationList) {
      this.conversationList.setConversations(this.conversationManager.getConversations());
    }
  }

  private handleAIMessageStarted(message: ConversationMessage): void {
    // Create AI message bubble directly without full conversation re-render
    this.messageDisplay.addAIMessage(message);
  }

  private handleStreamingUpdate(messageId: string, content: string, isComplete: boolean, isIncremental?: boolean): void {
    if (isIncremental) {
      // Streaming chunk - route to StreamingController
      this.streamingController.updateStreamingChunk(messageId, content);
    } else if (isComplete) {
      // Final content - finalize streaming and update MessageBubble
      this.streamingController.finalizeStreaming(messageId, content);
      this.messageDisplay.updateMessageContent(messageId, content);
    } else {
      // Start of new stream - initialize streaming
      this.streamingController.startStreaming(messageId);
      this.streamingController.updateStreamingChunk(messageId, content);
    }
  }

  private handleConversationUpdated(conversation: ConversationData): void {
    this.conversationManager.updateCurrentConversation(conversation);
    this.messageDisplay.setConversation(conversation);
    this.updateContextProgress();
  }

  private async handleSendMessage(message: string): Promise<void> {
    const currentConversation = this.conversationManager.getCurrentConversation();
    
    if (!currentConversation) {
      // Create new conversation with message
      await this.conversationManager.createNewConversationWithMessage(
        message,
        this.modelAgentManager.getMessageOptions()
      );
    } else {
      // Send message in current conversation
      await this.messageManager.sendMessage(
        currentConversation,
        message,
        this.modelAgentManager.getMessageOptions()
      );
    }
  }

  private async handleRetryMessage(messageId: string): Promise<void> {
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (currentConversation) {
      await this.messageManager.handleRetryMessage(
        currentConversation,
        messageId,
        this.modelAgentManager.getMessageOptions()
      );
    }
  }

  private async handleEditMessage(messageId: string, newContent: string): Promise<void> {
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (currentConversation) {
      await this.messageManager.handleEditMessage(
        currentConversation,
        messageId,
        newContent,
        this.modelAgentManager.getMessageOptions()
      );
    }
  }

  private handleModelChanged(model: ModelOption | null): void {
    this.updateContextProgress();
  }

  private handleAgentChanged(agent: AgentOption | null): void {
    // Agent changed
  }

  private async getContextUsage() {
    return TokenCalculator.getContextUsage(
      this.modelAgentManager.getSelectedModel(),
      this.conversationManager.getCurrentConversation(),
      this.modelAgentManager.getCurrentSystemPrompt()
    );
  }

  private async updateContextProgress(): Promise<void> {
    if (this.contextProgressBar) {
      await this.contextProgressBar.update();
      this.contextProgressBar.checkWarningThresholds();
    }
  }

  // Tool event handlers
  private handleToolCallsDetected(messageId: string, toolCalls: any[]): void {
    
    // With progressive tool execution, we don't need to batch re-render here
    // Individual tool accordions will be added via 'started' events
    // Just notify the MessageBubble that tool calls were detected
    const messageBubble = this.messageDisplay.findMessageBubble(messageId);
    messageBubble?.handleToolEvent('detected', toolCalls);
  }

  private handleToolExecutionStarted(messageId: string, toolCall: { id: string; name: string; parameters?: any }): void {
    const messageBubble = this.messageDisplay.findMessageBubble(messageId);
    messageBubble?.handleToolEvent('started', toolCall);
  }

  private handleToolExecutionCompleted(messageId: string, toolId: string, result: any, success: boolean, error?: string): void {
    const messageBubble = this.messageDisplay.findMessageBubble(messageId);
    messageBubble?.handleToolEvent('completed', { toolId, result, success, error });
  }

  private handleMessageIdUpdated(oldId: string, newId: string, updatedMessage: ConversationMessage): void {
    console.log('[ChatView] RECEIVED onMessageIdUpdated event:', {
      oldId,
      newId,
      updatedMessageId: updatedMessage.id,
      messageDisplayExists: !!this.messageDisplay
    });
    // Notify MessageDisplay to update the corresponding MessageBubble reference
    this.messageDisplay.updateMessageId(oldId, newId, updatedMessage);
  }

  private handleToolEvent(messageId: string, event: 'detected' | 'started' | 'completed', data: any): void {
    const messageBubble = this.messageDisplay.findMessageBubble(messageId);
    messageBubble?.handleToolEvent(event, data);
  }

  // Element reference management (simple store/retrieve)
  private elementRefs: any = {};

  private storeElementReferences(refs: any): void {
    this.elementRefs = refs;
  }

  private getElementReferences(): any {
    return this.elementRefs;
  }

  // =============================================================================
  // BRANCH EVENT HANDLERS
  // =============================================================================

  /**
   * Handle message alternative creation
   */
  private handleMessageAlternativeCreated(messageId: string, alternativeIndex: number): void {
    console.log('[ChatView] Message alternative created:', { messageId, alternativeIndex });
    
    // Update the message display to reflect new alternatives
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (currentConversation) {
      this.messageDisplay.setConversation(currentConversation);
    }
  }

  /**
   * Handle message alternative switching
   */
  private async handleMessageAlternativeSwitched(messageId: string, alternativeIndex: number): Promise<void> {
    console.log('[ChatView] Message alternative switched:', { messageId, alternativeIndex });
    
    // Use BranchManager to switch to the alternative (this updates the conversation)
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (currentConversation) {
      const success = await this.branchManager.switchToMessageAlternative(
        currentConversation,
        messageId,
        alternativeIndex
      );
      
      if (success) {
        // Get the updated message and update the bubble
        const updatedMessage = currentConversation.messages.find(msg => msg.id === messageId);
        if (updatedMessage) {
          this.messageDisplay.updateMessage(messageId, updatedMessage);
        }
      }
    }
  }


  private cleanup(): void {
    this.conversationList?.cleanup();
    this.messageDisplay?.cleanup();
    this.chatInput?.cleanup();
    this.modelSelector?.cleanup();
    this.agentSelector?.cleanup();
    this.contextProgressBar?.cleanup();
    // Branch navigator cleanup no longer needed
    this.uiStateController?.cleanup();
    this.streamingController?.cleanup();
  }
}
```

## ui/chat/components/AgentSelector.ts

```typescript
/**
 * AgentSelector - Dropdown for selecting AI agents with custom prompts
 * 
 * Displays available agents from the agent manager.
 * When an agent is selected, its prompt becomes the system prompt.
 */

export interface AgentOption {
  id: string;
  name: string;
  description?: string;
  systemPrompt: string;
}

export class AgentSelector {
  private element: HTMLElement | null = null;
  private selectElement: HTMLSelectElement | null = null;
  private currentAgent: AgentOption | null = null;

  constructor(
    private container: HTMLElement,
    private onAgentChange: (agent: AgentOption | null) => void,
    private getAvailableAgents: () => Promise<AgentOption[]>
  ) {
    this.render();
  }

  /**
   * Render the agent selector dropdown
   */
  private async render(): Promise<void> {
    this.container.empty();
    this.container.addClass('agent-selector');

    // Label
    const label = this.container.createDiv('agent-selector-label');
    label.textContent = 'Agent:';

    // Dropdown container
    const dropdownContainer = this.container.createDiv('agent-selector-dropdown');
    
    this.selectElement = dropdownContainer.createEl('select', {
      cls: 'agent-select'
    });

    // Add loading option
    const defaultOption = this.selectElement.createEl('option', {
      value: '',
      text: 'Loading agents...'
    });
    defaultOption.disabled = true;
    defaultOption.selected = true;

    // Load and populate agents
    await this.loadAgents();

    // Handle selection changes
    this.selectElement.addEventListener('change', () => {
      this.handleAgentChange();
    });

    this.element = this.container;
  }

  /**
   * Load available agents
   */
  private async loadAgents(): Promise<void> {
    if (!this.selectElement) return;

    try {
      const agents = await this.getAvailableAgents();
      
      // Clear loading option
      this.selectElement.innerHTML = '';
      
      // Add default "no agent" option
      const defaultOption = this.selectElement.createEl('option', {
        value: '',
        text: 'No agent (default)'
      });
      defaultOption.selected = true;

      // Add available agents
      agents.forEach(agent => {
        const option = this.selectElement!.createEl('option', {
          value: agent.id,
          text: agent.name
        });
        
        if (agent.description) {
          option.title = agent.description;
        }
      });

      // Set initial state (no agent selected)
      this.currentAgent = null;
      this.onAgentChange(null);

    } catch (error) {
      console.error('[AgentSelector] Failed to load agents:', error);
      
      if (this.selectElement) {
        this.selectElement.innerHTML = '';
        const errorOption = this.selectElement.createEl('option', {
          value: '',
          text: 'Error loading agents'
        });
        errorOption.disabled = true;
        errorOption.selected = true;
      }
    }
  }

  /**
   * Handle agent selection change
   */
  private handleAgentChange(): void {
    if (!this.selectElement) return;

    const selectedValue = this.selectElement.value;
    
    if (!selectedValue) {
      // No agent selected (default)
      this.currentAgent = null;
      this.onAgentChange(null);
      this.updateAgentInfo();
      return;
    }

    // Find the selected agent
    this.getAvailableAgents().then(agents => {
      const selectedAgent = agents.find(agent => agent.id === selectedValue);
      
      if (selectedAgent) {
        this.currentAgent = selectedAgent;
        this.onAgentChange(selectedAgent);
        this.updateAgentInfo();
      }
    });
  }

  /**
   * Get currently selected agent
   */
  getCurrentAgent(): AgentOption | null {
    return this.currentAgent;
  }

  /**
   * Set the selected agent programmatically
   */
  setAgent(agentId: string | null): void {
    if (!this.selectElement) return;

    if (!agentId) {
      this.selectElement.value = '';
      this.handleAgentChange();
      return;
    }

    const option = this.selectElement.querySelector(`option[value="${agentId}"]`);
    
    if (option) {
      this.selectElement.value = agentId;
      this.handleAgentChange();
    }
  }

  /**
   * Refresh the agent list
   */
  async refresh(): Promise<void> {
    await this.loadAgents();
  }


  /**
   * Update the agent info display
   */
  private updateAgentInfo(): void {
    const existingInfo = this.container.querySelector('.agent-info');
    if (existingInfo) {
      existingInfo.remove();
    }
    
    // Removed agent info display - no longer showing description card
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.element = null;
    this.selectElement = null;
    this.currentAgent = null;
  }
}
```

## ui/chat/components/ChatInput.ts

```typescript
/**
 * ChatInput - Message input component with send functionality
 * 
 * Provides text input, send button, and model selection
 */

export class ChatInput {
  private element: HTMLElement | null = null;
  private textArea: HTMLTextAreaElement | null = null;
  private sendButton: HTMLButtonElement | null = null;
  private isLoading = false;

  constructor(
    private container: HTMLElement,
    private onSendMessage: (message: string) => void,
    private getLoadingState: () => boolean
  ) {
    this.render();
  }

  /**
   * Set loading state
   */
  setLoading(loading: boolean): void {
    this.isLoading = loading;
    this.updateUI();
  }

  /**
   * Set placeholder text
   */
  setPlaceholder(placeholder: string): void {
    if (this.textArea) {
      this.textArea.placeholder = placeholder;
    }
  }

  /**
   * Render the chat input interface
   */
  private render(): void {
    this.container.empty();
    this.container.addClass('chat-input');

    // Input container with flex layout
    const inputContainer = this.container.createDiv('chat-input-flex');

    // Text area container
    const textareaContainer = inputContainer.createDiv('chat-textarea-container');
    this.textArea = textareaContainer.createEl('textarea', {
      cls: 'chat-textarea',
      attr: {
        placeholder: 'Type your message...',
        rows: '1'
      }
    });

    // Handle Enter key (send) and Shift+Enter (new line)
    this.textArea.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        this.handleSendMessage();
      }
    });

    // Auto-resize textarea
    this.textArea.addEventListener('input', () => {
      this.autoResizeTextarea();
    });

    // Send button container
    const buttonContainer = inputContainer.createDiv('chat-send-container');
    this.sendButton = buttonContainer.createEl('button', {
      cls: 'chat-send-button'
    });
    
    // Add send icon (Lucide 'send' icon)
    this.sendButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>';
    this.sendButton.setAttribute('aria-label', 'Send message');

    this.sendButton.addEventListener('click', () => {
      this.handleSendMessage();
    });

    // Model selector removed - now handled by separate ModelSelector component

    this.element = this.container;
    this.updateUI();
  }

  /**
   * Handle sending a message
   */
  private handleSendMessage(): void {
    if (!this.textArea || this.isLoading) return;

    const message = this.textArea.value.trim();
    if (!message) return;

    // Clear the input
    this.textArea.value = '';
    this.autoResizeTextarea();

    // Send the message
    this.onSendMessage(message);
  }

  /**
   * Auto-resize textarea based on content (limited to 2 lines)
   */
  private autoResizeTextarea(): void {
    if (!this.textArea) return;

    // Reset height to auto to get the correct scrollHeight
    this.textArea.style.height = 'auto';
    
    // Set height limits for 2 lines maximum
    const minHeight = 40; // Single line height with padding
    const maxHeight = 72; // Two line height (40px base + 32px for second line)
    const newHeight = Math.min(Math.max(this.textArea.scrollHeight, minHeight), maxHeight);
    this.textArea.style.height = newHeight + 'px';
    
    // Enable scrolling if content exceeds 2 lines
    this.textArea.style.overflowY = this.textArea.scrollHeight > maxHeight ? 'auto' : 'hidden';
  }

  /**
   * Update UI based on current state
   */
  private updateUI(): void {
    if (!this.sendButton || !this.textArea) return;

    const actuallyLoading = this.isLoading || this.getLoadingState();

    if (actuallyLoading) {
      this.sendButton.disabled = true;
      this.sendButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="chat-loading-spinner"><circle cx="12" cy="12" r="10"/><path d="m9 12 2 2 4-4"/></svg>';
      this.textArea.disabled = true;
    } else {
      this.sendButton.disabled = false;
      this.sendButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>';
      this.textArea.disabled = false;
    }
  }

  /**
   * Focus the input
   */
  focus(): void {
    if (this.textArea) {
      this.textArea.focus();
    }
  }

  /**
   * Clear the input
   */
  clear(): void {
    if (this.textArea) {
      this.textArea.value = '';
      this.autoResizeTextarea();
    }
  }

  /**
   * Get current input value
   */
  getValue(): string {
    return this.textArea?.value || '';
  }

  /**
   * Set input value
   */
  setValue(value: string): void {
    if (this.textArea) {
      this.textArea.value = value;
      this.autoResizeTextarea();
    }
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.element = null;
    this.textArea = null;
    this.sendButton = null;
  }
}
```

## ui/chat/components/ContextProgressBar.ts

```typescript
/**
 * ContextProgressBar - Visual indicator of context window usage
 * 
 * Shows how much of the current model's context window is being used
 * by the conversation history, helping users understand when they're
 * approaching the limit.
 */

export interface ContextUsage {
  used: number;
  total: number;
  percentage: number;
}

export class ContextProgressBar {
  private element: HTMLElement | null = null;
  private progressBar: HTMLElement | null = null;
  private usageText: HTMLElement | null = null;
  private currentUsage: ContextUsage = { used: 0, total: 0, percentage: 0 };

  constructor(
    private container: HTMLElement,
    private getContextUsage: () => Promise<ContextUsage>
  ) {
    this.render();
  }

  /**
   * Render the context progress bar
   */
  private render(): void {
    this.container.empty();
    this.container.addClass('context-progress-container');

    // Header
    const header = this.container.createDiv('context-progress-header');
    const label = header.createSpan('context-progress-label');
    label.textContent = 'Context Usage';

    this.usageText = header.createSpan('context-progress-usage');
    this.usageText.textContent = '0 / 0 tokens (0%)';

    // Progress bar container
    const progressContainer = this.container.createDiv('context-progress-bar-container');
    
    // Background bar
    const backgroundBar = progressContainer.createDiv('context-progress-bar-bg');
    
    // Progress bar (filled portion)
    this.progressBar = backgroundBar.createDiv('context-progress-bar-fill');
    this.progressBar.style.width = '0%';

    // Segments for visual indication
    this.createSegments(backgroundBar);

    this.element = this.container;
    this.updateDisplay();
  }

  /**
   * Create visual segments on the progress bar
   */
  private createSegments(container: HTMLElement): void {
    // Add segment markers at 25%, 50%, 75% for visual reference
    const segments = [25, 50, 75];
    
    segments.forEach(percent => {
      const segment = container.createDiv('context-progress-segment');
      segment.style.left = `${percent}%`;
    });
  }

  /**
   * Update the progress bar display
   */
  public async update(): Promise<void> {
    try {
      this.currentUsage = await this.getContextUsage();
      this.updateDisplay();
    } catch (error) {
      console.error('[ContextProgressBar] Failed to update context usage:', error);
    }
  }

  /**
   * Update the visual display
   */
  private updateDisplay(): void {
    if (!this.progressBar || !this.usageText) return;

    const { used, total, percentage } = this.currentUsage;

    // Update progress bar width
    this.progressBar.style.width = `${Math.min(percentage, 100)}%`;
    
    // Update color based on usage level
    this.progressBar.className = 'context-progress-bar-fill';
    
    if (percentage >= 90) {
      this.progressBar.addClass('context-critical'); // Red
    } else if (percentage >= 75) {
      this.progressBar.addClass('context-warning'); // Orange
    } else if (percentage >= 50) {
      this.progressBar.addClass('context-moderate'); // Yellow
    } else {
      this.progressBar.addClass('context-safe'); // Green
    }

    // Update usage text
    const usedFormatted = this.formatTokenCount(used);
    const totalFormatted = this.formatTokenCount(total);
    
    this.usageText.textContent = `${usedFormatted} / ${totalFormatted} tokens (${Math.round(percentage)}%)`;
    
    // Add tooltip with more details
    this.usageText.title = this.createTooltipText();
  }

  /**
   * Format token count for display
   */
  private formatTokenCount(tokens: number): string {
    if (tokens >= 1000000) {
      return `${(tokens / 1000000).toFixed(1)}M`;
    } else if (tokens >= 1000) {
      return `${(tokens / 1000).toFixed(1)}k`;
    } else {
      return tokens.toString();
    }
  }

  /**
   * Create detailed tooltip text
   */
  private createTooltipText(): string {
    const { used, total, percentage } = this.currentUsage;
    const remaining = total - used;
    
    return [
      `Context Window Usage`,
      `Used: ${used.toLocaleString()} tokens`,
      `Total: ${total.toLocaleString()} tokens`,
      `Remaining: ${remaining.toLocaleString()} tokens`,
      `Usage: ${percentage.toFixed(1)}%`
    ].join('\n');
  }

  /**
   * Set context usage directly (for immediate updates)
   */
  public setUsage(usage: ContextUsage): void {
    this.currentUsage = usage;
    this.updateDisplay();
  }

  /**
   * Get current usage
   */
  public getCurrentUsage(): ContextUsage {
    return { ...this.currentUsage };
  }

  /**
   * Show warning when approaching limit
   */
  public checkWarningThresholds(): void {
    const { percentage } = this.currentUsage;
    
    if (percentage >= 95) {
      this.showWarning('Context window nearly full. Consider starting a new conversation.', 'critical');
    } else if (percentage >= 85) {
      this.showWarning('Context window getting full. Responses may be truncated soon.', 'warning');
    }
  }

  /**
   * Show context usage warning
   */
  private showWarning(message: string, level: 'warning' | 'critical'): void {
    // Create temporary warning element
    const warning = document.createElement('div');
    warning.addClass('context-warning-message');
    warning.addClass(`context-warning-${level}`);
    warning.textContent = message;
    
    // Insert after the progress bar
    if (this.element) {
      this.element.appendChild(warning);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (warning.parentElement) {
          warning.remove();
        }
      }, 5000);
    }
  }

  /**
   * Reset usage (for new conversations)
   */
  public reset(): void {
    this.currentUsage = { used: 0, total: 0, percentage: 0 };
    this.updateDisplay();
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.element = null;
    this.progressBar = null;
    this.usageText = null;
  }
}
```

## ui/chat/components/ConversationList.ts

```typescript
/**
 * ConversationList - Sidebar component for managing conversations
 * 
 * Displays list of conversations with create/delete functionality
 */

import { ConversationData } from '../../../types/chat/ChatTypes';

export class ConversationList {
  private conversations: ConversationData[] = [];
  private activeConversationId: string | null = null;

  constructor(
    private container: HTMLElement,
    private onConversationSelect: (conversation: ConversationData) => void,
    private onConversationDelete: (conversationId: string) => void
  ) {
    this.render();
  }

  /**
   * Set conversations to display
   */
  setConversations(conversations: ConversationData[]): void {
    this.conversations = conversations.sort((a, b) => b.updated - a.updated);
    this.render();
  }

  /**
   * Set active conversation
   */
  setActiveConversation(conversationId: string): void {
    this.activeConversationId = conversationId;
    this.updateActiveState();
  }

  /**
   * Render the conversation list
   */
  private render(): void {
    this.container.empty();
    this.container.addClass('conversation-list');

    if (this.conversations.length === 0) {
      const emptyState = this.container.createDiv('conversation-list-empty');
      emptyState.textContent = 'No conversations yet';
      return;
    }

    this.conversations.forEach(conversation => {
      const item = this.container.createDiv('conversation-item');
      
      if (conversation.id === this.activeConversationId) {
        item.addClass('active');
      }

      // Main conversation content
      const content = item.createDiv('conversation-content');
      content.addEventListener('click', () => {
        this.onConversationSelect(conversation);
      });

      // Title
      const title = content.createDiv('conversation-title');
      title.textContent = conversation.title;

      // Last message preview
      const lastMessage = conversation.messages[conversation.messages.length - 1];
      if (lastMessage) {
        const preview = content.createDiv('conversation-preview');
        const previewText = lastMessage.content.length > 60 
          ? lastMessage.content.substring(0, 60) + '...'
          : lastMessage.content;
        preview.textContent = previewText;
      }

      // Timestamp
      const timestamp = content.createDiv('conversation-timestamp');
      timestamp.textContent = this.formatTimestamp(conversation.updated);

      // Delete button
      const deleteBtn = item.createDiv('conversation-delete');
      deleteBtn.innerHTML = '√ó';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm('Delete this conversation?')) {
          this.onConversationDelete(conversation.id);
        }
      });
    });
  }

  /**
   * Update active state styling
   */
  private updateActiveState(): void {
    const items = this.container.querySelectorAll('.conversation-item');
    items.forEach((item, index) => {
      const conversation = this.conversations[index];
      if (conversation && conversation.id === this.activeConversationId) {
        item.addClass('active');
      } else {
        item.removeClass('active');
      }
    });
  }

  /**
   * Format timestamp for display
   */
  private formatTimestamp(timestamp: number): string {
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    
    return date.toLocaleDateString();
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    // Clean up any event listeners if needed
  }
}
```

## ui/chat/components/MessageBranchNavigator.ts

```typescript
/**
 * MessageBranchNavigator - UI component for navigating between message alternatives
 * 
 * Shows mini "< X/Y >" navigation for individual messages that have multiple alternatives
 * Only displays when message has alternatives
 */

import { ConversationMessage } from '../../../types/chat/ChatTypes';
import { setIcon } from 'obsidian';

export interface MessageBranchNavigatorEvents {
  onAlternativeChanged: (messageId: string, alternativeIndex: number) => void;
  onError: (message: string) => void;
}

export class MessageBranchNavigator {
  private container: HTMLElement;
  private branchIndicator!: HTMLElement;
  private prevButton!: HTMLButtonElement;
  private nextButton!: HTMLButtonElement;
  private currentMessage: ConversationMessage | null = null;

  constructor(
    container: HTMLElement,
    private events: MessageBranchNavigatorEvents
  ) {
    this.container = container;
    this.createBranchNavigator();
    this.hide(); // Hidden by default
  }

  /**
   * Create the mini branch navigation UI
   */
  private createBranchNavigator(): void {
    this.container.addClass('message-branch-navigator');

    // Previous alternative button
    this.prevButton = this.container.createEl('button', {
      cls: 'message-branch-btn message-branch-prev',
      attr: { 
        'aria-label': 'Previous alternative',
        'title': 'Go to previous alternative response'
      }
    });
    this.prevButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15,18 9,12 15,6"></polyline></svg>`;

    // Branch indicator (shows current/total like "2/4")
    this.branchIndicator = this.container.createDiv('message-branch-indicator');
    this.branchIndicator.textContent = '1/1';

    // Next alternative button
    this.nextButton = this.container.createEl('button', {
      cls: 'message-branch-btn message-branch-next',
      attr: { 
        'aria-label': 'Next alternative',
        'title': 'Go to next alternative response'
      }
    });
    this.nextButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9,18 15,12 9,6"></polyline></svg>`;

    // Event listeners
    this.prevButton.addEventListener('click', () => this.handlePreviousAlternative());
    this.nextButton.addEventListener('click', () => this.handleNextAlternative());
  }

  /**
   * Update the navigator for a message
   */
  updateMessage(message: ConversationMessage): void {
    this.currentMessage = message;
    this.updateDisplay();
  }

  /**
   * Update the display based on current message
   */
  private updateDisplay(): void {
    if (!this.currentMessage || !this.hasAlternatives()) {
      this.hide();
      return;
    }

    const alternativeCount = this.getAlternativeCount();
    const currentIndex = this.currentMessage.activeAlternativeIndex || 0;
    
    // Show and update the indicator (1-based display)
    this.show();
    this.branchIndicator.textContent = `${currentIndex + 1}/${alternativeCount}`;
    
    // Update button states
    this.updateButtonStates(currentIndex, alternativeCount);
  }

  /**
   * Update navigation button states
   */
  private updateButtonStates(currentIndex: number, totalCount: number): void {
    const isFirst = currentIndex === 0;
    const isLast = currentIndex === totalCount - 1;
    
    this.prevButton.disabled = isFirst;
    this.nextButton.disabled = isLast;
    
    // Update visual states
    this.prevButton.toggleClass('disabled', isFirst);
    this.nextButton.toggleClass('disabled', isLast);
  }

  /**
   * Handle previous alternative navigation
   */
  private async handlePreviousAlternative(): Promise<void> {
    if (!this.currentMessage) return;
    
    const currentIndex = this.currentMessage.activeAlternativeIndex || 0;
    if (currentIndex <= 0) return;

    const newIndex = currentIndex - 1;
    this.events.onAlternativeChanged(this.currentMessage.id, newIndex);
    this.updateDisplay();
  }

  /**
   * Handle next alternative navigation
   */
  private async handleNextAlternative(): Promise<void> {
    if (!this.currentMessage) return;
    
    const currentIndex = this.currentMessage.activeAlternativeIndex || 0;
    const totalCount = this.getAlternativeCount();
    if (currentIndex >= totalCount - 1) return;

    const newIndex = currentIndex + 1;
    this.events.onAlternativeChanged(this.currentMessage.id, newIndex);
    this.updateDisplay();
  }

  /**
   * Check if current message has alternatives
   */
  private hasAlternatives(): boolean {
    return !!(this.currentMessage?.alternatives && this.currentMessage.alternatives.length > 0);
  }

  /**
   * Get total alternative count (including the original message)
   */
  private getAlternativeCount(): number {
    if (!this.hasAlternatives()) return 1;
    return (this.currentMessage!.alternatives!.length) + 1; // +1 for original message
  }

  /**
   * Show the navigator
   */
  private show(): void {
    this.container.removeClass('message-branch-navigator-hidden');
    this.container.addClass('message-branch-navigator-visible');
  }

  /**
   * Hide the navigator
   */
  private hide(): void {
    this.container.removeClass('message-branch-navigator-visible');
    this.container.addClass('message-branch-navigator-hidden');
  }

  /**
   * Get current alternative information for external use
   */
  getCurrentAlternativeInfo(): { current: number; total: number; hasAlternatives: boolean } | null {
    if (!this.currentMessage) return null;
    
    const currentIndex = this.currentMessage.activeAlternativeIndex || 0;
    const totalCount = this.getAlternativeCount();
    
    return {
      current: currentIndex + 1, // 1-based for display
      total: totalCount,
      hasAlternatives: this.hasAlternatives()
    };
  }

  /**
   * Check if navigator is currently visible
   */
  isVisible(): boolean {
    return this.container.hasClass('message-branch-navigator-visible');
  }

  /**
   * Clean up resources
   */
  destroy(): void {
    this.prevButton.removeEventListener('click', () => this.handlePreviousAlternative());
    this.nextButton.removeEventListener('click', () => this.handleNextAlternative());
    this.container.empty();
  }
}
```

## ui/chat/components/MessageBubble.ts

```typescript
/**
 * MessageBubble - Individual message bubble component
 * 
 * Renders user/AI messages with copy, retry, and edit actions
 */

import { ConversationMessage } from '../../../types/chat/ChatTypes';
import { ToolAccordion } from './ToolAccordion';
import { ProgressiveToolAccordion } from './ProgressiveToolAccordion';
import { MessageBranchNavigator, MessageBranchNavigatorEvents } from './MessageBranchNavigator';
import { MarkdownRenderer } from '../utils/MarkdownRenderer';
import { setIcon, Component, App } from 'obsidian';

export class MessageBubble extends Component {
  private element: HTMLElement | null = null;
  private loadingInterval: any = null;
  private progressiveToolAccordions: Map<string, ProgressiveToolAccordion> = new Map();
  private messageBranchNavigator: MessageBranchNavigator | null = null;

  constructor(
    private message: ConversationMessage,
    private app: App,
    private onCopy: (messageId: string) => void,
    private onRetry: (messageId: string) => void,
    private onEdit?: (messageId: string, newContent: string) => void,
    private onToolEvent?: (messageId: string, event: 'detected' | 'started' | 'completed', data: any) => void,
    private onMessageAlternativeChanged?: (messageId: string, alternativeIndex: number) => void
  ) {
    super();
  }

  /**
   * Create the message bubble element
   */
  createElement(): HTMLElement {
    // Create wrapper container that holds both bubble and actions
    const messageContainer = document.createElement('div');
    messageContainer.addClass('message-container');
    messageContainer.addClass(`message-${this.message.role}`);
    messageContainer.setAttribute('data-message-id', this.message.id);

    // Create the actual bubble
    const bubble = messageContainer.createDiv('message-bubble');

    // Message header with role icon only
    const header = bubble.createDiv('message-header');
    
    // Role icon
    const roleIcon = header.createDiv('message-role-icon');
    if (this.message.role === 'user') {
      setIcon(roleIcon, 'user');
    } else if (this.message.role === 'tool') {
      setIcon(roleIcon, 'wrench');
    } else {
      setIcon(roleIcon, 'bot');
    }

    // Message content
    const content = bubble.createDiv('message-content');
    
    // Render content with enhanced markdown support (use active alternative if any)
    const activeContent = this.getActiveMessageContent(this.message);
    this.renderContent(content, activeContent).catch(error => {
      console.error('[MessageBubble] Error rendering initial content:', error);
    });

    // Actions outside and underneath the bubble, justified right
    const actions = messageContainer.createDiv('message-actions-external');
    
    if (this.message.role === 'user') {
      // Edit button for user messages
      if (this.onEdit) {
        const editBtn = actions.createEl('button', { 
          cls: 'message-action-btn',
          attr: { title: 'Edit message' }
        });
        setIcon(editBtn, 'edit');
        editBtn.addEventListener('click', () => this.handleEdit());
      }
      
      // Retry button for user messages
      const retryBtn = actions.createEl('button', { 
        cls: 'message-action-btn',
        attr: { title: 'Retry message' }
      });
      setIcon(retryBtn, 'rotate-ccw');
      retryBtn.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        console.log('[MessageBubble] Retry button clicked!', {
          messageId: this.message.id,
          messageRole: this.message.role,
          messageContent: this.message.content.substring(0, 50) + '...',
          onRetryExists: !!this.onRetry,
          elementDataId: this.element?.getAttribute('data-message-id')
        });
        if (this.onRetry) {
          this.onRetry(this.message.id);
        } else {
          console.error('[MessageBubble] onRetry callback is null/undefined!');
        }
      });
    } else if (this.message.role === 'tool') {
      // Tool messages get minimal actions - just copy for debugging
      const copyBtn = actions.createEl('button', { 
        cls: 'message-action-btn',
        attr: { title: 'Copy tool execution details' }
      });
      setIcon(copyBtn, 'copy');
      copyBtn.addEventListener('click', () => {
        this.showCopyFeedback(copyBtn);
        this.onCopy(this.message.id);
      });
    } else {
      // Copy button for AI messages
      const copyBtn = actions.createEl('button', { 
        cls: 'message-action-btn',
        attr: { title: 'Copy message' }
      });
      setIcon(copyBtn, 'copy');
      copyBtn.addEventListener('click', () => {
        this.showCopyFeedback(copyBtn);
        this.onCopy(this.message.id);
      });
      
      // Message branch navigator for AI messages with alternatives
      if (this.message.alternatives && this.message.alternatives.length > 0) {
        const navigatorContainer = actions.createDiv('message-branch-navigator-container');
        
        const navigatorEvents: MessageBranchNavigatorEvents = {
          onAlternativeChanged: (messageId, alternativeIndex) => {
            if (this.onMessageAlternativeChanged) {
              this.onMessageAlternativeChanged(messageId, alternativeIndex);
            }
          },
          onError: (message) => console.error('[MessageBubble] Branch navigation error:', message)
        };
        
        this.messageBranchNavigator = new MessageBranchNavigator(navigatorContainer, navigatorEvents);
        this.messageBranchNavigator.updateMessage(this.message);
      }
    }

    this.element = messageContainer;
    return messageContainer;
  }

  /**
   * Render message content using enhanced markdown renderer
   */
  private async renderContent(container: HTMLElement, content: string): Promise<void> {
    // Handle loading state for AI messages
    if (this.message.isLoading && this.message.role === 'assistant' && !content.trim()) {
      container.innerHTML = '<span class="ai-loading">Thinking<span class="dots">...</span></span>';
      this.startLoadingAnimation(container);
      return;
    }

    // Use enhanced markdown renderer with Obsidian's native rendering
    try {
      await MarkdownRenderer.renderMarkdown(content, container, this.app, this);
    } catch (error) {
      console.error('[MessageBubble] Error rendering markdown:', error);
      // Fallback to plain text
      const pre = container.createEl('pre');
      pre.style.whiteSpace = 'pre-wrap';
      pre.textContent = content;
    }

    // Add tool accordion if there are tool calls
    this.renderToolCalls(container);
  }

  /**
   * Render tool calls accordion within the message content
   */
  private renderToolCalls(container: HTMLElement): void {
    // For tool role messages, always render the tool accordion
    if (this.message.role === 'tool' && this.message.toolCalls && this.message.toolCalls.length > 0) {
      console.log('[MessageBubble] Rendering tool accordion for tool message:', {
        messageId: this.message.id,
        toolCallCount: this.message.toolCalls.length,
        toolNames: this.message.toolCalls.map(tc => tc.name)
      });

      // Create accordion for tool execution message
      const accordion = new ToolAccordion(this.message.toolCalls);
      const accordionEl = accordion.createElement();
      container.appendChild(accordionEl);
      return;
    }

    // For assistant messages with tool_calls (historical data), also render tool accordions
    if (this.message.role === 'assistant' && this.message.toolCalls && this.message.toolCalls.length > 0) {
      console.log('[MessageBubble] Rendering tool accordion for assistant message with toolCalls:', {
        messageId: this.message.id,
        toolCallCount: this.message.toolCalls.length,
        toolNames: this.message.toolCalls.map(tc => tc.name)
      });

      // Create accordion for stored tool calls in assistant messages (legacy format)
      const accordion = new ToolAccordion(this.message.toolCalls);
      const accordionEl = accordion.createElement();
      container.appendChild(accordionEl);
      return;
    }

    // No tool calls to render
  }



  /**
   * Handle edit functionality
   */
  private handleEdit(): void {
    if (!this.onEdit || !this.element) return;
    
    const contentDiv = this.element.querySelector('.message-bubble .message-content');
    if (!contentDiv) return;

    // Create textarea for editing
    const textarea = document.createElement('textarea');
    textarea.className = 'message-edit-textarea';
    textarea.value = this.message.content;
    textarea.style.width = '100%';
    textarea.style.minHeight = '60px';
    textarea.style.resize = 'vertical';
    
    // Create edit controls
    const editControls = document.createElement('div');
    editControls.className = 'message-edit-controls';
    
    const saveBtn = editControls.createEl('button', {
      text: 'Save',
      cls: 'message-edit-save'
    });
    
    const cancelBtn = editControls.createEl('button', {
      text: 'Cancel', 
      cls: 'message-edit-cancel'
    });
    
    // Store original content
    const originalContent = contentDiv.innerHTML;
    
    // Replace content with edit interface
    contentDiv.empty();
    contentDiv.appendChild(textarea);
    contentDiv.appendChild(editControls);
    
    // Focus textarea
    textarea.focus();
    
    // Save handler
    saveBtn.addEventListener('click', () => {
      const newContent = textarea.value.trim();
      if (newContent && newContent !== this.message.content) {
        this.onEdit!(this.message.id, newContent);
      }
      this.exitEditMode(contentDiv, originalContent);
    });
    
    // Cancel handler
    cancelBtn.addEventListener('click', () => {
      this.exitEditMode(contentDiv, originalContent);
    });
    
    // ESC key handler
    textarea.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this.exitEditMode(contentDiv, originalContent);
      }
    });
  }

  /**
   * Exit edit mode and restore original content
   */
  private exitEditMode(contentDiv: Element, originalContent: string): void {
    contentDiv.innerHTML = originalContent;
  }

  /**
   * Get the DOM element
   */
  getElement(): HTMLElement | null {
    return this.element;
  }

  /**
   * Start loading animation (animated dots)
   */
  private startLoadingAnimation(container: HTMLElement): void {
    const dotsElement = container.querySelector('.dots');
    if (dotsElement) {
      let dotCount = 0;
      this.loadingInterval = setInterval(() => {
        dotCount = (dotCount + 1) % 4;
        dotsElement.textContent = '.'.repeat(dotCount);
      }, 500);
    }
  }

  /**
   * Stop loading animation
   */
  private stopLoadingAnimation(): void {
    if (this.loadingInterval) {
      clearInterval(this.loadingInterval);
      this.loadingInterval = null;
    }
  }

  /**
   * Update static message content - MessageBubble now handles final content only
   * Streaming is handled by StreamingController
   */
  updateContent(content: string): void {
    if (!this.element) return;

    const contentElement = this.element.querySelector('.message-content');
    if (!contentElement) return;

    // Stop any loading animations
    this.stopLoadingAnimation();
    
    // Clear any existing content
    contentElement.empty();
    
    // Render final content using Obsidian's markdown renderer
    this.renderContent(contentElement as HTMLElement, content).catch(error => {
      console.error('[MessageBubble] Error rendering content:', error);
      // Fallback to plain text
      const fallbackDiv = document.createElement('div');
      fallbackDiv.textContent = content;
      contentElement.appendChild(fallbackDiv);
    });
  }


  /**
   * Update MessageBubble with new message data (including tool calls)
   * This triggers a re-render when tool calls are detected from LLM
   */
  updateWithNewMessage(newMessage: ConversationMessage): void {
    console.log('[MessageBubble] updateWithNewMessage called:', {
      oldId: this.message.id,
      newId: newMessage.id,
      oldContent: this.message.content.substring(0, 30) + '...',
      newContent: newMessage.content.substring(0, 30) + '...',
      hasProgressiveAccordions: this.progressiveToolAccordions.size > 0
    });

    // PROBLEM: This method completely re-renders and puts tool calls at the end
    // We should avoid calling this if we already have progressive accordions
    if (this.progressiveToolAccordions.size > 0 && newMessage.toolCalls) {
      // Skip update - preserving progressive accordions
      // Just update the stored message reference but don't re-render
      console.log('[MessageBubble] Preserving progressive accordions, only updating message reference');
      this.message = newMessage;
      
      // Update branch navigator if it exists
      if (this.messageBranchNavigator) {
        this.messageBranchNavigator.updateMessage(newMessage);
      }
      return;
    }

    // Update stored message reference
    this.message = newMessage;
    
    // Update branch navigator if it exists
    if (this.messageBranchNavigator) {
      this.messageBranchNavigator.updateMessage(newMessage);
    }

    if (!this.element) return;
    const contentElement = this.element.querySelector('.message-content');
    if (!contentElement) return;

    // Clear existing content
    contentElement.empty();

    // Re-render content with the active alternative (if any)
    const activeContent = this.getActiveMessageContent(newMessage);
    this.renderContent(contentElement as HTMLElement, activeContent).catch(error => {
      console.error('[MessageBubble] Error re-rendering content:', error);
    });

    // If there are tool calls, render them
    if (newMessage.toolCalls && newMessage.toolCalls.length > 0) {
      this.renderToolCalls(contentElement as HTMLElement);
    }

    // If still loading, show appropriate loading state
    if (newMessage.isLoading && newMessage.role === 'assistant') {
      const loadingDiv = contentElement.createDiv('ai-loading-continuation');
      loadingDiv.innerHTML = '<span class="ai-loading">Thinking<span class="dots">...</span></span>';
      this.startLoadingAnimation(loadingDiv);
    }

    // Re-rendered with tool calls
  }

  /**
   * Get the active content for the message (original or alternative)
   */
  private getActiveMessageContent(message: ConversationMessage): string {
    const activeIndex = message.activeAlternativeIndex || 0;
    
    // Index 0 is the original message
    if (activeIndex === 0) {
      return message.content;
    }
    
    // Alternative messages start at index 1
    if (message.alternatives && message.alternatives.length > 0) {
      const alternativeIndex = activeIndex - 1;
      if (alternativeIndex >= 0 && alternativeIndex < message.alternatives.length) {
        return message.alternatives[alternativeIndex].content;
      }
    }
    
    // Fallback to original content
    return message.content;
  }

  /**
   * Escape HTML for safe display
   */
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Create individual accordion for a specific tool
   */
  createIndividualToolAccordion(toolCall: { id: string; name: string; parameters?: any }): void {
    
    if (!this.element) return;
    const contentElement = this.element.querySelector('.message-content');
    if (!contentElement) return;
    
    // On first tool call, move "Thinking..." to the bottom
    if (this.progressiveToolAccordions.size === 0) {
      // Find existing loading element
      const existingLoading = contentElement.querySelector('.ai-loading');
      if (existingLoading) {
        existingLoading.remove(); // Remove from current position
      }
      
      // Stop any existing loading animation
      this.stopLoadingAnimation();
    }
    
    // Create a new ProgressiveToolAccordion for this specific tool
    const toolAccordion = new ProgressiveToolAccordion();
    const accordionElement = toolAccordion.createElement();
    
    // Add it to the content (chronological order - accordions appear in order)
    contentElement.appendChild(accordionElement);
    
    // Store the accordion instance mapped to tool ID
    this.progressiveToolAccordions.set(toolCall.id, toolAccordion);
    
    // Start the tool execution in this accordion
    toolAccordion.startTool(toolCall);
    
    // Add "Thinking..." below all accordions for next potential tool calls
    this.addContinuationThinking(contentElement);
  }

  /**
   * Add "Thinking..." below accordions for continuation
   */
  private addContinuationThinking(contentElement: Element): void {
    // Remove any existing continuation thinking
    const existingContinuation = contentElement.querySelector('.ai-loading-continuation');
    if (existingContinuation) {
      existingContinuation.remove();
    }
    
    // Add new thinking state at the bottom
    const continuationLoading = contentElement.createDiv('ai-loading-continuation');
    continuationLoading.innerHTML = '<span class="ai-loading">Thinking<span class="dots">...</span></span>';
    this.startLoadingAnimation(continuationLoading);
  }

  /**
   * Complete individual tool execution
   */
  completeIndividualTool(toolId: string, result: any, success: boolean, error?: string): void {
    const toolAccordion = this.progressiveToolAccordions.get(toolId);
    if (toolAccordion) {
      toolAccordion.completeTool(toolId, result, success, error);
    }
  }

  /**
   * Remove continuation thinking when all tools are done (called when final response comes)
   */
  private removeContinuationThinking(): void {
    if (!this.element) return;
    const contentElement = this.element.querySelector('.message-content');
    if (!contentElement) return;
    
    const continuationLoading = contentElement.querySelector('.ai-loading-continuation');
    if (continuationLoading) {
      this.stopLoadingAnimation();
      continuationLoading.remove();
    }
  }

  /**
   * Handle tool events from MessageManager
   */
  handleToolEvent(event: 'detected' | 'started' | 'completed', data: any): void {
    switch(event) {
      case 'detected':
        // Tool calls detected - but don't show accordions yet (they come individually via 'started' events)
        break;
      case 'started':
        // Individual tool started - create separate accordion for this specific tool
        
        // Check if this tool accordion already exists (avoid duplicates)
        if (this.progressiveToolAccordions.has(data.id)) {
          break;
        }
        
        if (this.message.role === 'assistant') {
          this.createIndividualToolAccordion({
            id: data.id,
            name: data.name,
            parameters: data.parameters
          });
        }
        break;
      case 'completed':
        // Individual tool completed  
        this.completeIndividualTool(data.toolId, data.result, data.success, data.error);
        break;
    }
  }


  /**
   * Get progressive tool accordions for external updates
   */
  getProgressiveToolAccordions(): Map<string, ProgressiveToolAccordion> {
    return this.progressiveToolAccordions;
  }

  /**
   * Show visual feedback when copy button is clicked
   */
  private showCopyFeedback(button: HTMLElement): void {
    const originalIcon = button.innerHTML;
    const originalTitle = button.getAttribute('title') || '';
    
    // Change to checkmark icon and update tooltip
    setIcon(button, 'check');
    button.setAttribute('title', 'Copied!');
    button.classList.add('copy-success');
    
    // Revert after 1.5 seconds
    setTimeout(() => {
      button.innerHTML = originalIcon;
      button.setAttribute('title', originalTitle);
      button.classList.remove('copy-success');
    }, 1500);
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.stopLoadingAnimation();
    this.progressiveToolAccordions.forEach(accordion => {
      accordion.cleanup();
    });
    this.progressiveToolAccordions.clear();
    
    // Cleanup branch navigator
    if (this.messageBranchNavigator) {
      this.messageBranchNavigator.destroy();
      this.messageBranchNavigator = null;
    }
    
    this.element = null;
  }
}
```

## ui/chat/components/MessageDisplay.ts

```typescript
/**
 * MessageDisplay - Main chat message display area
 * 
 * Shows conversation messages with user/AI bubbles and tool execution displays
 */

import { ConversationData, ConversationMessage } from '../../../types/chat/ChatTypes';
import { MessageBubble } from './MessageBubble';
import { BranchManager } from '../services/BranchManager';
import { App } from 'obsidian';

export class MessageDisplay {
  private conversation: ConversationData | null = null;
  private messageBubbles: MessageBubble[] = [];

  constructor(
    private container: HTMLElement,
    private app: App,
    private branchManager: BranchManager,
    private onRetryMessage?: (messageId: string) => void,
    private onEditMessage?: (messageId: string, newContent: string) => void,
    private onToolEvent?: (messageId: string, event: 'detected' | 'started' | 'completed', data: any) => void,
    private onMessageAlternativeChanged?: (messageId: string, alternativeIndex: number) => void
  ) {
    this.render();
  }

  /**
   * Set conversation to display
   */
  setConversation(conversation: ConversationData): void {
    // Set conversation data
    
    // Check if we're just updating an existing conversation
    if (this.conversation && this.conversation.id === conversation.id) {
      // Same conversation - check if we can avoid full re-render
      
      // Check if any message bubbles have progressive accordions
      const hasProgressiveAccordions = this.messageBubbles.some(bubble => 
        bubble.getProgressiveToolAccordions().size > 0
      );
      
      // For message alternatives, we can preserve progressive accordions since alternatives don't affect structure
      if (hasProgressiveAccordions) {
        // Skip re-render to preserve progressive accordions
        // Just update the conversation data without re-rendering
        this.conversation = conversation;
        this.scrollToBottom();
        return;
      }
    }
    
    // Proceeding with full re-render
    this.conversation = conversation;
    this.render();
    this.scrollToBottom();
  }

  /**
   * Add a user message immediately (for optimistic updates)
   */
  addUserMessage(content: string): void {
    const message: ConversationMessage = {
      id: `temp_${Date.now()}`,
      role: 'user',
      content,
      timestamp: Date.now(),
      conversationId: this.conversation?.id || 'unknown'
    };

    const bubble = this.createMessageBubble(message);
    const messagesContainer = this.container.querySelector('.messages-container');
    if (messagesContainer) {
      messagesContainer.appendChild(bubble);
    }
    this.scrollToBottom();
  }

  /**
   * Add a message immediately using the actual message object (prevents duplicate message creation)
   */
  addMessage(message: ConversationMessage): void {
    console.log('[MessageDisplay] addMessage called with:', {
      messageId: message.id,
      messageRole: message.role,
      messageContent: message.content.substring(0, 30) + '...'
    });
    
    const bubble = this.createMessageBubble(message);
    this.container.querySelector('.messages-container')?.appendChild(bubble);
    this.scrollToBottom();
  }

  /**
   * Add an AI message immediately (for streaming setup)
   */
  addAIMessage(message: ConversationMessage): void {
    const bubble = this.createMessageBubble(message);
    this.container.querySelector('.messages-container')?.appendChild(bubble);
    this.scrollToBottom();
  }

  /**
   * Update a specific message content for final display (streaming handled by StreamingController)
   */
  updateMessageContent(messageId: string, content: string): void {
    // Find the MessageBubble instance for this message ID
    const messageBubble = this.messageBubbles.find(bubble => {
      const element = bubble.getElement();
      return element?.getAttribute('data-message-id') === messageId;
    });

    if (messageBubble) {
      // Use the MessageBubble's updateContent method for final content only
      messageBubble.updateContent(content);
    }
  }

  /**
   * Update a specific message with new data (including tool calls) without full re-render
   */
  updateMessage(messageId: string, updatedMessage: ConversationMessage): void {
    // Update message with new data

    if (!this.conversation) {
      return;
    }

    // Find and update the message in conversation data
    const messageIndex = this.conversation.messages.findIndex(msg => msg.id === messageId);
    // Update conversation data
    
    if (messageIndex !== -1) {
      this.conversation.messages[messageIndex] = updatedMessage;
      // Message updated in conversation
    }

    // Find the MessageBubble instance
    const messageBubble = this.messageBubbles.find(bubble => {
      const element = bubble.getElement();
      return element?.getAttribute('data-message-id') === messageId;
    });

    // Find message bubble for update

    if (messageBubble) {
      // Tell the MessageBubble to re-render with updated message data
      // Update message bubble
      messageBubble.updateWithNewMessage(updatedMessage);
      // Message bubble updated
    }
  }

  /**
   * Escape HTML for safe display
   */
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }


  /**
   * Show welcome state
   */
  showWelcome(): void {
    this.container.empty();
    this.container.addClass('message-display');

    const welcome = this.container.createDiv('chat-welcome');
    welcome.innerHTML = `
      <div class="chat-welcome-content">
        <div class="chat-welcome-icon">üí¨</div>
        <h2>Welcome to AI Chat</h2>
        <p>Start a conversation with your AI assistant. You can:</p>
        <ul>
          <li>Ask questions about your notes</li>
          <li>Create and edit content</li>
          <li>Search and organize your vault</li>
          <li>Get help with any task</li>
        </ul>
        <p>Type a message below to get started!</p>
      </div>
    `;
  }

  /**
   * Render the message display
   */
  private render(): void {
    // Full render - clears existing progressive accordions
    
    this.container.empty();
    this.container.addClass('message-display');

    if (!this.conversation) {
      this.showWelcome();
      return;
    }

    // Create scrollable messages container
    const messagesContainer = this.container.createDiv('messages-container');
    
    // Clear previous message bubbles
    this.messageBubbles = [];

    // Render all messages (no branch filtering needed for message-level alternatives)
    console.log('[MessageDisplay] Rendering conversation messages:', {
      conversationId: this.conversation.id,
      messageCount: this.conversation.messages.length,
      messageBreakdown: this.conversation.messages.reduce((acc, msg) => {
        acc[msg.role] = (acc[msg.role] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      messagesWithToolCalls: this.conversation.messages.filter(msg => msg.toolCalls && msg.toolCalls.length > 0).length,
      toolMessages: this.conversation.messages.filter(msg => msg.role === 'tool').length
    });

    this.conversation.messages.forEach((message, index) => {
      console.log(`[MessageDisplay] Creating bubble for message ${index}:`, {
        id: message.id,
        role: message.role,
        hasToolCalls: !!(message.toolCalls && message.toolCalls.length > 0),
        toolCallCount: message.toolCalls?.length || 0,
        contentPreview: message.content.substring(0, 50) + '...'
      });

      const messageEl = this.createMessageBubble(message);
      messagesContainer.appendChild(messageEl);
    });

    this.scrollToBottom();
  }

  /**
   * Create a message bubble element
   */
  private createMessageBubble(message: ConversationMessage): HTMLElement {
    const bubble = new MessageBubble(
      message,
      this.app,
      (messageId) => this.onCopyMessage(messageId),
      (messageId) => this.handleRetryMessage(messageId),
      (messageId, newContent) => this.handleEditMessage(messageId, newContent),
      this.onToolEvent,
      this.onMessageAlternativeChanged ? (messageId, alternativeIndex) => this.handleMessageAlternativeChanged(messageId, alternativeIndex) : undefined
    );

    this.messageBubbles.push(bubble);
    
    const bubbleEl = bubble.createElement();

    // Tool accordion is now rendered inside MessageBubble's content area

    return bubbleEl;
  }

  /**
   * Handle copy message action
   */
  private onCopyMessage(messageId: string): void {
    const message = this.findMessage(messageId);
    if (message) {
      navigator.clipboard.writeText(message.content).then(() => {
        // Message copied to clipboard
      }).catch(err => {
        // Failed to copy message
      });
    }
  }

  /**
   * Handle retry message action
   */
  private handleRetryMessage(messageId: string): void {
    if (this.onRetryMessage) {
      this.onRetryMessage(messageId);
    }
  }

  /**
   * Handle edit message action
   */
  private handleEditMessage(messageId: string, newContent: string): void {
    if (this.onEditMessage) {
      this.onEditMessage(messageId, newContent);
    }
  }

  /**
   * Handle message alternative changed action
   */
  private handleMessageAlternativeChanged(messageId: string, alternativeIndex: number): void {
    if (this.onMessageAlternativeChanged) {
      this.onMessageAlternativeChanged(messageId, alternativeIndex);
    }
  }

  /**
   * Find message by ID
   */
  private findMessage(messageId: string): ConversationMessage | undefined {
    return this.conversation?.messages.find(msg => msg.id === messageId);
  }

  /**
   * Find MessageBubble by messageId for tool events
   */
  findMessageBubble(messageId: string): MessageBubble | undefined {
    if (!this.conversation) return undefined;
    
    const messageIndex = this.conversation.messages.findIndex(msg => msg.id === messageId);
    if (messageIndex === -1) return undefined;
    
    // MessageBubbles are created in same order as messages
    return this.messageBubbles[messageIndex];
  }

  /**
   * Update MessageBubble with new message ID (for handling temporary -> real ID updates)
   */
  updateMessageId(oldId: string, newId: string, updatedMessage: ConversationMessage): void {
    // Find the MessageBubble that was created with the old (temporary) ID
    const messageBubble = this.messageBubbles.find(bubble => {
      const element = bubble.getElement();
      return element?.getAttribute('data-message-id') === oldId;
    });

    if (messageBubble) {
      console.log('[MessageDisplay] Updating MessageBubble ID:', { from: oldId, to: newId });
      
      // Update the MessageBubble's message reference and DOM attribute
      messageBubble.updateWithNewMessage(updatedMessage);
      
      // Update the DOM attribute to reflect the new ID
      const element = messageBubble.getElement();
      if (element) {
        element.setAttribute('data-message-id', newId);
      }
    } else {
      console.log('[MessageDisplay] Could not find MessageBubble with old ID:', oldId);
    }
  }

  /**
   * Check if any message bubbles have progressive tool accordions
   */
  hasProgressiveToolAccordions(): boolean {
    return this.messageBubbles.some(bubble => 
      bubble.getProgressiveToolAccordions().size > 0
    );
  }

  /**
   * Scroll to bottom of messages
   */
  private scrollToBottom(): void {
    const messagesContainer = this.container.querySelector('.messages-container');
    if (messagesContainer) {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.messageBubbles.forEach(bubble => bubble.cleanup());
    this.messageBubbles = [];
  }
}
```

## ui/chat/components/ModelSelector.ts

```typescript
/**
 * ModelSelector - Dropdown for selecting LLM models from validated providers
 * 
 * Displays available models from providers that have valid API keys.
 * Updates the chat service with the selected model for subsequent requests.
 */

export interface ModelOption {
  providerId: string;
  providerName: string;
  modelId: string;
  modelName: string;
  contextWindow: number;
}

export class ModelSelector {
  private element: HTMLElement | null = null;
  private selectElement: HTMLSelectElement | null = null;
  private currentModel: ModelOption | null = null;

  constructor(
    private container: HTMLElement,
    private onModelChange: (model: ModelOption) => void,
    private getAvailableModels: () => Promise<ModelOption[]>,
    private getDefaultModel?: () => Promise<{ provider: string; model: string }>
  ) {
    this.render();
  }

  /**
   * Render the model selector dropdown
   */
  private async render(): Promise<void> {
    this.container.empty();
    this.container.addClass('model-selector');

    // Label
    const label = this.container.createDiv('model-selector-label');
    label.textContent = 'Model:';

    // Dropdown container
    const dropdownContainer = this.container.createDiv('model-selector-dropdown');
    
    this.selectElement = dropdownContainer.createEl('select', {
      cls: 'model-select'
    });

    // Add default option
    const defaultOption = this.selectElement.createEl('option', {
      value: '',
      text: 'Loading models...'
    });
    defaultOption.disabled = true;
    defaultOption.selected = true;

    // Load and populate models
    await this.loadModels();

    // Handle selection changes
    this.selectElement.addEventListener('change', () => {
      this.handleModelChange();
    });

    this.element = this.container;
  }

  /**
   * Load available models from validated providers
   */
  private async loadModels(): Promise<void> {
    if (!this.selectElement) return;

    try {
      const models = await this.getAvailableModels();
      
      // Clear loading option
      this.selectElement.innerHTML = '';
      
      if (models.length === 0) {
        const noModelsOption = this.selectElement.createEl('option', {
          value: '',
          text: 'No models available'
        });
        noModelsOption.disabled = true;
        noModelsOption.selected = true;
        return;
      }

      // Add default selection option
      const defaultOption = this.selectElement.createEl('option', {
        value: '',
        text: 'Select model...'
      });

      // Group models by provider
      const modelsByProvider = new Map<string, ModelOption[]>();
      models.forEach(model => {
        if (!modelsByProvider.has(model.providerId)) {
          modelsByProvider.set(model.providerId, []);
        }
        modelsByProvider.get(model.providerId)!.push(model);
      });

      // Add models grouped by provider
      modelsByProvider.forEach((providerModels, providerId) => {
        const optgroup = this.selectElement!.createEl('optgroup', {
          attr: { label: providerModels[0].providerName }
        });

        providerModels.forEach(model => {
          const option = optgroup.createEl('option', {
            value: `${model.providerId}:${model.modelId}`,
            text: `${model.modelName} (${Math.round(model.contextWindow / 1000)}k)`
          });
        });
      });

      // Select configured default model or first model as fallback
      if (models.length > 0) {
        let defaultModel = models[0]; // Fallback to first model

        // Try to get configured default model
        if (this.getDefaultModel) {
          try {
            const configuredDefault = await this.getDefaultModel();
            const foundDefault = models.find(
              m => m.providerId === configuredDefault.provider && 
                   m.modelId === configuredDefault.model
            );
            if (foundDefault) {
              defaultModel = foundDefault;
            } else {
              console.warn('[ModelSelector] Configured default model not found in available models:', configuredDefault);
            }
          } catch (error) {
            console.warn('[ModelSelector] Failed to get configured default model:', error);
          }
        }

        this.selectElement.value = `${defaultModel.providerId}:${defaultModel.modelId}`;
        this.currentModel = defaultModel;
        this.onModelChange(defaultModel);
      }

    } catch (error) {
      console.error('[ModelSelector] Failed to load models:', error);
      
      if (this.selectElement) {
        this.selectElement.innerHTML = '';
        const errorOption = this.selectElement.createEl('option', {
          value: '',
          text: 'Error loading models'
        });
        errorOption.disabled = true;
        errorOption.selected = true;
      }
    }
  }

  /**
   * Handle model selection change
   */
  private handleModelChange(): void {
    if (!this.selectElement) return;

    const selectedValue = this.selectElement.value;
    if (!selectedValue) return;

    const [providerId, modelId] = selectedValue.split(':');
    
    // Find the selected model
    this.getAvailableModels().then(models => {
      const selectedModel = models.find(
        m => m.providerId === providerId && m.modelId === modelId
      );
      
      if (selectedModel) {
        this.currentModel = selectedModel;
        this.onModelChange(selectedModel);
      }
    });
  }

  /**
   * Get currently selected model
   */
  getCurrentModel(): ModelOption | null {
    return this.currentModel;
  }

  /**
   * Set the selected model programmatically
   */
  setModel(providerId: string, modelId: string): void {
    if (!this.selectElement) return;

    const value = `${providerId}:${modelId}`;
    const option = this.selectElement.querySelector(`option[value="${value}"]`);
    
    if (option) {
      this.selectElement.value = value;
      this.handleModelChange();
    }
  }

  /**
   * Refresh the model list
   */
  async refresh(): Promise<void> {
    await this.loadModels();
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.element = null;
    this.selectElement = null;
    this.currentModel = null;
  }
}
```

## ui/chat/components/ProgressiveToolAccordion.ts

```typescript
/**
 * ProgressiveToolAccordion - Real-time tool execution display
 * 
 * Shows tool execution progress in real-time with visual feedback:
 * - Shows tools as they start executing (glow effect)
 * - Updates with results as they complete
 * - Provides rich visual feedback during execution
 */

export interface ProgressiveToolCall {
  id: string;
  name: string;
  parameters?: any;
  status: 'pending' | 'executing' | 'completed' | 'failed';
  result?: any;
  error?: string;
  executionTime?: number;
  startTime?: number;
}

export class ProgressiveToolAccordion {
  private element: HTMLElement | null = null;
  private isExpanded = false;
  private tools: ProgressiveToolCall[] = [];

  constructor() {}

  /**
   * Create the progressive tool accordion element
   */
  createElement(): HTMLElement {
    const accordion = document.createElement('div');
    accordion.addClass('progressive-tool-accordion');

    // Header with summary (initially hidden until first tool)
    const header = accordion.createDiv('progressive-tool-header');
    header.addEventListener('click', () => this.toggle());
    header.style.display = 'none'; // Hidden until first tool starts

    // Status summary
    const summary = header.createDiv('tool-summary');
    
    // Icon (will update based on status)
    const icon = summary.createSpan('tool-icon');
    
    // Text (will update as tools execute)
    const text = summary.createSpan('tool-text');
    
    // Expand indicator
    const expandIcon = header.createDiv('tool-expand-icon');
    expandIcon.textContent = '‚ñ∂';

    // Content (initially hidden)
    const content = accordion.createDiv('progressive-tool-content');
    content.style.display = 'none';

    this.element = accordion;
    return accordion;
  }

  /**
   * Start executing a tool - shows it immediately with glow effect
   */
  startTool(toolCall: { id: string; name: string; parameters?: any }): void {
    console.log('[ProgressiveToolAccordion] Starting tool:', toolCall.name);
    
    const progressiveTool: ProgressiveToolCall = {
      id: toolCall.id,
      name: toolCall.name,
      parameters: toolCall.parameters,
      status: 'executing',
      startTime: Date.now()
    };

    this.tools.push(progressiveTool);
    this.updateDisplay();
    this.renderToolItem(progressiveTool);
  }

  /**
   * Complete a tool execution with results
   */
  completeTool(toolId: string, result: any, success: boolean, error?: string): void {
    console.log('[ProgressiveToolAccordion] Completing tool:', toolId);
    
    const tool = this.tools.find(t => t.id === toolId);
    if (!tool) return;

    tool.status = success ? 'completed' : 'failed';
    tool.result = result;
    tool.error = error;
    if (tool.startTime) {
      tool.executionTime = Date.now() - tool.startTime;
    }

    this.updateDisplay();
    this.updateToolItem(tool);
  }

  /**
   * Update the header display based on current tools
   */
  private updateDisplay(): void {
    if (!this.element) return;

    const header = this.element.querySelector('.progressive-tool-header') as HTMLElement;
    const icon = this.element.querySelector('.tool-icon') as HTMLElement;
    const text = this.element.querySelector('.tool-text') as HTMLElement;

    if (this.tools.length === 0) {
      header.style.display = 'none';
      return;
    }

    header.style.display = 'flex';

    const executing = this.tools.filter(t => t.status === 'executing');
    const completed = this.tools.filter(t => t.status === 'completed');
    const failed = this.tools.filter(t => t.status === 'failed');
    const total = this.tools.length;

    // Update icon based on status
    if (executing.length > 0) {
      icon.innerHTML = 'üîÑ'; // Executing
      icon.addClass('tool-executing');
      header.addClass('tool-executing');
    } else if (failed.length > 0) {
      icon.innerHTML = '‚ö†Ô∏è'; // Some failed
      icon.removeClass('tool-executing');
      header.removeClass('tool-executing');
    } else {
      icon.innerHTML = '‚úÖ'; // All completed
      icon.removeClass('tool-executing');
      header.removeClass('tool-executing');
    }

    // Update text based on tool names and status
    if (total === 1) {
      const tool = this.tools[0];
      if (tool.status === 'executing') {
        text.textContent = `${tool.name} (running...)`;
      } else {
        text.textContent = tool.name;
      }
    } else {
      const runningTools = executing.map(t => t.name).slice(0, 2);
      if (executing.length > 0) {
        if (executing.length === 1) {
          text.textContent = `${runningTools[0]} (running...) +${total - 1} more`;
        } else {
          text.textContent = `${runningTools.join(', ')} +${total - 2} more (running...)`;
        }
      } else {
        const toolNames = this.tools.map(t => t.name).slice(0, 2);
        const remaining = total - 2;
        if (remaining > 0) {
          text.textContent = `${toolNames.join(', ')} +${remaining} more`;
        } else {
          text.textContent = toolNames.join(', ');
        }
      }
    }
  }

  /**
   * Render individual tool execution item
   */
  private renderToolItem(tool: ProgressiveToolCall): void {
    if (!this.element) return;

    const content = this.element.querySelector('.progressive-tool-content') as HTMLElement;
    
    const item = document.createElement('div');
    item.addClass('progressive-tool-item');
    item.addClass(`tool-${tool.status}`);
    item.setAttribute('data-tool-id', tool.id);

    // Tool header
    const header = item.createDiv('progressive-tool-header-item');
    
    // Status indicator
    const statusIcon = header.createSpan('tool-status-icon');
    this.updateStatusIcon(statusIcon, tool.status);
    
    // Tool name
    const name = header.createSpan('tool-name');
    name.textContent = tool.name;
    
    // Execution info
    const meta = header.createSpan('tool-meta');
    this.updateExecutionMeta(meta, tool);

    // Parameters section (collapsible)
    if (tool.parameters && Object.keys(tool.parameters).length > 0) {
      const paramsSection = item.createDiv('tool-section');
      const paramsHeader = paramsSection.createDiv('tool-section-header');
      paramsHeader.textContent = 'Parameters:';
      
      const paramsContent = paramsSection.createEl('pre', { cls: 'tool-code' });
      paramsContent.textContent = JSON.stringify(tool.parameters, null, 2);
    }

    // Result section (will be filled when completed)
    const resultSection = item.createDiv('tool-section tool-result-section');
    resultSection.setAttribute('data-result-section', tool.id);
    resultSection.style.display = 'none'; // Hidden until completed

    // Error section (will be shown if failed)
    const errorSection = item.createDiv('tool-section tool-error-section');
    errorSection.setAttribute('data-error-section', tool.id);
    errorSection.style.display = 'none'; // Hidden unless failed

    content.appendChild(item);
  }

  /**
   * Update existing tool item when execution completes
   */
  private updateToolItem(tool: ProgressiveToolCall): void {
    if (!this.element) return;

    const item = this.element.querySelector(`[data-tool-id="${tool.id}"]`) as HTMLElement;
    if (!item) return;

    // Update status classes
    item.className = item.className.replace(/tool-(pending|executing|completed|failed)/g, '');
    item.addClass(`tool-${tool.status}`);

    // Update status icon
    const statusIcon = item.querySelector('.tool-status-icon') as HTMLElement;
    this.updateStatusIcon(statusIcon, tool.status);

    // Update execution meta
    const meta = item.querySelector('.tool-meta') as HTMLElement;
    this.updateExecutionMeta(meta, tool);

    // Show result section if completed successfully
    if (tool.status === 'completed' && tool.result) {
      const resultSection = item.querySelector(`[data-result-section="${tool.id}"]`) as HTMLElement;
      resultSection.style.display = 'block';
      
      const resultHeader = resultSection.createDiv('tool-section-header');
      resultHeader.textContent = 'Result:';
      
      const resultContent = resultSection.createEl('pre', { cls: 'tool-code' });
      if (typeof tool.result === 'string') {
        resultContent.textContent = tool.result;
      } else {
        resultContent.textContent = JSON.stringify(tool.result, null, 2);
      }
    }

    // Show error section if failed
    if (tool.status === 'failed' && tool.error) {
      const errorSection = item.querySelector(`[data-error-section="${tool.id}"]`) as HTMLElement;
      errorSection.style.display = 'block';
      
      const errorHeader = errorSection.createDiv('tool-section-header');
      errorHeader.textContent = 'Error:';
      
      const errorContent = errorSection.createDiv('tool-error-content');
      errorContent.textContent = tool.error;
    }
  }

  /**
   * Update status icon based on tool status
   */
  private updateStatusIcon(iconElement: HTMLElement, status: string): void {
    switch (status) {
      case 'pending':
        iconElement.textContent = '‚è≥';
        break;
      case 'executing':
        iconElement.innerHTML = 'üîÑ';
        iconElement.addClass('spinning');
        break;
      case 'completed':
        iconElement.textContent = '‚úÖ';
        iconElement.removeClass('spinning');
        break;
      case 'failed':
        iconElement.textContent = '‚ùå';
        iconElement.removeClass('spinning');
        break;
    }
  }

  /**
   * Update execution metadata display
   */
  private updateExecutionMeta(metaElement: HTMLElement, tool: ProgressiveToolCall): void {
    switch (tool.status) {
      case 'executing':
        if (tool.startTime) {
          const elapsed = Date.now() - tool.startTime;
          metaElement.textContent = `${Math.round(elapsed / 100) / 10}s`;
        }
        break;
      case 'completed':
      case 'failed':
        if (tool.executionTime) {
          metaElement.textContent = `${tool.executionTime}ms`;
        }
        break;
    }
  }

  /**
   * Toggle accordion expansion
   */
  private toggle(): void {
    if (!this.element) return;

    this.isExpanded = !this.isExpanded;
    
    const content = this.element.querySelector('.progressive-tool-content') as HTMLElement;
    const expandIcon = this.element.querySelector('.tool-expand-icon') as HTMLElement;
    
    if (this.isExpanded) {
      content.style.display = 'block';
      expandIcon.textContent = '‚ñº';
      this.element.addClass('expanded');
    } else {
      content.style.display = 'none';
      expandIcon.textContent = '‚ñ∂';
      this.element.removeClass('expanded');
    }
  }

  /**
   * Get the DOM element
   */
  getElement(): HTMLElement | null {
    return this.element;
  }

  /**
   * Get current tool status summary
   */
  getToolSummary(): { total: number; executing: number; completed: number; failed: number } {
    return {
      total: this.tools.length,
      executing: this.tools.filter(t => t.status === 'executing').length,
      completed: this.tools.filter(t => t.status === 'completed').length,
      failed: this.tools.filter(t => t.status === 'failed').length
    };
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.tools = [];
    this.element = null;
  }
}
```

## ui/chat/components/ToolAccordion.ts

```typescript
/**
 * ToolAccordion - Expandable display for tool executions
 * 
 * Shows tool calls and results in an accordion format
 */

import { ToolCall } from '../../../types/chat/ChatTypes';

export class ToolAccordion {
  private element: HTMLElement | null = null;
  private isExpanded = false;

  constructor(private toolCalls: ToolCall[]) {}

  /**
   * Create the tool accordion element
   */
  createElement(): HTMLElement {
    const accordion = document.createElement('div');
    accordion.addClass('tool-accordion');

    // Header with summary
    const header = accordion.createDiv('tool-accordion-header');
    header.addEventListener('click', () => this.toggle());

    // Tool count and status
    const summary = header.createDiv('tool-summary');
    const successCount = this.toolCalls.filter(tool => tool.success).length;
    const totalCount = this.toolCalls.length;
    
    const status = successCount === totalCount ? 'success' : 'partial';
    summary.addClass(`tool-status-${status}`);
    
    // Icon
    const icon = summary.createSpan('tool-icon');
    icon.textContent = status === 'success' ? '‚úÖ' : '‚ö†Ô∏è';
    
    // Text
    const text = summary.createSpan('tool-text');
    if (totalCount === 1) {
      text.textContent = this.toolCalls[0].name || null;
    } else {
      const toolNames = this.toolCalls.map(tc => tc.name).slice(0, 2);
      const remaining = totalCount - 2;
      if (remaining > 0) {
        text.textContent = `${toolNames.join(', ')} +${remaining} more`;
      } else {
        text.textContent = toolNames.join(', ');
      }
    }
    
    // Expand indicator
    const expandIcon = header.createDiv('tool-expand-icon');
    expandIcon.textContent = '‚ñ∂';

    // Content (initially hidden)
    const content = accordion.createDiv('tool-accordion-content');
    content.style.display = 'none';

    // Render tool calls
    this.toolCalls.forEach((toolCall, index) => {
      const toolItem = this.createToolCallItem(toolCall, index);
      content.appendChild(toolItem);
    });

    this.element = accordion;
    return accordion;
  }

  /**
   * Create individual tool call display
   */
  private createToolCallItem(toolCall: ToolCall, index: number): HTMLElement {
    const item = document.createElement('div');
    item.addClass('tool-call-item');
    item.addClass(toolCall.success ? 'tool-success' : 'tool-error');

    // Tool header
    const header = item.createDiv('tool-call-header');
    
    // Status indicator
    const statusIcon = header.createSpan('tool-status-icon');
    statusIcon.textContent = toolCall.success ? '‚úÖ' : '‚ùå';
    
    // Tool name
    const name = header.createSpan('tool-name');
    name.textContent = toolCall.name || null;
    
    // Execution time (if available) 
    if (toolCall.executionTime) {
      const meta = header.createSpan('tool-meta');
      meta.textContent = `${toolCall.executionTime}ms`;
    }

    // Parameters section
    if (toolCall.parameters && Object.keys(toolCall.parameters).length > 0) {
      const paramsSection = item.createDiv('tool-section');
      const paramsHeader = paramsSection.createDiv('tool-section-header');
      paramsHeader.textContent = 'Parameters:';
      
      const paramsContent = paramsSection.createEl('pre', { cls: 'tool-code' });
      paramsContent.textContent = JSON.stringify(toolCall.parameters, null, 2);
    }

    // Result section
    if (toolCall.result) {
      const resultSection = item.createDiv('tool-section');
      const resultHeader = resultSection.createDiv('tool-section-header');
      resultHeader.textContent = 'Result:';
      
      const resultContent = resultSection.createEl('pre', { cls: 'tool-code' });
      
      // Format result based on type
      if (typeof toolCall.result === 'string') {
        resultContent.textContent = toolCall.result;
      } else {
        resultContent.textContent = JSON.stringify(toolCall.result, null, 2);
      }
    }

    // Error section
    if (!toolCall.success && toolCall.error) {
      const errorSection = item.createDiv('tool-section tool-error-section');
      const errorHeader = errorSection.createDiv('tool-section-header');
      errorHeader.textContent = 'Error:';
      
      const errorContent = errorSection.createDiv('tool-error-content');
      errorContent.textContent = toolCall.error;
    }

    return item;
  }

  /**
   * Toggle accordion expansion
   */
  private toggle(): void {
    if (!this.element) return;

    this.isExpanded = !this.isExpanded;
    
    const content = this.element.querySelector('.tool-accordion-content') as HTMLElement;
    const expandIcon = this.element.querySelector('.tool-expand-icon') as HTMLElement;
    
    if (this.isExpanded) {
      content.style.display = 'block';
      expandIcon.textContent = '‚ñº';
      this.element.addClass('expanded');
    } else {
      content.style.display = 'none';
      expandIcon.textContent = '‚ñ∂';
      this.element.removeClass('expanded');
    }
  }

  /**
   * Get the DOM element
   */
  getElement(): HTMLElement | null {
    return this.element;
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.element = null;
  }
}
```

## ui/chat/controllers/StreamingController.ts

```typescript
/**
 * StreamingController - Handles all streaming-related UI updates and animations
 * Now with streaming-markdown integration for progressive markdown rendering
 */

import { MarkdownRenderer } from '../utils/MarkdownRenderer';
import { App, Component } from 'obsidian';

export interface StreamingControllerEvents {
  onAnimationStarted: (messageId: string) => void;
  onAnimationStopped: (messageId: string) => void;
}

export class StreamingController {
  private activeAnimations = new Map<string, any>(); // messageId -> intervalId
  private streamingStates = new Map<string, any>(); // messageId -> streaming-markdown state

  constructor(
    private containerEl: HTMLElement,
    private app: App,
    private component: Component,
    private events?: StreamingControllerEvents
  ) {}

  /**
   * Show loading animation for AI response
   */
  showAILoadingState(messageId: string): void {
    // Find the message element and add loading animation
    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
      const contentElement = messageElement.querySelector('.message-bubble .message-content');
      if (contentElement) {
        contentElement.innerHTML = '<span class="ai-loading">Thinking<span class="dots">...</span></span>';
        this.startLoadingAnimation(contentElement);
      }
    }
  }

  /**
   * Start streaming for a message (initialize streaming-markdown parser)
   */
  startStreaming(messageId: string): void {
    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    
    if (messageElement) {
      const contentElement = messageElement.querySelector('.message-bubble .message-content');
      
      if (contentElement) {
        // Stop loading animation
        this.stopLoadingAnimation(contentElement);
        
        // Initialize streaming-markdown parser for this message
        const streamingState = MarkdownRenderer.initializeStreamingParser(contentElement as HTMLElement);
        this.streamingStates.set(messageId, streamingState);
        
      } else {
        console.warn(`[StreamingController] Content element not found for message ${messageId}`);
      }
    } else {
      console.warn(`[StreamingController] Message element not found for messageId: ${messageId}`);
    }
  }

  /**
   * Update streaming message with new chunk (progressive rendering)
   */
  updateStreamingChunk(messageId: string, chunk: string): void {
    const streamingState = this.streamingStates.get(messageId);
    
    if (streamingState) {
      
      MarkdownRenderer.writeStreamingChunk(streamingState, chunk);
    } else {
      console.warn(`[StreamingController] No streaming state found for message ${messageId}`);
      // Initialize streaming if we missed the start
      this.startStreaming(messageId);
      // Try again
      const newStreamingState = this.streamingStates.get(messageId);
      if (newStreamingState) {
        MarkdownRenderer.writeStreamingChunk(newStreamingState, chunk);
      }
    }
  }

  /**
   * Finalize streaming for a message (switch to final Obsidian rendering if needed)
   */
  finalizeStreaming(messageId: string, finalContent: string): void {
    const streamingState = this.streamingStates.get(messageId);
    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    
    if (streamingState && messageElement) {
      const contentElement = messageElement.querySelector('.message-bubble .message-content');
      
      if (contentElement) {
        
        MarkdownRenderer.finalizeStreamingContent(
          streamingState,
          finalContent,
          contentElement as HTMLElement,
          this.app,
          this.component
        ).then(() => {
          // Clean up streaming state
          this.streamingStates.delete(messageId);
        }).catch(error => {
          console.error('[StreamingController] Error finalizing streaming:', error);
          // Clean up anyway
          this.streamingStates.delete(messageId);
        });
      }
    } else {
      console.warn(`[StreamingController] Cannot finalize - no streaming state or element for ${messageId}`);
    }
  }

  /**
   * Start loading animation (animated dots)
   */
  startLoadingAnimation(element: Element): void {
    const dotsElement = element.querySelector('.dots');
    if (dotsElement) {
      let dotCount = 0;
      const interval = setInterval(() => {
        dotCount = (dotCount + 1) % 4;
        dotsElement.textContent = '.'.repeat(dotCount);
      }, 500);
      
      // Store interval ID for cleanup
      const messageId = this.getMessageIdFromElement(element);
      if (messageId) {
        this.activeAnimations.set(messageId, interval);
        this.events?.onAnimationStarted(messageId);
      }
      
      // Also store on element for backward compatibility
      (element as any)._loadingInterval = interval as any;
    }
  }

  /**
   * Stop loading animation
   */
  stopLoadingAnimation(element: Element): void {
    // Clean up from element storage (backward compatibility)
    const elementInterval = (element as any)._loadingInterval;
    if (elementInterval) {
      clearInterval(elementInterval);
      delete (element as any)._loadingInterval;
    }

    // Clean up from our tracking
    const messageId = this.getMessageIdFromElement(element);
    if (messageId) {
      const interval = this.activeAnimations.get(messageId);
      if (interval) {
        clearInterval(interval);
        this.activeAnimations.delete(messageId);
        this.events?.onAnimationStopped(messageId);
      }
    }
  }

  /**
   * Stop all active animations
   */
  stopAllAnimations(): void {
    this.activeAnimations.forEach((interval, messageId) => {
      clearInterval(interval);
      this.events?.onAnimationStopped(messageId);
    });
    this.activeAnimations.clear();
  }

  /**
   * Remove loading message from UI
   */
  removeLoadingMessage(messageId: string): void {
    console.log(`[StreamingController] Removing loading message: ${messageId}`);
    
    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
      // Stop any active animation for this message
      const contentElement = messageElement.querySelector('.message-bubble .message-content');
      if (contentElement) {
        this.stopLoadingAnimation(contentElement);
      }
      
      // Remove the message element
      messageElement.remove();
    }

    // Clean up from our tracking
    const interval = this.activeAnimations.get(messageId);
    if (interval) {
      clearInterval(interval);
      this.activeAnimations.delete(messageId);
    }
  }

  /**
   * Get message ID from an element by traversing up the DOM
   */
  private getMessageIdFromElement(element: Element): string | null {
    let current = element as Element | null;
    while (current) {
      const messageId = current.getAttribute('data-message-id');
      if (messageId) {
        return messageId;
      }
      current = current.parentElement;
    }
    return null;
  }

  /**
   * Escape HTML for safe display
   */
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Get active animation count (for debugging/monitoring)
   */
  getActiveAnimationCount(): number {
    return this.activeAnimations.size;
  }

  /**
   * Cleanup all resources
   */
  cleanup(): void {
    this.stopAllAnimations();
    // Clean up streaming states
    this.streamingStates.clear();
  }
}
```

## ui/chat/controllers/UIStateController.ts

```typescript
/**
 * UIStateController - Manages all UI state transitions and visual feedback
 */

export interface UIStateControllerEvents {
  onSidebarToggled: (visible: boolean) => void;
}

export class UIStateController {
  private sidebarVisible = false;

  constructor(
    private containerEl: HTMLElement,
    private events: UIStateControllerEvents
  ) {}

  /**
   * Get sidebar visibility state
   */
  getSidebarVisible(): boolean {
    return this.sidebarVisible;
  }

  /**
   * Show welcome state when no conversation is selected
   */
  showWelcomeState(): void {
    const messageDisplay = this.containerEl.querySelector('.message-display-container');
    if (!messageDisplay) return;

    messageDisplay.empty();
    messageDisplay.addClass('message-display');

    const welcome = messageDisplay.createDiv('chat-welcome');
    welcome.innerHTML = `
      <div class="chat-welcome-content">
        <div class="chat-welcome-icon">üí¨</div>
        <h2>Welcome to AI Chat</h2>
        <p>Start a conversation with your AI assistant. You can:</p>
        <ul>
          <li>Ask questions about your notes</li>
          <li>Create and edit content</li>
          <li>Search and organize your vault</li>
          <li>Get help with any task</li>
        </ul>
        <p>Type a message below to get started!</p>
      </div>
    `;
  }

  /**
   * Show chat state when conversation is selected
   */
  showChatState(): void {
    // Chat state is handled by MessageDisplay component
    // This method exists for state management consistency
  }

  /**
   * Toggle conversation list visibility
   */
  toggleConversationList(): void {
    const sidebar = this.containerEl.querySelector('.chat-sidebar');
    const backdrop = this.containerEl.querySelector('.chat-backdrop');
    if (!sidebar || !backdrop) return;
    
    this.sidebarVisible = !this.sidebarVisible;
    
    if (this.sidebarVisible) {
      sidebar.removeClass('chat-sidebar-hidden');
      sidebar.addClass('chat-sidebar-visible');
      backdrop.addClass('chat-backdrop-visible');
    } else {
      sidebar.removeClass('chat-sidebar-visible');
      sidebar.addClass('chat-sidebar-hidden');
      backdrop.removeClass('chat-backdrop-visible');
    }

    this.events.onSidebarToggled(this.sidebarVisible);
  }

  /**
   * Show error message with auto-dismiss
   */
  showError(message: string): void {
    // Create a temporary error display
    const container = this.containerEl.querySelector('.message-display-container');
    if (container) {
      const errorEl = container.createDiv('chat-error');
      errorEl.textContent = message;
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        errorEl.remove();
      }, 5000);
    }
  }

  /**
   * Set loading state on chat input
   */
  setInputLoading(loading: boolean): void {
    const chatInput = this.containerEl.querySelector('.chat-input-container');
    if (chatInput) {
      const textarea = chatInput.querySelector('.chat-textarea') as HTMLTextAreaElement;
      const sendButton = chatInput.querySelector('.chat-send-button') as HTMLButtonElement;
      
      if (textarea && sendButton) {
        textarea.disabled = loading;
        sendButton.disabled = loading;
        
        if (loading) {
          sendButton.innerHTML = '<svg class="chat-loading-spinner" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="m12 6-4 4 4 4"/></svg>';
        } else {
          sendButton.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>';
        }
      }
    }
  }

  /**
   * Set input placeholder text
   */
  setInputPlaceholder(placeholder: string): void {
    const textarea = this.containerEl.querySelector('.chat-textarea') as HTMLTextAreaElement;
    if (textarea) {
      textarea.placeholder = placeholder;
    }
  }

  /**
   * Update context progress display
   */
  updateContextProgress(): void {
    // This will be handled by the ContextProgressBar component
    // Method exists for consistency with the original ChatView interface
  }

  /**
   * Initialize UI event listeners
   */
  initializeEventListeners(): void {
    // Hamburger menu button
    const hamburgerButton = this.containerEl.querySelector('.chat-hamburger-button');
    if (hamburgerButton) {
      hamburgerButton.addEventListener('click', () => this.toggleConversationList());
    }

    // Backdrop click to close sidebar
    const backdrop = this.containerEl.querySelector('.chat-backdrop');
    if (backdrop) {
      backdrop.addEventListener('click', () => {
        if (this.sidebarVisible) {
          this.toggleConversationList();
        }
      });
    }
  }

  /**
   * Clean up event listeners
   */
  cleanup(): void {
    // Remove event listeners if needed
    // Most listeners are attached to elements that will be removed with the container
  }
}
```

## ui/chat/services/BranchManager.ts

```typescript
/**
 * BranchManager - Handles message-level alternative operations
 * 
 * Manages creating and switching between alternative responses for individual messages
 * instead of conversation-level branching.
 */

// import { ConversationRepository } from '../../../database/services/chat/ConversationRepository';
type ConversationRepository = any;
import { ConversationData, ConversationMessage } from '../../../types/chat/ChatTypes';

export interface BranchManagerEvents {
  onMessageAlternativeCreated: (messageId: string, alternativeIndex: number) => void;
  onMessageAlternativeSwitched: (messageId: string, alternativeIndex: number) => void;
  onError: (message: string) => void;
}

export class BranchManager {
  constructor(
    private conversationRepo: ConversationRepository,
    private events: BranchManagerEvents
  ) {}

  /**
   * Create an alternative response for a specific message
   */
  async createMessageAlternative(
    conversation: ConversationData,
    messageId: string,
    alternativeResponse: ConversationMessage
  ): Promise<number | null> {
    try {
      console.log('[BranchManager] Creating message alternative:', {
        conversationId: conversation.id,
        messageId,
        alternativeContent: alternativeResponse.content.substring(0, 50) + '...'
      });

      // Find the message in the conversation
      const messageIndex = conversation.messages.findIndex(msg => msg.id === messageId);
      if (messageIndex === -1) {
        console.error('[BranchManager] Message not found:', messageId);
        return null;
      }

      const message = conversation.messages[messageIndex];
      
      // Initialize alternatives array if it doesn't exist
      if (!message.alternatives) {
        message.alternatives = [];
      }

      // Add the new alternative
      message.alternatives.push(alternativeResponse);
      const alternativeIndex = message.alternatives.length - 1;

      // Set the new alternative as active
      message.activeAlternativeIndex = alternativeIndex + 1; // +1 because 0 is the original message

      // Save the updated conversation to repository
      await this.conversationRepo.updateConversation(conversation.id, { messages: conversation.messages });

      console.log('[BranchManager] Message alternative created successfully:', {
        messageId,
        alternativeIndex: alternativeIndex + 1,
        totalAlternatives: message.alternatives.length + 1 // +1 for original
      });

      this.events.onMessageAlternativeCreated(messageId, alternativeIndex + 1);
      return alternativeIndex + 1;

    } catch (error) {
      console.error('[BranchManager] Failed to create message alternative:', error);
      this.events.onError('Failed to create alternative response');
      return null;
    }
  }

  /**
   * Switch to a specific alternative for a message
   */
  async switchToMessageAlternative(
    conversation: ConversationData,
    messageId: string,
    alternativeIndex: number
  ): Promise<boolean> {
    try {
      console.log('[BranchManager] Switching message alternative:', {
        conversationId: conversation.id,
        messageId,
        alternativeIndex
      });

      // Find the message in the conversation
      const messageIndex = conversation.messages.findIndex(msg => msg.id === messageId);
      if (messageIndex === -1) {
        console.error('[BranchManager] Message not found:', messageId);
        return false;
      }

      const message = conversation.messages[messageIndex];
      const totalAlternatives = this.getMessageAlternativeCount(message);

      // Validate alternative index
      if (alternativeIndex < 0 || alternativeIndex >= totalAlternatives) {
        console.error('[BranchManager] Invalid alternative index:', { alternativeIndex, totalAlternatives });
        return false;
      }

      // Update the active alternative index
      message.activeAlternativeIndex = alternativeIndex;

      // Save the updated conversation to repository
      await this.conversationRepo.updateConversation(conversation.id, { messages: conversation.messages });

      console.log('[BranchManager] Switched to message alternative:', {
        messageId,
        alternativeIndex,
        totalAlternatives
      });

      // Don't emit event here - ChatView handles this directly to avoid recursion
      return true;

    } catch (error) {
      console.error('[BranchManager] Failed to switch message alternative:', error);
      this.events.onError('Failed to switch to alternative response');
      return false;
    }
  }

  /**
   * Get the currently active message content (original or alternative)
   */
  getActiveMessageContent(message: ConversationMessage): string {
    const activeIndex = message.activeAlternativeIndex || 0;
    
    // Index 0 is the original message
    if (activeIndex === 0) {
      return message.content;
    }

    // Alternative indices are 1-based, so subtract 1 to get array index
    const alternativeArrayIndex = activeIndex - 1;
    if (message.alternatives && alternativeArrayIndex < message.alternatives.length) {
      return message.alternatives[alternativeArrayIndex].content;
    }

    // Fallback to original content if alternative not found
    return message.content;
  }

  /**
   * Get the currently active message tool calls
   */
  getActiveMessageToolCalls(message: ConversationMessage): any[] | undefined {
    const activeIndex = message.activeAlternativeIndex || 0;
    
    // Index 0 is the original message
    if (activeIndex === 0) {
      return message.toolCalls;
    }

    // Alternative indices are 1-based, so subtract 1 to get array index
    const alternativeArrayIndex = activeIndex - 1;
    if (message.alternatives && alternativeArrayIndex < message.alternatives.length) {
      return message.alternatives[alternativeArrayIndex].toolCalls;
    }

    // Fallback to original tool calls if alternative not found
    return message.toolCalls;
  }

  /**
   * Get alternative information for a message
   */
  getMessageAlternativeInfo(message: ConversationMessage): { current: number; total: number; hasAlternatives: boolean } {
    const activeIndex = message.activeAlternativeIndex || 0;
    const totalAlternatives = this.getMessageAlternativeCount(message);
    
    return {
      current: activeIndex + 1, // 1-based for display
      total: totalAlternatives,
      hasAlternatives: totalAlternatives > 1
    };
  }

  /**
   * Get total alternative count for a message (including original)
   */
  private getMessageAlternativeCount(message: ConversationMessage): number {
    const alternativesCount = message.alternatives?.length || 0;
    return alternativesCount + 1; // +1 for the original message
  }

  /**
   * Check if a message has alternatives
   */
  hasMessageAlternatives(message: ConversationMessage): boolean {
    return !!(message.alternatives && message.alternatives.length > 0);
  }

  /**
   * Get all alternatives for a message (including original as index 0)
   */
  getAllMessageAlternatives(message: ConversationMessage): ConversationMessage[] {
    const alternatives: ConversationMessage[] = [message]; // Original message at index 0
    
    if (message.alternatives) {
      alternatives.push(...message.alternatives);
    }
    
    return alternatives;
  }

  /**
   * Get the previous alternative index for navigation
   */
  getPreviousAlternativeIndex(message: ConversationMessage): number | null {
    const currentIndex = message.activeAlternativeIndex || 0;
    return currentIndex > 0 ? currentIndex - 1 : null;
  }

  /**
   * Get the next alternative index for navigation
   */
  getNextAlternativeIndex(message: ConversationMessage): number | null {
    const currentIndex = message.activeAlternativeIndex || 0;
    const totalCount = this.getMessageAlternativeCount(message);
    return currentIndex < totalCount - 1 ? currentIndex + 1 : null;
  }
}
```

## ui/chat/services/ConversationManager.ts

```typescript
/**
 * ConversationManager - Handles all conversation CRUD operations
 */

import { ChatService } from '../../../services/chat/ChatService';
import { ConversationData } from '../../../types/chat/ChatTypes';
import { BranchManager } from './BranchManager';

export interface ConversationManagerEvents {
  onConversationSelected: (conversation: ConversationData) => void;
  onConversationsChanged: () => void;
  onError: (message: string) => void;
}

export class ConversationManager {
  private currentConversation: ConversationData | null = null;
  private conversations: ConversationData[] = [];

  constructor(
    private chatService: ChatService,
    private branchManager: BranchManager,
    private events: ConversationManagerEvents
  ) {}

  /**
   * Get current conversation
   */
  getCurrentConversation(): ConversationData | null {
    return this.currentConversation;
  }

  /**
   * Get all conversations
   */
  getConversations(): ConversationData[] {
    return this.conversations;
  }

  /**
   * Load conversations from the chat service
   */
  async loadConversations(): Promise<void> {
    try {
      this.conversations = await this.chatService.listConversations({ limit: 50 });
      console.log('[ConversationManager] Loaded conversations:', {
        count: this.conversations.length,
        conversationIds: this.conversations.map(c => c.id),
        firstConversation: this.conversations[0] ? {
          id: this.conversations[0].id,
          title: this.conversations[0].title,
          messageCount: this.conversations[0].messages.length
        } : null
      });
      
      this.events.onConversationsChanged();
      
      // Auto-select the most recent conversation
      if (this.conversations.length > 0 && !this.currentConversation) {
        await this.selectConversation(this.conversations[0]);
      }
    } catch (error) {
      console.error('[ConversationManager] Failed to load conversations:', error);
      this.events.onError('Failed to load conversations');
    }
  }

  /**
   * Select and display a conversation
   */
  async selectConversation(conversation: ConversationData): Promise<void> {
    try {
      this.currentConversation = conversation;
      console.log('[ConversationManager] Selecting conversation:', {
        conversationId: conversation.id,
        title: conversation.title,
        currentMessageCount: conversation.messages.length
      });
      
      // Load full conversation data
      const fullConversation = await this.chatService.getConversation(conversation.id);
      console.log('[ConversationManager] Full conversation loaded:', {
        conversationId: conversation.id,
        found: !!fullConversation,
        messageCount: fullConversation?.messages.length || 0,
        messagesPreview: fullConversation?.messages.slice(0, 3).map(m => ({
          id: m.id,
          role: m.role,
          contentLength: m.content.length,
          hasToolCalls: !!(m.toolCalls && m.toolCalls.length > 0),
          toolCallCount: m.toolCalls?.length || 0
        })) || []
      });
      
      if (fullConversation) {
        this.currentConversation = fullConversation;
        this.events.onConversationSelected(fullConversation);
      }
    } catch (error) {
      console.error('[ConversationManager] Failed to select conversation:', error);
      this.events.onError('Failed to load conversation');
    }
  }

  /**
   * Create a new conversation
   */
  async createNewConversation(title?: string): Promise<void> {
    try {
      // Prompt for title if not provided
      const conversationTitle = title || await this.promptForConversationTitle();
      if (!conversationTitle) return; // User cancelled
      
      const result = await this.chatService.createConversation(conversationTitle);
      
      if (result.success && result.conversationId) {
        // Reload conversations and select the new one
        await this.loadConversations();
        const newConversation = await this.chatService.getConversation(result.conversationId);
        if (newConversation) {
          await this.selectConversation(newConversation);
        }
      } else {
        this.events.onError(result.error || 'Failed to create conversation');
      }
    } catch (error) {
      console.error('[ConversationManager] Failed to create conversation:', error);
      this.events.onError('Failed to create conversation');
    }
  }

  /**
   * Create new conversation with initial message
   */
  async createNewConversationWithMessage(
    message: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
    }
  ): Promise<void> {
    const title = message.length > 50 ? message.substring(0, 47) + '...' : message;
    
    try {
      const result = await this.chatService.createConversation(title, message, options);
      
      if (result.success && result.conversationId) {
        // Reload conversations and select the new one
        await this.loadConversations();
        const newConversation = await this.chatService.getConversation(result.conversationId);
        if (newConversation) {
          await this.selectConversation(newConversation);
        }
      } else {
        this.events.onError(result.error || 'Failed to create conversation');
      }
    } catch (error) {
      console.error('[ConversationManager] Failed to create conversation with message:', error);
      this.events.onError('Failed to create conversation');
    }
  }

  /**
   * Delete a conversation
   */
  async deleteConversation(conversationId: string): Promise<void> {
    try {
      const success = await this.chatService.deleteConversation(conversationId);
      
      if (success) {
        // If this was the current conversation, clear it
        if (this.currentConversation?.id === conversationId) {
          this.currentConversation = null;
        }
        
        // Reload conversation list
        await this.loadConversations();
      } else {
        this.events.onError('Failed to delete conversation');
      }
    } catch (error) {
      console.error('[ConversationManager] Failed to delete conversation:', error);
      this.events.onError('Failed to delete conversation');
    }
  }

  /**
   * Update current conversation data
   */
  updateCurrentConversation(conversation: ConversationData): void {
    this.currentConversation = conversation;
  }

  /**
   * Prompt user for conversation title
   */
  private async promptForConversationTitle(): Promise<string | null> {
    return new Promise((resolve) => {
      // Create modal overlay
      const overlay = document.createElement('div');
      overlay.addClass('chat-modal-overlay');
      
      // Create modal dialog
      const modal = overlay.createDiv('chat-modal');
      
      // Modal header
      const header = modal.createDiv('chat-modal-header');
      header.createEl('h3', { text: 'New Conversation' });
      
      // Close button
      const closeBtn = header.createEl('button', { 
        cls: 'chat-modal-close',
        text: '√ó' 
      });
      
      // Modal content
      const content = modal.createDiv('chat-modal-content');
      content.createEl('p', { text: 'Enter a title for your new conversation:' });
      
      const input = content.createEl('input', {
        type: 'text',
        cls: 'chat-title-input',
        attr: { placeholder: 'e.g., "Help with React project"' }
      });
      
      // Modal actions
      const actions = modal.createDiv('chat-modal-actions');
      const cancelBtn = actions.createEl('button', { 
        text: 'Cancel',
        cls: 'chat-btn-secondary'
      });
      const createBtn = actions.createEl('button', { 
        text: 'Create Chat',
        cls: 'chat-btn-primary'
      });
      
      // Event handlers
      const cleanup = () => {
        overlay.remove();
      };
      
      const handleSubmit = () => {
        const title = input.value.trim();
        if (title) {
          cleanup();
          resolve(title);
        } else {
          input.focus();
          input.addClass('chat-input-error');
          setTimeout(() => input.removeClass('chat-input-error'), 2000);
        }
      };
      
      const handleCancel = () => {
        cleanup();
        resolve(null);
      };
      
      // Wire up events
      closeBtn.addEventListener('click', handleCancel);
      cancelBtn.addEventListener('click', handleCancel);
      createBtn.addEventListener('click', handleSubmit);
      
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleSubmit();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          handleCancel();
        }
      });
      
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          handleCancel();
        }
      });
      
      // Add to page and focus
      document.body.appendChild(overlay);
      input.focus();
      input.select();
    });
  }

}
```

## ui/chat/services/MessageManager.ts

```typescript
/**
 * MessageManager - Handles all message operations including sending, editing, retry, and streaming
 */

import { ChatService } from '../../../services/chat/ChatService';
import { ConversationData, ConversationMessage } from '../../../types/chat/ChatTypes';
import { BranchManager } from './BranchManager';

export interface MessageManagerEvents {
  onMessageAdded: (message: ConversationMessage) => void;
  onAIMessageStarted: (message: ConversationMessage) => void;
  onStreamingUpdate: (messageId: string, content: string, isComplete: boolean, isIncremental?: boolean) => void;
  onConversationUpdated: (conversation: ConversationData) => void;
  onLoadingStateChanged: (isLoading: boolean) => void;
  onError: (message: string) => void;
  onToolCallsDetected: (messageId: string, toolCalls: any[]) => void;
  onToolExecutionStarted: (messageId: string, toolCall: { id: string; name: string; parameters?: any }) => void;
  onToolExecutionCompleted: (messageId: string, toolId: string, result: any, success: boolean, error?: string) => void;
  onMessageIdUpdated: (oldId: string, newId: string, updatedMessage: ConversationMessage) => void;
}

export class MessageManager {
  private isLoading = false;

  constructor(
    private chatService: ChatService,
    private branchManager: BranchManager,
    private events: MessageManagerEvents
  ) {}

  /**
   * Get current loading state
   */
  getIsLoading(): boolean {
    return this.isLoading;
  }

  /**
   * Send a message in a conversation
   */
  async sendMessage(
    conversation: ConversationData,
    message: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
    }
  ): Promise<void> {
    try {
      this.setLoading(true);

      // 1. Add user message immediately and show it
      const userMessage: ConversationMessage = {
        id: `msg_${Date.now()}_user`,
        role: 'user' as const,
        content: message,
        timestamp: Date.now(),
        conversationId: conversation.id
      };
      
      // Add user message to conversation and display immediately (progressive updates only)
      conversation.messages.push(userMessage);
      this.events.onMessageAdded(userMessage);
      
      // 2. Create placeholder AI message with loading animation
      const aiMessageId = `msg_${Date.now()}_ai`;
      const placeholderAiMessage: ConversationMessage = {
        id: aiMessageId,
        role: 'assistant' as const,
        content: '',
        timestamp: Date.now(),
        conversationId: conversation.id
      };
      
      // Add placeholder AI message and create bubble for streaming
      conversation.messages.push(placeholderAiMessage);
      this.events.onAIMessageStarted(placeholderAiMessage);

      // 3. Stream AI response
      try {
        // First add the user message to repository
        const userMessageResult = await this.chatService.addMessage({
          conversationId: conversation.id,
          role: 'user',
          content: message
        });
        
        // Update the temporary user message with the real ID from repository
        console.log('[MessageManager] addMessage result:', userMessageResult);
        if (userMessageResult.success && userMessageResult.messageId) {
          const tempMessageIndex = conversation.messages.findIndex(msg => msg.id === userMessage.id);
          console.log('[MessageManager] Looking for temp message:', {
            tempId: userMessage.id,
            found: tempMessageIndex >= 0,
            conversationMessageCount: conversation.messages.length
          });
          if (tempMessageIndex >= 0) {
            const oldId = conversation.messages[tempMessageIndex].id;
            conversation.messages[tempMessageIndex].id = userMessageResult.messageId;
            
            // Also update the original userMessage object that UI components reference
            userMessage.id = userMessageResult.messageId;
            
            console.log('[MessageManager] Updated temp message ID:', {
              from: oldId,
              to: userMessageResult.messageId,
              messageIndex: tempMessageIndex,
              userMessageIdAlsoUpdated: true
            });
            
            // Notify UI about message ID update so MessageBubble can update its reference
            console.log('[MessageManager] EMITTING onMessageIdUpdated event:', {
              oldId,
              newId: userMessageResult.messageId,
              updatedMessageId: userMessage.id,
              eventExists: !!this.events.onMessageIdUpdated
            });
            this.events.onMessageIdUpdated(oldId, userMessageResult.messageId, userMessage);
          }
        } else {
          console.log('[MessageManager] Failed to get real message ID from repository');
        }

        let streamedContent = '';
        let toolCalls: any[] | undefined = undefined;

        // Stream the AI response
        for await (const chunk of this.chatService.generateResponseStreaming(
          conversation.id,
          message,
          conversation,
          {
            provider: options?.provider,
            model: options?.model,
            systemPrompt: options?.systemPrompt,
            messageId: aiMessageId // Pass the placeholder messageId for UI consistency
          }
        )) {
          
          // For token chunks, add to accumulated content AND emit incremental update
          if (chunk.chunk) {
            // Real-time chunk received - send to UI immediately
            
            streamedContent += chunk.chunk;
            
            // Send only the new chunk to UI for incremental updates
            this.events.onStreamingUpdate(aiMessageId, chunk.chunk, false, true); // isComplete = false, isIncremental = true
          }

          // Extract tool calls when available
          if (chunk.toolCalls) {
            toolCalls = chunk.toolCalls;
            
            // Only emit tool calls event for final chunk to avoid duplication
            if (chunk.complete) {
                this.events.onToolCallsDetected(aiMessageId, toolCalls);
            }
          }

          if (chunk.complete) {
            // Update conversation with final accumulated content
            const placeholderMessageIndex = conversation.messages.findIndex(msg => msg.id === aiMessageId);
            if (placeholderMessageIndex >= 0) {
              conversation.messages[placeholderMessageIndex] = {
                ...conversation.messages[placeholderMessageIndex],
                content: streamedContent,
                toolCalls: toolCalls
              };
            }
            
            // Send final complete content for any final processing
            this.events.onStreamingUpdate(aiMessageId, streamedContent, true, false); // isComplete = true, isIncremental = false
            // Streaming complete - conversation updated without re-render
            break;
          }
        }

      } catch (sendError) {
        this.events.onError('Failed to send message');
        this.removeLoadingMessage(conversation, aiMessageId);
        throw sendError;
      }
    } catch (error) {
      this.events.onError('Failed to send message');
    } finally {
      this.setLoading(false);
    }
  }

  /**
   * Handle retry message action - creates message-level alternatives
   */
  async handleRetryMessage(
    conversation: ConversationData,
    messageId: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
    }
  ): Promise<void> {
    const message = conversation.messages.find(msg => msg.id === messageId);
    if (!message) return;
    
    try {
      console.log('[MessageManager] Handling retry for message:', { messageId, role: message.role });

      // For user messages, regenerate the AI response
      if (message.role === 'user') {
        await this.regenerateAIResponse(conversation, messageId, options);
      }
      // For AI messages, create an alternative response
      else if (message.role === 'assistant') {
        await this.createAlternativeAIResponse(conversation, messageId, options);
      }

      // Notify that conversation was updated
      this.events.onConversationUpdated(conversation);
      
    } catch (error) {
      console.error('[MessageManager] Failed to handle retry:', error);
      this.events.onError('Failed to retry message');
    }
  }

  /**
   * Regenerate AI response for a user message (creates alternative in following AI message)
   */
  private async regenerateAIResponse(
    conversation: ConversationData,
    userMessageId: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
    }
  ): Promise<void> {
    const userMessage = conversation.messages.find(msg => msg.id === userMessageId);
    if (!userMessage || userMessage.role !== 'user') return;

    // Find the AI message that follows this user message
    const userMessageIndex = conversation.messages.findIndex(msg => msg.id === userMessageId);
    if (userMessageIndex === -1) return;

    const aiMessageIndex = userMessageIndex + 1;
    const aiMessage = conversation.messages[aiMessageIndex];
    
    if (aiMessage && aiMessage.role === 'assistant') {
      // Create alternative for existing AI message
      await this.createAlternativeAIResponse(conversation, aiMessage.id, options);
    } else {
      // No AI response exists, generate a new one
      await this.sendMessage(conversation, userMessage.content, options);
    }
  }

  /**
   * Create an alternative response for an AI message
   */
  private async createAlternativeAIResponse(
    conversation: ConversationData,
    aiMessageId: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
    }
  ): Promise<void> {
    const aiMessage = conversation.messages.find(msg => msg.id === aiMessageId);
    if (!aiMessage || aiMessage.role !== 'assistant') return;

    // Find the user message that prompted this AI response
    const aiMessageIndex = conversation.messages.findIndex(msg => msg.id === aiMessageId);
    if (aiMessageIndex === 0) return; // No previous message

    const userMessage = conversation.messages[aiMessageIndex - 1];
    if (!userMessage || userMessage.role !== 'user') return;

    try {
      this.setLoading(true);

      // Reset the existing AI message to loading state by clearing its content
      this.events.onStreamingUpdate(aiMessageId, '', false, false);

      // Generate new AI response with streaming
      let streamedContent = '';
      let toolCalls: any[] | undefined = undefined;

      for await (const chunk of this.chatService.generateResponseStreaming(
        conversation.id,
        userMessage.content,
        conversation,
        {
          provider: options?.provider,
          model: options?.model,
          systemPrompt: options?.systemPrompt
        }
      )) {
        if (chunk.chunk) {
          streamedContent += chunk.chunk;
          // Stream only the new chunk to the UI in real-time (not accumulated content)
          this.events.onStreamingUpdate(aiMessageId, chunk.chunk, false, true);
        }
        if (chunk.toolCalls) {
          toolCalls = chunk.toolCalls;
        }
        if (chunk.complete) {
          // Final streaming update
          this.events.onStreamingUpdate(aiMessageId, streamedContent, true, false);
          break;
        }
      }

      // Create alternative response
      const alternativeResponse: ConversationMessage = {
        id: `alt_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`,
        role: 'assistant',
        content: streamedContent,
        timestamp: Date.now(),
        conversationId: conversation.id,
        toolCalls: toolCalls
      };

      // Add alternative using BranchManager
      const alternativeIndex = await this.branchManager.createMessageAlternative(
        conversation,
        aiMessageId,
        alternativeResponse
      );

      console.log('[MessageManager] Created alternative response:', { aiMessageId, alternativeIndex });

    } catch (error) {
      console.error('[MessageManager] Failed to create alternative response:', error);
      this.events.onError('Failed to generate alternative response');
    } finally {
      this.setLoading(false);
    }
  }

  // Removed legacy sendMessageToBranch method - using message-level alternatives now


  /**
   * Handle edit message action - ONLY updates content, does NOT regenerate
   */
  async handleEditMessage(
    conversation: ConversationData,
    messageId: string,
    newContent: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
    }
  ): Promise<void> {
    const messageIndex = conversation.messages.findIndex(msg => msg.id === messageId);
    if (messageIndex === -1) return;
    
    // Update ONLY the message content
    conversation.messages[messageIndex].content = newContent;
    
    // Update the conversation in storage
    await this.chatService.updateConversation(conversation);
    
    // Notify about conversation update so UI can refresh
    this.events.onConversationUpdated(conversation);
    
    // That's it! No auto-regeneration - user must click retry if they want to branch
  }

  /**
   * Add a user message for optimistic updates
   */
  addUserMessage(conversation: ConversationData, content: string): void {
    const message: ConversationMessage = {
      id: `temp_${Date.now()}`,
      role: 'user',
      content,
      timestamp: Date.now(),
      conversationId: conversation.id
    };
    
    conversation.messages.push(message);
    this.events.onMessageAdded(message);
  }

  /**
   * Remove loading message from conversation
   */
  private removeLoadingMessage(conversation: ConversationData, messageId: string): void {
    const messageIndex = conversation.messages.findIndex(msg => msg.id === messageId);
    if (messageIndex >= 0) {
      conversation.messages.splice(messageIndex, 1);
      this.events.onConversationUpdated(conversation);
    }
  }

  /**
   * Set loading state and notify
   */
  private setLoading(loading: boolean): void {
    this.isLoading = loading;
    this.events.onLoadingStateChanged(loading);
  }
}
```

## ui/chat/services/ModelAgentManager.ts

```typescript
/**
 * ModelAgentManager - Handles model and agent selection, loading, and state management
 */

import { ModelOption } from '../components/ModelSelector';
import { AgentOption } from '../components/AgentSelector';
import { ProviderUtils } from '../utils/ProviderUtils';

export interface ModelAgentManagerEvents {
  onModelChanged: (model: ModelOption | null) => void;
  onAgentChanged: (agent: AgentOption | null) => void;
  onSystemPromptChanged: (systemPrompt: string | null) => void;
}

export class ModelAgentManager {
  private selectedModel: ModelOption | null = null;
  private selectedAgent: AgentOption | null = null;
  private currentSystemPrompt: string | null = null;

  constructor(
    private app: any, // Obsidian App
    private events: ModelAgentManagerEvents
  ) {}

  /**
   * Get current selected model
   */
  getSelectedModel(): ModelOption | null {
    return this.selectedModel;
  }

  /**
   * Get current selected agent
   */
  getSelectedAgent(): AgentOption | null {
    return this.selectedAgent;
  }

  /**
   * Get current system prompt
   */
  getCurrentSystemPrompt(): string | null {
    return this.currentSystemPrompt;
  }

  /**
   * Handle model selection change
   */
  handleModelChange(model: ModelOption | null): void {
    this.selectedModel = model;
    this.events.onModelChanged(model);
  }

  /**
   * Handle agent selection change
   */
  handleAgentChange(agent: AgentOption | null): void {
    this.selectedAgent = agent;
    this.currentSystemPrompt = agent?.systemPrompt || null;
    
    this.events.onAgentChanged(agent);
    this.events.onSystemPromptChanged(this.currentSystemPrompt);
  }

  /**
   * Get the configured default model from plugin settings
   */
  async getDefaultModel(): Promise<{ provider: string; model: string }> {
    try {
      const plugin = this.app.plugins.plugins['claudesidian-mcp'];
      if (!plugin) {
        throw new Error('Plugin not found');
      }

      const pluginData = await plugin.loadData();
      const defaultModel = pluginData?.llmProviders?.defaultModel;
      
      if (!defaultModel?.provider || !defaultModel?.model) {
        throw new Error('No default model configured in settings');
      }

      return defaultModel;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Get available models from validated providers
   */
  async getAvailableModels(): Promise<ModelOption[]> {
    try {
      // Get plugin instance to access settings data
      const plugin = this.app.plugins.plugins['claudesidian-mcp'];
      if (!plugin) {
        return [];
      }

      // Load plugin data directly
      const pluginData = await plugin.loadData();
      if (!pluginData?.llmProviders?.providers) {
        return [];
      }

      const models: ModelOption[] = [];
      const providers = pluginData.llmProviders.providers;
      
      // Import ModelRegistry to get actual model specs
      const { ModelRegistry } = await import('../../../services/llm/adapters/ModelRegistry');
      
      // Iterate through enabled providers with valid API keys
      Object.entries(providers).forEach(([providerId, config]: [string, any]) => {
        // Only include providers that are enabled and have API keys
        if (!config.enabled || !config.apiKey || !config.apiKey.trim()) {
          return;
        }
        
        const providerName = this.getProviderDisplayName(providerId);
        
        // Get all available models for this provider from ModelRegistry
        const providerModels = ModelRegistry.getProviderModels(providerId);
        
        providerModels.forEach(modelSpec => {
          models.push({
            providerId,
            providerName,
            modelId: modelSpec.apiName,
            modelName: modelSpec.name,
            contextWindow: modelSpec.contextWindow
          });
        });
      });

      return models;
    } catch (error) {
      return [];
    }
  }

  /**
   * Get available agents from agent manager
   */
  async getAvailableAgents(): Promise<AgentOption[]> {
    try {
      // Get plugin instance to access settings data
      const plugin = this.app.plugins.plugins['claudesidian-mcp'];
      if (!plugin) {
        return [];
      }

      // Load plugin data directly
      const pluginData = await plugin.loadData();
      const agentOptions: AgentOption[] = [];

      // Get custom prompts from plugin data - they are stored as an array, not object
      const customPrompts = pluginData?.customPrompts?.prompts || [];
      
      // Add custom prompt-based agents
      customPrompts.forEach((prompt: any) => {
        if (prompt.prompt && prompt.prompt.trim() && prompt.isEnabled !== false) {
          agentOptions.push({
            id: prompt.id,
            name: prompt.name || 'Unnamed Agent',
            description: prompt.description || 'Custom agent prompt',
            systemPrompt: prompt.prompt
          });
        }
      });

      return agentOptions;
    } catch (error) {
      return [];
    }
  }

  /**
   * Get message options for current selection
   */
  getMessageOptions(): {
    provider?: string;
    model?: string;
    systemPrompt?: string;
  } {
    return {
      provider: this.selectedModel?.providerId,
      model: this.selectedModel?.modelId,
      systemPrompt: this.currentSystemPrompt || undefined
    };
  }

  /**
   * Get display name for provider with tool calling indicator
   */
  private getProviderDisplayName(providerId: string): string {
    return ProviderUtils.getProviderDisplayNameWithTools(providerId);
  }
}
```

## ui/chat/utils/ContentProcessor.ts

```typescript
/**
 * ContentProcessor - Handles content formatting, escaping, and processing utilities
 */

export class ContentProcessor {
  /**
   * Escape HTML for safe display
   */
  static escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Unescape HTML entities
   */
  static unescapeHtml(html: string): string {
    const div = document.createElement('div');
    div.innerHTML = html;
    return div.textContent || div.innerText || '';
  }

  /**
   * Process markdown content for display (basic implementation)
   */
  static processMarkdown(content: string): string {
    // Simple markdown processing - can be enhanced later
    let processed = content;
    
    // Code blocks
    processed = processed.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');
    
    // Inline code
    processed = processed.replace(/`([^`]+)`/g, '<code>$1</code>');
    
    // Bold
    processed = processed.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    
    // Italic
    processed = processed.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    
    // Headers
    processed = processed.replace(/^### (.*$)/gim, '<h3>$1</h3>');
    processed = processed.replace(/^## (.*$)/gim, '<h2>$1</h2>');
    processed = processed.replace(/^# (.*$)/gim, '<h1>$1</h1>');
    
    // Lists
    processed = processed.replace(/^[\s]*\* (.+)$/gm, '<li>$1</li>');
    processed = processed.replace(/^[\s]*- (.+)$/gm, '<li>$1</li>');
    
    // Wrap consecutive list items in ul tags  
    processed = processed.replace(/(<li>.*<\/li>)/g, '<ul>$1</ul>');
    
    // Line breaks
    processed = processed.replace(/\n/g, '<br>');
    
    return processed;
  }

  /**
   * Sanitize content to prevent XSS
   */
  static sanitizeContent(content: string): string {
    // Remove potentially dangerous tags and attributes
    const dangerous = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
    let sanitized = content.replace(dangerous, '');
    
    // Remove javascript: and data: URLs
    sanitized = sanitized.replace(/javascript:/gi, '');
    sanitized = sanitized.replace(/data:/gi, '');
    
    // Remove on* event handlers
    sanitized = sanitized.replace(/on\w+\s*=/gi, '');
    
    return sanitized;
  }

  /**
   * Truncate text to specified length with ellipsis
   */
  static truncateText(text: string, maxLength: number, ellipsis: string = '...'): string {
    if (text.length <= maxLength) {
      return text;
    }
    
    return text.substring(0, maxLength - ellipsis.length) + ellipsis;
  }

  /**
   * Extract plain text from HTML content
   */
  static extractPlainText(html: string): string {
    const div = document.createElement('div');
    div.innerHTML = html;
    return div.textContent || div.innerText || '';
  }

  /**
   * Format conversation preview text
   */
  static formatConversationPreview(lastMessage: string, maxLength: number = 100): string {
    // Remove markdown formatting for preview
    let preview = lastMessage
      .replace(/```[\s\S]*?```/g, '[code block]') // Replace code blocks
      .replace(/`([^`]+)`/g, '$1') // Remove inline code backticks
      .replace(/\*\*([^*]+)\*\*/g, '$1') // Remove bold
      .replace(/\*([^*]+)\*/g, '$1') // Remove italic
      .replace(/^#+\s*/gm, '') // Remove headers
      .replace(/^\s*[-*]\s*/gm, '') // Remove list markers
      .replace(/\n+/g, ' ') // Replace newlines with spaces
      .trim();
    
    return this.truncateText(preview, maxLength);
  }

  /**
   * Validate and clean message content
   */
  static cleanMessageContent(content: string): string {
    // Trim whitespace
    let cleaned = content.trim();
    
    // Remove excessive whitespace
    cleaned = cleaned.replace(/\s+/g, ' ');
    
    // Remove null bytes
    cleaned = cleaned.replace(/\0/g, '');
    
    return cleaned;
  }

  /**
   * Check if content is safe for display
   */
  static isContentSafe(content: string): boolean {
    // Check for dangerous patterns
    const dangerousPatterns = [
      /<script/i,
      /javascript:/i,
      /data:text\/html/i,
      /vbscript:/i,
      /on\w+\s*=/i
    ];
    
    return !dangerousPatterns.some(pattern => pattern.test(content));
  }

  /**
   * Format file size for display
   */
  static formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 B';
    
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }
}
```

## ui/chat/utils/MarkdownRenderer.ts

```typescript
/**
 * Enhanced Markdown Renderer Service
 * 
 * Provides streaming markdown rendering using streaming-markdown library
 * with fallback to Obsidian's native MarkdownRenderer API for final rendering.
 */

import { App, Component, MarkdownRenderer as ObsidianMarkdownRenderer } from 'obsidian';
import * as smd from 'streaming-markdown';

export class MarkdownRenderer {
  
  /**
   * Render complete markdown content using Obsidian's native renderer
   * This provides full markdown support including blockquotes, checkboxes, strikethrough, etc.
   */
  static async renderMarkdown(
    content: string, 
    container: HTMLElement, 
    app: App, 
    component: Component
  ): Promise<void> {
    try {
      // Clear container first
      container.empty();
      
      // Use Obsidian's native markdown renderer
      await ObsidianMarkdownRenderer.render(
        app,
        content,
        container,
        '', // sourcePath - empty for chat context
        component
      );
      
    } catch (error) {
      console.error('[MarkdownRenderer] Error rendering markdown:', error);
      // Fallback to plain text if rendering fails
      this.renderPlainText(content, container);
    }
  }

  /**
   * Initialize streaming markdown parser for progressive rendering
   */
  static initializeStreamingParser(container: HTMLElement): any {
    
    // Clear container
    container.empty();
    
    // Create dedicated content container for streaming-markdown
    const contentDiv = document.createElement('div');
    contentDiv.className = 'streaming-content';
    container.appendChild(contentDiv);
    
    
    // Initialize streaming-markdown renderer with content div
    const renderer = smd.default_renderer(contentDiv);
    const parser = smd.parser(renderer);
    
    
    return { parser, renderer, contentDiv };
  }

  /**
   * Write chunk to streaming markdown parser
   */
  static writeStreamingChunk(streamingState: any, chunk: string): void {
    
    if (streamingState && streamingState.parser) {
      try {
        smd.parser_write(streamingState.parser, chunk);
        
      } catch (error) {
        console.error('[MarkdownRenderer] Error writing streaming chunk:', error);
      }
    }
  }

  /**
   * Finalize streaming parser and optionally render with Obsidian
   */
  static async finalizeStreamingContent(
    streamingState: any,
    finalContent: string,
    container: HTMLElement,
    app: App,
    component: Component,
    useObsidianRenderer: boolean = true
  ): Promise<void> {
    // Finalize streaming parser
    if (streamingState && streamingState.parser) {
      try {
        smd.parser_end(streamingState.parser);
      } catch (error) {
        console.error('[MarkdownRenderer] Error finalizing streaming parser:', error);
      }
    }
    
    // Optionally replace with Obsidian's native renderer for advanced features
    if (useObsidianRenderer && this.hasAdvancedMarkdownFeatures(finalContent)) {
      // Remove streaming content
      const streamingContent = container.querySelector('.streaming-content');
      if (streamingContent) {
        streamingContent.remove();
      }
      
      // Render final content with full Obsidian renderer
      const finalDiv = document.createElement('div');
      finalDiv.className = 'final-content';
      container.appendChild(finalDiv);
      
      try {
        await ObsidianMarkdownRenderer.render(
          app,
          finalContent,
          finalDiv,
          '',
          component
        );
      } catch (error) {
        console.error('[MarkdownRenderer] Error finalizing with Obsidian renderer:', error);
        // Keep the streaming-markdown result
        if (streamingContent) {
          container.appendChild(streamingContent);
        }
      }
    }
  }

  /**
   * Check if content has advanced markdown features that benefit from Obsidian renderer
   */
  private static hasAdvancedMarkdownFeatures(content: string): boolean {
    const advancedPatterns = [
      /^-\s\[[x\s]\]/m, // Checkboxes
      /^\>/m, // Blockquotes  
      /\[\[.*\]\]/m, // Internal links
      /!\[\[.*\]\]/m, // Embedded files
      /^\|.*\|/m, // Tables
      /^```\w/m, // Code blocks with language
    ];
    
    return advancedPatterns.some(pattern => pattern.test(content));
  }

  /**
   * Fallback plain text rendering
   */
  private static renderPlainText(content: string, container: HTMLElement): void {
    const pre = document.createElement('pre');
    pre.style.whiteSpace = 'pre-wrap';
    pre.style.wordWrap = 'break-word';
    pre.textContent = content;
    container.appendChild(pre);
  }

  /**
   * Escape HTML for safe display
   */
  private static escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Check if content appears to be markdown (has common markdown patterns)
   */
  static hasMarkdownFormatting(content: string): boolean {
    const markdownPatterns = [
      /^#{1,6}\s/, // Headers
      /^\*\s|\d+\.\s/, // Lists
      /^\>\s/, // Blockquotes
      /^-\s\[[\sx]\]\s/, // Checkboxes
      /\*\*.*\*\*/, // Bold
      /\*.*\*/, // Italic
      /`.*`/, // Inline code
      /```/, // Code blocks
      /~~.*~~/, // Strikethrough
    ];
    
    return markdownPatterns.some(pattern => pattern.test(content));
  }
}
```

## ui/chat/utils/ProviderUtils.ts

```typescript
/**
 * ProviderUtils - Utilities for provider and display name formatting
 */

export class ProviderUtils {
  /**
   * Get display name for provider
   */
  static getProviderDisplayName(providerId: string): string {
    const displayNames: Record<string, string> = {
      'openai': 'OpenAI',
      'anthropic': 'Anthropic',
      'mistral': 'Mistral AI',
      'ollama': 'Ollama',
      'openrouter': 'OpenRouter',
      'google': 'Google',
      'cohere': 'Cohere',
      'huggingface': 'Hugging Face',
      'groq': 'Groq',
      'perplexity': 'Perplexity',
      'requesty': 'Requesty'
    };
    return displayNames[providerId] || this.capitalizeString(providerId);
  }

  /**
   * Capitalize agent name for display
   */
  static capitalizeAgentName(agentId: string): string {
    return agentId
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  /**
   * Capitalize a string
   */
  static capitalizeString(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  /**
   * Format model name for display
   */
  static formatModelName(modelId: string, modelName?: string): string {
    if (modelName) {
      return modelName;
    }
    
    // Convert model IDs to readable names
    const modelDisplayNames: Record<string, string> = {
      'gpt-4': 'GPT-4',
      'gpt-4-turbo': 'GPT-4 Turbo',
      'gpt-3.5-turbo': 'GPT-3.5 Turbo',
      'claude-3-opus': 'Claude 3 Opus',
      'claude-3-sonnet': 'Claude 3 Sonnet',
      'claude-3-haiku': 'Claude 3 Haiku',
      'mistral-large': 'Mistral Large',
      'mistral-medium': 'Mistral Medium',
      'mistral-small': 'Mistral Small'
    };

    return modelDisplayNames[modelId] || this.capitalizeString(modelId.replace(/-/g, ' '));
  }

  /**
   * Get provider color for UI theming
   */
  static getProviderColor(providerId: string): string {
    const colors: Record<string, string> = {
      'openai': '#10a37f',
      'anthropic': '#d97757',
      'mistral': '#ff6b35',
      'ollama': '#000000',
      'openrouter': '#8b5cf6',
      'google': '#4285f4',
      'cohere': '#39c6b9',
      'huggingface': '#ff9a00'
    };
    return colors[providerId] || '#6b7280';
  }

  /**
   * Get provider icon (emoji or symbol)
   */
  static getProviderIcon(providerId: string): string {
    const icons: Record<string, string> = {
      'openai': 'ü§ñ',
      'anthropic': 'üß†',
      'mistral': 'üå™Ô∏è',
      'ollama': 'ü¶ô',
      'openrouter': 'üîÄ',
      'google': 'üîç',
      'cohere': 'üß¨',
      'huggingface': 'ü§ó'
    };
    return icons[providerId] || 'ü§ñ';
  }

  /**
   * Format context window size for display
   */
  static formatContextWindow(contextWindow: number): string {
    if (contextWindow >= 1000000) {
      return `${(contextWindow / 1000000).toFixed(1)}M tokens`;
    } else if (contextWindow >= 1000) {
      return `${(contextWindow / 1000).toFixed(0)}K tokens`;
    } else {
      return `${contextWindow} tokens`;
    }
  }

  /**
   * Get short provider abbreviation
   */
  static getProviderAbbreviation(providerId: string): string {
    const abbreviations: Record<string, string> = {
      'openai': 'OAI',
      'anthropic': 'ANT',
      'mistral': 'MST',
      'ollama': 'OLL',
      'openrouter': 'OR',
      'google': 'GGL',
      'cohere': 'COH',
      'huggingface': 'HF'
    };
    return abbreviations[providerId] || providerId.substring(0, 3).toUpperCase();
  }

  /**
   * Check if provider supports streaming
   */
  static supportsStreaming(providerId: string): boolean {
    const streamingProviders = [
      'openai',
      'anthropic', 
      'mistral',
      'ollama',
      'openrouter'
    ];
    return streamingProviders.includes(providerId);
  }

  /**
   * Check if provider supports function calling (tool calling)
   * Based on API documentation research as of 2024-2025
   */
  static supportsFunctionCalling(providerId: string): boolean {
    const functionCallingProviders = [
      'openai',      // ‚úÖ Native OpenAI function calling
      'openrouter',  // ‚úÖ OpenAI-compatible function calling
      'groq',        // ‚úÖ OpenAI-compatible function calling  
      'mistral',     // ‚úÖ Native Mistral function calling
      'requesty',    // ‚úÖ OpenAI-compatible function calling
      'anthropic'    // ‚úÖ Native Claude tool calling
    ];
    // Note: Perplexity does NOT support function calling (web search focused)
    return functionCallingProviders.includes(providerId);
  }

  /**
   * Get lucide wrench icon SVG for providers that support function calling
   */
  static getToolIconSVG(): string {
    return '<svg class="lucide lucide-wrench" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>';
  }

  /**
   * Get provider display name with tool icon if supported
   * For optgroup labels, uses text-based indicator since HTML isn't supported
   */
  static getProviderDisplayNameWithTools(providerId: string): string {
    const displayName = this.getProviderDisplayName(providerId);
    const supportsTools = this.supportsFunctionCalling(providerId);
    
    if (supportsTools) {
      return `${displayName} üîß`; // Using emoji for optgroup compatibility
    }
    return displayName;
  }

  /**
   * Get provider display name with HTML tool icon for other UI contexts
   * Returns HTML string with SVG icon for tool-capable providers
   */
  static getProviderDisplayNameWithToolsHTML(providerId: string): string {
    const displayName = this.getProviderDisplayName(providerId);
    const supportsTools = this.supportsFunctionCalling(providerId);
    
    if (supportsTools) {
      return `${displayName} ${this.getToolIconSVG()}`;
    }
    return displayName;
  }

  /**
   * Get provider capabilities
   */
  static getProviderCapabilities(providerId: string): {
    streaming: boolean;
    functionCalling: boolean;
    imageInput: boolean;
    jsonMode: boolean;
  } {
    return {
      streaming: this.supportsStreaming(providerId),
      functionCalling: this.supportsFunctionCalling(providerId),
      imageInput: ['openai', 'anthropic', 'google'].includes(providerId),
      jsonMode: ['openai', 'mistral'].includes(providerId)
    };
  }
}
```

## ui/chat/utils/TokenCalculator.ts

```typescript
/**
 * TokenCalculator - Handles token counting and context usage calculations
 */

import { ConversationData } from '../../../types/chat/ChatTypes';
import { ModelOption } from '../components/ModelSelector';
import { ContextUsage } from '../components/ContextProgressBar';

export class TokenCalculator {
  /**
   * Get current context usage for a conversation and model
   */
  static async getContextUsage(
    selectedModel: ModelOption | null,
    currentConversation: ConversationData | null,
    currentSystemPrompt: string | null
  ): Promise<ContextUsage> {
    try {
      if (!selectedModel || !currentConversation) {
        return { used: 0, total: 0, percentage: 0 };
      }

      // Estimate token count for current conversation
      const totalTokens = this.estimateTokenCount(currentConversation, currentSystemPrompt);
      const contextWindow = selectedModel.contextWindow;
      const percentage = (totalTokens / contextWindow) * 100;

      return {
        used: totalTokens,
        total: contextWindow,
        percentage: Math.min(percentage, 100)
      };
    } catch (error) {
      console.error('[TokenCalculator] Error calculating context usage:', error);
      return { used: 0, total: 0, percentage: 0 };
    }
  }

  /**
   * Estimate token count for a conversation
   */
  static estimateTokenCount(
    conversation: ConversationData,
    currentSystemPrompt?: string | null
  ): number {
    let totalTokens = 0;
    
    // Add system prompt tokens if provided
    if (currentSystemPrompt) {
      totalTokens += this.estimateTextTokens(currentSystemPrompt);
    }
    
    // Add message tokens
    conversation.messages.forEach(message => {
      totalTokens += this.estimateTextTokens(message.content);
      
      // Add tokens for tool calls if present
      if (message.toolCalls) {
        message.toolCalls.forEach(toolCall => {
          if (toolCall.parameters) {
            totalTokens += this.estimateTextTokens(JSON.stringify(toolCall.parameters));
          }
          if (toolCall.result) {
            const resultText = typeof toolCall.result === 'string' 
              ? toolCall.result 
              : JSON.stringify(toolCall.result);
            totalTokens += this.estimateTextTokens(resultText);
          }
        });
      }
    });
    
    return totalTokens;
  }

  /**
   * Rough estimation of token count for text (4 chars ‚âà 1 token)
   */
  static estimateTextTokens(text: string): number {
    return Math.ceil(text.length / 4);
  }

  /**
   * Check if conversation is approaching context limits
   */
  static getContextWarningLevel(percentage: number): 'safe' | 'moderate' | 'warning' | 'critical' {
    if (percentage < 50) return 'safe';
    if (percentage < 70) return 'moderate';
    if (percentage < 85) return 'warning';
    return 'critical';
  }

  /**
   * Get warning message for context usage
   */
  static getContextWarningMessage(percentage: number): string | null {
    const level = this.getContextWarningLevel(percentage);
    
    switch (level) {
      case 'warning':
        return 'Context approaching limit. Consider starting a new conversation.';
      case 'critical':
        return 'Context limit nearly reached. Responses may be truncated.';
      default:
        return null;
    }
  }

  /**
   * Estimate tokens for a single message before sending
   */
  static estimateMessageTokens(
    message: string,
    systemPrompt?: string | null
  ): number {
    let tokens = this.estimateTextTokens(message);
    
    if (systemPrompt) {
      tokens += this.estimateTextTokens(systemPrompt);
    }
    
    return tokens;
  }

  /**
   * Check if a new message would exceed context limits
   */
  static wouldExceedContextLimit(
    currentUsage: ContextUsage,
    newMessage: string,
    systemPrompt?: string | null,
    bufferPercentage: number = 10 // Leave 10% buffer
  ): boolean {
    const newMessageTokens = this.estimateMessageTokens(newMessage, systemPrompt);
    const projectedUsage = currentUsage.used + newMessageTokens;
    const maxAllowed = currentUsage.total * (100 - bufferPercentage) / 100;
    
    return projectedUsage > maxAllowed;
  }
}
```

## utils/PathManager.ts

```typescript
/**
 * PathManager - Centralized path management utility for Obsidian plugin
 * Location: src/utils/PathManager.ts
 * 
 * This class provides centralized path construction, validation, and conversion
 * to eliminate path duplication issues in the Electron environment.
 * 
 * Usage:
 * - By DirectoryService for consistent path operations
 * - By storage services for data path construction
 * - By any service that needs reliable path handling
 */

import { App, Plugin, normalizePath, FileSystemAdapter } from 'obsidian';

export interface PathValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  normalizedPath: string;
}

export interface ConversionResult {
  success: boolean;
  relativePath?: string;
  error?: string;
  strategy?: string;
}

/**
 * Core PathManager class - handles all path operations for the plugin
 */
export class PathManager {
  private readonly vaultBasePath: string | null;
  private readonly pluginId: string;

  constructor(
    private readonly app: App,
    private readonly plugin: Plugin
  ) {
    this.pluginId = plugin.manifest.id;
    this.vaultBasePath = this.detectVaultBasePath();
  }

  /**
   * Detect the vault base path from Obsidian's FileSystemAdapter
   */
  private detectVaultBasePath(): string | null {
    try {
      const adapter = this.app.vault.adapter;
      if (adapter instanceof FileSystemAdapter) {
        const basePath = adapter.getBasePath();
        console.log(`[PathManager] Detected vault base path: ${basePath}`);
        return basePath;
      }
      
      console.warn('[PathManager] FileSystemAdapter not available - running on mobile?');
      return null;
    } catch (error) {
      console.error('[PathManager] Failed to detect vault base path:', error);
      return null;
    }
  }

  /**
   * Create plugin-relative path - always returns path relative to vault root
   */
  createPluginPath(subPath?: string): string {
    const basePath = `.obsidian/plugins/${this.pluginId}`;
    if (!subPath) return basePath;
    
    const sanitizedSubPath = this.sanitizePath(subPath);
    return `${basePath}/${sanitizedSubPath}`;
  }

  /**
   * Create data directory path - always returns relative path
   */
  createDataPath(subPath?: string): string {
    const dataPath = this.createPluginPath('data');
    if (!subPath) return dataPath;
    
    const sanitizedSubPath = this.sanitizePath(subPath);
    return `${dataPath}/${sanitizedSubPath}`;
  }

  /**
   * Create data storage path - always returns relative path
   */
  createDataStoragePath(subPath: string): string {
    const sanitizedPath = this.sanitizePath(subPath);
    return this.createDataPath(`storage/${sanitizedPath}`);
  }

  /**
   * Convert absolute path to vault-relative path
   * This is the core method that prevents path duplication
   */
  makeVaultRelative(absolutePath: string): string {
    if (!this.vaultBasePath) {
      console.warn('[PathManager] Cannot convert to relative - vault base path unavailable');
      return this.extractPluginPathFallback(absolutePath);
    }

    try {
      // Strategy 1: Direct base path removal
      const directResult = this.attemptDirectConversion(absolutePath, this.vaultBasePath);
      if (directResult.success && directResult.relativePath) {
        return directResult.relativePath;
      }

      // Strategy 2: Plugin path extraction using regex
      const regexResult = this.attemptRegexConversion(absolutePath);
      if (regexResult.success && regexResult.relativePath) {
        return regexResult.relativePath;
      }

      // Strategy 3: Fallback to safe plugin path
      console.warn(`[PathManager] All conversion strategies failed for: ${absolutePath}`);
      return this.createDataPath('storage');

    } catch (error) {
      console.error('[PathManager] Path conversion error:', error);
      return this.createDataPath('storage');
    }
  }

  /**
   * Direct conversion strategy - remove vault base path
   */
  private attemptDirectConversion(absolutePath: string, basePath: string): ConversionResult {
    const normalizedAbsolute = this.normalizeSeparators(absolutePath);
    const normalizedBase = this.normalizeSeparators(basePath);

    if (normalizedAbsolute.startsWith(normalizedBase)) {
      let relativePath = normalizedAbsolute.substring(normalizedBase.length);
      
      // Remove leading separator
      if (relativePath.startsWith('/')) {
        relativePath = relativePath.substring(1);
      }
      
      if (relativePath) {
        return {
          success: true,
          relativePath,
          strategy: 'direct'
        };
      }
    }
    
    return {
      success: false,
      error: 'Path does not start with base path'
    };
  }

  /**
   * Regex conversion strategy - extract plugin path pattern
   */
  private attemptRegexConversion(absolutePath: string): ConversionResult {
    const normalized = this.normalizeSeparators(absolutePath);
    
    // Pattern to match: any-prefix/(.obsidian/plugins/plugin-id/...)
    const pattern = /.*[\/\\](\.obsidian[\/\\]plugins[\/\\][^\/\\]+[\/\\].*)$/;
    const match = normalized.match(pattern);
    
    if (match) {
      const relativePath = match[1].replace(/\\/g, '/');
      return {
        success: true,
        relativePath,
        strategy: 'regex'
      };
    }
    
    return {
      success: false,
      error: 'Plugin path pattern not found'
    };
  }

  /**
   * Fallback extraction when other methods fail
   */
  private extractPluginPathFallback(path: string): string {
    const normalized = this.normalizeSeparators(path);
    
    // Look for .obsidian/plugins anywhere in path
    const obsidianIndex = normalized.indexOf('.obsidian/plugins/');
    if (obsidianIndex >= 0) {
      return normalized.substring(obsidianIndex);
    }

    // Ultimate fallback - return safe default
    return this.createDataPath('storage');
  }

  /**
   * Validate path format and detect potential issues
   */
  validatePath(path: string): PathValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check for absolute path indicators
    if (this.isAbsolutePath(path)) {
      errors.push('Path should be relative to vault root, not absolute');
    }

    // Check for backslashes (should use forward slashes)
    if (path.includes('\\')) {
      warnings.push('Path contains backslashes, should use forward slashes');
    }

    // Check for path traversal
    if (path.includes('..')) {
      errors.push('Path traversal sequences (..) are not allowed');
    }

    // Check for duplicated base paths
    if (this.vaultBasePath && this.detectDuplicatedPath(path)) {
      errors.push('Duplicated base path detected');
    }

    // Check path length limits
    if (path.length > 260) {
      warnings.push('Path length exceeds recommended limits for cross-platform compatibility');
    }

    const normalizedPath = this.normalizeSeparators(path);

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      normalizedPath
    };
  }

  /**
   * Detect if path contains duplicated base path
   */
  private detectDuplicatedPath(path: string): boolean {
    if (!this.vaultBasePath) return false;

    const normalizedPath = this.normalizeSeparators(path);
    const normalizedBase = this.normalizeSeparators(this.vaultBasePath);
    
    // Count occurrences of base path
    const basePathPattern = this.escapeRegExp(normalizedBase);
    const matches = normalizedPath.match(new RegExp(basePathPattern, 'g'));
    
    return (matches?.length ?? 0) > 1;
  }

  /**
   * Check if path is absolute
   */
  private isAbsolutePath(path: string): boolean {
    return /^[A-Za-z]:|^\//.test(path);
  }

  /**
   * Normalize path separators to forward slashes
   */
  private normalizeSeparators(path: string): string {
    return path.replace(/\\/g, '/');
  }

  /**
   * Sanitize path component for filesystem safety
   */
  private sanitizePath(path: string): string {
    return path
      .replace(/[<>:"|?*]/g, '_')  // Replace invalid filesystem chars
      .replace(/\\/g, '/')         // Normalize separators
      .replace(/\/+/g, '/')        // Remove duplicate separators
      .replace(/^\/|\/$/g, '')     // Remove leading/trailing separators
      .substring(0, 255);          // Limit length for filesystem compatibility
  }

  /**
   * Escape string for use in regular expression
   */
  private escapeRegExp(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * Safe path operation wrapper - validates path before operation
   */
  async safePathOperation<T>(
    path: string,
    operation: (validPath: string) => Promise<T>,
    operationName: string = 'unknown'
  ): Promise<T> {
    try {
      // Convert to relative if absolute
      const relativePath = this.isAbsolutePath(path) 
        ? this.makeVaultRelative(path) 
        : path;

      // Validate the path
      const validation = this.validatePath(relativePath);
      if (!validation.isValid) {
        throw new Error(`Path validation failed: ${validation.errors.join(', ')}`);
      }

      // Normalize and execute operation
      const normalizedPath = normalizePath(relativePath);
      return await operation(normalizedPath);

    } catch (error) {
      console.error(`[PathManager] Safe operation '${operationName}' failed for path: ${path}`, error);
      throw error;
    }
  }

  /**
   * Get vault base path if available
   */
  getVaultBasePath(): string | null {
    return this.vaultBasePath;
  }

  /**
   * Check if vault base path is available
   */
  isVaultPathAvailable(): boolean {
    return this.vaultBasePath !== null;
  }
}
```

## utils/UpdateManager.ts

```typescript
import { Notice, Plugin, requestUrl } from 'obsidian';
import { MCPSettings } from '../types';

interface ReleaseAsset {
    name: string;
    browser_download_url: string;
}

interface GitHubRelease {
    tag_name: string;
    assets: ReleaseAsset[];
}

/**
 * UpdateManager handles checking for and applying plugin updates from GitHub releases
 * Fetches the latest release info and downloads required files:
 * - main.js
 * - connector.js
 * - styles.css
 * - manifest.json
 */
export class UpdateManager {
    private readonly GITHUB_API = 'https://api.github.com/repos/ProfSynapse/claudesidian-mcp';
    private readonly REQUIRED_FILES = ['main.js', 'connector.js', 'styles.css', 'manifest.json'];

    constructor(private plugin: Plugin) {}

    /**
     * Check if a new version is available
     * @returns true if update available, false if current
     */
    async checkForUpdate(): Promise<boolean> {
        try {
            const release = await this.fetchLatestRelease();
            const latestVersion = release.tag_name.replace('v', '');
            const currentVersion = this.plugin.manifest.version;
            
            return this.compareVersions(latestVersion, currentVersion) > 0;
        } catch (error) {
            console.error('Failed to check for updates:', error);
            throw new Error('Failed to check for updates: ' + (error as Error).message);
        }
    }

    /**
     * Download and install the latest version of the plugin
     */
    async updatePlugin(): Promise<void> {
        try {
            const release = await this.fetchLatestRelease();
            const latestVersion = release.tag_name.replace('v', '');
            
            // Verify all required files exist in release
            const assets = release.assets;
            const missingFiles = this.REQUIRED_FILES.filter(file => 
                !assets.some(asset => asset.name === file)
            );

            if (missingFiles.length > 0) {
                throw new Error(`Release is missing required files: ${missingFiles.join(', ')}`);
            }

            // Download and save each file
            for (const fileName of this.REQUIRED_FILES) {
                const asset = assets.find((a: ReleaseAsset) => a.name === fileName);
                if (!asset) continue;

                const content = await this.downloadFile(asset.browser_download_url);
                
                // Handle file content appropriately based on type
                await this.plugin.app.vault.adapter.writeBinary(
                    `${this.plugin.manifest.dir}/${fileName}`,
                    content
                );
            }

            // Update settings to reflect the latest version
            // Note: The manifest.json file has already been written to disk above
            // The in-memory manifest will be updated when Obsidian restarts
            await this.updateVersionInSettings(latestVersion);

            new Notice(`Plugin updated successfully to version ${latestVersion}! Please refresh Obsidian to apply changes.`);
        } catch (error) {
            console.error('Failed to update plugin:', error);
            new Notice('Failed to update plugin: ' + (error as Error).message);
            throw error;
        }
    }

    /**
     * Update the version in the plugin settings
     * @param version The version to set
     */
    private async updateVersionInSettings(version: string): Promise<void> {
        try {
            // Load current settings
            const currentData = await this.plugin.loadData() as MCPSettings;
            
            // Create updated settings with version info
            const updatedData = {
                ...currentData,
                lastUpdateVersion: version,
                lastUpdateDate: new Date().toISOString()
            };
            
            // Save the updated settings
            await this.plugin.saveData(updatedData);
        } catch (error) {
            console.error('Failed to update version in settings:', error);
            // Don't throw here to prevent blocking the update process
        }
    }

    /**
     * Compare two version strings
     * @returns 1 if v1 > v2, -1 if v1 < v2, 0 if equal
     */
    private compareVersions(v1: string, v2: string): number {
        const parts1 = v1.split('.').map(Number);
        const parts2 = v2.split('.').map(Number);

        for (let i = 0; i < 3; i++) {
            if (parts1[i] > parts2[i]) return 1;
            if (parts1[i] < parts2[i]) return -1;
        }
        
        return 0;
    }

    /**
     * Fetch latest release information from GitHub
     */
    private async fetchLatestRelease(): Promise<GitHubRelease> {
        const response = await requestUrl({
            url: `${this.GITHUB_API}/releases/latest`,
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'User-Agent': 'Obsidian-Plugin-Updater'
            }
        });
        
        if (response.status !== 200) {
            throw new Error(`GitHub API error: ${response.status}`);
        }
        
        return response.json;
    }

    /**
     * Download file content from URL
     */
    private async downloadFile(url: string): Promise<ArrayBuffer> {
        const response = await requestUrl({
            url: url,
            method: 'GET'
        });
        
        if (response.status !== 200) {
            throw new Error(`Failed to download file: ${response.status}`);
        }
        
        return response.arrayBuffer;
    }
}

```

## utils/contextUtils.ts

```typescript
import { CommonParameters, CommonResult, ModeCallResult, ModeCall } from '../types';

/**
 * Interface for workspace context
 */
export interface WorkspaceContext {
  workspaceId: string;
  workspacePath?: string[];
  activeWorkspace?: boolean;
}

/**
 * Parse workspace context from parameters
 * @param workspaceContext String or object representation of workspace context  
 * @param fallbackId Optional fallback workspace ID if parsing fails
 * @param contextParam Optional context parameter containing workspaceId
 * @returns Parsed workspace context or null if not provided
 */
export function parseWorkspaceContext(
  workspaceContext: CommonParameters['workspaceContext'] | null | undefined,
  fallbackId = 'default-workspace',
  contextParam?: any
): WorkspaceContext | null {
  // First, try to get workspaceId from context parameter if available
  let workspaceId: string | undefined;
  
  if (contextParam?.workspaceId) {
    workspaceId = contextParam.workspaceId;
    console.log('[parseWorkspaceContext] Using workspaceId from context:', workspaceId);
  }

  if (!workspaceContext) {
    // If no workspaceContext but we have workspaceId from context, create a minimal context
    if (workspaceId) {
      return {
        workspaceId: workspaceId,
        workspacePath: [],
        activeWorkspace: true
      };
    }
    return null;
  }

  let parsedContext: Partial<WorkspaceContext> = {};

  // Handle string vs object format
  if (typeof workspaceContext === 'string') {
    try {
      parsedContext = JSON.parse(workspaceContext);
    } catch (e) {
      console.warn('Invalid workspace context JSON:', e);
      return {
        workspaceId: workspaceId || fallbackId,
        workspacePath: [],
        activeWorkspace: true
      };
    }
  } else if (typeof workspaceContext === 'object' && workspaceContext !== null) {
    parsedContext = workspaceContext;
  }

  // Use workspaceId from context if available, otherwise from workspaceContext
  const finalWorkspaceId = workspaceId || parsedContext.workspaceId;
  
  if (!finalWorkspaceId) {
    console.warn('workspaceId is required but was not provided in context or workspaceContext');
    return {
      workspaceId: fallbackId,
      workspacePath: [],
      activeWorkspace: true
    };
  }

  return {
    workspaceId: finalWorkspaceId,
    workspacePath: parsedContext.workspacePath || [],
    activeWorkspace: parsedContext.activeWorkspace !== undefined ? parsedContext.activeWorkspace : true
  };
}

/**
 * Serialize workspace context to a string (for storage or parameters)
 * @param context Workspace context object
 * @returns Serialized JSON string
 */
export function serializeWorkspaceContext(context: WorkspaceContext): string {
  return JSON.stringify(context);
}

/**
 * Merge workspace contexts from two different sources
 * Handles conflicts by prioritizing the context from the priority source
 * 
 * @param context1 First workspace context
 * @param context2 Second workspace context
 * @param priorityContext Which context to prioritize if both have the same workspace ID ('first' or 'second')
 * @returns Merged workspace context or null if contexts are from different workspaces
 */
export function mergeWorkspaceContexts(
  context1: WorkspaceContext | null | undefined,
  context2: WorkspaceContext | null | undefined,
  priorityContext: 'first' | 'second' = 'first'
): WorkspaceContext | null {
  // Handle null/undefined cases
  if (!context1 && !context2) {
    return null;
  }
  
  if (!context1) {
    return context2 || null;
  }
  
  if (!context2) {
    return context1;
  }
  
  // If the contexts are from different workspaces, return the priority one
  if (context1.workspaceId !== context2.workspaceId) {
    return priorityContext === 'first' ? context1 : context2;
  }
  
  // Same workspace, so merge them with priority
  const priority = priorityContext === 'first' ? context1 : context2;
  const secondary = priorityContext === 'first' ? context2 : context1;
  
  return {
    workspaceId: priority.workspaceId,
    // Combine paths if both have workspace paths (using priority's if only one has a path)
    workspacePath: priority.workspacePath || secondary.workspacePath || [],
    // Use priority's activeWorkspace flag if present
    activeWorkspace: priority.activeWorkspace !== undefined ? 
      priority.activeWorkspace : 
      secondary.activeWorkspace !== undefined ? 
        secondary.activeWorkspace : 
        true
  };
}

/**
 * Track and merge workspace contexts from multiple mode calls
 * This function processes an array of mode call results and returns the best workspace context
 * 
 * @param results Array of mode call results
 * @param originalContext Original workspace context (optional baseline)
 * @returns The most appropriate workspace context to use
 */
export function trackWorkspaceContexts(
  results: ModeCallResult[],
  originalContext?: WorkspaceContext | null
): WorkspaceContext | null {
  if (!results || results.length === 0) {
    return originalContext || null;
  }
  
  // Filter only successful results with workspace context
  const successfulResults = results.filter(r => r.success && r.workspaceContext);
  
  if (successfulResults.length === 0) {
    return originalContext || null;
  }
  
  // Start with the original context
  let currentContext = originalContext || null;
  
  // Process each result in sequence, merging contexts as we go
  for (const result of successfulResults) {
    currentContext = mergeWorkspaceContexts(currentContext, result.workspaceContext, 'second');
  }
  
  return currentContext;
}

/**
 * Prepare mode call parameters with appropriate context
 * This helps maintain consistent session and workspace context
 * 
 * @param modeCall Mode call definition
 * @param sessionId Current session ID
 * @param currentContext Current workspace context
 * @returns Prepared parameters with context
 */
export function prepareModeCallParams(
  modeCall: ModeCall,
  sessionId: string | undefined,
  currentContext: WorkspaceContext | null | undefined
): any {
  // Start with a copy of the original parameters
  const params = { ...modeCall.parameters };
  
  // Apply session ID if not already present
  if (sessionId && !params.sessionId) {
    params.sessionId = sessionId;
  }
  
  // Apply workspace context if not already present
  if (currentContext && (!params.workspaceContext || !parseWorkspaceContext(params.workspaceContext)?.workspaceId)) {
    params.workspaceContext = currentContext;
  }
  
  return params;
}

/**
 * Extract context information from parameters for use in prepareResult calls
 * This function handles both legacy string context and enhanced object context
 * @param params Parameters object that may contain context information
 * @returns Context suitable for prepareResult calls
 */
export function extractContextFromParams(params: any): CommonResult['context'] {
  if (params.context !== undefined) {
    return normalizeContextForResult(params.context);
  }
  return undefined;
}

/**
 * Normalize context for result output - handles both string and object formats
 * @param context Context in either string or enhanced object format
 * @returns Normalized context for result
 */
export function normalizeContextForResult(context: any): CommonResult['context'] {
  if (typeof context === 'string') {
    return context;
  } else if (typeof context === 'object' && context !== null) {
    // Return the enhanced context object as-is
    return context;
  }
  return undefined;
}
```

## utils/directoryTreeUtils.ts

```typescript
import { App, TFile, TFolder } from 'obsidian';
import { sanitizePath } from './pathUtils';

/**
 * Directory tree node representing a file or folder
 */
export interface DirectoryTreeNode {
  /**
   * Name of the file or folder
   */
  name: string;
  
  /**
   * Full path to the file or folder
   */
  path: string;
  
  /**
   * Type of the node
   */
  type: 'file' | 'folder';
  
  /**
   * Children nodes (only for folders)
   */
  children?: DirectoryTreeNode[];
  
  /**
   * File extension (only for files)
   */
  extension?: string;
  
  /**
   * Last modified timestamp (only for files)
   */
  lastModified?: number;
  
  /**
   * File size in bytes (only for files)
   */
  size?: number;
  
  
  /**
   * Whether this file is in the workspace's related files
   */
  isRelatedFile?: boolean;
  
  /**
   * Description from frontmatter (only for markdown files)
   */
  description?: string;
}

/**
 * Options for building directory trees
 */
export interface DirectoryTreeOptions {
  /**
   * Maximum depth to traverse (0 = unlimited)
   */
  maxDepth?: number;
  
  /**
   * Whether to include file metadata (size, lastModified)
   */
  includeMetadata?: boolean;
  
  /**
   * File extensions to include (empty = all files)
   */
  includeExtensions?: string[];
  
  /**
   * File extensions to exclude
   */
  excludeExtensions?: string[];
  
  
  /**
   * List of related files to mark
   */
  relatedFiles?: string[];
}

/**
 * Build a directory tree structure for a given root folder
 */
export class DirectoryTreeBuilder {
  private app: App;
  
  constructor(app: App) {
    this.app = app;
  }
  
  /**
   * Build a directory tree for the given root path
   */
  async buildTree(rootPath: string, options: DirectoryTreeOptions = {}): Promise<DirectoryTreeNode | null> {
    const normalizedRootPath = sanitizePath(rootPath, false);
    
    // Get the root folder
    const rootFolder = this.app.vault.getAbstractFileByPath(normalizedRootPath);
    
    if (!rootFolder) {
      return null;
    }
    
    if (rootFolder instanceof TFile) {
      // If root is a file, return a single file node
      return await this.buildFileNode(rootFolder, options);
    }
    
    if (rootFolder instanceof TFolder) {
      // Build tree from folder
      return await this.buildFolderNode(rootFolder, options, 0);
    }
    
    return null;
  }
  
  /**
   * Build a directory tree for multiple root paths
   */
  async buildMultiTree(rootPaths: string[], options: DirectoryTreeOptions = {}): Promise<DirectoryTreeNode[]> {
    const trees: DirectoryTreeNode[] = [];
    
    for (const rootPath of rootPaths) {
      const tree = await this.buildTree(rootPath, options);
      if (tree) {
        trees.push(tree);
      }
    }
    
    return trees;
  }
  
  /**
   * Build a flattened list of all files in the directory tree
   */
  async getFileList(rootPath: string, options: DirectoryTreeOptions = {}): Promise<string[]> {
    const tree = await this.buildTree(rootPath, options);
    if (!tree) {
      return [];
    }
    
    return this.flattenTree(tree);
  }
  
  /**
   * Build a node for a file
   */
  private async buildFileNode(file: TFile, options: DirectoryTreeOptions): Promise<DirectoryTreeNode> {
    const node: DirectoryTreeNode = {
      name: file.name,
      path: file.path,
      type: 'file',
      extension: file.extension
    };
    
    // Add metadata if requested
    if (options.includeMetadata && file.stat) {
      node.lastModified = file.stat.mtime;
    }
    
    
    // Mark as related file if in the list
    if (options.relatedFiles && options.relatedFiles.includes(file.path)) {
      node.isRelatedFile = true;
    }
    
    // Get description from frontmatter for markdown files
    if (file.extension === 'md') {
      try {
        const content = await this.app.vault.read(file);
        const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
        
        if (frontmatterMatch) {
          const frontmatter = frontmatterMatch[1];
          // Look for description field
          const descMatch = frontmatter.match(/description\s*:\s*["']?([^\n"']+)["']?/);
          if (descMatch) {
            node.description = descMatch[1].trim();
          }
        }
      } catch (error) {
        // Ignore errors reading file
      }
    }
    
    return node;
  }
  
  /**
   * Build a node for a folder
   */
  private async buildFolderNode(
    folder: TFolder, 
    options: DirectoryTreeOptions, 
    currentDepth: number
  ): Promise<DirectoryTreeNode> {
    const node: DirectoryTreeNode = {
      name: folder.name,
      path: folder.path,
      type: 'folder',
      children: []
    };
    
    // Check depth limit
    if (options.maxDepth && currentDepth >= options.maxDepth) {
      return node;
    }
    
    // Process children
    for (const child of folder.children) {
      if (child instanceof TFile) {
        // Filter by extensions if specified
        if (options.includeExtensions && options.includeExtensions.length > 0) {
          if (!options.includeExtensions.includes(child.extension)) {
            continue;
          }
        }
        
        if (options.excludeExtensions && options.excludeExtensions.includes(child.extension)) {
          continue;
        }
        
        const fileNode = await this.buildFileNode(child, options);
        node.children!.push(fileNode);
      } else if (child instanceof TFolder) {
        const folderNode = await this.buildFolderNode(child, options, currentDepth + 1);
        node.children!.push(folderNode);
      }
    }
    
    // Sort children: folders first by name, then files by last modified (newest first)
    node.children!.sort((a, b) => {
      // Folders come before files
      if (a.type === 'folder' && b.type === 'file') return -1;
      if (a.type === 'file' && b.type === 'folder') return 1;
      
      // Between folders, sort alphabetically
      if (a.type === 'folder' && b.type === 'folder') {
        return a.name.localeCompare(b.name);
      }
      
      // Between files, sort by last modified (newest first)
      if (a.type === 'file' && b.type === 'file') {
        const aTime = a.lastModified || 0;
        const bTime = b.lastModified || 0;
        return bTime - aTime;
      }
      
      return 0;
    });
    
    return node;
  }
  
  
  /**
   * Flatten a directory tree into a list of file paths
   */
  private flattenTree(node: DirectoryTreeNode): string[] {
    const files: string[] = [];
    
    if (node.type === 'file') {
      files.push(node.path);
    } else if (node.children) {
      for (const child of node.children) {
        files.push(...this.flattenTree(child));
      }
    }
    
    return files;
  }
  
  /**
   * Find a node in the tree by path
   */
  findNodeByPath(tree: DirectoryTreeNode, targetPath: string): DirectoryTreeNode | null {
    const normalizedTarget = sanitizePath(targetPath, false);
    const normalizedCurrentPath = sanitizePath(tree.path, false);
    
    if (normalizedCurrentPath === normalizedTarget) {
      return tree;
    }
    
    if (tree.children) {
      for (const child of tree.children) {
        const found = this.findNodeByPath(child, targetPath);
        if (found) {
          return found;
        }
      }
    }
    
    return null;
  }
  
  
  /**
   * Get all files marked as related files in the tree
   */
  getRelatedFiles(tree: DirectoryTreeNode): string[] {
    const relatedFiles: string[] = [];
    
    if (tree.type === 'file' && tree.isRelatedFile) {
      relatedFiles.push(tree.path);
    } else if (tree.children) {
      for (const child of tree.children) {
        relatedFiles.push(...this.getRelatedFiles(child));
      }
    }
    
    return relatedFiles;
  }
}

/**
 * Utility functions for working with directory trees
 */
export class DirectoryTreeUtils {
  /**
   * Convert a directory tree to a simple text representation
   */
  static treeToText(tree: DirectoryTreeNode, indent = ''): string {
    let result = '';
    const _isLast = true; // We'll handle this in the caller
    
    const prefix = tree.type === 'folder' ? 'üìÅ ' : 'üìÑ ';
    const keyIndicator = '';
    const relatedIndicator = tree.isRelatedFile ? ' üîó' : '';
    const description = tree.description ? ` - ${tree.description}` : '';
    
    result += `${indent}${prefix}${tree.name}${keyIndicator}${relatedIndicator}${description}\n`;
    
    if (tree.children && tree.children.length > 0) {
      for (let i = 0; i < tree.children.length; i++) {
        const isChildLast = i === tree.children.length - 1;
        const childIndent = indent + (isChildLast ? '    ' : '‚îÇ   ');
        const childPrefix = isChildLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
        
        result += `${indent}${childPrefix}`;
        result += this.treeToText(tree.children[i], childIndent).substring(indent.length + 4);
      }
    }
    
    return result;
  }
  
  /**
   * Get statistics about a directory tree
   */
  static getTreeStats(tree: DirectoryTreeNode): {
    totalFiles: number;
    totalFolders: number;
    relatedFiles: number;
    maxDepth: number;
  } {
    const stats = {
      totalFiles: 0,
      totalFolders: 0,
      relatedFiles: 0,
      maxDepth: 0
    };
    
    this.calculateStats(tree, stats, 0);
    
    return stats;
  }
  
  private static calculateStats(
    node: DirectoryTreeNode, 
    stats: any, 
    currentDepth: number
  ): void {
    stats.maxDepth = Math.max(stats.maxDepth, currentDepth);
    
    if (node.type === 'file') {
      stats.totalFiles++;
      if (node.isRelatedFile) stats.relatedFiles++;
    } else {
      stats.totalFolders++;
    }
    
    if (node.children) {
      for (const child of node.children) {
        this.calculateStats(child, stats, currentDepth + 1);
      }
    }
  }
}
```

## utils/errorUtils.ts

```typescript
/**
 * Utility functions for error handling
 */

/**
 * Extracts a readable message from any error type
 * @param error Any error type (Error, string, unknown, etc.)
 * @returns A string message representing the error
 */
export function getErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  } else if (typeof error === 'string') {
    return error;
  } else if (error && typeof error === 'object' && 'message' in error && typeof error.message === 'string') {
    return error.message;
  } else if (error === null) {
    return 'Null error';
  } else if (error === undefined) {
    return 'Undefined error';
  } else {
    return String(error);
  }
}

/**
 * Creates a prefixed error message from any error type
 * @param prefix The prefix to add to the error message (e.g. "Failed to create folder: ")
 * @param error Any error type (Error, string, unknown, etc.)
 * @returns A string message with the prefix and the error
 */
export function createErrorMessage(prefix: string, error: unknown): string {
  return `${prefix}${getErrorMessage(error)}`;
}
```

## utils/filterUtils.ts

```typescript
/**
 * Utility functions for handling filter patterns in various modes
 */

/**
 * Create a regex from a filter pattern that supports both glob patterns and regex
 * @param pattern The filter pattern (can be glob pattern like "*test*" or regex)
 * @param flags Optional regex flags (default: 'i' for case-insensitive)
 * @returns RegExp object for filtering
 */
export function createFilterRegex(pattern: string, flags = 'i'): RegExp {
  try {
    // First, try to use the pattern as-is (might be a valid regex)
    return new RegExp(pattern, flags);
  } catch (error) {
    // If it fails, treat it as a simple glob pattern and convert to regex
    // Convert glob patterns to regex: * becomes .*, ? becomes .
    const escapedPattern = pattern
      .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars except * and ?
      .replace(/\*/g, '.*') // Convert * to .*
      .replace(/\?/g, '.'); // Convert ? to .
    return new RegExp(escapedPattern, flags);
  }
}

/**
 * Filter an array of items by name using a pattern
 * @param items Array of items with a 'name' property
 * @param pattern Filter pattern (glob or regex)
 * @returns Filtered array
 */
export function filterByName<T extends { name: string }>(items: T[], pattern: string): T[] {
  if (!pattern) return items;
  
  const filterRegex = createFilterRegex(pattern);
  return items.filter(item => filterRegex.test(item.name));
}

/**
 * Filter an array of items by a custom property using a pattern
 * @param items Array of items
 * @param pattern Filter pattern (glob or regex)
 * @param getProperty Function to extract the property to filter by
 * @returns Filtered array
 */
export function filterByProperty<T>(
  items: T[], 
  pattern: string, 
  getProperty: (item: T) => string
): T[] {
  if (!pattern) return items;
  
  const filterRegex = createFilterRegex(pattern);
  return items.filter(item => filterRegex.test(getProperty(item)));
}

/**
 * Standard filter description for use in parameter schemas
 */
export const FILTER_DESCRIPTION = 'Optional filter pattern. Supports glob patterns (* for any chars, ? for single char) or regular expressions. Examples: "*deep*", "test*", ".*regex.*"';
```

## utils/jsonUtils.ts

```typescript
/**
 * Utility functions for JSON operations
 * This module provides reusable functions for handling JSON-related operations
 * across the codebase, particularly focused on safe stringification and array parsing.
 */

/**
 * Safely stringify an object, handling circular references
 * @param obj - Object to stringify
 * @returns JSON string representation of the object
 * 
 * Example:
 * ```ts
 * const obj = { a: 1 };
 * obj.self = obj; // circular reference
 * console.log(safeStringify(obj)); // {"a":1,"self":"[Circular Reference]"}
 * ```
 */
export function safeStringify(obj: any): string {
    const seen = new WeakSet();
    return JSON.stringify(obj, (_, value) => {
        if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
                return '[Circular Reference]';
            }
            seen.add(value);
        }
        return value;
    }, 2);
}

/**
 * Parse string representations of JSON arrays in arguments
 * Handles cases where array parameters might be passed as stringified JSON
 * 
 * @param args - Arguments object to parse
 * @returns Parsed arguments object with proper arrays
 * 
 * Example:
 * ```ts
 * const args = { paths: '["file1.txt","file2.txt"]' };
 * const parsed = parseJsonArrays(args);
 * console.log(parsed.paths); // ['file1.txt', 'file2.txt']
 * ```
 */
export function parseJsonArrays(args: any): any {
    if (!args || typeof args !== 'object') {
        return args;
    }

    const result: any = {};
    
    // Process each property in the arguments object
    for (const [key, value] of Object.entries(args)) {
        // Check if the value is a string that looks like a JSON array
        if (typeof value === 'string' &&
            value.trim().startsWith('[') &&
            value.trim().endsWith(']')) {
            try {
                // Attempt to parse the string as JSON
                result[key] = JSON.parse(value);
            } catch (error) {
                // If parsing fails, keep the original string value
                console.warn(`Failed to parse string as array for parameter '${key}':`, error);
                result[key] = value;
            }
        } else {
            // For non-array strings or other types, keep the original value
            result[key] = value;
        }
    }
    
    return result;
}

```

## utils/logger.ts

```typescript
/**
 * Enhanced logger that handles different types of logging.
 * Used to replace all console.log/warn/error calls with a centralized system
 * that can be configured to show only necessary logs.
 */
export const logger = {
    /**
     * Log fatal system errors that prevent core functionality
     */
    systemError(error: Error, context?: string) {
        console.error(
            `SYSTEM ERROR${context ? ` [${context}]` : ''}: ${error.message}`
        );
    },
    
    /**
     * Log system warnings that don't prevent functionality but indicate issues
     */
    systemWarn(message: string, context?: string) {
        console.warn(
            `SYSTEM WARNING${context ? ` [${context}]` : ''}: ${message}`
        );
    },
    
    /**
     * Log informational messages during development
     */
    systemLog(message: string, context?: string) {
        // Disabled to reduce console output during production
        // console.log(
        //     `SYSTEM INFO${context ? ` [${context}]` : ''}: ${message}`
        // );
    }
    
    // operationError function removed to eliminate unnecessary console logs
};

```

## utils/nudgeHelpers.ts

```typescript
/**
 * Helper functions for dynamic tool nudges
 * Provides common logic for nudge triggers based on the dynamic tool nudges specification
 */

import { Recommendation } from './recommendationUtils';

/**
 * Helper functions for analyzing tool results and creating nudges
 */
export class NudgeHelpers {
  
  /**
   * Check if multiple files were found (>3 files) to suggest batch operations
   */
  static checkMultipleFiles(fileCount: number): Recommendation | null {
    if (fileCount > 3) {
      return {
        type: "efficiency",
        message: "Multiple files found. Consider using ContentManager batchContent to read several files efficiently in one operation."
      };
    }
    return null;
  }

  /**
   * Check if files are from different folders to suggest organization
   */
  static checkDifferentFolders(filePaths: string[]): Recommendation | null {
    if (filePaths.length === 0) return null;
    
    // Extract unique folder paths
    const folders = new Set(filePaths.map(path => {
      const lastSlash = path.lastIndexOf('/');
      return lastSlash === -1 ? '' : path.substring(0, lastSlash);
    }));
    
    if (folders.size > 1) {
      return {
        type: "organization", 
        message: "Found related files across multiple folders. You might want to consider organizing them with VaultManager."
      };
    }
    return null;
  }

  /**
   * Check if content is large (>7,000 characters) to suggest state saving
   */
  static checkLargeContent(contentLength: number): Recommendation | null {
    if (contentLength > 7000) {
      return {
        type: "save",
        message: "Large document read. Consider using MemoryManager createState to capture key insights before continuing."
      };
    }
    return null;
  }

  /**
   * Always suggest frontmatter and wikilinks for new files
   */
  static suggestObsidianFeatures(): Recommendation {
    return {
      type: "obsidian_features",
      message: "New file created. Consider adding frontmatter for metadata and wikilinks [[like this]] to connect with other notes."
    };
  }

  /**
   * Check session for multiple file creations to suggest state saving
   */
  static checkMultipleFilesInSession(sessionContext: any): Recommendation | null {
    // This would need session tracking - for now return null and implement later with full session context
    // In the future, this could check session memory for previous file creation operations
    return null;
  }

  /**
   * Check for many files read in batch (>3) to suggest state saving
   */
  static checkBatchReadOperations(readCount: number): Recommendation | null {
    if (readCount > 3) {
      return {
        type: "save",
        message: "Multiple files reviewed. Consider using MemoryManager createState to capture your findings."
      };
    }
    return null;
  }

  /**
   * Check for many files created in batch (>2) to suggest agent creation
   */
  static checkBatchCreateOperations(createCount: number): Recommendation | null {
    if (createCount > 2) {
      return {
        type: "agent_suggestion",
        message: "Creating multiple similar files? Consider using AgentManager to create a custom agent for this type of content generation."
      };
    }
    return null;
  }

  /**
   * Always suggest link checking after moving files
   */
  static suggestLinkChecking(): Recommendation {
    return {
      type: "link_check",
      message: "Files moved. Consider checking if any internal links need updating with ContentManager."
    };
  }

  /**
   * Always suggest customization after duplicating files
   */
  static suggestCustomization(): Recommendation {
    return {
      type: "customization",
      message: "File duplicated. Consider using ContentManager to customize the copy for its new purpose."
    };
  }

  /**
   * Always suggest impact awareness after command execution
   */
  static suggestImpactAwareness(): Recommendation {
    return {
      type: "awareness",
      message: "Obsidian command executed. If this changed settings or enabled features, consider how it might affect your current workflow."
    };
  }

  /**
   * Always suggest state saving after prompt execution
   */
  static suggestCaptureProgress(): Recommendation {
    return {
      type: "capture",
      message: "Agent analysis complete. Consider using MemoryManager createState to save this progress."
    };
  }

  /**
   * Always suggest workspace integration for new agents
   */
  static suggestWorkspaceIntegration(): Recommendation {
    return {
      type: "workspace_integration",
      message: "New agent created. Consider associating it with your current workspace using MemoryManager updateWorkspace for automatic availability."
    };
  }

  /**
   * Check for large workspace (>20 files) to suggest exploration tools
   */
  static checkLargeWorkspace(fileCount: number): Recommendation | null {
    if (fileCount > 20) {
      return {
        type: "exploration",
        message: "Large workspace loaded. Consider using VaultManager listDirectory to explore the structure, or VaultLibrarian search to find specific content."
      };
    }
    return null;
  }

  /**
   * Always suggest next steps after state creation
   */
  static suggestNextSteps(): Recommendation {
    return {
      type: "next_steps",
      message: "Progress saved. Consider what you'd like to work on next, or use AgentManager if you want to automate similar future workflows."
    };
  }

  /**
   * Check memory search results for previous states
   */
  static checkPreviousStates(results: any[]): Recommendation | null {
    // Look for states in memory search results
    const hasStates = results.some(result => 
      result.category === 'states' || 
      (result.metadata && result.metadata.type === 'state')
    );
    
    if (hasStates) {
      return {
        type: "context_restoration",
        message: "Relevant previous work found. Consider using MemoryManager loadState to restore that context."
      };
    }
    return null;
  }

  /**
   * Check memory search results for workspace sessions
   */
  static checkWorkspaceSessions(results: any[]): Recommendation | null {
    // Look for sessions in memory search results
    const hasSessions = results.some(result => 
      result.category === 'sessions' || 
      (result.metadata && result.metadata.type === 'session')
    );
    
    if (hasSessions) {
      return {
        type: "session_continuation",
        message: "Related workspace sessions found. Consider MemoryManager loadSession and/or load state to continue previous work."
      };
    }
    return null;
  }

  /**
   * Helper to extract file paths from search results
   */
  static extractFilePathsFromResults(results: any[]): string[] {
    if (!Array.isArray(results)) return [];
    
    return results
      .map(result => result.filePath || result.path || result.file)
      .filter(path => typeof path === 'string')
      .filter(Boolean);
  }

  /**
   * Helper to count file operations in batch results
   */
  static countOperationsByType(operations: any[]): { read: number; create: number; total: number } {
    if (!Array.isArray(operations)) return { read: 0, create: 0, total: 0 };
    
    const read = operations.filter(op => op.operation === 'read' || op.type === 'read').length;
    const create = operations.filter(op => op.operation === 'create' || op.type === 'create').length;
    
    return { read, create, total: operations.length };
  }
}
```

## utils/parameterHintUtils.ts

```typescript
/**
 * Utilities for generating helpful parameter hints for users
 */
import { getErrorMessage } from './errorUtils';
import { ValidationError } from './validationUtils';

/**
 * Parameter hint for a specific mode parameter
 */
export interface ParameterHint {
    name: string;
    description: string;
    type: string;
    required: boolean;
    defaultValue?: any;
    constraints?: string;
    example?: any;
}

/**
 * Contextual help for a specific mode
 */
export interface ModeHelp {
    modeName: string;
    description: string;
    parameters: ParameterHint[];
    examples?: {
        description: string;
        parameters: Record<string, any>;
    }[];
}

/**
 * Generate structured parameter hints from a JSON schema
 * 
 * @param schema JSON schema to generate hints from
 * @returns Parameter hints for all properties in the schema
 */
export function generateStructuredHints(schema: any): ParameterHint[] {
    if (!schema || !schema.properties || typeof schema.properties !== 'object') {
        return [];
    }
    
    const requiredProps = Array.isArray(schema.required) ? schema.required : [];
    const hints: ParameterHint[] = [];
    
    for (const [propName, propSchema] of Object.entries<any>(schema.properties)) {
        if (!propSchema) continue;
        
        const hint: ParameterHint = {
            name: propName,
            description: propSchema.description || 'No description provided',
            type: getTypeFromSchema(propSchema),
            required: requiredProps.includes(propName)
        };
        
        // Add default value if present
        if (propSchema.default !== undefined) {
            hint.defaultValue = propSchema.default;
        }
        
        // Add constraints if present
        const constraints = getConstraintsFromSchema(propSchema);
        if (constraints) {
            hint.constraints = constraints;
        }
        
        // Add example if present
        if (propSchema.examples && propSchema.examples.length > 0) {
            hint.example = propSchema.examples[0];
        } else if (propSchema.example !== undefined) {
            hint.example = propSchema.example;
        }
        
        hints.push(hint);
    }
    
    // Sort required parameters first, then alphabetically
    return hints.sort((a, b) => {
        if (a.required && !b.required) return -1;
        if (!a.required && b.required) return 1;
        return a.name.localeCompare(b.name);
    });
}

/**
 * Generate structured mode help from a mode's schema and metadata
 * 
 * @param modeName Name of the mode
 * @param description Description of the mode
 * @param schema JSON schema for the mode parameters
 * @param examples Optional examples of mode usage
 * @returns Structured help object for the mode
 */
export function generateModeHelp(
    modeName: string, 
    description: string, 
    schema: any,
    examples?: { description: string; parameters: Record<string, any> }[]
): ModeHelp {
    return {
        modeName,
        description,
        parameters: generateStructuredHints(schema),
        examples
    };
}

/**
 * Format mode help into a user-friendly string
 * 
 * @param help Structured mode help object
 * @returns Formatted help string
 */
export function formatModeHelp(help: ModeHelp): string {
    let output = `## ${help.modeName}\n\n${help.description}\n\n### Parameters:\n\n`;
    
    for (const param of help.parameters) {
        output += `**${param.name}**${param.required ? ' (Required)' : ' (Optional)'}: ${param.description}\n`;
        output += `- Type: ${param.type}\n`;
        
        if (param.defaultValue !== undefined) {
            output += `- Default: ${JSON.stringify(param.defaultValue)}\n`;
        }
        
        if (param.constraints) {
            output += `- Constraints: ${param.constraints}\n`;
        }
        
        if (param.example !== undefined) {
            output += `- Example: ${JSON.stringify(param.example)}\n`;
        }
        
        output += '\n';
    }
    
    if (help.examples && help.examples.length > 0) {
        output += `### Examples:\n\n`;
        
        for (const example of help.examples) {
            output += `#### ${example.description}\n\`\`\`json\n${JSON.stringify(example.parameters, null, 2)}\n\`\`\`\n\n`;
        }
    }
    
    return output;
}

/**
 * Generate parameter hints for validation errors
 * 
 * @param errors Array of validation errors
 * @param schema JSON schema used for validation
 * @returns Array of hint strings for each error
 */
export function generateHintsForErrors(errors: ValidationError[], schema: any): Record<string, string> {
    const hints: Record<string, string> = {};
    
    if (!schema || !schema.properties) {
        return hints;
    }
    
    for (const error of errors) {
        // Skip errors already having hints
        if (error.hint) continue;
        
        // Get parameter name from the error path
        const paramName = error.path.length > 0 ? error.path[0] : '';
        if (!paramName || typeof paramName !== 'string') continue;
        
        // Get schema for this parameter
        const paramSchema = schema.properties[paramName];
        if (!paramSchema) continue;
        
        // Generate hint based on error code
        let hint = '';
        
        switch (error.code) {
            case 'MISSING_REQUIRED':
                hint = `Required parameter. ${paramSchema.description || ''}`;
                break;
                
            case 'TYPE_ERROR':
                hint = `Must be ${getTypeFromSchema(paramSchema)}. ${paramSchema.description || ''}`;
                break;
                
            case 'ENUM_ERROR':
                if (paramSchema.enum && Array.isArray(paramSchema.enum)) {
                    hint = `Must be one of: ${paramSchema.enum.map((v: any) => JSON.stringify(v)).join(', ')}`;
                }
                break;
                
            case 'MIN_ERROR':
                hint = `Must be at least ${paramSchema.minimum}`;
                break;
                
            case 'MAX_ERROR':
                hint = `Must be at most ${paramSchema.maximum}`;
                break;
                
            case 'MIN_LENGTH_ERROR':
                hint = `Must be at least ${paramSchema.minLength} characters long`;
                break;
                
            case 'MAX_LENGTH_ERROR':
                hint = `Must be at most ${paramSchema.maxLength} characters long`;
                break;
                
            case 'PATTERN_ERROR':
                hint = `Must match pattern: ${paramSchema.pattern}`;
                break;
                
            default:
                // For unknown error codes, provide general parameter information
                hint = paramSchema.description || '';
                if (paramSchema.type) {
                    hint += ` Type: ${getTypeFromSchema(paramSchema)}.`;
                }
        }
        
        if (hint) {
            hints[paramName] = hint;
        }
    }
    
    return hints;
}

/**
 * Extract type information from a schema property
 * 
 * @param schema Schema property to extract type from
 * @returns String representation of the property type
 */
function getTypeFromSchema(schema: any): string {
    if (!schema) return 'any';
    
    if (schema.enum && Array.isArray(schema.enum)) {
        return `enum (${schema.enum.map((v: any) => JSON.stringify(v)).join(', ')})`;
    }
    
    if (schema.type) {
        if (schema.type === 'array' && schema.items) {
            const itemType = schema.items.type || 'any';
            return `array of ${itemType}`;
        }
        
        if (schema.type === 'object' && schema.properties) {
            const propNames = Object.keys(schema.properties);
            if (propNames.length === 0) {
                return 'object';
            }
            return `object with properties: ${propNames.join(', ')}`;
        }
        
        return Array.isArray(schema.type) ? schema.type.join(' | ') : schema.type;
    }
    
    return 'any';
}

/**
 * Extract constraints from a schema property
 * 
 * @param schema Schema property to extract constraints from
 * @returns String representation of constraints, or undefined if none
 */
function getConstraintsFromSchema(schema: any): string | undefined {
    if (!schema) return undefined;
    
    const constraints: string[] = [];
    
    if (schema.minLength !== undefined) {
        constraints.push(`min length: ${schema.minLength}`);
    }
    
    if (schema.maxLength !== undefined) {
        constraints.push(`max length: ${schema.maxLength}`);
    }
    
    if (schema.pattern) {
        constraints.push(`pattern: ${schema.pattern}`);
    }
    
    if (schema.minimum !== undefined) {
        constraints.push(`min: ${schema.minimum}`);
    }
    
    if (schema.maximum !== undefined) {
        constraints.push(`max: ${schema.maximum}`);
    }
    
    if (schema.minItems !== undefined) {
        constraints.push(`min items: ${schema.minItems}`);
    }
    
    if (schema.maxItems !== undefined) {
        constraints.push(`max items: ${schema.maxItems}`);
    }
    
    return constraints.length > 0 ? constraints.join(', ') : undefined;
}
```

## utils/pathUtils.ts

```typescript
/**
 * Utilities for handling file paths safely
 */

/**
 * Basic path normalization - removes leading slash for Obsidian compatibility
 * @param path Path to normalize
 * @returns Normalized path without leading slash
 */
export function normalizePath(path: string): string {
    return path.startsWith('/') ? path.slice(1) : path;
}

/**
 * Determines if a path should be treated as absolute
 */
export function isAbsolutePath(path: string): boolean {
    // Check for absolute path patterns
    return path.startsWith('/') || /^[A-Z]:\\/i.test(path) || path.startsWith('\\\\');
}

/**
 * Sanitizes a filename or folder name
 * @param name The name to sanitize
 * @param useUnderscores Whether to replace spaces with underscores
 */
export function sanitizeName(name: string, useUnderscores = false): string {
    if (!name || typeof name !== 'string') {
        return '_unnamed_';
    }

    let sanitized = name
        // Replace characters invalid in Windows paths
        .replace(/[<>:"\\|?*]/g, '_')
        // Remove leading/trailing periods and spaces
        .replace(/^[\s.]+|[\s.]+$/g, '');

    if (useUnderscores) {
        sanitized = sanitized
            // Replace multiple spaces/underscores with single underscore
            .replace(/\s+/g, '_')
            .replace(/_+/g, '_');
    }

    // Ensure name isn't empty after sanitization
    return sanitized || '_unnamed_';
}

/**
 * Sanitizes a file path by replacing invalid characters with safe alternatives
 * @param path The file path to sanitize
 * @param preserveLeadingSlash Whether to preserve a leading slash if present
 * @returns A sanitized path safe for file system operations
 */
export function sanitizePath(path: string, preserveLeadingSlash = false): string {
    // Handle empty or invalid input
    if (!path || typeof path !== 'string') {
        return '';
    }

    // Detect if path had a leading slash
    const hadLeadingSlash = path.startsWith('/');

    // Normalize path separators
    const normalizedPath = path.replace(/\\/g, '/');

    // Split path into parts
    const parts = normalizedPath.split('/');

    // Sanitize each part while preserving structure
    const sanitizedParts = parts.map((part, index) => {
        // Skip empty parts, dots, and root indicators
        if (!part || part === '.' || part === '..' || 
            (index === 0 && isAbsolutePath(path))) {
            return part;
        }

        return sanitizeName(part, false);
    });

    // Reconstruct path
    let result = sanitizedParts.join('/');
    
    // Handle leading slash consistently
    if (hadLeadingSlash && preserveLeadingSlash) {
        // Ensure path starts with exactly one slash
        result = '/' + result.replace(/^\/+/, '');
    } else {
        // Remove any leading slashes
        result = result.replace(/^\/+/, '');
    }

    return result;
}

/**
 * Ensures a path has a .md extension
 * @param path The file path to check
 * @returns Path with .md extension
 */
export function ensureMdExtension(path: string): string {
    if (!path.toLowerCase().endsWith('.md')) {
        return path + '.md';
    }
    return path;
}

/**
 * Operation types for path normalization
 */
export type OperationType = 'NOTE' | 'DIRECTORY' | 'GENERIC';

/**
 * Smart path normalization that handles missing file extensions
 * Only adds .md extension for note operations when no extension is present
 * @param path The file path to normalize
 * @param preserveLeadingSlash Whether to preserve a leading slash if present
 * @param operationType Type of operation to determine extension handling
 * @returns Normalized path with appropriate extension handling
 */
export function smartNormalizePath(
    path: string, 
    preserveLeadingSlash = false, 
    operationType: OperationType = 'GENERIC'
): string {
    if (!path || typeof path !== 'string') {
        return '';
    }

    // First apply standard path sanitization
    const sanitizedPath = sanitizePath(path, preserveLeadingSlash);
    
    // Only add .md extension for note operations when no extension is present
    if (operationType === 'NOTE' && 
        sanitizedPath && 
        !sanitizedPath.endsWith('/') && 
        !hasFileExtension(sanitizedPath)) {
        return sanitizedPath + '.md';
    }
    
    return sanitizedPath;
}

/**
 * Checks if a path has any file extension
 * @param path The path to check
 * @returns True if path has an extension, false otherwise
 */
function hasFileExtension(path: string): boolean {
    const lastSlashIndex = path.lastIndexOf('/');
    const lastDotIndex = path.lastIndexOf('.');
    
    // Extension must come after the last slash (if any) and not be the first character of filename
    return lastDotIndex > lastSlashIndex && lastDotIndex > lastSlashIndex + 1;
}

// Removed isLikelyFolder function - no longer needed with explicit operation types

/**
 * Gets the parent folder path from a file path
 * @param path The file path
 * @returns The parent folder path
 */
export function getFolderPath(path: string): string {
    const parts = path.split('/');
    return parts.slice(0, -1).join('/');
}

/**
 * Validates a file path for basic safety
 * @param path The file path to validate
 * @returns True if path is valid, false otherwise
 */
export function isValidPath(path: string): boolean {
    if (!path || typeof path !== 'string') {
        return false;
    }

    // Check for absolute paths or directory traversal
    if (path.startsWith('/') || path.includes('..')) {
        return false;
    }

    // Check for invalid characters
    const invalidChars = /[<>:"\\|?*\x00-\x1F]/;
    if (invalidChars.test(path)) {
        return false;
    }

    return true;
}

```

## utils/recommendationUtils.ts

```typescript
/**
 * Utility for standardized recommendation injection into mode results
 * Used across agents to provide consistent recommendation arrays in MCP responses
 */

export interface Recommendation {
	type: string;
	message: string;
}

/**
 * Adds recommendations array to any mode result object
 * @param result - The base result object from a mode execution
 * @param recommendations - Array of recommendations to inject
 * @returns Enhanced result with recommendations field
 */
export function addRecommendations(result: any, recommendations: Recommendation[]): any {
	return { ...result, recommendations };
}
```

## utils/schemaUtils.ts

```typescript
import type { CommonResult } from '../types';
import { enhanceSchemaDocumentation } from './validationUtils';

/**
 * Utility functions for handling JSON schemas in a DRY way
 */

/**
 * Get schema for workspace context parameters
 * @returns JSON schema for workspace context
 */
export function getWorkspaceContextSchema(): any {
  return enhanceSchemaDocumentation({
    workspaceContext: {
      oneOf: [
        {
          type: 'object',
          properties: {
            workspaceId: { 
              type: 'string',
              description: 'Workspace identifier (optional - uses default workspace if not provided)' 
            },
            workspacePath: { 
              type: 'array', 
              items: { type: 'string' },
              description: 'Path from root workspace to specific phase/task'
            },
            contextDepth: {
              type: 'string',
              enum: ['minimal', 'standard', 'comprehensive'],
              description: 'Level of context to include in results'
            }
          },
          description: 'Optional workspace context object - if not provided, uses a default workspace'
        },
        {
          type: 'string',
          description: 'Optional workspace context as JSON string - must contain workspaceId field'
        }
      ],
      description: 'Optional workspace context - if not provided, uses a default workspace'
    }
  });
}

/**
 * Get schema for a single mode call
 * @returns JSON schema for a mode call
 */
export function getModeCallSchema(): any {
  return enhanceSchemaDocumentation({
    type: 'object',
    properties: {
      tool: { 
        type: 'string',
        description: 'Agent name to execute mode on' 
      },
      mode: { 
        type: 'string',
        description: 'Mode to execute' 
      },
      parameters: { 
        type: 'object',
        description: 'Parameters to pass to the mode'
      },
      returnHere: { 
        type: 'boolean',
        description: 'Whether to return results to original agent'
      },
      continueOnFailure: {
        type: 'boolean',
        description: 'Whether to continue execution if this mode fails'
      },
      strategy: {
        type: 'string',
        enum: ['serial', 'parallel'],
        description: 'Execution strategy for this mode call'
      },
      callName: {
        type: 'string',
        description: 'Optional name to identify this mode call in the results'
      }
    },
    required: ['tool', 'mode', 'parameters'],
    description: 'Mode call definition'
  });
}


/**
 * Get schema for session parameters (now part of context - kept for backward compatibility)
 * @returns Empty schema since session fields are now in context
 */
export function getSessionSchema(): any {
  return {};
}

/**
 * Get schema for context parameter
 * @returns JSON schema for context
 */
export function getContextSchema(): any {
  return enhanceSchemaDocumentation({
    context: {
      type: 'object',
      properties: {
        sessionId: {
          type: 'string',
          description: '2-4 word name for this session, or the session ID when provided by system'
        },
        workspaceId: {
          type: 'string',
          description: 'REQUIRED: Workspace identifier for associating this tool call with the correct workspace. Use the workspace ID from the most recent loadWorkspace call, or the workspace ID that was provided/discussed in the conversation. If no workspace has been loaded, use "default".'
        },
        sessionDescription: {
          type: 'string',
          description: 'Brief description of what this session is about - updates as conversation evolves',
          minLength: 10
        },
        sessionMemory: {
          type: 'string',
          description: 'Summary of what has happened in the conversation so far, including key decisions, actions taken, and important context',
          minLength: 10
        },
        toolContext: {
          type: 'string', 
          description: 'Specific context for why this tool/mode is being used at this moment',
          minLength: 5
        },
        primaryGoal: {
          type: 'string',
          description: 'The overarching goal of the current conversation/task',
          minLength: 5
        },
        subgoal: {
          type: 'string',
          description: 'What this specific tool call is trying to accomplish',
          minLength: 5
        }
      },
      required: ['sessionId', 'workspaceId', 'sessionDescription', 'sessionMemory', 'toolContext', 'primaryGoal', 'subgoal'],
      description: 'Rich contextual information for this tool call including session management'
    }
  });
}

export function getCommonParameterSchema(): any {
  return {
    ...getSessionSchema(),
    ...getWorkspaceContextSchema(),
    ...getContextSchema()
  };
}

/**
 * Get schema for common result
 * @returns JSON schema for common result
 */
export function getCommonResultSchema(): any {
  return enhanceSchemaDocumentation({
    type: 'object',
    properties: {
      success: {
        type: 'boolean',
        description: 'Whether the operation was successful'
      },
      error: {
        type: 'string',
        description: 'Error message if operation failed'
      },
      data: {
        type: 'object',
        description: 'Operation-specific result data'
      },
      context: {
        type: 'string',
        description: 'Background information and purpose for running this tool'
      },
      workspaceContext: {
        type: 'object',
        properties: {
          workspaceId: { 
            type: 'string',
            description: 'Workspace identifier'
          },
          workspacePath: { 
            type: 'array', 
            items: { type: 'string' },
            description: 'Path from root workspace to specific phase/task'
          },
          sessionId: {
            type: 'string',
            description: 'Session identifier used for this operation'
          },
          activeWorkspace: { 
            type: 'boolean',
            description: 'Whether this workspace is currently active'
          },
          contextDepth: {
            type: 'string',
            enum: ['minimal', 'standard', 'comprehensive'],
            description: 'Level of context included in results'
          }
        },
        description: 'Workspace context that was used'
      },
      sessionId: {
        type: 'string',
        description: 'Session identifier used for tracking tool calls'
      }
    },
    required: ['success', 'sessionId']
  });
}

/**
 * Merge custom parameter schema with common parameter schema
 * @param customSchema The mode-specific schema
 * @returns Merged schema with common parameters
 */
export function mergeWithCommonSchema(customSchema: any): any {
  const commonSchema = getCommonParameterSchema();
  
  // Merge properties without duplication
  const mergedProperties = {
    ...customSchema.properties,
    ...commonSchema
  };
  
  // Merge required arrays without duplicates
  const customRequired = customSchema.required || [];
  const commonRequired = ['sessionId', 'context'];
  const mergedRequired = Array.from(new Set([...customRequired, ...commonRequired]));
  
  return {
    type: 'object',
    properties: mergedProperties,
    required: mergedRequired
  };
}

/**
 * Create a standardized result object
 * @param success Whether the operation was successful
 * @param data Operation-specific data
 * @param error Error message if operation failed
 * @param workspaceContext Workspace context used
 * @param sessionId Session identifier
 * @param context Contextual information (rich object or string for backward compatibility)
 * @param additionalProps Additional properties to include in the result
 * @returns Standardized result object
 */
export function createResult<T extends CommonResult>(
  success: boolean,
  data?: any,
  error?: string,
  workspaceContext?: CommonResult['workspaceContext'],
  sessionId?: string,
  context?: CommonResult['context'] | string,
  additionalProps?: Record<string, any>
): T {
  const result: any = {
    success,
    ...(data !== undefined && { data }),
    ...(error !== undefined && { error }),
    ...(workspaceContext !== undefined && { workspaceContext }),
    ...(sessionId !== undefined && { sessionId }),
    ...(context !== undefined && { context })
  };
  
  // Add any additional properties
  if (additionalProps) {
    Object.assign(result, additionalProps);
  }
  
  return result as T;
}
```

## utils/schemas/SchemaBuilder.ts

```typescript
/**
 * SchemaBuilder - Unified schema building system for all agent modes
 * Location: /src/utils/schemas/SchemaBuilder.ts
 * 
 * This file consolidates 4 duplicate schema builders into a single, unified system:
 * - agentManager/modes/batchExecutePrompt/utils/SchemaBuilder.ts
 * - agentManager/modes/execute/services/SchemaBuilder.ts  
 * - contentManager/modes/batch/schemas/SchemaBuilder.ts
 * - memoryManager/modes/session/create/services/SessionSchemaBuilder.ts
 * 
 * Used by all agent modes requiring schema generation for MCP tool definitions.
 */

import { 
  SchemaType, 
  SchemaContext, 
  ISchemaBuilder,
  ProviderInfo,
  CommonSchemaProperties,
  SchemaValidationResult,
  SchemaStatistics
} from './SchemaTypes';

// Re-export SchemaType for consumers
export { SchemaType } from './SchemaTypes';
import { LLMProviderManager } from '../../services/llm/providers/ProviderManager';
import { StaticModelsService } from '../../services/StaticModelsService';
import { mergeWithCommonSchema } from '../schemaUtils';

/**
 * Unified schema builder that handles all schema generation across the application
 * Eliminates code duplication and provides consistent schema patterns
 */
export class SchemaBuilder {
  private providerManager: LLMProviderManager | null;
  
  constructor(providerManager?: LLMProviderManager | null) {
    this.providerManager = providerManager || null;
  }

  /**
   * Main entry point - builds schema based on type and context
   */
  static buildSchema(type: SchemaType, context: SchemaContext): { 
    parameterSchema: any; 
    resultSchema: any; 
  } {
    const builder = new SchemaBuilder(context.providerManager);
    const concreteBuilder = builder.getBuilder(type);
    
    return {
      parameterSchema: concreteBuilder.buildParameterSchema(context),
      resultSchema: concreteBuilder.buildResultSchema(context)
    };
  }

  /**
   * Instance method for parameter schema building
   */
  buildParameterSchema(type: SchemaType, context: SchemaContext): any {
    const builder = this.getBuilder(type);
    return builder.buildParameterSchema(context);
  }

  /**
   * Instance method for result schema building  
   */
  buildResultSchema(type: SchemaType, context: SchemaContext): any {
    const builder = this.getBuilder(type);
    return builder.buildResultSchema(context);
  }

  /**
   * Get specific builder for schema type
   */
  private getBuilder(type: SchemaType): ISchemaBuilder {
    switch (type) {
      case SchemaType.BatchExecute:
        return new BatchExecuteSchemaBuilder(this.providerManager);
      case SchemaType.Execute:
        return new ExecuteSchemaBuilder(this.providerManager);
      case SchemaType.ContentBatch:
        return new ContentBatchSchemaBuilder();
      case SchemaType.Session:
        return new SessionSchemaBuilder();
      default:
        throw new Error(`Unknown schema type: ${type}`);
    }
  }

  /**
   * Update provider manager instance
   */
  updateProviderManager(providerManager: LLMProviderManager | null): void {
    this.providerManager = providerManager;
  }

  /**
   * Get provider information for schema building
   */
  getProviderInfo(): ProviderInfo {
    if (!this.providerManager) {
      return {
        enabledProviders: [],
        availableModels: [],
        hasProviderManager: false
      };
    }

    return {
      enabledProviders: this.getEnabledProviders(),
      availableModels: this.getAvailableModels(),
      hasProviderManager: true
    };
  }

  /**
   * Build common schema properties used across multiple types
   */
  buildCommonProperties(options: { 
    includeProviders?: boolean; 
    includeActions?: boolean; 
  } = {}): CommonSchemaProperties {
    const properties: CommonSchemaProperties = {};
    
    if (options.includeProviders) {
      const providerInfo = this.getProviderInfo();
      
      const defaultModel = this.getDefaultModel();
      
      properties.provider = {
        type: 'string',
        description: `LLM provider name (optional, defaults to: ${defaultModel?.provider || 'not configured'}). Use listModels to see available providers.`,
        default: defaultModel?.provider
      };

      properties.model = {
        type: 'string',
        description: `Model name (optional, defaults to: ${defaultModel?.model || 'not configured'}). Use listModels to see available models.`,
        default: defaultModel?.model
      };
    }

    if (options.includeActions) {
      properties.action = this.buildActionSchema();
    }

    return properties;
  }

  /**
   * Build action schema for content operations
   */
  private buildActionSchema(): any {
    return {
      type: 'object',
      description: 'Optional action to perform with the LLM response',
      properties: {
        type: {
          type: 'string',
          enum: ['create', 'append', 'prepend', 'replace', 'findReplace'],
          description: 'Type of content action to perform'
        },
        targetPath: {
          type: 'string',
          description: 'Path to the target file for the action'
        },
        position: {
          type: 'number',
          description: 'Line position for replace actions'
        },
        findText: {
          type: 'string',
          description: 'Text to find and replace (required for findReplace action)'
        },
        replaceAll: {
          type: 'boolean',
          description: 'Whether to replace all occurrences (default: false)',
          default: false
        },
        caseSensitive: {
          type: 'boolean',
          description: 'Whether search is case sensitive (default: true)',
          default: true
        },
        wholeWord: {
          type: 'boolean',
          description: 'Whether to match whole words only (default: false)',
          default: false
        }
      },
      required: ['type', 'targetPath']
    };
  }

  /**
   * Get enabled providers from provider manager
   */
  private getEnabledProviders(): string[] {
    if (!this.providerManager) return [];
    
    try {
      const settings = this.providerManager.getSettings();
      return Object.keys(settings.providers)
        .filter(id => settings.providers[id]?.enabled && settings.providers[id]?.apiKey);
    } catch (error) {
      console.warn('SchemaBuilder: Error getting enabled providers:', error);
      return [];
    }
  }

  /**
   * Get available models from enabled providers
   */
  private getAvailableModels(): string[] {
    if (!this.providerManager) return [];
    
    try {
      const staticModelsService = StaticModelsService.getInstance();
      const enabledProviders = this.getEnabledProviders();
      const models: string[] = [];
      
      enabledProviders.forEach(providerId => {
        try {
          const providerModels = staticModelsService.getModelsForProvider(providerId);
          models.push(...providerModels.map((m: any) => m.id));
        } catch (error) {
          console.warn(`SchemaBuilder: Error getting models for provider ${providerId}:`, error);
        }
      });
      
      return [...new Set(models)]; // Remove duplicates
    } catch (error) {
      console.warn('SchemaBuilder: Error getting available models:', error);
      return [];
    }
  }

  /**
   * Get default model from provider manager settings
   */
  private getDefaultModel(): { provider: string; model: string } | null {
    if (!this.providerManager) return null;
    
    try {
      const settings = this.providerManager.getSettings();
      return settings.defaultModel || null;
    } catch (error) {
      console.warn('SchemaBuilder: Error getting default model:', error);
      return null;
    }
  }

  /**
   * Validate schema configuration
   */
  validateConfiguration(): SchemaValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!this.providerManager) {
      warnings.push('Provider manager not available - schema will not include dynamic provider/model information');
    }

    const enabledProviders = this.getEnabledProviders();
    if (enabledProviders.length === 0) {
      warnings.push('No providers are currently enabled - users may not be able to execute prompts');
    }

    const availableModels = this.getAvailableModels();
    if (availableModels.length === 0) {
      warnings.push('No models are available - users may not be able to execute prompts');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Get schema building statistics
   */
  getStatistics(): SchemaStatistics {
    const providerInfo = this.getProviderInfo();
    
    return {
      parameterProperties: 0, // Will be set by concrete implementations
      resultProperties: 0, // Will be set by concrete implementations  
      supportedTypes: Object.values(SchemaType),
      hasProviderManager: !!this.providerManager,
      enabledProvidersCount: providerInfo.enabledProviders.length,
      availableModelsCount: providerInfo.availableModels.length
    };
  }
}

/**
 * Batch Execute Schema Builder - Handles complex batch LLM execution schemas
 */
class BatchExecuteSchemaBuilder implements ISchemaBuilder {
  constructor(private providerManager: LLMProviderManager | null) {}

  buildParameterSchema(context: SchemaContext): any {
    const builder = new SchemaBuilder(this.providerManager);
    const commonProps = builder.buildCommonProperties({ 
      includeProviders: true, 
      includeActions: true 
    });

    const batchSchema = {
      type: 'object',
      title: 'Batch Execute LLM Prompts Parameters',
      description: 'Execute multiple LLM prompts concurrently across different providers with context support.',
      properties: {
        prompts: {
          type: 'array',
          description: 'Array of prompts to execute concurrently',
          items: {
            type: 'object',
            title: 'Individual Prompt Configuration',
            description: 'Configuration for a single LLM prompt execution',
            properties: {
              prompt: {
                type: 'string',
                description: 'The prompt text to send to the LLM',
                examples: [
                  'Summarize this document',
                  'Generate unit tests for this code',
                  'Explain this concept in simple terms'
                ]
              },
              provider: commonProps.provider,
              model: commonProps.model,
              contextFiles: {
                type: 'array',
                description: 'Optional context files to include with this prompt',
                items: { type: 'string' }
              },
              workspace: {
                type: 'string',
                description: 'Optional workspace for context'
              },
              id: {
                type: 'string',
                description: 'Custom identifier for this prompt'
              },
              sequence: {
                type: 'number',
                description: 'Sequence number for ordered execution. Prompts with same sequence run in parallel, sequences execute in numerical order (0, 1, 2, etc.). If not specified, defaults to 0.',
                minimum: 0,
                examples: [0, 1, 2, 3]
              },
              parallelGroup: {
                type: 'string',
                description: 'Parallel group within sequence - prompts with same parallelGroup run together, different groups run sequentially within the sequence',
                examples: ['groupA', 'groupB', 'preprocessing', 'analysis']
              },
              includePreviousResults: {
                type: 'boolean',
                description: 'Whether to include previous sequence results as context for this prompt. Only applies when sequence > 0.',
                default: false
              },
              contextFromSteps: {
                type: 'array',
                description: 'Specific IDs of previous steps to include as context (if not specified, includes all previous results when includePreviousResults is true)',
                items: { type: 'string' }
              },
              action: commonProps.action,
              agent: {
                type: 'string',
                description: 'Optional custom agent/prompt to use for this prompt'
              }
            },
            required: ['prompt']
          },
          minItems: 1,
          maxItems: 100
        },
        mergeResponses: {
          type: 'boolean',
          description: 'Whether to merge all responses into a single result (default: false)',
          default: false
        }
      },
      required: ['prompts'],
      additionalProperties: false
    };
    
    return mergeWithCommonSchema(batchSchema);
  }

  buildResultSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the batch execution was successful'
        },
        results: {
          type: 'array',
          description: 'Individual prompt results (if mergeResponses is false)',
          items: this.buildPromptResultSchema()
        },
        merged: {
          type: 'object',
          description: 'Merged response (if mergeResponses is true)',
          properties: {
            totalPrompts: {
              type: 'number',
              description: 'Total number of prompts executed'
            },
            successfulPrompts: {
              type: 'number',
              description: 'Number of prompts that succeeded'
            },
            combinedResponse: {
              type: 'string',
              description: 'All responses combined into a single string'
            },
            providersUsed: {
              type: 'array',
              description: 'List of providers that were used',
              items: { type: 'string' }
            }
          }
        },
        stats: {
          type: 'object',
          description: 'Execution statistics',
          properties: {
            totalExecutionTimeMS: {
              type: 'number',
              description: 'Total execution time in milliseconds'
            },
            promptsExecuted: {
              type: 'number',
              description: 'Number of prompts executed'
            },
            promptsFailed: {
              type: 'number',
              description: 'Number of prompts that failed'
            },
            avgExecutionTimeMS: {
              type: 'number',
              description: 'Average execution time per prompt'
            },
            tokensUsed: {
              type: 'number',
              description: 'Total tokens used (if available)'
            }
          }
        },
        error: {
          type: 'string',
          description: 'Error message if batch execution failed'
        }
      },
      required: ['success'],
      additionalProperties: false
    };
  }

  private buildPromptResultSchema(): any {
    return {
      type: 'object',
      properties: {
        id: { type: 'string', description: 'Custom identifier for this prompt' },
        prompt: { type: 'string', description: 'The original prompt text' },
        success: { type: 'boolean', description: 'Whether this individual prompt succeeded' },
        response: { type: 'string', description: 'The LLM response (if successful)' },
        provider: { type: 'string', description: 'The provider that was used' },
        model: { type: 'string', description: 'The model that was used' },
        error: { type: 'string', description: 'Error message (if failed)' },
        executionTime: { type: 'number', description: 'Execution time in milliseconds' },
        sequence: { type: 'number', description: 'Sequence number this prompt was executed in' },
        parallelGroup: { type: 'string', description: 'Parallel group this prompt was executed in' },
        agent: { type: 'string', description: 'The custom agent that was used' },
        actionPerformed: {
          type: 'object',
          description: 'Details about any action performed with the response',
          properties: {
            type: { type: 'string', description: 'Type of action performed' },
            targetPath: { type: 'string', description: 'Target path for the action' },
            success: { type: 'boolean', description: 'Whether the action was successful' },
            error: { type: 'string', description: 'Error message if action failed' }
          }
        }
      }
    };
  }
}

/**
 * Execute Schema Builder - Handles single prompt execution schemas
 */
class ExecuteSchemaBuilder implements ISchemaBuilder {
  constructor(private providerManager: LLMProviderManager | null) {}

  buildParameterSchema(context: SchemaContext): any {
    const builder = new SchemaBuilder(this.providerManager);
    const commonProps = builder.buildCommonProperties({ 
      includeProviders: true, 
      includeActions: true 
    });

    return mergeWithCommonSchema({
      properties: {
        agent: {
          type: 'string',
          description: 'Custom prompt agent name/id to use as system prompt (optional - if not provided, uses raw prompt only)'
        },
        filepaths: {
          type: 'array',
          items: { type: 'string' },
          description: 'Optional array of file paths to include content as context'
        },
        prompt: {
          type: 'string',
          description: 'User prompt/question to send to the LLM'
        },
        provider: commonProps.provider,
        model: commonProps.model,
        temperature: {
          type: 'number',
          minimum: 0,
          maximum: 1,
          description: 'Temperature setting for response randomness (0.0-1.0)'
        },
        maxTokens: {
          type: 'number',
          description: 'Maximum tokens to generate'
        },
        action: commonProps.action
      },
      required: ['prompt']
    });
  }

  buildResultSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        error: { type: 'string' },
        data: {
          type: 'object',
          properties: {
            response: { type: 'string' },
            model: { type: 'string' },
            provider: { type: 'string' },
            agentUsed: { type: 'string' },
            usage: {
              type: 'object',
              properties: {
                promptTokens: { type: 'number' },
                completionTokens: { type: 'number' },
                totalTokens: { type: 'number' }
              },
              required: ['promptTokens', 'completionTokens', 'totalTokens']
            },
            cost: {
              type: 'object',
              properties: {
                inputCost: { type: 'number' },
                outputCost: { type: 'number' },
                totalCost: { type: 'number' },
                currency: { type: 'string' }
              },
              required: ['inputCost', 'outputCost', 'totalCost', 'currency']
            },
            filesIncluded: {
              type: 'array',
              items: { type: 'string' }
            },
            actionPerformed: {
              type: 'object',
              properties: {
                type: { type: 'string' },
                targetPath: { type: 'string' },
                success: { type: 'boolean' },
                error: { type: 'string' }
              },
              required: ['type', 'targetPath', 'success']
            }
          },
          required: ['response', 'model', 'provider', 'agentUsed']
        },
        sessionId: { type: 'string' },
        context: { type: 'string' }
      },
      required: ['success', 'sessionId']
    };
  }
}

/**
 * Content Batch Schema Builder - Handles batch content operations
 */
class ContentBatchSchemaBuilder implements ISchemaBuilder {
  buildParameterSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        operations: {
          type: 'array',
          description: 'Array of operations to perform',
          items: {
            type: 'object',
            properties: {
              type: {
                type: 'string',
                enum: ['read', 'create', 'append', 'prepend', 'replace', 'replaceByLine', 'delete', 'findReplace'],
                description: 'Type of operation'
              },
              params: {
                type: 'object',
                description: 'Operation-specific parameters. IMPORTANT: All operations require a "filePath" parameter.'
              }
            },
            required: ['type', 'params']
          }
        },
        workspaceContext: {
          type: 'object',
          description: 'Workspace context for the operation'
        },
        sessionId: {
          type: 'string',
          description: 'Session identifier for tracking'
        },
      },
      required: ['operations']
    };
  }

  buildResultSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation succeeded' },
        error: { type: 'string', description: 'Error message if success is false' },
        data: {
          type: 'object',
          properties: {
            results: {
              type: 'array',
              description: 'Array of operation results',
              items: {
                type: 'object',
                properties: {
                  success: { type: 'boolean', description: 'Whether the operation succeeded' },
                  error: { type: 'string', description: 'Error message if success is false' },
                  data: { type: 'object', description: 'Operation-specific result data' },
                  type: { type: 'string', description: 'Type of operation' },
                  filePath: { type: 'string', description: 'File path for the operation' }
                },
                required: ['success', 'type', 'filePath']
              }
            }
          },
          required: ['results']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: { type: 'string', description: 'ID of the workspace' },
            workspacePath: {
              type: 'array',
              items: { type: 'string' },
              description: 'Path of the workspace'
            },
            activeWorkspace: { type: 'boolean', description: 'Whether this is the active workspace' }
          }
        },
      },
      required: ['success']
    };
  }
}

/**
 * Session Schema Builder - Handles session creation schemas
 */
class SessionSchemaBuilder implements ISchemaBuilder {
  buildParameterSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name for the session' },
        description: { type: 'string', description: 'Description of the session purpose' },
        context: {
          type: 'string',
          description: 'Purpose or goal of this session - IMPORTANT: This will be stored with the session and used in memory operations',
          minLength: 1
        },
        generateContextTrace: {
          type: 'boolean',
          description: 'Whether to generate an initial memory trace with session context',
          default: true
        },
        sessionGoal: { type: 'string', description: 'The goal or purpose of this session (for memory context)' },
        previousSessionId: { type: 'string', description: 'Reference to previous session ID to establish continuity' },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Tags to associate with this session'
        },
        contextDepth: {
          type: 'string',
          enum: ['minimal', 'standard', 'comprehensive'],
          description: 'How much context to include in the initial memory trace',
          default: 'standard'
        },
        workspaceContext: {
          oneOf: [
            {
              type: 'object',
              properties: {
                workspaceId: { type: 'string', description: 'Workspace identifier (optional - uses default workspace if not provided)' },
                workspacePath: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Path from root workspace to specific phase/task'
                }
              },
              description: 'Optional workspace context object - if not provided, uses a default workspace'
            },
            {
              type: 'string',
              description: 'Optional workspace context as JSON string - must contain workspaceId field'
            }
          ],
          description: 'Optional workspace context - if not provided, uses a default workspace'
        }
      }
    };
  }

  buildResultSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation was successful' },
        data: {
          type: 'object',
          properties: {
            sessionId: { type: 'string', description: 'ID of the created session' },
            name: { type: 'string', description: 'Name of the created session' },
            workspaceId: { type: 'string', description: 'ID of the workspace' },
            startTime: { type: 'number', description: 'Session start timestamp' },
            previousSessionId: { type: 'string', description: 'ID of the previous session (if continuing)' },
            purpose: { type: 'string', description: 'The purpose of this session extracted from context parameter' },
            context: { type: 'string', description: 'Contextual information about the operation (from CommonResult)' },
            memoryContext: {
              type: 'object',
              description: 'Detailed contextual information about the session',
              properties: {
                summary: { type: 'string', description: 'Summary of the workspace state at session start' },
                purpose: { type: 'string', description: 'The purpose or goal of this session derived from context parameter' },
                relevantFiles: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Key files relevant to this session'
                },
                recentActivities: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      timestamp: { type: 'number', description: 'When the activity occurred' },
                      description: { type: 'string', description: 'Description of the activity' },
                      type: { type: 'string', description: 'Type of activity' }
                    }
                  },
                  description: 'Recent activities in the workspace'
                },
                tags: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Tags describing this session'
                }
              },
              required: ['summary', 'tags']
            }
          },
          required: ['sessionId', 'workspaceId', 'startTime']
        },
        error: { type: 'string', description: 'Error message if operation failed' },
        context: { type: 'string', description: 'The purpose and context of this session creation' }
      },
      required: ['success']
    };
  }
}
```

## utils/schemas/SchemaTypes.ts

```typescript
/**
 * SchemaTypes - Centralized type definitions for unified schema builder system
 * Location: /src/utils/schemas/SchemaTypes.ts
 * 
 * This file provides type definitions and enums for the unified schema builder,
 * consolidating patterns from 4 duplicate schema builders across the codebase.
 * Used by SchemaBuilder.ts to maintain type safety and consistent schema generation.
 */

import { LLMProviderManager } from '../../services/llm/providers/ProviderManager';

/**
 * Schema types supported by the unified builder
 */
export const SchemaType = {
  BatchExecute: 'batchExecute',
  Execute: 'execute', 
  ContentBatch: 'contentBatch',
  Session: 'session',
  State: 'state'
} as const;

export type SchemaType = typeof SchemaType[keyof typeof SchemaType];

/**
 * Context information for schema building
 */
export interface SchemaContext {
  mode: string;
  parameters?: any;
  options?: SchemaOptions;
  providerManager?: LLMProviderManager | null;
}

/**
 * Options for customizing schema generation
 */
export interface SchemaOptions {
  includeProviderInfo?: boolean;
  includeActions?: boolean;
  includeSession?: boolean;
  includeWorkspace?: boolean;
  maxItems?: number;
  minItems?: number;
}

/**
 * Base interface for all schema builders
 */
export interface ISchemaBuilder {
  buildParameterSchema(context: SchemaContext): any;
  buildResultSchema(context: SchemaContext): any;
}

/**
 * Provider and model information for dynamic schemas
 */
export interface ProviderInfo {
  enabledProviders: string[];
  availableModels: string[];
  hasProviderManager: boolean;
}

/**
 * Action schema configuration
 */
export interface ActionConfig {
  type: 'create' | 'append' | 'prepend' | 'replace' | 'findReplace';
  targetPath: string;
  position?: number;
  findText?: string;
  replaceAll?: boolean;
  caseSensitive?: boolean;
  wholeWord?: boolean;
}

/**
 * Content operation types for batch operations
 */
export type ContentOperationType = 
  | 'read' 
  | 'create' 
  | 'append' 
  | 'prepend' 
  | 'replace' 
  | 'replaceByLine' 
  | 'delete' 
  | 'findReplace';

/**
 * Session context depth options
 */
export type ContextDepth = 'minimal' | 'standard' | 'comprehensive';

/**
 * Execution sequence configuration
 */
export interface SequenceConfig {
  sequence?: number;
  parallelGroup?: string;
  includePreviousResults?: boolean;
  contextFromSteps?: string[];
}

/**
 * Usage and cost information
 */
export interface UsageInfo {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
}

export interface CostInfo {
  inputCost: number;
  outputCost: number;
  totalCost: number;
  currency: string;
}

/**
 * Common schema properties that appear across multiple schema types
 */
export interface CommonSchemaProperties {
  // Provider/Model properties
  provider?: {
    type: string;
    description: string;
    enum?: string[];
    examples?: string[];
    default?: string;
  };
  model?: {
    type: string;
    description: string;
    enum?: string[];
    examples?: string[];
    default?: string;
  };
  
  // Action properties
  action?: any;
  
  // Session properties
  sessionId?: {
    type: string;
    description: string;
  };
  
  // Workspace properties
  workspaceContext?: any;
  
  // Context properties
  context?: any;
}

/**
 * Schema validation result
 */
export interface SchemaValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Schema builder statistics
 */
export interface SchemaStatistics {
  parameterProperties: number;
  resultProperties: number;
  supportedTypes: SchemaType[];
  hasProviderManager: boolean;
  enabledProvidersCount: number;
  availableModelsCount: number;
}
```

## utils/sessionUtils.ts

```typescript
/**
 * Session utility functions for consistent session management
 * Provides standardized methods for generating and working with session IDs
 */

/**
 * Generate a standardized session ID based on current datetime
 * @returns Session ID in the format s-YYYYMMDDhhmmss
 */
export function generateSessionId(): string {
    const now = new Date();
    const formattedDate = now.toISOString().replace(/[-:.TZ]/g, '').slice(0, 14);
    return `s-${formattedDate}`;
}

/**
 * Format session instructions for Claude
 * @param sessionId The session ID to include in instructions
 * @returns Formatted instruction string
 */
export function formatSessionInstructions(sessionId: string): string {
    return `üîÑ SESSION ID: ${sessionId} - MANDATORY: Use this ID in all future requests, do NOT use the name.`;
}

/**
 * Determines if a session ID is new (created by us) or externally provided
 * This is useful for deciding when to show session instructions
 * 
 * @param sessionId The session ID to check
 * @returns Boolean indicating if this appears to be a session ID in our format
 */
export function isStandardSessionId(sessionId: string): boolean {
    // Check if it follows our s-YYYYMMDDhhmmss format
    return /^s-\d{14}$/.test(sessionId);
}

/**
 * Enhances a context string with session instructions
 * 
 * @param sessionId The session ID to include in instructions
 * @param contextString The original context string
 * @returns Enhanced context string with instructions
 */
export function enhanceContextWithSessionInstructions(
    sessionId: string, 
    contextString?: string
): string {
    const instructions = formatSessionInstructions(sessionId);
    if (!contextString) {
        return instructions;
    }
    return `${instructions}\n\n${contextString}`;
}
```

## utils/validation/CommonValidators.ts

```typescript
/**
 * Location: /src/utils/validation/CommonValidators.ts
 * Purpose: Reusable validation functions for the most common parameter patterns
 * 
 * This utility provides standardized validation functions that eliminate duplication
 * across modes by centralizing common validation patterns like required strings,
 * file paths, session context, and other frequently validated parameter types.
 * 
 * Used by: All modes for parameter validation via BaseMode.validateCustom()
 * Integrates with: ValidationResultHelper, BaseMode, CommonParameters
 */

import { CommonParameters } from '../../types/mcp/AgentTypes';
import { ValidationError } from './ValidationResultHelper';

/**
 * String validation options interface
 */
export interface StringValidationOptions {
  /**
   * Minimum length (default: 1)
   */
  minLength?: number;
  
  /**
   * Maximum length (default: 500)
   */
  maxLength?: number;
  
  /**
   * Allow empty strings (default: false)
   */
  allowEmpty?: boolean;
  
  /**
   * Trim whitespace before validation (default: true)
   */
  trimWhitespace?: boolean;
  
  /**
   * Regular expression pattern to match
   */
  pattern?: string;
  
  /**
   * Hint for pattern requirements
   */
  patternHint?: string;
}

/**
 * File path validation options interface
 */
export interface FilePathValidationOptions {
  /**
   * Apply Obsidian-specific validation rules (default: true)
   */
  obsidianValidation?: boolean;
  
  /**
   * Allow glob patterns like *.md (default: false)
   */
  allowGlobs?: boolean;
  
  /**
   * Allow directory paths (default: true)
   */
  allowDirectories?: boolean;
  
  /**
   * Required file extension
   */
  requiredExtension?: string;
  
  /**
   * Maximum path length (default: 1000)
   */
  maxLength?: number;
}

/**
 * Session context validation options interface
 */
export interface SessionContextOptions {
  /**
   * Require session ID to be present (default: true)
   */
  requireSessionId?: boolean;
  
  /**
   * Require workspace context (default: false)
   */
  requireWorkspace?: boolean;
  
  /**
   * Minimum length for context fields (default: 5)
   */
  minContextLength?: number;
}

/**
 * Validation rule function type
 */
export type ValidationRule<T> = (value: any, fieldName: string) => ValidationError | null;

/**
 * Validation rule set type
 */
export type ValidationRuleSet<T> = {
  [K in keyof T]?: ValidationRule<T[K]>;
};

/**
 * CommonValidators - Centralized validation utilities for common parameter patterns
 */
export class CommonValidators {
  /**
   * Validate required string with comprehensive error reporting
   * 
   * Provides detailed validation for string fields with customizable constraints
   * and consistent error messaging across all modes.
   * 
   * @param value Value to validate
   * @param fieldName Name of the field being validated
   * @param options Validation options
   * @returns ValidationError if validation fails, null if valid
   */
  static requiredString(
    value: any,
    fieldName: string,
    options: StringValidationOptions = {}
  ): ValidationError | null {
    const opts: Required<StringValidationOptions> = {
      minLength: 1,
      maxLength: 500,
      allowEmpty: false,
      trimWhitespace: true,
      pattern: undefined as any,
      patternHint: undefined as any,
      ...options
    };

    // Check for null/undefined
    if (value === null || value === undefined) {
      return this.createFieldError(fieldName, 'FIELD_REQUIRED', 
        `${fieldName} is required`, 'Please provide a value');
    }

    // Check type
    if (typeof value !== 'string') {
      return this.createFieldError(fieldName, 'TYPE_ERROR',
        `${fieldName} must be a string`, 
        `Expected string, received ${typeof value}`);
    }

    const processedValue = opts.trimWhitespace ? value.trim() : value;

    // Check empty string
    if (!opts.allowEmpty && processedValue.length === 0) {
      return this.createFieldError(fieldName, 'EMPTY_STRING',
        `${fieldName} cannot be empty`,
        'Please provide a non-empty value');
    }

    // Check minimum length
    if (processedValue.length < opts.minLength) {
      return this.createFieldError(fieldName, 'MIN_LENGTH',
        `${fieldName} must be at least ${opts.minLength} characters`,
        `Current length: ${processedValue.length}`);
    }

    // Check maximum length
    if (processedValue.length > opts.maxLength) {
      return this.createFieldError(fieldName, 'MAX_LENGTH',
        `${fieldName} must not exceed ${opts.maxLength} characters`,
        `Current length: ${processedValue.length}`);
    }

    // Check pattern
    if (opts.pattern && !new RegExp(opts.pattern).test(processedValue)) {
      return this.createFieldError(fieldName, 'PATTERN_MISMATCH',
        `${fieldName} format is invalid`,
        opts.patternHint || 'Please check the required format');
    }

    return null;
  }

  /**
   * Validate file path with Obsidian-specific constraints
   * 
   * Handles file path validation including Obsidian-specific rules for
   * invalid characters, reserved names, and path length constraints.
   * 
   * @param value Value to validate
   * @param fieldName Name of the field being validated
   * @param options Validation options
   * @returns ValidationError if validation fails, null if valid
   */
  static filePath(
    value: any, 
    fieldName: string = 'filePath',
    options: FilePathValidationOptions = {}
  ): ValidationError | null {
    // First validate as required string
    const stringError = this.requiredString(value, fieldName, {
      minLength: 1,
      maxLength: options.maxLength || 1000
    });
    if (stringError) return stringError;

    const path = value.trim();
    
    // Obsidian-specific file path validation
    if (options.obsidianValidation !== false) {
      // Check for invalid characters in Obsidian file paths
      const invalidChars = /[<>:"|?*\u0000-\u001f]/;
      if (!options.allowGlobs && invalidChars.test(path)) {
        return this.createFieldError(fieldName, 'INVALID_PATH_CHARS',
          `${fieldName} contains invalid characters`,
          'File paths cannot contain: < > : " | ? * or control characters');
      }

      // Allow glob patterns if specified
      if (options.allowGlobs) {
        const invalidGlobChars = /[<>:"|]/;
        if (invalidGlobChars.test(path)) {
          return this.createFieldError(fieldName, 'INVALID_GLOB_CHARS',
            `${fieldName} contains invalid characters for glob patterns`,
            'Glob patterns cannot contain: < > : " | or control characters');
        }
      }

      // Check for reserved names (Windows-specific but good practice)
      const reservedNames = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])(\.|$)/i;
      const fileName = path.split(/[/\\]/).pop() || '';
      if (reservedNames.test(fileName)) {
        return this.createFieldError(fieldName, 'RESERVED_NAME',
          `${fieldName} uses a reserved file name`,
          'Avoid reserved names like CON, PRN, AUX, etc.');
      }
    }

    // Check required extension
    if (options.requiredExtension && !path.toLowerCase().endsWith(`.${options.requiredExtension.toLowerCase()}`)) {
      return this.createFieldError(fieldName, 'MISSING_EXTENSION',
        `${fieldName} must have .${options.requiredExtension} extension`,
        `Add .${options.requiredExtension} to the file path`);
    }

    return null;
  }

  /**
   * Validate session context (common across all modes)
   * 
   * Validates the CommonParameters context structure including session ID,
   * workspace context, and other contextual information required for proper
   * session tracking and tool operation.
   * 
   * @param params CommonParameters to validate
   * @param mode Mode instance for context inheritance
   * @param options Validation options
   * @returns Array of validation errors
   */
  static validateSessionContext(
    params: CommonParameters,
    mode?: any, // Accept any type to avoid protected method access issues
    options: SessionContextOptions = {}
  ): ValidationError[] {
    const errors: ValidationError[] = [];
    const opts: Required<SessionContextOptions> = {
      requireSessionId: true,
      requireWorkspace: false,
      minContextLength: 5,
      ...options
    };

    // Validate context object structure
    if (!params.context) {
      if (opts.requireSessionId) {
        errors.push(this.createFieldError(
          'context',
          'CONTEXT_REQUIRED',
          'Context object is required',
          'Provide context with sessionId and other required fields'
        ));
      }
      return errors;
    }

    // Session ID validation
    if (opts.requireSessionId) {
      const sessionId = params.context.sessionId;
      if (!sessionId) {
        errors.push(this.createFieldError(
          'context.sessionId',
          'SESSION_ID_REQUIRED',
          'Session ID is required for tool tracking',
          'Ensure context.sessionId is provided'
        ));
      } else if (typeof sessionId !== 'string' || sessionId.trim().length === 0) {
        errors.push(this.createFieldError(
          'context.sessionId',
          'SESSION_ID_INVALID',
          'Session ID must be a non-empty string',
          'Provide a valid session identifier'
        ));
      }
    }

    // Workspace ID validation (required in context)
    if (!params.context.workspaceId) {
      errors.push(this.createFieldError(
        'context.workspaceId',
        'WORKSPACE_ID_REQUIRED',
        'Workspace ID is required in context',
        'Provide workspaceId in the context object'
      ));
    }

    // Validate context field lengths
    const contextFields = [
      { key: 'sessionDescription', name: 'Session description' },
      { key: 'sessionMemory', name: 'Session memory' },
      { key: 'toolContext', name: 'Tool context' },
      { key: 'primaryGoal', name: 'Primary goal' },
      { key: 'subgoal', name: 'Subgoal' }
    ];

    for (const field of contextFields) {
      const value = (params.context as any)[field.key];
      if (value !== undefined && (typeof value !== 'string' || value.trim().length < opts.minContextLength)) {
        errors.push(this.createFieldError(
          `context.${field.key}`,
          'CONTEXT_FIELD_TOO_SHORT',
          `${field.name} must be at least ${opts.minContextLength} characters`,
          `Provide meaningful ${field.name.toLowerCase()}`
        ));
      }
    }

    // Workspace context validation if required
    if (opts.requireWorkspace && mode && typeof mode.getInheritedWorkspaceContext === 'function') {
      try {
        const workspaceContext = mode.getInheritedWorkspaceContext(params);
        if (!workspaceContext?.workspaceId) {
          errors.push(this.createFieldError(
            'workspaceContext',
            'WORKSPACE_CONTEXT_REQUIRED',
            'Workspace context is required',
            'Provide workspaceContext or ensure inherited context is available'
          ));
        }
      } catch (error) {
        console.warn('Error validating workspace context:', error);
      }
    }

    return errors;
  }

  /**
   * Batch field validation with comprehensive error collection
   * 
   * Validates multiple fields using provided validators and collects all errors
   * in a single pass, providing comprehensive validation feedback.
   * 
   * @param params Object containing fields to validate
   * @param validators Mapping of field names to validation functions
   * @returns Array of validation errors
   */
  static validateFields<T>(
    params: T,
    validators: ValidationRuleSet<T>
  ): ValidationError[] {
    const errors: ValidationError[] = [];
    const startTime = performance.now();

    for (const [fieldName, validator] of Object.entries(validators)) {
      try {
        if (typeof validator === 'function') {
          const fieldValue = (params as any)[fieldName];
          const error = validator(fieldValue, fieldName);
          if (error) {
            errors.push(error);
          }
        }
      } catch (validationError) {
        errors.push(this.createFieldError(
          fieldName,
          'VALIDATION_ERROR',
          `Validation failed for ${fieldName}`,
          String(validationError)
        ));
      }
    }

    // Track validation performance
    this.trackValidationPerformance('validateFields', startTime, errors.length === 0);

    return errors;
  }

  /**
   * Validate boolean flag with type checking
   * 
   * @param value Value to validate
   * @param fieldName Name of the field being validated
   * @param required Whether the field is required
   * @returns ValidationError if validation fails, null if valid
   */
  static booleanFlag(
    value: any,
    fieldName: string,
    required: boolean = false
  ): ValidationError | null {
    if (value === undefined || value === null) {
      if (required) {
        return this.createFieldError(fieldName, 'FIELD_REQUIRED',
          `${fieldName} is required`, 'Provide true or false');
      }
      return null;
    }

    if (typeof value !== 'boolean') {
      return this.createFieldError(fieldName, 'TYPE_ERROR',
        `${fieldName} must be a boolean`, 
        `Expected true or false, received ${typeof value}`);
    }

    return null;
  }

  /**
   * Validate numeric value with range constraints
   * 
   * @param value Value to validate
   * @param fieldName Name of the field being validated
   * @param options Validation options
   * @returns ValidationError if validation fails, null if valid
   */
  static numericValue(
    value: any,
    fieldName: string,
    options: {
      minimum?: number;
      maximum?: number;
      integer?: boolean;
      required?: boolean;
    } = {}
  ): ValidationError | null {
    if (value === undefined || value === null) {
      if (options.required) {
        return this.createFieldError(fieldName, 'FIELD_REQUIRED',
          `${fieldName} is required`, 'Provide a numeric value');
      }
      return null;
    }

    if (typeof value !== 'number' || isNaN(value)) {
      return this.createFieldError(fieldName, 'TYPE_ERROR',
        `${fieldName} must be a number`, 
        `Expected number, received ${typeof value}`);
    }

    if (options.integer && !Number.isInteger(value)) {
      return this.createFieldError(fieldName, 'INTEGER_REQUIRED',
        `${fieldName} must be an integer`, 
        `Received ${value}, expected whole number`);
    }

    if (options.minimum !== undefined && value < options.minimum) {
      return this.createFieldError(fieldName, 'MINIMUM_VALUE',
        `${fieldName} must be at least ${options.minimum}`,
        `Current value: ${value}`);
    }

    if (options.maximum !== undefined && value > options.maximum) {
      return this.createFieldError(fieldName, 'MAXIMUM_VALUE',
        `${fieldName} must not exceed ${options.maximum}`,
        `Current value: ${value}`);
    }

    return null;
  }

  /**
   * Extract session ID from CommonParameters
   * 
   * Helper method to safely extract session ID with fallbacks
   * 
   * @param params CommonParameters to extract from
   * @returns Session ID or undefined
   */
  static extractSessionId(params: CommonParameters): string | undefined {
    return params.context?.sessionId;
  }

  /**
   * Create standardized field error
   * 
   * @param fieldName Name of the field that failed validation
   * @param code Machine-readable error code
   * @param message Human-readable error message
   * @param hint Optional hint to help resolve the issue
   * @returns ValidationError object
   */
  private static createFieldError(
    fieldName: string,
    code: string,
    message: string,
    hint?: string
  ): ValidationError {
    return {
      path: fieldName.split('.'),
      message,
      code,
      hint,
      severity: 'error',
      context: { fieldName }
    };
  }

  /**
   * Track validation performance for monitoring
   * 
   * Integrates with existing CompatibilityMonitor system when available
   * 
   * @param operation Name of the validation operation
   * @param startTime Start time of the operation
   * @param success Whether validation succeeded
   */
  private static trackValidationPerformance(
    operation: string,
    startTime: number,
    success: boolean
  ): void {
    const duration = performance.now() - startTime;
    
    // Integration with existing CompatibilityMonitor
    if (typeof (globalThis as any).CompatibilityMonitor !== 'undefined') {
      (globalThis as any).CompatibilityMonitor.trackValidation(
        'CommonValidators',
        operation,
        startTime,
        performance.now(),
        success
      );
    }

    // Debug logging for performance issues
    if (duration > 5) { // Log operations taking >5ms
      console.debug(`CommonValidators: ${operation} took ${duration.toFixed(2)}ms`, {
        success,
        duration
      });
    }
  }
}
```

## utils/validation/SchemaBlocks.ts

```typescript
/**
 * Location: /src/utils/validation/SchemaBlocks.ts
 * Purpose: Provide reusable, composable schema components to reduce schema definition duplication
 * 
 * This utility provides standardized schema building blocks that can be composed together
 * to create consistent JSON schemas across all modes, reducing duplication and ensuring
 * consistent parameter validation and documentation.
 * 
 * Used by: All modes for parameter schema definition via getParameterSchema()
 * Integrates with: JSON Schema, BaseMode.getMergedSchema(), existing schemaUtils
 */

/**
 * JSON Schema type definition
 */
export interface JSONSchema {
  type?: string;
  properties?: Record<string, any>;
  required?: string[];
  description?: string;
  minLength?: number;
  maxLength?: number;
  minimum?: number;
  maximum?: number;
  pattern?: string;
  format?: string;
  examples?: any[];
  items?: JSONSchema;
  enum?: any[];
  oneOf?: JSONSchema[];
  allOf?: JSONSchema[];
  not?: JSONSchema;
  if?: JSONSchema;
  then?: JSONSchema;
  anyOf?: JSONSchema[];
  dependencies?: Record<string, string[]>;
  additionalProperties?: boolean;
  default?: any;
  title?: string;
  
  // Custom extensions for tooling
  'x-sensitive'?: boolean;
  'x-pattern-hint'?: string;
  'x-labels'?: Record<string, string>;
}

/**
 * Schema block options for enhanced configuration
 */
export interface SchemaBlockOptions {
  description: string;
  required?: boolean;
  examples?: string[];
  constraints?: Record<string, any>;
  metadata?: Record<string, any>;
}

/**
 * SchemaBlocks - Composable schema building components for consistent schema creation
 */
export class SchemaBlocks {
  
  /**
   * Create validated string schema with comprehensive constraints
   * 
   * Provides a standardized string schema with common validation constraints
   * and consistent formatting across all modes.
   * 
   * @param options Configuration for the string schema
   * @returns JSON Schema for validated string
   */
  static validatedString(options: {
    description: string;
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    patternHint?: string;
    examples?: string[];
    format?: 'email' | 'uri' | 'date-time' | 'password';
    sensitive?: boolean;
    required?: boolean;
  }): JSONSchema {
    const schema: JSONSchema = {
      type: 'string',
      description: options.description
    };

    // Apply length constraints
    if (options.minLength !== undefined) schema.minLength = options.minLength;
    if (options.maxLength !== undefined) schema.maxLength = options.maxLength;
    
    // Apply pattern validation
    if (options.pattern) schema.pattern = options.pattern;
    if (options.format) schema.format = options.format;
    if (options.examples) schema.examples = options.examples;

    // Add metadata for enhanced tooling
    if (options.sensitive) schema['x-sensitive'] = true;
    if (options.patternHint) schema['x-pattern-hint'] = options.patternHint;

    return schema;
  }

  /**
   * Entity name schema with intelligent defaults based on entity type
   * 
   * Provides consistent naming schemas for different entity types with
   * appropriate length limits and character constraints.
   * 
   * @param entityType Type of entity being named
   * @param options Additional configuration options
   * @returns JSON Schema for entity name
   */
  static entityName(entityType: string, options: {
    maxLength?: number;
    allowSpecialChars?: boolean;
    uniqueConstraint?: boolean;
    examples?: string[];
  } = {}): JSONSchema {
    const maxLength = options.maxLength || this.getDefaultMaxLength(entityType);
    const pattern = options.allowSpecialChars 
      ? '^[a-zA-Z0-9\\s\\-_.@#+]+$'
      : '^[a-zA-Z0-9\\s\\-_]+$';
    
    const description = `Name of the ${entityType}${
      options.uniqueConstraint ? ' (must be unique)' : ''
    }`;
    
    const examples = options.examples || this.generateEntityExamples(entityType);

    return this.validatedString({
      description,
      minLength: 1,
      maxLength,
      pattern,
      patternHint: 'Letters, numbers, spaces, hyphens, and underscores allowed',
      examples
    });
  }

  /**
   * Search query schema with context-aware examples and constraints
   * 
   * Provides specialized schemas for different search contexts with appropriate
   * examples and validation rules.
   * 
   * @param context Type of search being performed
   * @param options Additional configuration options
   * @returns JSON Schema for search query
   */
  static searchQuery(context: 'content' | 'files' | 'memory' | 'universal' = 'universal', options: {
    maxLength?: number;
    allowEmpty?: boolean;
    examples?: string[];
  } = {}): JSONSchema {
    const contextExamples = {
      content: ['project planning', 'typescript validation', 'API documentation'],
      files: ['README.md', '*.ts', 'config'],
      memory: ['recent sessions', 'workspace activity', 'tool usage'],
      universal: ['project planning', 'machine learning', 'typescript', 'notes']
    };

    return this.validatedString({
      description: `Search query for ${context} search`,
      minLength: options.allowEmpty ? 0 : 1,
      maxLength: options.maxLength || 1000,
      examples: options.examples || contextExamples[context]
    });
  }

  /**
   * File path schema with Obsidian-specific validation
   * 
   * Provides file path validation appropriate for different file operations
   * with Obsidian-specific constraints and examples.
   * 
   * @param context Type of file operation
   * @param options Additional configuration options
   * @returns JSON Schema for file path
   */
  static filePath(context: 'read' | 'write' | 'search' = 'read', options: {
    allowGlobs?: boolean;
    allowDirectories?: boolean;
    requiredExtension?: string;
    examples?: string[];
  } = {}): JSONSchema {
    const contextDescriptions = {
      read: 'Path to file to read',
      write: 'Path where file will be created or modified',
      search: 'Path to restrict search scope'
    };

    let pattern = '^[^<>:"|?*\\x00-\\x1f]+$'; // Basic file path validation
    if (options.allowGlobs) {
      pattern = '^[^<>:"|\\x00-\\x1f]+$'; // Allow * and ? for globs
    }

    return this.validatedString({
      description: contextDescriptions[context],
      minLength: 1,
      maxLength: 1000,
      pattern,
      patternHint: 'Valid file path without reserved characters',
      examples: options.examples || this.generateFilePathExamples(context, options)
    });
  }

  /**
   * Boolean flag schema with enhanced UX
   * 
   * Provides consistent boolean schemas with user-friendly labels
   * and clear descriptions.
   * 
   * @param purpose What the boolean flag controls
   * @param defaultValue Default value for the flag
   * @param options Additional configuration
   * @returns JSON Schema for boolean flag
   */
  static booleanFlag(purpose: string, defaultValue: boolean = false, options: {
    description?: string;
    trueLabel?: string;
    falseLabel?: string;
  } = {}): JSONSchema {
    const schema: JSONSchema = {
      type: 'boolean',
      description: options.description || `Whether to ${purpose}`,
      default: defaultValue
    };

    // Add labels for better UX in tools
    if (options.trueLabel && options.falseLabel) {
      schema['x-labels'] = {
        true: options.trueLabel,
        false: options.falseLabel
      };
    }

    return schema;
  }

  /**
   * Numeric limit schema with context-aware defaults
   * 
   * Provides number schemas with appropriate defaults and constraints
   * based on the usage context.
   * 
   * @param context Usage context for the numeric value
   * @param options Additional configuration options
   * @returns JSON Schema for numeric limit
   */
  static numericLimit(context: 'search' | 'list' | 'batch' = 'search', options: {
    defaultValue?: number;
    minimum?: number;
    maximum?: number;
    allowUnlimited?: boolean;
    description?: string;
  } = {}): JSONSchema {
    const contextDefaults = {
      search: { default: 10, min: 1, max: 50 },
      list: { default: 20, min: 1, max: 100 },
      batch: { default: 10, min: 1, max: 1000 }
    };

    const defaults = contextDefaults[context];
    const defaultValue = options.defaultValue ?? defaults.default;
    const minimum = options.minimum ?? defaults.min;
    const maximum = options.maximum ?? defaults.max;

    const schema: JSONSchema = {
      type: 'number',
      description: options.description || `Maximum number of results (default: ${defaultValue})`,
      minimum,
      default: defaultValue
    };

    if (!options.allowUnlimited) {
      schema.maximum = maximum;
    }

    return schema;
  }

  /**
   * Enum selection schema with descriptive options
   * 
   * Creates enum schemas with clear descriptions and examples
   * for better user experience.
   * 
   * @param values Array of allowed values
   * @param options Configuration options
   * @returns JSON Schema for enum selection
   */
  static enumSelection<T extends string>(values: T[], options: {
    description: string;
    default?: T;
    labels?: Record<T, string>;
  }): JSONSchema {
    const schema: JSONSchema = {
      type: 'string',
      enum: values,
      description: options.description
    };

    if (options.default) {
      schema.default = options.default;
    }

    if (options.labels) {
      schema['x-labels'] = options.labels;
    }

    return schema;
  }

  /**
   * Advanced schema composition with validation rules
   * 
   * Composes multiple schema blocks together with advanced JSON Schema
   * features like conditional validation and mutual exclusivity.
   * 
   * @param blocks Schema blocks to compose
   * @param options Composition configuration
   * @returns Composed JSON Schema
   */
  static composeSchema(blocks: Record<string, JSONSchema>, options: {
    required?: string[];
    conditionalRequired?: Record<string, string[]>;
    mutuallyExclusive?: string[][];
    dependencies?: Record<string, string[]>;
    additionalProperties?: boolean;
    title?: string;
    description?: string;
  } = {}): JSONSchema {
    const schema: JSONSchema = {
      type: 'object',
      properties: blocks,
      additionalProperties: options.additionalProperties ?? false
    };

    if (options.title) schema.title = options.title;
    if (options.description) schema.description = options.description;
    if (options.required) schema.required = options.required;

    // Advanced JSON Schema features
    if (options.conditionalRequired) {
      schema.allOf = [];
      for (const [condition, requiredFields] of Object.entries(options.conditionalRequired)) {
        schema.allOf.push({
          if: { properties: { [condition]: { const: true } } },
          then: { required: requiredFields }
        });
      }
    }

    if (options.mutuallyExclusive && options.mutuallyExclusive.length > 0) {
      schema.not = {
        anyOf: options.mutuallyExclusive.map(group => ({
          allOf: group.map(field => ({ required: [field] }))
        }))
      };
    }

    if (options.dependencies) {
      schema.dependencies = options.dependencies;
    }

    return schema;
  }

  /**
   * Context field schema for rich session context
   * 
   * Provides standardized schema for context fields used in session tracking
   * and tool operation context.
   * 
   * @param fieldType Type of context field
   * @param options Configuration options
   * @returns JSON Schema for context field
   */
  static contextField(fieldType: 'description' | 'memory' | 'goal' | 'subgoal', options: {
    minLength?: number;
    maxLength?: number;
    examples?: string[];
  } = {}): JSONSchema {
    const fieldConfig = {
      description: {
        desc: 'Brief description of what this session/operation is about',
        defaultMin: 10,
        defaultMax: 500,
        examples: ['Working on validation system', 'Debugging search functionality', 'Planning new features']
      },
      memory: {
        desc: 'Summary of what has happened in the conversation so far',
        defaultMin: 10,
        defaultMax: 1000,
        examples: ['Implemented validation utilities, now working on schema blocks', 'Fixed search bug, testing results']
      },
      goal: {
        desc: 'The overarching goal of the current conversation/task',
        defaultMin: 5,
        defaultMax: 200,
        examples: ['Implement validation standardization', 'Fix search performance issues', 'Add new agent features']
      },
      subgoal: {
        desc: 'What this specific operation is trying to accomplish',
        defaultMin: 5,
        defaultMax: 200,
        examples: ['Create schema building blocks', 'Test validation integration', 'Document new utilities']
      }
    };

    const config = fieldConfig[fieldType];

    return this.validatedString({
      description: config.desc,
      minLength: options.minLength || config.defaultMin,
      maxLength: options.maxLength || config.defaultMax,
      examples: options.examples || config.examples
    });
  }

  // Helper methods for generating defaults and examples

  /**
   * Get default maximum length for different entity types
   * 
   * @param entityType Type of entity
   * @returns Default maximum length
   */
  private static getDefaultMaxLength(entityType: string): number {
    const defaults: Record<string, number> = {
      prompt: 100,
      session: 150,
      workspace: 100,
      file: 255,
      description: 500,
      content: 5000,
      query: 1000,
      name: 100
    };
    return defaults[entityType] || 100;
  }

  /**
   * Generate appropriate examples for entity types
   * 
   * @param entityType Type of entity
   * @returns Array of example names
   */
  private static generateEntityExamples(entityType: string): string[] {
    const examples: Record<string, string[]> = {
      prompt: ['Code Reviewer', 'Technical Writer', 'Research Assistant'],
      session: ['Daily Planning', 'Code Review Session', 'Research Notes'],
      workspace: ['Project Alpha', 'Research Workspace', 'Client Work'],
      file: ['README.md', 'config.json', 'main.ts'],
      query: ['search term', 'project planning', 'typescript validation'],
      name: ['My Item', 'New Entity', 'Custom Name']
    };
    return examples[entityType] || [`My ${entityType}`, `${entityType} name`];
  }

  /**
   * Generate file path examples based on context and options
   * 
   * @param context File operation context
   * @param options Configuration options
   * @returns Array of example file paths
   */
  private static generateFilePathExamples(
    context: 'read' | 'write' | 'search',
    options: any
  ): string[] {
    const baseExamples = {
      read: ['path/to/file.md', 'notes/daily-notes.txt', 'docs/README.md'],
      write: ['output/result.md', 'generated/summary.txt', 'exports/data.json'],
      search: ['notes/', 'projects/**/*.md', 'docs/']
    };

    let examples = baseExamples[context];

    if (options.allowGlobs) {
      examples = [...examples, '**/*.ts', 'src/**/*', '*.{md,txt}'];
    }

    if (options.requiredExtension) {
      examples = examples.map(ex => 
        ex.includes('.') ? ex : `${ex}.${options.requiredExtension}`
      );
    }

    return examples;
  }
}
```

## utils/validation/ValidationResultHelper.ts

```typescript
/**
 * Location: /src/utils/validation/ValidationResultHelper.ts
 * Purpose: Centralized result creation patterns to ensure consistency across all modes
 * 
 * This utility provides standardized methods for creating error and success results,
 * ensuring consistent error handling, context extraction, and response formatting
 * across all agents and modes.
 * 
 * Used by: All BaseMode implementations for standardized result creation
 * Integrates with: BaseMode, CommonParameters, CommonResult, contextUtils
 */

import { CommonParameters, CommonResult } from '../../types/mcp/AgentTypes';
import { extractContextFromParams, WorkspaceContext } from '../contextUtils';
import { getErrorMessage } from '../errorUtils';
import { createResult } from '../schemaUtils';

// Type for BaseMode interface without direct import to avoid file casing conflicts
interface ModeInterface {
  slug: string;
  name: string;
  description: string;
  version: string;
  constructor: { name: string };
}

/**
 * Validation error interface for detailed error reporting
 */
export interface ValidationError {
  /**
   * Path to the field that failed validation (e.g., ['name'] or ['workspaceContext', 'workspaceId'])
   */
  path: string[];
  
  /**
   * Human-readable error message
   */
  message: string;
  
  /**
   * Machine-readable error code for categorization
   */
  code: string;
  
  /**
   * Optional hint to help users resolve the issue
   */
  hint?: string;
  
  /**
   * Error severity level
   */
  severity?: 'error' | 'warning';
  
  /**
   * Additional context information
   */
  context?: Record<string, any>;
}

/**
 * Validation result interface for comprehensive validation outcomes
 */
export interface ValidationResult<T> {
  /**
   * Whether validation succeeded
   */
  success: boolean;
  
  /**
   * Validated data (original or transformed)
   */
  data: T;
  
  /**
   * Array of validation errors
   */
  errors: ValidationError[];
  
  /**
   * Optional warnings that don't prevent success
   */
  warnings?: string[];
  
  /**
   * Optional metadata about the validation process
   */
  metadata?: ValidationMetadata;
}

/**
 * Metadata about the validation process
 */
export interface ValidationMetadata {
  /**
   * Time taken to perform validation (milliseconds)
   */
  duration?: number;
  
  /**
   * Number of fields validated
   */
  fieldCount?: number;
  
  /**
   * Whether fallback validation was used
   */
  usedFallback?: boolean;
  
  /**
   * Additional context-specific metadata
   */
  [key: string]: any;
}

/**
 * Context extraction result
 */
interface ContextExtractionResult {
  sessionId?: string;
  workspaceContext?: WorkspaceContext;
  contextString?: string;
}

/**
 * ValidationResultHelper - Centralized result creation for consistent error and success handling
 */
export class ValidationResultHelper {
  /**
   * Create standardized error result with automatic context handling
   * 
   * This method provides consistent error formatting across all modes, ensuring
   * proper session tracking, workspace context handling, and error message formatting.
   * 
   * @param mode The mode instance creating the result
   * @param error Error string, Error object, or array of ValidationErrors
   * @param params Original parameters (for context extraction)
   * @param additionalContext Additional context to include in result
   * @returns Standardized error result
   */
  static createErrorResult<TResult extends CommonResult>(
    mode: ModeInterface,
    error: string | Error | ValidationError[],
    params?: CommonParameters,
    additionalContext?: Record<string, any>
  ): TResult {
    const startTime = performance.now();
    
    try {
      // Extract context information
      const contextResult = this.extractAndValidateContext(params, mode);
      
      // Format error message
      let errorMessage: string;
      let errorCode: string = 'VALIDATION_ERROR';
      let errorDetails: any = {};
      
      if (Array.isArray(error)) {
        // Handle ValidationError array
        const primaryErrors = error.filter(e => e.severity !== 'warning');
        if (primaryErrors.length > 0) {
          errorMessage = primaryErrors.map(e => e.message).join('; ');
          errorCode = primaryErrors[0].code || 'VALIDATION_ERROR';
          errorDetails = {
            validationErrors: error,
            errorCount: primaryErrors.length,
            warningCount: error.filter(e => e.severity === 'warning').length
          };
        } else {
          errorMessage = 'Validation failed with warnings';
          errorDetails = { validationErrors: error };
        }
      } else if (error instanceof Error) {
        errorMessage = error.message;
        errorCode = error.name || 'ERROR';
        errorDetails = {
          errorType: error.constructor.name,
          stack: error.stack
        };
      } else {
        errorMessage = error;
      }
      
      // Track error creation performance
      this.trackPerformance(
        mode.constructor.name,
        'error-result-creation',
        startTime,
        false,
        { errorCode, hasValidationErrors: Array.isArray(error) }
      );
      
      // Create standardized result - pass contextString as the context parameter
      return createResult<TResult>(
        false,
        null,
        errorMessage,
        contextResult.workspaceContext,
        contextResult.sessionId,
        contextResult.contextString,
        {
          errorCode,
          errorDetails,
          timestamp: Date.now(),
          mode: mode.name,
          ...additionalContext
        }
      );
      
    } catch (resultError) {
      // Fallback error creation if the main process fails
      console.error(`Error creating error result in ${mode.constructor.name}:`, resultError);
      
      return createResult<TResult>(
        false,
        null,
        `Error creating error result: ${getErrorMessage(resultError)}. Original error: ${getErrorMessage(error)}`,
        undefined,
        undefined,
        undefined,
        undefined
      );
    }
  }
  
  /**
   * Create standardized success result with context propagation
   * 
   * Ensures consistent success result formatting with proper context handling
   * and session tracking across all modes.
   * 
   * @param mode The mode instance creating the result
   * @param data Result data to include
   * @param params Original parameters (for context extraction)
   * @param additionalData Additional properties to include in result
   * @returns Standardized success result
   */
  static createSuccessResult<TResult extends CommonResult>(
    mode: ModeInterface,
    data: any,
    params?: CommonParameters,
    additionalData?: Record<string, any>
  ): TResult {
    const startTime = performance.now();
    
    try {
      // Extract context information
      const contextResult = this.extractAndValidateContext(params, mode);
      
      // Track success result creation performance
      this.trackPerformance(
        mode.constructor.name,
        'success-result-creation',
        startTime,
        true,
        { hasData: !!data, dataType: typeof data }
      );
      
      // Create standardized result
      return createResult<TResult>(
        true,
        data,
        undefined,
        contextResult.workspaceContext,
        contextResult.sessionId,
        contextResult.contextString,
        {
          timestamp: Date.now(),
          mode: mode.name,
          ...additionalData
        }
      );
      
    } catch (resultError) {
      console.error(`Error creating success result in ${mode.constructor.name}:`, resultError);
      
      // Fallback to error result if success result creation fails
      return this.createErrorResult(
        mode,
        `Error creating success result: ${getErrorMessage(resultError)}`,
        params
      );
    }
  }
  
  /**
   * Create validation result for field-level validation operations
   * 
   * @param data Original data being validated
   * @param errors Array of validation errors
   * @param warnings Optional array of warnings
   * @param metadata Optional validation metadata
   * @returns Validation result
   */
  static createValidationResult<T>(
    data: T,
    errors: ValidationError[] = [],
    warnings?: string[],
    metadata?: ValidationMetadata
  ): ValidationResult<T> {
    return {
      success: errors.filter(e => e.severity !== 'warning').length === 0,
      data,
      errors,
      warnings,
      metadata
    };
  }
  
  /**
   * Extract and validate session context from parameters
   * 
   * Handles the complex logic of extracting session IDs, workspace context,
   * and contextual information from parameters with proper fallbacks.
   * 
   * @param params Parameters to extract context from
   * @param mode Mode instance for context inheritance
   * @returns Extracted context information
   */
  private static extractAndValidateContext(
    params?: CommonParameters,
    mode?: ModeInterface
  ): ContextExtractionResult {
    const result: ContextExtractionResult = {};
    
    if (!params) {
      return result;
    }
    
    // Extract session ID from context
    if (params.context?.sessionId) {
      result.sessionId = params.context.sessionId;
    }
    
    // Extract workspace context using existing utility
    if (params.workspaceContext || (mode && typeof (mode as any).getInheritedWorkspaceContext === 'function')) {
      try {
        const workspaceContext = mode ? (mode as any).getInheritedWorkspaceContext(params) : null;
        if (workspaceContext) {
          result.workspaceContext = workspaceContext;
        }
      } catch (error) {
        console.warn('Error extracting workspace context:', error);
      }
    }
    
    // Extract context string from parameters
    if (params.context) {
      if (typeof params.context === 'string') {
        result.contextString = params.context;
      } else {
        // Convert rich context object to string
        const contextResult = extractContextFromParams(params);
        if (typeof contextResult === 'string') {
          result.contextString = contextResult;
        } else if (contextResult) {
          // Convert object to readable string
          result.contextString = Object.entries(contextResult)
            .filter(([_, value]) => value)
            .map(([key, value]) => `${key}: ${value}`)
            .join(', ');
        }
      }
    }
    
    return result;
  }
  
  /**
   * Track performance metrics for validation operations
   * 
   * Integrates with existing CompatibilityMonitor system when available
   * 
   * @param modeName Name of the mode performing validation
   * @param operation Type of operation being tracked
   * @param startTime Start time of the operation
   * @param success Whether the operation succeeded
   * @param metadata Additional metadata to track
   */
  private static trackPerformance(
    modeName: string,
    operation: string,
    startTime: number,
    success: boolean,
    metadata?: Record<string, any>
  ): void {
    const duration = performance.now() - startTime;
    
    // Integration with existing CompatibilityMonitor if available
    if (typeof (globalThis as any).CompatibilityMonitor !== 'undefined') {
      (globalThis as any).CompatibilityMonitor.trackValidation(
        `ValidationResultHelper_${modeName}`,
        operation,
        startTime,
        performance.now(),
        success
      );
    }
    
    // Additional performance logging for debugging
    if (duration > 10) { // Log slow operations (>10ms)
      console.debug(`ValidationResultHelper: ${operation} in ${modeName} took ${duration.toFixed(2)}ms`, {
        success,
        metadata
      });
    }
  }
}
```

## utils/validation/index.ts

```typescript
/**
 * Location: /src/utils/validation/index.ts
 * Purpose: Export barrel for validation utilities providing clean import interface
 * 
 * This file centralizes all validation utility exports for easy access throughout
 * the application, providing a clean interface for importing validation functionality.
 * 
 * Used by: All modes and utilities requiring validation functionality
 * Exports: All core validation utilities from Phase 1 implementation
 */

// Core validation utilities
export {
  ValidationResultHelper
} from './ValidationResultHelper';

export type {
  ValidationError,
  ValidationResult,
  ValidationMetadata
} from './ValidationResultHelper';

export {
  CommonValidators
} from './CommonValidators';

export type {
  StringValidationOptions,
  FilePathValidationOptions,
  SessionContextOptions,
  ValidationRule,
  ValidationRuleSet
} from './CommonValidators';

export {
  SchemaBlocks
} from './SchemaBlocks';

export type {
  JSONSchema,
  SchemaBlockOptions
} from './SchemaBlocks';


// Re-export commonly used patterns for convenience
// Note: Individual imports are preferred to avoid circular dependencies
// and provide better tree-shaking for the build process.
```

## utils/validationUtils.ts

```typescript
/**
 * Specialized utilities for parameter validation and providing helpful feedback
 */
// import { getErrorMessage } from './errorUtils';

/**
 * Represents a parameter validation error
 */
export interface ValidationError {
    path: string[];    // Path to the parameter that failed validation
    message: string;   // Error message
    code: string;      // Error code for classification
    hint?: string;     // Optional hint for fixing the issue
    expectedType?: string; // Expected type or format
    receivedType?: string; // Received type or format
    allowedValues?: any[]; // Allowed values if enum
}

/**
 * Validates parameters against a schema with enhanced error reporting
 * 
 * @param params Parameters to validate
 * @param schema Schema to validate against
 * @returns An array of validation errors, empty if validation passed
 */
export function validateParams(params: any, schema: any): ValidationError[] {
    const errors: ValidationError[] = [];
    
    // Check if schema exists
    if (!schema || typeof schema !== 'object') {
        return [{
            path: [],
            message: 'Invalid schema: Schema is missing or not an object',
            code: 'INVALID_SCHEMA'
        }];
    }
    
    // Handle required properties
    const requiredProps = Array.isArray(schema.required) ? schema.required : [];
    for (const prop of requiredProps) {
        if (!hasProperty(params, prop)) {
            errors.push({
                path: [prop],
                message: `Missing required parameter: ${prop}`,
                code: 'MISSING_REQUIRED',
                hint: `The parameter '${prop}' is required and must be provided`
            });
        }
    }
    
    // Validate properties that are provided
    if (schema.properties) {
        validateObjectProperties(params, schema.properties, [], errors);
    }
    
    // Check for conditional validations (allOf, anyOf, oneOf)
    if (schema.allOf && Array.isArray(schema.allOf)) {
        validateAllOf(params, schema.allOf, errors);
    }
    
    if (schema.anyOf && Array.isArray(schema.anyOf)) {
        validateAnyOf(params, schema.anyOf, errors);
    }
    
    if (schema.oneOf && Array.isArray(schema.oneOf)) {
        validateOneOf(params, schema.oneOf, errors);
    }
    
    return errors;
}

/**
 * Validate object properties against schema
 */
function validateObjectProperties(
    obj: any, 
    propSchemas: Record<string, any>, 
    path: string[], 
    errors: ValidationError[]
): void {
    if (!obj || typeof obj !== 'object' || Array.isArray(obj)) {
        errors.push({
            path,
            message: 'Expected an object',
            code: 'TYPE_ERROR',
            expectedType: 'object',
            receivedType: Array.isArray(obj) ? 'array' : typeof obj
        });
        return;
    }
    
    for (const [propName, propValue] of Object.entries(obj)) {
        const propPath = [...path, propName];
        const propSchema = propSchemas[propName];
        
        // Skip validation if no schema for this property
        if (!propSchema) continue;
        
        // Validate property value against its schema
        validateProperty(propValue, propSchema, propPath, errors);
    }
}

/**
 * Validate a specific property value against its schema
 */
function validateProperty(
    value: any, 
    schema: any, 
    path: string[], 
    errors: ValidationError[]
): void {
    // Handle type validation
    if (schema.type) {
        const typeValid = validateType(value, schema.type);
        if (!typeValid) {
            errors.push({
                path,
                message: `Invalid type for ${path.join('.')}`,
                code: 'TYPE_ERROR',
                expectedType: schema.type,
                receivedType: Array.isArray(value) ? 'array' : typeof value,
                hint: `This parameter expects ${getTypeDescription(schema.type)}`
            });
            // If type is invalid, skip further validation to avoid cascading errors
            return;
        }
    }
    
    // Handle minimum/maximum for numbers
    if (schema.type === 'number' || schema.type === 'integer') {
        if (schema.minimum !== undefined && value < schema.minimum) {
            errors.push({
                path,
                message: `Value ${value} is less than minimum ${schema.minimum}`,
                code: 'MIN_ERROR',
                hint: `The minimum allowed value is ${schema.minimum}`
            });
        }
        
        if (schema.maximum !== undefined && value > schema.maximum) {
            errors.push({
                path,
                message: `Value ${value} is greater than maximum ${schema.maximum}`,
                code: 'MAX_ERROR',
                hint: `The maximum allowed value is ${schema.maximum}`
            });
        }
    }
    
    // Handle minLength/maxLength for strings
    if (schema.type === 'string') {
        if (schema.minLength !== undefined && value.length < schema.minLength) {
            errors.push({
                path,
                message: `String length ${value.length} is less than minLength ${schema.minLength}`,
                code: 'MIN_LENGTH_ERROR',
                hint: `The string must be at least ${schema.minLength} characters long`
            });
        }
        
        if (schema.maxLength !== undefined && value.length > schema.maxLength) {
            errors.push({
                path,
                message: `String length ${value.length} is greater than maxLength ${schema.maxLength}`,
                code: 'MAX_LENGTH_ERROR',
                hint: `The string must be at most ${schema.maxLength} characters long`
            });
        }
        
        // Handle pattern for strings
        if (schema.pattern) {
            const pattern = new RegExp(schema.pattern);
            if (!pattern.test(value)) {
                errors.push({
                    path,
                    message: `String does not match pattern: ${schema.pattern}`,
                    code: 'PATTERN_ERROR',
                    hint: schema.patternHint || `The string must match the pattern: ${schema.pattern}`
                });
            }
        }
    }
    
    // Handle enum validation
    if (schema.enum && Array.isArray(schema.enum)) {
        if (!schema.enum.includes(value)) {
            errors.push({
                path,
                message: `Value is not one of the allowed values`,
                code: 'ENUM_ERROR',
                allowedValues: schema.enum,
                hint: `Valid values are: ${schema.enum.join(', ')}`
            });
        }
    }
    
    // Handle array validation
    if (schema.type === 'array' && Array.isArray(value)) {
        // Validate minItems/maxItems
        if (schema.minItems !== undefined && value.length < schema.minItems) {
            errors.push({
                path,
                message: `Array length ${value.length} is less than minItems ${schema.minItems}`,
                code: 'MIN_ITEMS_ERROR',
                hint: `The array must have at least ${schema.minItems} items`
            });
        }
        
        if (schema.maxItems !== undefined && value.length > schema.maxItems) {
            errors.push({
                path,
                message: `Array length ${value.length} is greater than maxItems ${schema.maxItems}`,
                code: 'MAX_ITEMS_ERROR',
                hint: `The array must have at most ${schema.maxItems} items`
            });
        }
        
        // Validate array items
        if (schema.items) {
            for (let i = 0; i < value.length; i++) {
                validateProperty(value[i], schema.items, [...path, i.toString()], errors);
            }
        }
    }
    
    // Validate nested object properties
    if (schema.type === 'object' && schema.properties && typeof value === 'object' && value !== null) {
        validateObjectProperties(value, schema.properties, path, errors);
    }
}

/**
 * Validate all conditions in allOf must be satisfied
 */
function validateAllOf(obj: any, schemas: any[], errors: ValidationError[]): void {
    for (const schema of schemas) {
        const subErrors = validateParams(obj, schema);
        errors.push(...subErrors);
    }
}

/**
 * Validate at least one condition in anyOf must be satisfied
 */
function validateAnyOf(obj: any, schemas: any[], errors: ValidationError[]): void {
    const allSubErrors: ValidationError[][] = [];
    
    // Check if at least one schema is valid
    const isValid = schemas.some(schema => {
        const subErrors = validateParams(obj, schema);
        allSubErrors.push(subErrors);
        return subErrors.length === 0;
    });
    
    if (!isValid) {
        // Find the schema with the fewest errors (closest match)
        let minErrorCount = Infinity;
        let bestMatchErrors: ValidationError[] = [];
        
        for (const subErrors of allSubErrors) {
            if (subErrors.length < minErrorCount) {
                minErrorCount = subErrors.length;
                bestMatchErrors = subErrors;
            }
        }
        
        // Add the errors from the closest match
        errors.push({
            path: [],
            message: 'None of the anyOf conditions were satisfied',
            code: 'ANY_OF_ERROR',
            hint: 'The input must satisfy at least one of the specified conditions'
        });
        
        errors.push(...bestMatchErrors);
    }
}

/**
 * Validate exactly one condition in oneOf must be satisfied
 */
function validateOneOf(obj: any, schemas: any[], errors: ValidationError[]): void {
    const validSchemas = schemas.filter(schema => validateParams(obj, schema).length === 0);
    
    if (validSchemas.length === 0) {
        // Same approach as anyOf for providing helpful errors
        let minErrorCount = Infinity;
        let bestMatchErrors: ValidationError[] = [];
        
        for (const schema of schemas) {
            const subErrors = validateParams(obj, schema);
            if (subErrors.length < minErrorCount) {
                minErrorCount = subErrors.length;
                bestMatchErrors = subErrors;
            }
        }
        
        errors.push({
            path: [],
            message: 'None of the oneOf conditions were satisfied',
            code: 'ONE_OF_ERROR',
            hint: 'The input must satisfy exactly one of the specified conditions'
        });
        
        errors.push(...bestMatchErrors);
    } else if (validSchemas.length > 1) {
        errors.push({
            path: [],
            message: `${validSchemas.length} oneOf conditions were satisfied, but exactly one is required`,
            code: 'ONE_OF_MULTIPLE_ERROR',
            hint: 'The input must satisfy exactly one of the specified conditions, not multiple'
        });
    }
}

/**
 * Check if an object has a given property
 */
function hasProperty(obj: any, prop: string): boolean {
    return obj && typeof obj === 'object' && prop in obj;
}

/**
 * Validate a value against a JSON Schema type
 */
function validateType(value: any, type: string | string[]): boolean {
    const types = Array.isArray(type) ? type : [type];
    
    return types.some(t => {
        switch (t) {
            case 'string':
                return typeof value === 'string';
            case 'number':
                return typeof value === 'number' && !isNaN(value);
            case 'integer':
                return typeof value === 'number' && !isNaN(value) && Number.isInteger(value);
            case 'boolean':
                return typeof value === 'boolean';
            case 'array':
                return Array.isArray(value);
            case 'object':
                return typeof value === 'object' && value !== null && !Array.isArray(value);
            case 'null':
                return value === null;
            default:
                return false;
        }
    });
}

/**
 * Get a human-readable description of a type
 */
function getTypeDescription(type: string | string[]): string {
    if (Array.isArray(type)) {
        if (type.length === 1) {
            return getTypeDescription(type[0]);
        }
        
        const descriptions = type.map(t => getTypeDescription(t));
        const lastDesc = descriptions.pop();
        return descriptions.length > 0
            ? `${descriptions.join(', ')} or ${lastDesc}`
            : lastDesc as string;
    }
    
    switch (type) {
        case 'string': return 'a string';
        case 'number': return 'a number';
        case 'integer': return 'an integer';
        case 'boolean': return 'a boolean (true or false)';
        case 'array': return 'an array';
        case 'object': return 'an object';
        case 'null': return 'null';
        default: return `a ${type}`;
    }
}

/**
 * Format validation errors into a detailed error message
 * 
 * @param errors Array of validation errors
 * @returns Formatted error message
 */
export function formatValidationErrors(errors: ValidationError[]): string {
    if (errors.length === 0) {
        return '';
    }
    
    let message = 'Parameter validation failed:\n';
    
    for (const error of errors) {
        const pathStr = error.path.length > 0 ? error.path.join('.') : 'root';
        message += `- ${pathStr}: ${error.message}\n`;
        
        if (error.hint) {
            message += `  Hint: ${error.hint}\n`;
        }
        
        if (error.expectedType && error.receivedType) {
            message += `  Expected ${error.expectedType}, received ${error.receivedType}\n`;
        }
        
        if (error.allowedValues && error.allowedValues.length > 0) {
            const valuesStr = error.allowedValues.map(v => JSON.stringify(v)).join(', ');
            message += `  Allowed values: [${valuesStr}]\n`;
        }
    }
    
    return message;
}

/**
 * Utility function to generate parameter hints from a schema
 * 
 * @param schema The schema to generate hints from
 * @returns Object with parameter hints
 */
export function generateParameterHints(schema: any): Record<string, string> {
    const hints: Record<string, string> = {};
    
    if (!schema || !schema.properties) {
        return hints;
    }
    
    const requiredProps = Array.isArray(schema.required) ? schema.required : [];
    
    for (const [propName, propSchema] of Object.entries<any>(schema.properties)) {
        const isRequired = requiredProps.includes(propName);
        const typeInfo = getTypeInfo(propSchema);
        const constraints = getConstraints(propSchema);
        
        let hint = `${isRequired ? 'Required' : 'Optional'} - ${propSchema.description || 'No description'}`;
        
        if (typeInfo) {
            hint += `\nType: ${typeInfo}`;
        }
        
        if (constraints) {
            hint += `\nConstraints: ${constraints}`;
        }
        
        hints[propName] = hint;
    }
    
    return hints;
}

/**
 * Get type information from a schema property
 */
function getTypeInfo(schema: any): string {
    if (!schema) return '';
    
    if (schema.enum && Array.isArray(schema.enum)) {
        return `One of: [${schema.enum.map((v: any) => JSON.stringify(v)).join(', ')}]`;
    }
    
    if (schema.type) {
        if (schema.type === 'array' && schema.items) {
            const itemType = schema.items.type || 'any';
            return `Array of ${itemType}`;
        }
        return Array.isArray(schema.type) ? schema.type.join(' | ') : schema.type;
    }
    
    return '';
}

/**
 * Get constraints information from a schema property
 */
function getConstraints(schema: any): string {
    if (!schema) return '';
    
    const constraints: string[] = [];
    
    if (schema.minLength !== undefined) {
        constraints.push(`min length: ${schema.minLength}`);
    }
    
    if (schema.maxLength !== undefined) {
        constraints.push(`max length: ${schema.maxLength}`);
    }
    
    if (schema.pattern) {
        constraints.push(`pattern: ${schema.pattern}`);
    }
    
    if (schema.minimum !== undefined) {
        constraints.push(`min: ${schema.minimum}`);
    }
    
    if (schema.maximum !== undefined) {
        constraints.push(`max: ${schema.maximum}`);
    }
    
    if (schema.minItems !== undefined) {
        constraints.push(`min items: ${schema.minItems}`);
    }
    
    if (schema.maxItems !== undefined) {
        constraints.push(`max items: ${schema.maxItems}`);
    }
    
    return constraints.join(', ');
}

/**
 * Utility function to enhance a schema with detailed parameter documentation
 * This updates descriptions with type information and required/optional status
 * 
 * @param schema The schema to enhance
 * @returns The enhanced schema
 */
export function enhanceSchemaDocumentation(schema: any): any {
    if (!schema || !schema.properties) {
        return schema;
    }
    
    // Create a deep copy to avoid modifying the original
    const enhancedSchema = JSON.parse(JSON.stringify(schema));
    const requiredProps = Array.isArray(enhancedSchema.required) ? enhancedSchema.required : [];
    
    for (const [propName, propSchema] of Object.entries<any>(enhancedSchema.properties)) {
        const isRequired = requiredProps.includes(propName);
        const requirementMarker = isRequired ? '[REQUIRED] ' : '[OPTIONAL] ';
        
        // Enhance the description with type information
        if (propSchema.description) {
            propSchema.description = requirementMarker + propSchema.description;
        } else {
            propSchema.description = requirementMarker + 'No description provided';
        }
        
        // Add type information to the description
        const typeInfo = getTypeInfo(propSchema);
        if (typeInfo) {
            propSchema.description += ` (${typeInfo})`;
        }
        
        // Add constraints to the description
        const constraints = getConstraints(propSchema);
        if (constraints) {
            propSchema.description += ` [${constraints}]`;
        }
        
        // Recursively enhance nested objects
        if (propSchema.type === 'object' && propSchema.properties) {
            enhancedSchema.properties[propName] = enhanceSchemaDocumentation(propSchema);
        }
        
        // Enhance array item schemas
        if (propSchema.type === 'array' && propSchema.items) {
            if (propSchema.items.type === 'object' && propSchema.items.properties) {
                propSchema.items = enhanceSchemaDocumentation(propSchema.items);
            }
        }
    }
    
    return enhancedSchema;
}
```

## utils/vaultUtils.ts

```typescript
/**
 * Utility functions for vault-related operations
 * This module provides functions for working with vault names and identifiers
 */

/**
 * Sanitizes a vault name for use in identifiers, filenames, and configuration keys
 * 
 * This function standardizes vault names by:
 * - Converting to lowercase
 * - Removing special characters (keeping only alphanumeric, spaces, and hyphens)
 * - Replacing spaces with hyphens
 * - Normalizing multiple consecutive hyphens to a single hyphen
 * 
 * @param vaultName - The original vault name to sanitize
 * @returns A sanitized version of the vault name suitable for use in identifiers
 * @throws Error if the input is null, undefined, or not a string
 * 
 * @example
 * // Returns "my-vault-name"
 * sanitizeVaultName("My Vault Name!");
 * 
 * @example
 * // Returns "test-vault-123"
 * sanitizeVaultName("Test Vault 123 @#$%");
 */
export function sanitizeVaultName(vaultName: string): string {
    // Input validation
    if (vaultName === null || vaultName === undefined) {
        throw new Error('Vault name cannot be null or undefined');
    }
    
    if (typeof vaultName !== 'string') {
        throw new Error(`Expected vault name to be a string, got ${typeof vaultName}`);
    }
    
    // Sanitize the vault name
    return vaultName
        .toLowerCase()           // Convert to lowercase
        .replace(/[^\w\s-]/g, '') // Remove special characters (keep alphanumeric, spaces, hyphens)
        .replace(/\s+/g, '-')     // Replace spaces with hyphens
        .replace(/-+/g, '-');     // Replace multiple consecutive hyphens with a single one
}
```

## utils/workspaceUtils.ts

```typescript
import { normalizePath } from "obsidian";
import { WorkspaceService } from '../agents/memoryManager/services/WorkspaceService';
import { ProjectWorkspace } from "../database/workspace-types";

/**
 * Utility functions for working with workspaces and files
 */

/**
 * Check if a file is within a workspace
 * @param filePath Path of the file to check
 * @param workspace Workspace to check against
 * @returns True if the file is in the workspace, false otherwise
 */
export function fileIsInWorkspace(filePath: string, workspace: ProjectWorkspace): boolean {
  const normalizedFilePath = normalizePath(filePath);
  const normalizedRootFolder = normalizePath(workspace.rootFolder);
  
  // Check if file is in the root folder
  if (normalizedFilePath.startsWith(normalizedRootFolder + '/') || 
      normalizedFilePath === normalizedRootFolder) {
    return true;
  }
  
  // Check related folders
  for (const folder of (workspace.relatedFolders || [])) {
    const normalizedFolder = normalizePath(folder);
    if (normalizedFilePath.startsWith(normalizedFolder + '/') || 
        normalizedFilePath === normalizedFolder) {
      return true;
    }
  }
  
  // Check individual related files
  if (workspace.relatedFiles) {
    for (const file of workspace.relatedFiles) {
      const normalizedFile = normalizePath(file);
      if (normalizedFilePath === normalizedFile) {
        return true;
      }
    }
  }
  
  return false;
}

/**
 * Get all workspaces that contain a file
 * @param filePath Path of the file to check
 * @param workspaceService WorkspaceService instance
 * @returns Promise resolving to an array of workspace IDs that contain the file
 */
export async function getWorkspacesForFile(
  filePath: string, 
  workspaceService: WorkspaceService
): Promise<string[]> {
  // Get all workspaces
  const workspaces = await workspaceService.getWorkspaces();
  const matchingWorkspaceIds: string[] = [];
  
  // Normalize the file path
  const normalizedFilePath = normalizePath(filePath);
  
  // Check each workspace
  for (const workspace of workspaces) {
    if (fileIsInWorkspace(normalizedFilePath, workspace)) {
      matchingWorkspaceIds.push(workspace.id);
    }
  }
  
  return matchingWorkspaceIds;
}

/**
 * Find the "best" workspace for a file based on folder path specificity
 * @param filePath Path of the file to check
 * @param workspaceService WorkspaceService instance
 * @returns Promise resolving to the best matching workspace ID or undefined if none found
 */
export async function getBestWorkspaceForFile(
  filePath: string, 
  workspaceService: WorkspaceService
): Promise<string | undefined> {
  // Get all workspaces that contain this file
  const workspaceIds = await getWorkspacesForFile(filePath, workspaceService);
  
  if (workspaceIds.length === 0) {
    return undefined;
  }
  
  if (workspaceIds.length === 1) {
    return workspaceIds[0];
  }
  
  // Multiple workspaces match, find the best one based on path specificity
  const workspaces: ProjectWorkspace[] = [];
  for (const id of workspaceIds) {
    const workspace = await workspaceService.getWorkspace(id);
    if (workspace) {
      workspaces.push(workspace);
    }
  }
  
  // Prioritize by folder path length (longer paths are more specific)
  const normalizedFilePath = normalizePath(filePath);
  
  // Sort by the closest folder match
  workspaces.sort((a, b) => {
    const aPath = normalizePath(a.rootFolder);
    const bPath = normalizePath(b.rootFolder);
    
    // If the file is directly in one of the folders, prioritize that one
    const directlyInA = normalizedFilePath.indexOf(aPath) === 0 && 
                      normalizedFilePath.substring(aPath.length).split('/').filter(Boolean).length === 0;
    const directlyInB = normalizedFilePath.indexOf(bPath) === 0 && 
                      normalizedFilePath.substring(bPath.length).split('/').filter(Boolean).length === 0;
    
    if (directlyInA && !directlyInB) return -1;
    if (directlyInB && !directlyInA) return 1;
    
    // Otherwise take the longest matching path (most specific)
    return bPath.length - aPath.length;
  });
      
  return workspaces[0].id;
}

/**
 * Update the activity history for all relevant workspaces when a file is modified
 * @param filePath Path of the file that was modified
 * @param action The action performed ('create', 'edit', 'delete' - will be mapped to valid activity types)
 * @param workspaceService WorkspaceService instance
 * @remarks 'delete' actions will be recorded as 'view' in the workspace activity history
 */
export async function updateWorkspaceActivityForFile(
  filePath: string,
  action: 'create' | 'edit' | 'delete',
  workspaceService: WorkspaceService
): Promise<void> {
  // Get all workspaces that contain this file
  const workspaceIds = await getWorkspacesForFile(filePath, workspaceService);
  
  // Map our action types to the ones expected by workspace activity
  // For 'delete' actions, use 'view' as it's a valid action type
  const activityAction = action === 'delete' ? 'view' : 
                     action === 'create' ? 'create' : 'edit';
  
  // Record the activity for each workspace
  for (const workspaceId of workspaceIds) {
    try {
      await workspaceService.addActivity(workspaceId, {
        timestamp: Date.now(),
        action: activityAction,
        duration: 0, // Instant action
        context: filePath
      });
    } catch (error) {
      console.error(`Error updating activity for workspace ${workspaceId}:`, error);
    }
  }
}
```

