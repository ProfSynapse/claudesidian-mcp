/**
 * EmbeddingService - Refactored using SOLID principles and service composition
 * Acts as a coordinator/facade for embedding-related operations
 */

import { Plugin, Notice, TFile } from 'obsidian';
import { IEmbeddingProvider, ITokenTrackingProvider } from '../../interfaces/IEmbeddingProvider';
import { MemorySettings } from '../../../types';
import { getErrorMessage } from '../../../utils/errorUtils';

import {
  EmbeddingGenerator,
  EmbeddingProviderManager,
  ContentHashService,
  IndexingProgressTracker,
  EmbeddingSettingsManager,
  FileIndexingService,
  IndexingStateManager,
  CollectionCleanupService
} from '../indexing/embedding';
import { ProcessedFilesStateManager } from '../indexing/state/ProcessedFilesStateManager';

/**
 * Refactored EmbeddingService using composition pattern
 * Maintains the same public interface while delegating to specialized services
 */
export class EmbeddingService {
  // Composed services following Dependency Injection principle
  private embeddingGenerator: EmbeddingGenerator;
  private providerManager: EmbeddingProviderManager;
  private contentHashService: ContentHashService;
  private progressTracker: IndexingProgressTracker;
  private settingsManager: EmbeddingSettingsManager;
  private fileIndexingService: FileIndexingService;
  private stateManager: IndexingStateManager;
  private collectionCleanupService: CollectionCleanupService;

  /**
   * Plugin instance
   */
  private plugin: Plugin;

  /**
   * Create a new embedding service
   * @param plugin Plugin instance
   * @param stateManager State manager for processed files tracking (REQUIRED)
   */
  constructor(plugin: Plugin, stateManager: ProcessedFilesStateManager) {
    this.plugin = plugin;
    
    // Validate required dependencies
    if (!stateManager) {
      console.error('CRITICAL: EmbeddingService requires StateManager');
      throw new Error('EmbeddingService requires a valid ProcessedFilesStateManager');
    }
    
    // Initialize composed services
    this.settingsManager = new EmbeddingSettingsManager(plugin);
    this.providerManager = new EmbeddingProviderManager();
    this.embeddingGenerator = new EmbeddingGenerator();
    this.contentHashService = new ContentHashService(plugin, stateManager);
    
    this.progressTracker = new IndexingProgressTracker();
    this.fileIndexingService = new FileIndexingService(
      plugin,
      this.embeddingGenerator,
      this.contentHashService,
      this.settingsManager,
      this.progressTracker
    );
    this.stateManager = new IndexingStateManager(plugin);
    this.collectionCleanupService = new CollectionCleanupService(plugin);
    
    this.initializeServices();
  }

  /**
   * Initialize services based on current settings
   */
  private async initializeServices(): Promise<void> {
    try {
      const settings = this.settingsManager.getSettings();
      
      if (settings.embeddingsEnabled) {
        await this.providerManager.initializeProvider(settings);
        const provider = this.providerManager.getProvider();
        this.embeddingGenerator.setProvider(provider);
      }
    } catch (error) {
      console.error('Failed to initialize embedding services:', error);
    }
  }

  /**
   * Check if provider implements token tracking interface
   * @param provider Embedding provider to check
   * @returns true if provider implements ITokenTrackingProvider
   */
  private isTokenTrackingProvider(provider: IEmbeddingProvider | null): boolean {
    return this.providerManager.isTokenTrackingProvider(provider);
  }

  /**
   * Get the embedding provider
   */
  getProvider(): IEmbeddingProvider | null {
    return this.providerManager.getProvider();
  }

  /**
   * Get embedding for text
   * @param text Text to generate embedding for
   */
  async getEmbedding(text: string): Promise<number[] | null> {
    if (!this.settingsManager.areEmbeddingsEnabled()) {
      return null;
    }
    
    return await this.embeddingGenerator.generateSingle(text);
  }

  /**
   * Get embeddings for multiple texts
   * @param texts Array of texts to generate embeddings for
   */
  async getEmbeddings(texts: string[]): Promise<number[][] | null> {
    if (!this.settingsManager.areEmbeddingsEnabled()) {
      return null;
    }
    
    return await this.embeddingGenerator.generateBatch(texts);
  }

  /**
   * Check if embeddings are enabled
   */
  areEmbeddingsEnabled(): boolean {
    return this.settingsManager.areEmbeddingsEnabled();
  }

  /**
   * Get the dimensions of embeddings generated by the current provider
   * @returns Number of dimensions or null if provider not available
   */
  getDimensions(): number | null {
    return this.embeddingGenerator.getDimensions();
  }

  /**
   * Get current settings
   */
  getSettings(): MemorySettings {
    return this.settingsManager.getSettings();
  }

  /**
   * Update settings and reinitialize services
   * @param settings Memory settings
   */
  async updateSettings(settings: MemorySettings): Promise<void> {
    const oldSettings = this.settingsManager.getSettings();
    const comparison = this.settingsManager.compareSettings(settings);
    
    // Check for provider/dimension conflicts
    if ((comparison.providerChanged || comparison.dimensionsChanged) && settings.embeddingsEnabled) {
      const hasExistingEmbeddings = await this.hasExistingEmbeddings();
      
      if (hasExistingEmbeddings) {
        console.warn(`⚠️  Provider dimension conflict detected!
          Previous: ${comparison.oldProvider} (${comparison.oldDimensions} dims)
          New: ${comparison.newProvider} (${comparison.newDimensions} dims)
          
          ChromaDB requires all embeddings in a collection to have the same dimensions.
          Existing embeddings must be reindexed with the new provider.`);
        
        // Check if there are active indexing operations
        const hasResumableIndexing = await this.stateManager.hasResumableIndexing();
        if (hasResumableIndexing) {
          throw new Error(`Cannot switch embedding providers while indexing is in progress. Please wait for current indexing to complete or clear the indexing state before switching providers.`);
        }
        
        await this.clearEmbeddingsForProviderChange(comparison);
      }
    }
    
    // Update settings
    this.settingsManager.updateSettings(settings);
    
    // Reinitialize services
    await this.initializeServices();
    
    // Save settings
    await this.settingsManager.saveSettings();
  }

  /**
   * Delegate provider change cleanup to CollectionCleanupService
   */
  private async clearEmbeddingsForProviderChange(comparison: any): Promise<void> {
    await this.collectionCleanupService.clearEmbeddingsForProviderChange(comparison);
  }

  /**
   * Calculate similarity between two embeddings
   * @param embedding1 First embedding
   * @param embedding2 Second embedding
   */
  calculateSimilarity(embedding1: number[], embedding2: number[]): number {
    return this.embeddingGenerator.calculateSimilarity(embedding1, embedding2);
  }

  /**
   * Check if there's a resumable indexing operation
   */
  async hasResumableIndexing(): Promise<boolean> {
    console.log('DEBUG: EmbeddingService.hasResumableIndexing called');
    const result = await this.stateManager.hasResumableIndexing();
    console.log('DEBUG: EmbeddingService.hasResumableIndexing result:', result);
    return result;
  }

  /**
   * Resume a previously interrupted indexing operation
   */
  async resumeIndexing(progressCallback?: (current: number, total: number) => void): Promise<string[]> {
    const state = await this.stateManager.loadState();
    if (!state || state.pendingFiles.length === 0) {
      throw new Error('No resumable indexing operation found');
    }
    
    console.log(`Resuming indexing: ${state.completedFiles.length} completed, ${state.pendingFiles.length} remaining`);
    
    // Update the state to show we're resuming
    state.status = 'indexing';
    await this.stateManager.saveState(state);
    
    // Use state-aware batch processing for resumable operations
    const result = await this.resumableBatchIndexFiles(state.pendingFiles, (current, total) => {
      // Adjust progress to account for already completed files
      const totalProgress = state.completedFiles.length + current;
      const totalFiles = state.totalFiles;
      
      if (progressCallback) {
        progressCallback(totalProgress, totalFiles);
      }
    });
    
    // Clear the state after successful completion
    await this.stateManager.clearState();
    
    return result;
  }

  /**
   * Resumable batch indexing with state tracking
   */
  async resumableBatchIndexFiles(
    filePaths: string[], 
    progressCallback?: (current: number, total: number) => void
  ): Promise<string[]> {
    if (!this.settingsManager.areEmbeddingsEnabled()) {
      throw new Error('Embeddings are disabled in settings');
    }
    
    if (!filePaths || filePaths.length === 0) {
      return [];
    }
    
    // Get plugin and vector store
    const plugin = this.plugin.app.plugins.plugins['claudesidian-mcp'] as any;
    if (!plugin || !plugin.vectorStore) {
      throw new Error('Vector store not available');
    }
    
    try {
      // Use state-aware file indexing
      const result = await this.fileIndexingService.processFilesInBatches(
        filePaths, 
        plugin.vectorStore,
        true,  // batchMode
        progressCallback,
        false,  // silent
        true  // Enable state tracking
      );
      
      // Return just the processed files to match the expected return type
      return result.processedFiles;
    } catch (error) {
      // Mark as paused on interruption, don't clear state
      await this.stateManager.pauseIndexing();
      throw error;
    }
  }

  /**
   * Update embeddings for files that have changed
   * @param filePaths Array of file paths that have been modified
   * @param progressCallback Optional callback for progress updates
   */
  async updateFileEmbeddings(filePaths: string[], progressCallback?: (current: number, total: number) => void): Promise<string[]> {
    return await this.incrementalIndexFiles(filePaths, progressCallback);
  }

  /**
   * Update file embeddings silently without showing progress notices
   * @param filePaths Array of file paths to update
   */
  async updateFileEmbeddingsSilent(filePaths: string[]): Promise<string[]> {
    return await this.incrementalIndexFilesSilent(filePaths);
  }

  /**
   * Update only the changed chunks of a file based on content diff
   * @param filePath File path to update
   * @param oldContent Previous file content
   * @param newContent New file content
   * @param workspaceId Optional workspace ID
   */
  async updateChangedChunks(filePath: string, oldContent: string, newContent: string, workspaceId?: string): Promise<string[]> {
    if (!this.settingsManager.areEmbeddingsEnabled()) {
      throw new Error('Embeddings are disabled in settings');
    }

    try {
      // For now, do a full re-embedding of the file
      // TODO: Implement differential chunking in the future
      return await this.updateFileEmbeddings([filePath]);
    } catch (error) {
      console.error(`Error updating changed chunks for ${filePath}:`, error);
      throw error;
    }
  }

  /**
   * Incremental file indexing with progress tracking
   * @param filePaths Array of file paths to index
   * @param progressCallback Optional progress callback
   */
  async incrementalIndexFiles(filePaths: string[], progressCallback?: (current: number, total: number) => void): Promise<string[]> {
    if (!this.settingsManager.areEmbeddingsEnabled()) {
      throw new Error('Embeddings are disabled in settings');
    }
    
    if (!filePaths || filePaths.length === 0) {
      return [];
    }
    
    // Get plugin and vector store
    const plugin = this.plugin.app.plugins.plugins['claudesidian-mcp'] as any;
    if (!plugin || !plugin.vectorStore) {
      throw new Error('Vector store not available');
    }
    
    // Mark this as a system operation to prevent file event loops
    plugin.vectorStore.startSystemOperation();
    
    try {
      // Initialize progress tracking
      const progressState = this.progressTracker.initializeProgress(
        filePaths.length, 
        'incremental-index', 
        true
      );
      
      const results = await this.processFilesInBatches(
        filePaths, 
        plugin.vectorStore, 
        false, // incremental mode
        progressCallback
      );
      
      // Complete progress tracking
      this.progressTracker.completeProgress(
        true, 
        undefined, 
        `✅ Successfully processed ${results.processedFiles.length} files`
      );
      
      return results.ids;
    } catch (error) {
      this.progressTracker.completeProgress(
        false, 
        getErrorMessage(error), 
        `❌ Error processing files: ${getErrorMessage(error)}`
      );
      throw error;
    } finally {
      plugin.vectorStore.endSystemOperation();
    }
  }

  /**
   * Silent incremental file indexing without UI updates
   * @param filePaths Array of file paths to index
   */
  async incrementalIndexFilesSilent(filePaths: string[]): Promise<string[]> {
    if (!this.settingsManager.areEmbeddingsEnabled()) {
      throw new Error('Embeddings are disabled in settings');
    }
    
    if (!filePaths || filePaths.length === 0) {
      return [];
    }
    
    const plugin = this.plugin.app.plugins.plugins['claudesidian-mcp'] as any;
    if (!plugin || !plugin.vectorStore) {
      throw new Error('Vector store not available');
    }
    
    plugin.vectorStore.startSystemOperation();
    
    try {
      const results = await this.processFilesInBatches(
        filePaths, 
        plugin.vectorStore, 
        false, // incremental mode
        undefined, // no progress callback
        true // silent mode
      );
      
      return results.ids;
    } finally {
      plugin.vectorStore.endSystemOperation();
    }
  }

  /**
   * Batch file indexing with full reindexing
   * @param filePaths Array of file paths to index
   * @param progressCallback Optional progress callback
   */
  async batchIndexFiles(filePaths: string[], progressCallback?: (current: number, total: number) => void): Promise<string[]> {
    if (!this.settingsManager.areEmbeddingsEnabled()) {
      throw new Error('Embeddings are disabled in settings');
    }
    
    if (!filePaths || filePaths.length === 0) {
      return [];
    }
    
    const plugin = this.plugin.app.plugins.plugins['claudesidian-mcp'] as any;
    if (!plugin || !plugin.vectorStore) {
      throw new Error('Vector store not available');
    }
    
    // Set reindexing flag to prevent conflicts
    plugin.isReindexing = true;
    
    try {
      // Initialize progress tracking
      const progressState = this.progressTracker.initializeProgress(
        filePaths.length, 
        'batch-index', 
        true
      );
      
      const results = await this.processFilesInBatches(
        filePaths, 
        plugin.vectorStore, 
        true, // batch mode
        progressCallback
      );
      
      // Complete progress tracking
      this.progressTracker.completeProgress(
        true, 
        undefined, 
        `✅ Successfully indexed ${results.processedFiles.length} files`
      );
      
      // Clear indexing state on success
      await this.stateManager.clearState();
      
      return results.ids;
    } catch (error) {
      // Save error state for potential resume
      const state = await this.stateManager.loadState();
      if (state) {
        state.status = 'error';
        state.errorMessage = getErrorMessage(error);
        await this.stateManager.saveState(state);
      }
      
      this.progressTracker.completeProgress(
        false, 
        getErrorMessage(error), 
        `❌ Error during batch indexing: ${getErrorMessage(error)}`
      );
      
      throw error;
    } finally {
      plugin.isReindexing = false;
    }
  }

  /**
   * Delegate file processing to FileIndexingService
   */
  private async processFilesInBatches(
    filePaths: string[], 
    vectorStore: any, 
    batchMode = false,
    progressCallback?: (current: number, total: number) => void,
    silent = false
  ): Promise<{ ids: string[]; processedFiles: string[]; failedFiles: string[] }> {
    return this.fileIndexingService.processFilesInBatches(
      filePaths,
      vectorStore,
      batchMode,
      progressCallback,
      silent
    );
  }

  /**
   * Check if there are existing embeddings
   * CRITICAL FIX: Use lightweight collection existence check instead of count() to prevent loading all data
   */
  async hasExistingEmbeddings(): Promise<boolean> {
    try {
      const plugin = this.plugin.app.plugins.plugins['claudesidian-mcp'] as any;
      if (!plugin || !plugin.vectorStore) {
        return false;
      }
      
      const vectorStore = plugin.vectorStore;
      const hasCollection = await vectorStore.hasCollection('file_embeddings');
      
      if (!hasCollection) {
        return false;
      }
      
      // CRITICAL FIX: Instead of calling count() which triggers loading all data,
      // assume collection exists = has embeddings. This is sufficient for settings validation.
      // The exact count is not needed - we only need to know if embeddings exist.
      // Collection exists, assuming it has embeddings
      return true;
    } catch (error) {
      console.error('Error checking for existing embeddings:', error);
      return false;
    }
  }

  /**
   * Cleanup resources
   */
  async cleanup(): Promise<void> {
    await this.providerManager.cleanup();
    this.progressTracker.cancelProgress();
  }
}