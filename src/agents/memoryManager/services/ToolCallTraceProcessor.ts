/**
 * src/database/services/memory/ToolCallTraceProcessor.ts
 * 
 * Service responsible for processing tool call traces with complete JSON preservation
 * and enhanced metadata generation. Extracted from MemoryTraceService.ts.
 * 
 * This service handles:
 * - Tool call trace processing and enrichment
 * - Performance metrics calculation
 * - Relationship extraction from tool calls
 * - Search optimization data generation
 * - Embedding content generation for tool calls
 */

import type { PendingToolCallCapture } from '../../../services/toolcall-capture/ToolCallCaptureService';
import { 
  ToolCallMemoryTrace, 
  ToolCallPerformanceMetrics,
  ToolCallRelationships,
  ToolCallSearchOptimization,
  ToolCallProcessingContext
} from '../../../types/memory/TraceTypes';

/**
 * Service for processing tool call traces with enhanced metadata and optimization
 */
export class ToolCallTraceProcessor {
  
  /**
   * Process a pending tool call capture into a complete tool call memory trace
   * @param pendingCapture - Complete tool call capture data
   * @returns Promise resolving to processed tool call trace data
   */
  async processToolCallTrace(pendingCapture: PendingToolCallCapture): Promise<ToolCallProcessingContext> {
    try {
      const request = pendingCapture.request;
      const response = pendingCapture.response;
      const sessionContext = pendingCapture.sessionContext;
      
      if (!response) {
        throw new Error('Cannot process tool call trace without response data');
      }
      
      // Generate embedding content from tool call data
      const embeddingContent = this.generateToolCallEmbeddingContent(request, response);
      
      // Determine if embedding should be generated
      const shouldEmbed = this.shouldGenerateEmbedding(request, response);
      
      // Extract relationships
      const relationships = this.extractToolCallRelationships(request, response);
      
      // Calculate performance metrics
      const performanceMetrics = this.calculateToolCallPerformanceMetrics(request, response);
      
      // Generate search optimization data
      const searchOptimization = this.generateSearchOptimization(request, response, embeddingContent, shouldEmbed);
      
      return {
        request,
        response,
        sessionContext,
        shouldEmbed,
        embeddingContent,
        relationships,
        performanceMetrics,
        searchOptimization
      };
      
    } catch (error) {
      console.error('[ToolCallTraceProcessor] Failed to process tool call trace:', error);
      throw new Error(`Failed to process tool call trace: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Build a complete tool call memory trace from processing context
   * @param context - Processing context with all computed data
   * @returns Complete tool call memory trace
   */
  buildToolCallTrace(context: ToolCallProcessingContext, embedding: number[]): ToolCallMemoryTrace {
    const { request, response, sessionContext, relationships, performanceMetrics, searchOptimization, embeddingContent } = context;
    
    // Create enhanced tool call memory trace
    const toolCallTrace: ToolCallMemoryTrace = {
      // Base memory trace fields
      id: '', // Will be generated by collection
      workspaceId: sessionContext.workspaceId,
      workspacePath: sessionContext.workspacePath || [sessionContext.workspaceId],
      contextLevel: 'workspace',
      activityType: 'research', // Tool calls are generally research/discovery activities
      content: embeddingContent,
      embedding: embedding,
      sessionId: sessionContext.sessionId,
      timestamp: request.timestamp,
      importance: performanceMetrics.importance,
      tags: this.generateToolCallTags(request, response),
      
      // Tool call specific fields
      toolCallId: request.toolCallId,
      agent: request.agent,
      mode: request.mode,
      toolName: `${request.agent}.${request.mode}`,
      
      // Enhanced metadata with complete JSON preservation
      metadata: {
        request: {
          originalParams: request.params,
          normalizedParams: request.params, // Could be enhanced with validation
          workspaceContext: request.workspaceContext,
          source: request.source
        },
        response: {
          result: response.result,
          success: response.success,
          error: response.error,
          resultType: response.resultType || this.inferResultType(response.result),
          resultSummary: response.resultSummary || this.generateResultSummary(response),
          affectedResources: response.affectedResources || relationships.affectedResources
        },
        
        // Legacy compatibility
        tool: `${request.agent}.${request.mode}`,
        params: request.params,
        result: response.result,
        relatedFiles: relationships.relatedFiles
      },
      
      // Execution context
      executionContext: {
        timing: {
          startTimestamp: request.timestamp,
          endTimestamp: response.timestamp,
          executionTime: response.executionTime
        },
        environment: {
          pluginVersion: '1.0.0', // Would be extracted from plugin
          platform: process.platform || 'unknown'
        },
        userContext: {
          sessionStart: sessionContext.sessionCreated ? request.timestamp : 0,
          sessionDuration: response.timestamp - request.timestamp,
          previousToolCalls: 0 // Would be extracted from session
        },
        performance: performanceMetrics
      },
      
      // Relationships
      relationships: relationships,
      
      // Search optimization
      searchOptimization: searchOptimization
    };
    
    return toolCallTrace;
  }
  
  /**
   * Generate embedding content from tool call data with complete JSON preservation
   * @private
   */
  private generateToolCallEmbeddingContent(request: any, response: any): string {
    const parts = [
      `Tool: ${request.agent}.${request.mode}`,
      `Status: ${response.success ? 'SUCCESS' : 'FAILED'}`,
      `Time: ${new Date(request.timestamp).toISOString()}`,
      `Workspace: ${request.workspaceContext?.workspaceId || 'unknown'}`,
      '',
      '=== COMPLETE REQUEST ===',
      JSON.stringify(request.params, null, 2),
      '',
      '=== COMPLETE RESPONSE ===',
      JSON.stringify(response.result, null, 2)
    ];
    
    // Add error details if failed
    if (!response.success && response.error) {
      parts.push('');
      parts.push('=== ERROR DETAILS ===');
      parts.push(JSON.stringify(response.error, null, 2));
    }
    
    return parts.filter(part => part !== null && part !== undefined).join('\n');
  }
  
  /**
   * Determine if embedding should be generated for this tool call
   * @private
   */
  private shouldGenerateEmbedding(request: any, response: any): boolean {
    // Always embed failed operations for debugging
    if (!response.success) return true;
    
    // High-value agents always get embeddings
    const highValueAgents = ['contentManager', 'memoryManager', 'vaultLibrarian', 'agentManager'];
    if (highValueAgents.includes(request.agent)) return true;
    
    // Long execution times indicate important operations
    if (response.executionTime > 5000) return true;
    
    // Complex operations with multiple resources
    if (request.params?.paths && Array.isArray(request.params.paths) && request.params.paths.length > 1) {
      return true;
    }
    
    // Batch operations
    if (request.params?.operations && Array.isArray(request.params.operations)) {
      return true;
    }
    
    // Default: Skip simple operations
    const skipModes = ['healthCheck', 'getStatus', 'listModes'];
    return !skipModes.includes(request.mode);
  }
  
  /**
   * Extract relationships from tool call data
   * @private
   */
  private extractToolCallRelationships(request: any, response: any): ToolCallRelationships {
    const relatedFiles: string[] = [];
    const affectedResources: string[] = [];
    
    // Extract file paths from parameters
    if (request.params?.filePath) relatedFiles.push(request.params.filePath);
    if (request.params?.paths && Array.isArray(request.params.paths)) {
      relatedFiles.push(...request.params.paths);
    }
    if (request.params?.operations && Array.isArray(request.params.operations)) {
      for (const op of request.params.operations) {
        if (op.filePath) relatedFiles.push(op.filePath);
        if (op.paths) relatedFiles.push(...op.paths);
      }
    }
    
    // Extract affected resources from response
    if (response.affectedResources && Array.isArray(response.affectedResources)) {
      affectedResources.push(...response.affectedResources);
    }
    
    return {
      relatedFiles: Array.from(new Set(relatedFiles)), // Remove duplicates
      affectedResources: Array.from(new Set(affectedResources)),
      sessionToolCalls: [], // Would be populated from session context
      workspaceContext: request.workspaceContext?.workspacePath || []
    };
  }
  
  /**
   * Calculate performance metrics for tool call
   * @private
   */
  private calculateToolCallPerformanceMetrics(request: any, response: any): ToolCallPerformanceMetrics {
    let importance = 0.5; // Base importance
    
    // Failed operations are more important for debugging
    if (!response.success) importance += 0.3;
    
    // Long execution times indicate complexity
    if (response.executionTime > 1000) importance += 0.2;
    if (response.executionTime > 5000) importance += 0.3;
    
    // High-value agents get higher importance
    const highValueAgents = ['contentManager', 'memoryManager', 'vaultLibrarian', 'agentManager'];
    if (highValueAgents.includes(request.agent)) importance += 0.2;
    
    // Multi-file operations are more complex
    const fileCount = this.countAffectedFiles(request.params);
    if (fileCount > 1) importance += 0.1;
    if (fileCount > 5) importance += 0.2;
    
    return {
      importance: Math.min(importance, 1.0),
      complexity: this.calculateComplexity(request, response),
      userEngagement: 0.5 // Would be calculated based on actual user interaction
    };
  }
  
  /**
   * Generate search optimization data
   * @private
   */
  private generateSearchOptimization(request: any, response: any, embeddingContent: string, shouldEmbed: boolean): ToolCallSearchOptimization {
    return {
      embeddingContent: {
        primary: embeddingContent,
        keywords: this.extractKeywords(request, response),
        entities: this.extractEntities(request, response)
      },
      categories: {
        functionalCategory: this.categorizeTool(request.agent, request.mode),
        domainCategory: this.categorizeDomain(request, response),
        complexityCategory: this.categorizeComplexity(request, response),
        impactCategory: this.categorizeImpact(request, response)
      },
      searchTags: this.generateToolCallTags(request, response),
      searchScoring: {
        recencyScore: 1.0, // New tool calls get max recency
        frequencyScore: 0.5,
        successScore: response.success ? 1.0 : 0.0,
        impactScore: this.calculateToolCallPerformanceMetrics(request, response).importance,
        userEngagementScore: 0.5
      },
      indexingHints: {
        shouldEmbed: shouldEmbed,
        embeddingPriority: this.calculateToolCallPerformanceMetrics(request, response).importance > 0.7 ? 'high' : 'medium',
        cacheStrategy: 'session',
        searchFrequency: 'occasional'
      }
    };
  }
  
  /**
   * Generate tags for tool call trace
   * @private
   */
  private generateToolCallTags(request: any, response: any): string[] {
    const tags = [
      'tool-call',
      request.agent,
      request.mode,
      `${request.agent}.${request.mode}`,
      response.success ? 'success' : 'error'
    ];
    
    // Add source tag
    tags.push(request.source);
    
    // Add execution time category
    if (response.executionTime > 5000) tags.push('slow-execution');
    else if (response.executionTime < 100) tags.push('fast-execution');
    
    // Add complexity tags
    const fileCount = this.countAffectedFiles(request.params);
    if (fileCount > 1) tags.push('multi-file');
    if (fileCount > 10) tags.push('bulk-operation');
    
    return tags;
  }
  
  // Helper methods
  private generateActionDescription(request: any, response: any): string {
    return `${request.agent} ${request.mode} operation ${response.success ? 'completed' : 'failed'}`;
  }
  
  private summarizeParameters(params: any): string {
    if (!params || typeof params !== 'object') return 'none';
    const keys = Object.keys(params);
    return keys.length > 0 ? `${keys.length} parameters (${keys.slice(0, 3).join(', ')})` : 'none';
  }
  
  private summarizeResult(result: any): string {
    if (!result) return 'no result';
    if (typeof result === 'string') return result.length > 100 ? `${result.substring(0, 100)}...` : result;
    if (typeof result === 'object') return `object with ${Object.keys(result).length} properties`;
    return String(result);
  }
  
  private inferResultType(result: any): string {
    if (result === null || result === undefined) return 'null';
    if (Array.isArray(result)) return 'array';
    return typeof result;
  }
  
  private generateResultSummary(response: any): string {
    if (!response.success && response.error) {
      return `Error: ${response.error.message}`;
    }
    return this.summarizeResult(response.result);
  }
  
  private countAffectedFiles(params: any): number {
    let count = 0;
    if (params?.filePath) count++;
    if (params?.paths && Array.isArray(params.paths)) count += params.paths.length;
    if (params?.operations && Array.isArray(params.operations)) {
      for (const op of params.operations) {
        if (op.filePath) count++;
        if (op.paths && Array.isArray(op.paths)) count += op.paths.length;
      }
    }
    return count;
  }
  
  private calculateComplexity(request: any, response: any): number {
    let complexity = 0.5;
    complexity += Math.min(response.executionTime / 10000, 0.3); // Execution time factor
    complexity += Math.min(this.countAffectedFiles(request.params) / 10, 0.2); // File count factor
    return Math.min(complexity, 1.0);
  }
  
  private extractKeywords(request: any, response: any): string[] {
    const keywords = [request.agent, request.mode];
    if (request.workspaceContext?.workspaceId) keywords.push(request.workspaceContext.workspaceId);
    return keywords;
  }
  
  private extractEntities(request: any, response: any): string[] {
    const entities: string[] = [];
    // Extract file paths as entities
    const relatedFiles = this.extractToolCallRelationships(request, response).relatedFiles;
    entities.push(...relatedFiles.map((path: string) => path.split('/').pop() || path));
    return entities;
  }
  
  private categorizeTool(agent: string, mode: string): string {
    const categories: Record<string, string> = {
      'contentManager': 'content-management',
      'vaultManager': 'file-management',
      'vaultLibrarian': 'search-discovery',
      'memoryManager': 'memory-state',
      'agentManager': 'ai-automation',
      'commandManager': 'system-control'
    };
    return categories[agent] || 'general';
  }
  
  private categorizeDomain(request: any, response: any): string {
    // Analyze the operation to determine domain
    if (request.mode.includes('search') || request.mode.includes('find')) return 'search';
    if (request.mode.includes('create') || request.mode.includes('write')) return 'creation';
    if (request.mode.includes('update') || request.mode.includes('edit')) return 'modification';
    if (request.mode.includes('delete') || request.mode.includes('remove')) return 'deletion';
    if (request.mode.includes('read') || request.mode.includes('get')) return 'retrieval';
    return 'general';
  }
  
  private categorizeComplexity(request: any, response: any): string {
    const complexity = this.calculateComplexity(request, response);
    if (complexity > 0.8) return 'high';
    if (complexity > 0.5) return 'medium';
    return 'low';
  }
  
  private categorizeImpact(request: any, response: any): string {
    const fileCount = this.countAffectedFiles(request.params);
    if (fileCount > 10) return 'high';
    if (fileCount > 1) return 'medium';
    if (!response.success) return 'medium'; // Errors have medium impact for debugging
    return 'low';
  }
}