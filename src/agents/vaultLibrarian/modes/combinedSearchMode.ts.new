import { App } from 'obsidian';
import { BaseMode } from '../../../baseMode';
import { CombinedSearchParams, SemanticSearchResult } from '../types';
import { VaultLibrarianAgent } from '../vaultLibrarian';
import { parseWorkspaceContext } from '../../../utils/contextUtils';
import { EmbeddingService } from '../../../database/services/EmbeddingService';
import { ChromaSearchService } from '../../../database/services/ChromaSearchService';
import { MemoryService } from '../../../database/services/MemoryService';

/**
 * Mode for combined search with filters and semantic search
 */
export class CombinedSearchMode extends BaseMode<CombinedSearchParams, SemanticSearchResult> {
  private embeddingService: EmbeddingService | null = null;
  private searchService: ChromaSearchService | null = null;
  private memoryService: MemoryService | null = null;
  
  /**
   * Create a new CombinedSearchMode
   * @param app Obsidian app instance
   * @param memoryService Optional memory service for recording activity
   * @param searchService Optional search service for performing search
   * @param embeddingService Optional embedding service
   */
  constructor(
    private app: App,
    memoryService?: MemoryService | null,
    searchService?: ChromaSearchService | null,
    embeddingService?: EmbeddingService | null
  ) {
    super(
      'combinedSearch',
      'Combined Search',
      'Hybrid metadata/semantic search',
      '1.0.0'
    );
    
    // Store services passed from constructor
    this.memoryService = memoryService || null;
    this.searchService = searchService || null;
    this.embeddingService = embeddingService || null;
    
    // Try to get services from plugin if not provided in constructor
    if (!this.memoryService || !this.searchService || !this.embeddingService) {
      try {
        const plugin = this.app.plugins?.getPlugin('claudesidian-mcp');
        
        if (plugin?.services) {
          if (!this.embeddingService && plugin.services.embeddingService) {
            this.embeddingService = plugin.services.embeddingService;
          }
          
          if (!this.searchService && plugin.services.searchService) {
            this.searchService = plugin.services.searchService;
          }
          
          if (!this.memoryService && plugin.services.memoryService) {
            this.memoryService = plugin.services.memoryService;
          }
        }
      } catch (error) {
        console.error("Failed to initialize services for combined search:", error);
      }
    }
  }
  
  /**
   * Execute the mode
   * @param params Mode parameters
   * @returns Promise that resolves with result
   */
  async execute(params: CombinedSearchParams): Promise<SemanticSearchResult> {
    try {
      const { query, filters, limit, threshold, workspaceContext, handoff } = params;
      
      if (!query || query.trim() === '') {
        return this.prepareResult(false, undefined, 'Query is required');
      }
      
      // Parse workspace context early for use throughout the method
      const parsedContext = parseWorkspaceContext(workspaceContext);
      
      // Check if we can use ChromaDB services
      if (this.searchService && this.embeddingService) {
        return await this.executeWithChromaDB(params);
      } else {
        return await this.executeWithLegacyServices(params);
      }
    } catch (error) {
      return this.prepareResult(false, undefined, `Error performing combined search: ${error.message}`);
    }
  }
  
  /**
   * Execute using ChromaDB services
   * @param params Mode parameters
   * @returns Promise that resolves with result
   */
  private async executeWithChromaDB(params: CombinedSearchParams): Promise<SemanticSearchResult> {
    const { query, filters, limit, threshold, workspaceContext, handoff } = params;
    
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(workspaceContext);
    
    // Check if services are available
    if (!this.searchService) {
      return this.prepareResult(false, undefined, 'Search service is not available');
    }
    
    if (!this.embeddingService) {
      return this.prepareResult(false, undefined, 'Embedding service is not available');
    }
    
    // Check if embeddings are enabled
    if (!this.embeddingService.areEmbeddingsEnabled()) {
      return this.prepareResult(false, undefined, 'Embeddings functionality is currently disabled. Please enable embeddings and provide a valid API key in settings to use semantic search.');
    }
    
    try {
      // Execute combined search using ChromaDB search service
      const result = await this.searchService.combinedSearch(
        query,
        filters || {},
        limit || 10,
        threshold || 0.7
      );
      
      // Record this activity if in a workspace context
      await this.recordActivity(params, result);
      
      // Prepare result with workspace context
      const response = this.prepareResult(
        result.success !== false, // Handle case where success is not explicitly set
        {
          matches: result.matches || []
        },
        result.error,
        workspaceContext
      );
      
      // Handle handoff if requested
      if (handoff) {
        return this.handleHandoff(handoff, response);
      }
      
      return response;
    } catch (error) {
      return this.prepareResult(false, undefined, `Error performing combined search with ChromaDB: ${error.message}`);
    }
  }
  
  /**
   * Execute using legacy services
   * @param params Mode parameters
   * @returns Promise that resolves with result
   */
  private async executeWithLegacyServices(params: CombinedSearchParams): Promise<SemanticSearchResult> {
    const { query, filters, limit, threshold, workspaceContext, handoff } = params;
    
    // Execute combined search by getting access to the VaultLibrarian
    let result = { success: false, matches: [], error: "VaultLibrarian not found" };
    
    try {
      const plugin = this.app.plugins?.getPlugin('claudesidian-mcp');
      if (plugin?.connector?.getVaultLibrarian) {
        const vaultLibrarian = plugin.connector.getVaultLibrarian();
        if (vaultLibrarian?.combinedSearch) {
          result = await vaultLibrarian.combinedSearch(
            query,
            filters || {},
            limit || 10,
            threshold || 0.7
          );
        } else {
          return this.prepareResult(false, undefined, "VaultLibrarian combinedSearch method not available");
        }
      } else {
        return this.prepareResult(false, undefined, "VaultLibrarian not available through connector");
      }
    } catch (error) {
      return this.prepareResult(false, undefined, `Error performing combined search: ${error.message}`);
    }
    
    // Record this activity if in a workspace context
    await this.recordActivity(params, result);
    
    // Prepare result with workspace context
    const response = this.prepareResult(
      result.success !== false, // Handle case where success is not explicitly set
      {
        matches: result.matches || []
      },
      result.error,
      workspaceContext
    );
    
    // Handle handoff if requested
    if (handoff) {
      return this.handleHandoff(handoff, response);
    }
    
    return response;
  }
  
  /**
   * Record search activity in workspace memory
   * @param params Parameters used for search
   * @param result Result of search operation
   */
  private async recordActivity(
    params: CombinedSearchParams, 
    result: {
      success?: boolean;
      matches?: Array<{
        similarity: number;
        content: string;
        filePath: string;
        lineStart?: number;
        lineEnd?: number;
        metadata?: any;
      }>;
      error?: string;
    }
  ): Promise<void> {
    // Parse workspace context
    const parsedContext = parseWorkspaceContext(params.workspaceContext);
    
    if (!parsedContext?.workspaceId) {
      return; // Skip if no workspace context
    }
    
    // Use memory service directly if available
    if (this.memoryService) {
      try {
        // Create activity content
        const matchCount = result.matches?.length || 0;
        const topMatches = result.matches?.slice(0, 3).map(m => m.filePath) || [];
        
        let filtersDesc = '';
        if (params.filters) {
          const parts = [];
          if (params.filters.tags && params.filters.tags.length > 0) {
            parts.push(`tags: ${params.filters.tags.join(', ')}`);
          }
          if (params.filters.paths && params.filters.paths.length > 0) {
            parts.push(`paths: ${params.filters.paths.join(', ')}`);
          }
          if (params.filters.properties && Object.keys(params.filters.properties).length > 0) {
            parts.push(`properties: ${JSON.stringify(params.filters.properties)}`);
          }
          if (params.filters.dateRange) {
            parts.push(`dateRange: ${JSON.stringify(params.filters.dateRange)}`);
          }
          
          if (parts.length > 0) {
            filtersDesc = `Filters: ${parts.join('; ')}\n`;
          }
        }
        
        const content = `Combined search: "${params.query}"\n` +
                        filtersDesc +
                        `Matches found: ${matchCount}\n` +
                        (topMatches.length > 0 ? `Top matches: ${topMatches.join(', ')}\n` : '') +
                        (result.error ? `Error: ${result.error}\n` : '');
        
        // Record activity trace using memory service
        await this.memoryService.recordActivityTrace(
          parsedContext.workspaceId,
          {
            type: 'research',
            content,
            metadata: {
              tool: 'CombinedSearchMode',
              params: {
                query: params.query,
                filters: params.filters,
                limit: params.limit,
                threshold: params.threshold
              },
              result: {
                matchCount,
                topMatches: topMatches
              },
              relatedFiles: topMatches
            },
            sessionId: params.sessionId
          }
        );
        
        return;
      } catch (error) {
        console.error('Error recording activity with memory service:', error);
      }
    }
    
    // Try to get the memory service from the plugin directly if it wasn't passed to the constructor
    // This is a fallback in case the constructor isn't updated yet 
    if (!this.memoryService) {
      try {
        const plugin = this.app.plugins.getPlugin('claudesidian-mcp');
        if (plugin?.services?.memoryService) {
          this.memoryService = plugin.services.memoryService;
          
          // Try again with the newly obtained memory service
          await this.recordActivity(params, result);
          return;
        }
      } catch (error) {
        console.error('Error accessing memory service from plugin:', error);
      }
    }
    
    // Log that we couldn't record the activity
    console.warn('Unable to record search activity - memory service unavailable');
  }
  
  /**
   * Get the JSON schema for the mode's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): Record<string, any> {
    return {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'The query to search for'
        },
        filters: {
          type: 'object',
          properties: {
            tags: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Tags to filter by'
            },
            paths: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Paths to filter by'
            },
            properties: {
              type: 'object',
              description: 'Properties to filter by'
            },
            dateRange: {
              type: 'object',
              properties: {
                start: {
                  type: 'string',
                  description: 'Start date in ISO format'
                },
                end: {
                  type: 'string',
                  description: 'End date in ISO format'
                }
              },
              description: 'Date range to filter by'
            }
          },
          description: 'Filters to apply to the search'
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results to return',
          default: 10
        },
        threshold: {
          type: 'number',
          description: 'Similarity threshold (0-1)',
          default: 0.7
        },
        ...this.getCommonParameterSchema()
      },
      required: ['query']
    };
  }
  
  /**
   * Get the JSON schema for the mode's result
   * @returns JSON schema object
   */
  getResultSchema(): Record<string, any> {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            matches: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  similarity: {
                    type: 'number',
                    description: 'Similarity score (0-1)'
                  },
                  content: {
                    type: 'string',
                    description: 'Chunk content'
                  },
                  filePath: {
                    type: 'string',
                    description: 'Path to the file'
                  },
                  lineStart: {
                    type: 'number',
                    description: 'Starting line in the file'
                  },
                  lineEnd: {
                    type: 'number',
                    description: 'Ending line in the file'
                  },
                  metadata: {
                    type: 'object',
                    properties: {
                      frontmatter: {
                        type: 'object',
                        description: 'Frontmatter properties'
                      },
                      tags: {
                        type: 'array',
                        items: {
                          type: 'string'
                        },
                        description: 'Tags in the document'
                      }
                    }
                  }
                },
                required: ['similarity', 'content', 'filePath']
              }
            }
          },
          required: ['matches']
        },
        workspaceContext: {
          type: 'object'
        },
        handoffResult: {
          type: 'object'
        }
      },
      required: ['success']
    };
  }
}